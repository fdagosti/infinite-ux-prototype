{"version":3,"sources":["webpack:///scripts.bf57562ff54fc229c6a6.bundle.js","webpack:////Users/francoisdagostini/Projects/infiniteUx-prototype/~/script-loader/addScript.js","webpack:////Users/francoisdagostini/Projects/infiniteUx-prototype/~/bootstrap/dist/js/bootstrap.js?4cdf","webpack:////Users/francoisdagostini/Projects/infiniteUx-prototype/~/jquery/dist/jquery.js?39e4","webpack:////Users/francoisdagostini/Projects/infiniteUx-prototype/src/assets/videojs/video.js?694a","webpack:////Users/francoisdagostini/Projects/infiniteUx-prototype/src/assets/videojs/videojs-contrib-hls.js?1705","webpack:////Users/francoisdagostini/Projects/infiniteUx-prototype/~/tether/dist/js/tether.js?00b7","webpack:////Users/francoisdagostini/Projects/infiniteUx-prototype/~/bootstrap/dist/js/bootstrap.js","webpack:////Users/francoisdagostini/Projects/infiniteUx-prototype/~/jquery/dist/jquery.js","webpack:////Users/francoisdagostini/Projects/infiniteUx-prototype/src/assets/videojs/video.js","webpack:////Users/francoisdagostini/Projects/infiniteUx-prototype/src/assets/videojs/videojs-contrib-hls.js","webpack:////Users/francoisdagostini/Projects/infiniteUx-prototype/~/tether/dist/js/tether.js"],"names":["webpackJsonp","1116","module","exports","__webpack_require__","130","src","execScript","eval","call","517","518","519","520","521","808","809","829","830","831"],"mappings":"AAAAA,cAAc,EAAE,IAEVC,KACA,SAASC,EAAQC,EAASC,GAEhCA,EAAoB,KACpBA,EAAoB,KACpBA,EAAoB,KACpBA,EAAoB,KACpBF,EAAOC,QAAUC,EAAoB,MAK/BC,IACA,SAASH,EAAQC,GCXvBD,EAAAC,QAAA,SAAAG,GACA,mBAAAC,YACAA,WAAAD,GAEAE,KAAAC,KAAA,KAAAH,KDuBMI,IACA,SAASR,EAAQC,EAASC,GEhChCA,EAAA,KAAAA,EAAA,OFsCMO,IACA,SAAST,EAAQC,EAASC,GGvChCA,EAAA,KAAAA,EAAA,OH6CMQ,IACA,SAASV,EAAQC,EAASC,GI9ChCA,EAAA,KAAAA,EAAA,OJoDMS,IACA,SAASX,EAAQC,EAASC,GKrDhCA,EAAA,KAAAA,EAAA,OL2DMU,IACA,SAASZ,EAAQC,EAASC,GM5DhCA,EAAA,KAAAA,EAAA,ONkEMW,IACA,SAASb,EAAQC,GOnEvBD,EAAAC,QAAA;EPyEMa,IACA,SAASd,EAAQC,GQ1EvBD,EAAAC,QAAA;ERgFMc,IACA,SAASf,EAAQC,GSjFvBD,EAAAC,QAAA;ETuFMe,IACA,SAAShB,EAAQC,GUxFvBD,EAAAC,QAAA;EV8FMgB,IACA,SAASjB,EAAQC,GW/FvBD,EAAAC,QAAA;IXqGG","file":"scripts.bf57562ff54fc229c6a6.bundle.js","sourcesContent":["webpackJsonp([3,5],{\n\n/***/ 1116:\n/***/ function(module, exports, __webpack_require__) {\n\n__webpack_require__(518);\n__webpack_require__(521);\n__webpack_require__(517);\n__webpack_require__(519);\nmodule.exports = __webpack_require__(520);\n\n\n/***/ },\n\n/***/ 130:\n/***/ function(module, exports) {\n\n/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript !== \"undefined\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\r\n\n\n/***/ },\n\n/***/ 517:\n/***/ function(module, exports, __webpack_require__) {\n\n__webpack_require__(130)(__webpack_require__(808))\n\n/***/ },\n\n/***/ 518:\n/***/ function(module, exports, __webpack_require__) {\n\n__webpack_require__(130)(__webpack_require__(809))\n\n/***/ },\n\n/***/ 519:\n/***/ function(module, exports, __webpack_require__) {\n\n__webpack_require__(130)(__webpack_require__(829))\n\n/***/ },\n\n/***/ 520:\n/***/ function(module, exports, __webpack_require__) {\n\n__webpack_require__(130)(__webpack_require__(830))\n\n/***/ },\n\n/***/ 521:\n/***/ function(module, exports, __webpack_require__) {\n\n__webpack_require__(130)(__webpack_require__(831))\n\n/***/ },\n\n/***/ 808:\n/***/ function(module, exports) {\n\nmodule.exports = \"/*!\\n * Bootstrap v4.0.0-alpha.5 (https://getbootstrap.com)\\n * Copyright 2011-2016 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n */\\n\\nif (typeof jQuery === 'undefined') {\\n  throw new Error('Bootstrap\\\\'s JavaScript requires jQuery')\\n}\\n\\n+function ($) {\\n  var version = $.fn.jquery.split(' ')[0].split('.')\\n  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1) || (version[0] >= 4)) {\\n    throw new Error('Bootstrap\\\\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0')\\n  }\\n}(jQuery);\\n\\n\\n+function () {\\n\\nvar _typeof = typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; };\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v4.0.0-alpha.5): util.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\nvar Util = function ($) {\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Private TransitionEnd Helpers\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var transition = false;\\n\\n  var MAX_UID = 1000000;\\n\\n  var TransitionEndEvent = {\\n    WebkitTransition: 'webkitTransitionEnd',\\n    MozTransition: 'transitionend',\\n    OTransition: 'oTransitionEnd otransitionend',\\n    transition: 'transitionend'\\n  };\\n\\n  // shoutout AngusCroll (https://goo.gl/pxwQGp)\\n  function toType(obj) {\\n    return {}.toString.call(obj).match(/\\\\s([a-zA-Z]+)/)[1].toLowerCase();\\n  }\\n\\n  function isElement(obj) {\\n    return (obj[0] || obj).nodeType;\\n  }\\n\\n  function getSpecialTransitionEndEvent() {\\n    return {\\n      bindType: transition.end,\\n      delegateType: transition.end,\\n      handle: function handle(event) {\\n        if ($(event.target).is(this)) {\\n          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params\\n        }\\n        return undefined;\\n      }\\n    };\\n  }\\n\\n  function transitionEndTest() {\\n    if (window.QUnit) {\\n      return false;\\n    }\\n\\n    var el = document.createElement('bootstrap');\\n\\n    for (var name in TransitionEndEvent) {\\n      if (el.style[name] !== undefined) {\\n        return { end: TransitionEndEvent[name] };\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  function transitionEndEmulator(duration) {\\n    var _this = this;\\n\\n    var called = false;\\n\\n    $(this).one(Util.TRANSITION_END, function () {\\n      called = true;\\n    });\\n\\n    setTimeout(function () {\\n      if (!called) {\\n        Util.triggerTransitionEnd(_this);\\n      }\\n    }, duration);\\n\\n    return this;\\n  }\\n\\n  function setTransitionEndSupport() {\\n    transition = transitionEndTest();\\n\\n    $.fn.emulateTransitionEnd = transitionEndEmulator;\\n\\n    if (Util.supportsTransitionEnd()) {\\n      $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();\\n    }\\n  }\\n\\n  /**\\n   * --------------------------------------------------------------------------\\n   * Public Util Api\\n   * --------------------------------------------------------------------------\\n   */\\n\\n  var Util = {\\n\\n    TRANSITION_END: 'bsTransitionEnd',\\n\\n    getUID: function getUID(prefix) {\\n      do {\\n        /* eslint-disable no-bitwise */\\n        prefix += ~~(Math.random() * MAX_UID); // \\\"~~\\\" acts like a faster Math.floor() here\\n        /* eslint-enable no-bitwise */\\n      } while (document.getElementById(prefix));\\n      return prefix;\\n    },\\n    getSelectorFromElement: function getSelectorFromElement(element) {\\n      var selector = element.getAttribute('data-target');\\n\\n      if (!selector) {\\n        selector = element.getAttribute('href') || '';\\n        selector = /^#[a-z]/i.test(selector) ? selector : null;\\n      }\\n\\n      return selector;\\n    },\\n    reflow: function reflow(element) {\\n      new Function('bs', 'return bs')(element.offsetHeight);\\n    },\\n    triggerTransitionEnd: function triggerTransitionEnd(element) {\\n      $(element).trigger(transition.end);\\n    },\\n    supportsTransitionEnd: function supportsTransitionEnd() {\\n      return Boolean(transition);\\n    },\\n    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {\\n      for (var property in configTypes) {\\n        if (configTypes.hasOwnProperty(property)) {\\n          var expectedTypes = configTypes[property];\\n          var value = config[property];\\n          var valueType = void 0;\\n\\n          if (value && isElement(value)) {\\n            valueType = 'element';\\n          } else {\\n            valueType = toType(value);\\n          }\\n\\n          if (!new RegExp(expectedTypes).test(valueType)) {\\n            throw new Error(componentName.toUpperCase() + ': ' + ('Option \\\"' + property + '\\\" provided type \\\"' + valueType + '\\\" ') + ('but expected type \\\"' + expectedTypes + '\\\".'));\\n          }\\n        }\\n      }\\n    }\\n  };\\n\\n  setTransitionEndSupport();\\n\\n  return Util;\\n}(jQuery);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v4.0.0-alpha.5): alert.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\nvar Alert = function ($) {\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME = 'alert';\\n  var VERSION = '4.0.0-alpha.5';\\n  var DATA_KEY = 'bs.alert';\\n  var EVENT_KEY = '.' + DATA_KEY;\\n  var DATA_API_KEY = '.data-api';\\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\\n  var TRANSITION_DURATION = 150;\\n\\n  var Selector = {\\n    DISMISS: '[data-dismiss=\\\"alert\\\"]'\\n  };\\n\\n  var Event = {\\n    CLOSE: 'close' + EVENT_KEY,\\n    CLOSED: 'closed' + EVENT_KEY,\\n    CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY\\n  };\\n\\n  var ClassName = {\\n    ALERT: 'alert',\\n    FADE: 'fade',\\n    IN: 'in'\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Alert = function () {\\n    function Alert(element) {\\n      _classCallCheck(this, Alert);\\n\\n      this._element = element;\\n    }\\n\\n    // getters\\n\\n    // public\\n\\n    Alert.prototype.close = function close(element) {\\n      element = element || this._element;\\n\\n      var rootElement = this._getRootElement(element);\\n      var customEvent = this._triggerCloseEvent(rootElement);\\n\\n      if (customEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      this._removeElement(rootElement);\\n    };\\n\\n    Alert.prototype.dispose = function dispose() {\\n      $.removeData(this._element, DATA_KEY);\\n      this._element = null;\\n    };\\n\\n    // private\\n\\n    Alert.prototype._getRootElement = function _getRootElement(element) {\\n      var selector = Util.getSelectorFromElement(element);\\n      var parent = false;\\n\\n      if (selector) {\\n        parent = $(selector)[0];\\n      }\\n\\n      if (!parent) {\\n        parent = $(element).closest('.' + ClassName.ALERT)[0];\\n      }\\n\\n      return parent;\\n    };\\n\\n    Alert.prototype._triggerCloseEvent = function _triggerCloseEvent(element) {\\n      var closeEvent = $.Event(Event.CLOSE);\\n\\n      $(element).trigger(closeEvent);\\n      return closeEvent;\\n    };\\n\\n    Alert.prototype._removeElement = function _removeElement(element) {\\n      $(element).removeClass(ClassName.IN);\\n\\n      if (!Util.supportsTransitionEnd() || !$(element).hasClass(ClassName.FADE)) {\\n        this._destroyElement(element);\\n        return;\\n      }\\n\\n      $(element).one(Util.TRANSITION_END, $.proxy(this._destroyElement, this, element)).emulateTransitionEnd(TRANSITION_DURATION);\\n    };\\n\\n    Alert.prototype._destroyElement = function _destroyElement(element) {\\n      $(element).detach().trigger(Event.CLOSED).remove();\\n    };\\n\\n    // static\\n\\n    Alert._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var $element = $(this);\\n        var data = $element.data(DATA_KEY);\\n\\n        if (!data) {\\n          data = new Alert(this);\\n          $element.data(DATA_KEY, data);\\n        }\\n\\n        if (config === 'close') {\\n          data[config](this);\\n        }\\n      });\\n    };\\n\\n    Alert._handleDismiss = function _handleDismiss(alertInstance) {\\n      return function (event) {\\n        if (event) {\\n          event.preventDefault();\\n        }\\n\\n        alertInstance.close(this);\\n      };\\n    };\\n\\n    _createClass(Alert, null, [{\\n      key: 'VERSION',\\n      get: function get() {\\n        return VERSION;\\n      }\\n    }]);\\n\\n    return Alert;\\n  }();\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME] = Alert._jQueryInterface;\\n  $.fn[NAME].Constructor = Alert;\\n  $.fn[NAME].noConflict = function () {\\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\\n    return Alert._jQueryInterface;\\n  };\\n\\n  return Alert;\\n}(jQuery);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v4.0.0-alpha.5): button.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\nvar Button = function ($) {\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME = 'button';\\n  var VERSION = '4.0.0-alpha.5';\\n  var DATA_KEY = 'bs.button';\\n  var EVENT_KEY = '.' + DATA_KEY;\\n  var DATA_API_KEY = '.data-api';\\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\\n\\n  var ClassName = {\\n    ACTIVE: 'active',\\n    BUTTON: 'btn',\\n    FOCUS: 'focus'\\n  };\\n\\n  var Selector = {\\n    DATA_TOGGLE_CARROT: '[data-toggle^=\\\"button\\\"]',\\n    DATA_TOGGLE: '[data-toggle=\\\"buttons\\\"]',\\n    INPUT: 'input',\\n    ACTIVE: '.active',\\n    BUTTON: '.btn'\\n  };\\n\\n  var Event = {\\n    CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY,\\n    FOCUS_BLUR_DATA_API: 'focus' + EVENT_KEY + DATA_API_KEY + ' ' + ('blur' + EVENT_KEY + DATA_API_KEY)\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Button = function () {\\n    function Button(element) {\\n      _classCallCheck(this, Button);\\n\\n      this._element = element;\\n    }\\n\\n    // getters\\n\\n    // public\\n\\n    Button.prototype.toggle = function toggle() {\\n      var triggerChangeEvent = true;\\n      var rootElement = $(this._element).closest(Selector.DATA_TOGGLE)[0];\\n\\n      if (rootElement) {\\n        var input = $(this._element).find(Selector.INPUT)[0];\\n\\n        if (input) {\\n          if (input.type === 'radio') {\\n            if (input.checked && $(this._element).hasClass(ClassName.ACTIVE)) {\\n              triggerChangeEvent = false;\\n            } else {\\n              var activeElement = $(rootElement).find(Selector.ACTIVE)[0];\\n\\n              if (activeElement) {\\n                $(activeElement).removeClass(ClassName.ACTIVE);\\n              }\\n            }\\n          }\\n\\n          if (triggerChangeEvent) {\\n            input.checked = !$(this._element).hasClass(ClassName.ACTIVE);\\n            $(this._element).trigger('change');\\n          }\\n\\n          input.focus();\\n        }\\n      } else {\\n        this._element.setAttribute('aria-pressed', !$(this._element).hasClass(ClassName.ACTIVE));\\n      }\\n\\n      if (triggerChangeEvent) {\\n        $(this._element).toggleClass(ClassName.ACTIVE);\\n      }\\n    };\\n\\n    Button.prototype.dispose = function dispose() {\\n      $.removeData(this._element, DATA_KEY);\\n      this._element = null;\\n    };\\n\\n    // static\\n\\n    Button._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var data = $(this).data(DATA_KEY);\\n\\n        if (!data) {\\n          data = new Button(this);\\n          $(this).data(DATA_KEY, data);\\n        }\\n\\n        if (config === 'toggle') {\\n          data[config]();\\n        }\\n      });\\n    };\\n\\n    _createClass(Button, null, [{\\n      key: 'VERSION',\\n      get: function get() {\\n        return VERSION;\\n      }\\n    }]);\\n\\n    return Button;\\n  }();\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {\\n    event.preventDefault();\\n\\n    var button = event.target;\\n\\n    if (!$(button).hasClass(ClassName.BUTTON)) {\\n      button = $(button).closest(Selector.BUTTON);\\n    }\\n\\n    Button._jQueryInterface.call($(button), 'toggle');\\n  }).on(Event.FOCUS_BLUR_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {\\n    var button = $(event.target).closest(Selector.BUTTON)[0];\\n    $(button).toggleClass(ClassName.FOCUS, /^focus(in)?$/.test(event.type));\\n  });\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME] = Button._jQueryInterface;\\n  $.fn[NAME].Constructor = Button;\\n  $.fn[NAME].noConflict = function () {\\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\\n    return Button._jQueryInterface;\\n  };\\n\\n  return Button;\\n}(jQuery);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v4.0.0-alpha.5): carousel.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\nvar Carousel = function ($) {\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME = 'carousel';\\n  var VERSION = '4.0.0-alpha.5';\\n  var DATA_KEY = 'bs.carousel';\\n  var EVENT_KEY = '.' + DATA_KEY;\\n  var DATA_API_KEY = '.data-api';\\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\\n  var TRANSITION_DURATION = 600;\\n  var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key\\n  var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key\\n\\n  var Default = {\\n    interval: 5000,\\n    keyboard: true,\\n    slide: false,\\n    pause: 'hover',\\n    wrap: true\\n  };\\n\\n  var DefaultType = {\\n    interval: '(number|boolean)',\\n    keyboard: 'boolean',\\n    slide: '(boolean|string)',\\n    pause: '(string|boolean)',\\n    wrap: 'boolean'\\n  };\\n\\n  var Direction = {\\n    NEXT: 'next',\\n    PREVIOUS: 'prev'\\n  };\\n\\n  var Event = {\\n    SLIDE: 'slide' + EVENT_KEY,\\n    SLID: 'slid' + EVENT_KEY,\\n    KEYDOWN: 'keydown' + EVENT_KEY,\\n    MOUSEENTER: 'mouseenter' + EVENT_KEY,\\n    MOUSELEAVE: 'mouseleave' + EVENT_KEY,\\n    LOAD_DATA_API: 'load' + EVENT_KEY + DATA_API_KEY,\\n    CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY\\n  };\\n\\n  var ClassName = {\\n    CAROUSEL: 'carousel',\\n    ACTIVE: 'active',\\n    SLIDE: 'slide',\\n    RIGHT: 'right',\\n    LEFT: 'left',\\n    ITEM: 'carousel-item'\\n  };\\n\\n  var Selector = {\\n    ACTIVE: '.active',\\n    ACTIVE_ITEM: '.active.carousel-item',\\n    ITEM: '.carousel-item',\\n    NEXT_PREV: '.next, .prev',\\n    INDICATORS: '.carousel-indicators',\\n    DATA_SLIDE: '[data-slide], [data-slide-to]',\\n    DATA_RIDE: '[data-ride=\\\"carousel\\\"]'\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Carousel = function () {\\n    function Carousel(element, config) {\\n      _classCallCheck(this, Carousel);\\n\\n      this._items = null;\\n      this._interval = null;\\n      this._activeElement = null;\\n\\n      this._isPaused = false;\\n      this._isSliding = false;\\n\\n      this._config = this._getConfig(config);\\n      this._element = $(element)[0];\\n      this._indicatorsElement = $(this._element).find(Selector.INDICATORS)[0];\\n\\n      this._addEventListeners();\\n    }\\n\\n    // getters\\n\\n    // public\\n\\n    Carousel.prototype.next = function next() {\\n      if (!this._isSliding) {\\n        this._slide(Direction.NEXT);\\n      }\\n    };\\n\\n    Carousel.prototype.nextWhenVisible = function nextWhenVisible() {\\n      // Don't call next when the page isn't visible\\n      if (!document.hidden) {\\n        this.next();\\n      }\\n    };\\n\\n    Carousel.prototype.prev = function prev() {\\n      if (!this._isSliding) {\\n        this._slide(Direction.PREVIOUS);\\n      }\\n    };\\n\\n    Carousel.prototype.pause = function pause(event) {\\n      if (!event) {\\n        this._isPaused = true;\\n      }\\n\\n      if ($(this._element).find(Selector.NEXT_PREV)[0] && Util.supportsTransitionEnd()) {\\n        Util.triggerTransitionEnd(this._element);\\n        this.cycle(true);\\n      }\\n\\n      clearInterval(this._interval);\\n      this._interval = null;\\n    };\\n\\n    Carousel.prototype.cycle = function cycle(event) {\\n      if (!event) {\\n        this._isPaused = false;\\n      }\\n\\n      if (this._interval) {\\n        clearInterval(this._interval);\\n        this._interval = null;\\n      }\\n\\n      if (this._config.interval && !this._isPaused) {\\n        this._interval = setInterval($.proxy(document.visibilityState ? this.nextWhenVisible : this.next, this), this._config.interval);\\n      }\\n    };\\n\\n    Carousel.prototype.to = function to(index) {\\n      var _this2 = this;\\n\\n      this._activeElement = $(this._element).find(Selector.ACTIVE_ITEM)[0];\\n\\n      var activeIndex = this._getItemIndex(this._activeElement);\\n\\n      if (index > this._items.length - 1 || index < 0) {\\n        return;\\n      }\\n\\n      if (this._isSliding) {\\n        $(this._element).one(Event.SLID, function () {\\n          return _this2.to(index);\\n        });\\n        return;\\n      }\\n\\n      if (activeIndex === index) {\\n        this.pause();\\n        this.cycle();\\n        return;\\n      }\\n\\n      var direction = index > activeIndex ? Direction.NEXT : Direction.PREVIOUS;\\n\\n      this._slide(direction, this._items[index]);\\n    };\\n\\n    Carousel.prototype.dispose = function dispose() {\\n      $(this._element).off(EVENT_KEY);\\n      $.removeData(this._element, DATA_KEY);\\n\\n      this._items = null;\\n      this._config = null;\\n      this._element = null;\\n      this._interval = null;\\n      this._isPaused = null;\\n      this._isSliding = null;\\n      this._activeElement = null;\\n      this._indicatorsElement = null;\\n    };\\n\\n    // private\\n\\n    Carousel.prototype._getConfig = function _getConfig(config) {\\n      config = $.extend({}, Default, config);\\n      Util.typeCheckConfig(NAME, config, DefaultType);\\n      return config;\\n    };\\n\\n    Carousel.prototype._addEventListeners = function _addEventListeners() {\\n      if (this._config.keyboard) {\\n        $(this._element).on(Event.KEYDOWN, $.proxy(this._keydown, this));\\n      }\\n\\n      if (this._config.pause === 'hover' && !('ontouchstart' in document.documentElement)) {\\n        $(this._element).on(Event.MOUSEENTER, $.proxy(this.pause, this)).on(Event.MOUSELEAVE, $.proxy(this.cycle, this));\\n      }\\n    };\\n\\n    Carousel.prototype._keydown = function _keydown(event) {\\n      event.preventDefault();\\n\\n      if (/input|textarea/i.test(event.target.tagName)) {\\n        return;\\n      }\\n\\n      switch (event.which) {\\n        case ARROW_LEFT_KEYCODE:\\n          this.prev();\\n          break;\\n        case ARROW_RIGHT_KEYCODE:\\n          this.next();\\n          break;\\n        default:\\n          return;\\n      }\\n    };\\n\\n    Carousel.prototype._getItemIndex = function _getItemIndex(element) {\\n      this._items = $.makeArray($(element).parent().find(Selector.ITEM));\\n      return this._items.indexOf(element);\\n    };\\n\\n    Carousel.prototype._getItemByDirection = function _getItemByDirection(direction, activeElement) {\\n      var isNextDirection = direction === Direction.NEXT;\\n      var isPrevDirection = direction === Direction.PREVIOUS;\\n      var activeIndex = this._getItemIndex(activeElement);\\n      var lastItemIndex = this._items.length - 1;\\n      var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;\\n\\n      if (isGoingToWrap && !this._config.wrap) {\\n        return activeElement;\\n      }\\n\\n      var delta = direction === Direction.PREVIOUS ? -1 : 1;\\n      var itemIndex = (activeIndex + delta) % this._items.length;\\n\\n      return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];\\n    };\\n\\n    Carousel.prototype._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, directionalClassname) {\\n      var slideEvent = $.Event(Event.SLIDE, {\\n        relatedTarget: relatedTarget,\\n        direction: directionalClassname\\n      });\\n\\n      $(this._element).trigger(slideEvent);\\n\\n      return slideEvent;\\n    };\\n\\n    Carousel.prototype._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {\\n      if (this._indicatorsElement) {\\n        $(this._indicatorsElement).find(Selector.ACTIVE).removeClass(ClassName.ACTIVE);\\n\\n        var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];\\n\\n        if (nextIndicator) {\\n          $(nextIndicator).addClass(ClassName.ACTIVE);\\n        }\\n      }\\n    };\\n\\n    Carousel.prototype._slide = function _slide(direction, element) {\\n      var _this3 = this;\\n\\n      var activeElement = $(this._element).find(Selector.ACTIVE_ITEM)[0];\\n      var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);\\n\\n      var isCycling = Boolean(this._interval);\\n\\n      var directionalClassName = direction === Direction.NEXT ? ClassName.LEFT : ClassName.RIGHT;\\n\\n      if (nextElement && $(nextElement).hasClass(ClassName.ACTIVE)) {\\n        this._isSliding = false;\\n        return;\\n      }\\n\\n      var slideEvent = this._triggerSlideEvent(nextElement, directionalClassName);\\n      if (slideEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      if (!activeElement || !nextElement) {\\n        // some weirdness is happening, so we bail\\n        return;\\n      }\\n\\n      this._isSliding = true;\\n\\n      if (isCycling) {\\n        this.pause();\\n      }\\n\\n      this._setActiveIndicatorElement(nextElement);\\n\\n      var slidEvent = $.Event(Event.SLID, {\\n        relatedTarget: nextElement,\\n        direction: directionalClassName\\n      });\\n\\n      if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.SLIDE)) {\\n\\n        $(nextElement).addClass(direction);\\n\\n        Util.reflow(nextElement);\\n\\n        $(activeElement).addClass(directionalClassName);\\n        $(nextElement).addClass(directionalClassName);\\n\\n        $(activeElement).one(Util.TRANSITION_END, function () {\\n          $(nextElement).removeClass(directionalClassName).removeClass(direction);\\n\\n          $(nextElement).addClass(ClassName.ACTIVE);\\n\\n          $(activeElement).removeClass(ClassName.ACTIVE).removeClass(direction).removeClass(directionalClassName);\\n\\n          _this3._isSliding = false;\\n\\n          setTimeout(function () {\\n            return $(_this3._element).trigger(slidEvent);\\n          }, 0);\\n        }).emulateTransitionEnd(TRANSITION_DURATION);\\n      } else {\\n        $(activeElement).removeClass(ClassName.ACTIVE);\\n        $(nextElement).addClass(ClassName.ACTIVE);\\n\\n        this._isSliding = false;\\n        $(this._element).trigger(slidEvent);\\n      }\\n\\n      if (isCycling) {\\n        this.cycle();\\n      }\\n    };\\n\\n    // static\\n\\n    Carousel._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var data = $(this).data(DATA_KEY);\\n        var _config = $.extend({}, Default, $(this).data());\\n\\n        if ((typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object') {\\n          $.extend(_config, config);\\n        }\\n\\n        var action = typeof config === 'string' ? config : _config.slide;\\n\\n        if (!data) {\\n          data = new Carousel(this, _config);\\n          $(this).data(DATA_KEY, data);\\n        }\\n\\n        if (typeof config === 'number') {\\n          data.to(config);\\n        } else if (typeof action === 'string') {\\n          if (data[action] === undefined) {\\n            throw new Error('No method named \\\"' + action + '\\\"');\\n          }\\n          data[action]();\\n        } else if (_config.interval) {\\n          data.pause();\\n          data.cycle();\\n        }\\n      });\\n    };\\n\\n    Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {\\n      var selector = Util.getSelectorFromElement(this);\\n\\n      if (!selector) {\\n        return;\\n      }\\n\\n      var target = $(selector)[0];\\n\\n      if (!target || !$(target).hasClass(ClassName.CAROUSEL)) {\\n        return;\\n      }\\n\\n      var config = $.extend({}, $(target).data(), $(this).data());\\n      var slideIndex = this.getAttribute('data-slide-to');\\n\\n      if (slideIndex) {\\n        config.interval = false;\\n      }\\n\\n      Carousel._jQueryInterface.call($(target), config);\\n\\n      if (slideIndex) {\\n        $(target).data(DATA_KEY).to(slideIndex);\\n      }\\n\\n      event.preventDefault();\\n    };\\n\\n    _createClass(Carousel, null, [{\\n      key: 'VERSION',\\n      get: function get() {\\n        return VERSION;\\n      }\\n    }, {\\n      key: 'Default',\\n      get: function get() {\\n        return Default;\\n      }\\n    }]);\\n\\n    return Carousel;\\n  }();\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_SLIDE, Carousel._dataApiClickHandler);\\n\\n  $(window).on(Event.LOAD_DATA_API, function () {\\n    $(Selector.DATA_RIDE).each(function () {\\n      var $carousel = $(this);\\n      Carousel._jQueryInterface.call($carousel, $carousel.data());\\n    });\\n  });\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME] = Carousel._jQueryInterface;\\n  $.fn[NAME].Constructor = Carousel;\\n  $.fn[NAME].noConflict = function () {\\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\\n    return Carousel._jQueryInterface;\\n  };\\n\\n  return Carousel;\\n}(jQuery);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v4.0.0-alpha.5): collapse.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\nvar Collapse = function ($) {\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME = 'collapse';\\n  var VERSION = '4.0.0-alpha.5';\\n  var DATA_KEY = 'bs.collapse';\\n  var EVENT_KEY = '.' + DATA_KEY;\\n  var DATA_API_KEY = '.data-api';\\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\\n  var TRANSITION_DURATION = 600;\\n\\n  var Default = {\\n    toggle: true,\\n    parent: ''\\n  };\\n\\n  var DefaultType = {\\n    toggle: 'boolean',\\n    parent: 'string'\\n  };\\n\\n  var Event = {\\n    SHOW: 'show' + EVENT_KEY,\\n    SHOWN: 'shown' + EVENT_KEY,\\n    HIDE: 'hide' + EVENT_KEY,\\n    HIDDEN: 'hidden' + EVENT_KEY,\\n    CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY\\n  };\\n\\n  var ClassName = {\\n    IN: 'in',\\n    COLLAPSE: 'collapse',\\n    COLLAPSING: 'collapsing',\\n    COLLAPSED: 'collapsed'\\n  };\\n\\n  var Dimension = {\\n    WIDTH: 'width',\\n    HEIGHT: 'height'\\n  };\\n\\n  var Selector = {\\n    ACTIVES: '.card > .in, .card > .collapsing',\\n    DATA_TOGGLE: '[data-toggle=\\\"collapse\\\"]'\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Collapse = function () {\\n    function Collapse(element, config) {\\n      _classCallCheck(this, Collapse);\\n\\n      this._isTransitioning = false;\\n      this._element = element;\\n      this._config = this._getConfig(config);\\n      this._triggerArray = $.makeArray($('[data-toggle=\\\"collapse\\\"][href=\\\"#' + element.id + '\\\"],' + ('[data-toggle=\\\"collapse\\\"][data-target=\\\"#' + element.id + '\\\"]')));\\n\\n      this._parent = this._config.parent ? this._getParent() : null;\\n\\n      if (!this._config.parent) {\\n        this._addAriaAndCollapsedClass(this._element, this._triggerArray);\\n      }\\n\\n      if (this._config.toggle) {\\n        this.toggle();\\n      }\\n    }\\n\\n    // getters\\n\\n    // public\\n\\n    Collapse.prototype.toggle = function toggle() {\\n      if ($(this._element).hasClass(ClassName.IN)) {\\n        this.hide();\\n      } else {\\n        this.show();\\n      }\\n    };\\n\\n    Collapse.prototype.show = function show() {\\n      var _this4 = this;\\n\\n      if (this._isTransitioning || $(this._element).hasClass(ClassName.IN)) {\\n        return;\\n      }\\n\\n      var actives = void 0;\\n      var activesData = void 0;\\n\\n      if (this._parent) {\\n        actives = $.makeArray($(Selector.ACTIVES));\\n        if (!actives.length) {\\n          actives = null;\\n        }\\n      }\\n\\n      if (actives) {\\n        activesData = $(actives).data(DATA_KEY);\\n        if (activesData && activesData._isTransitioning) {\\n          return;\\n        }\\n      }\\n\\n      var startEvent = $.Event(Event.SHOW);\\n      $(this._element).trigger(startEvent);\\n      if (startEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      if (actives) {\\n        Collapse._jQueryInterface.call($(actives), 'hide');\\n        if (!activesData) {\\n          $(actives).data(DATA_KEY, null);\\n        }\\n      }\\n\\n      var dimension = this._getDimension();\\n\\n      $(this._element).removeClass(ClassName.COLLAPSE).addClass(ClassName.COLLAPSING);\\n\\n      this._element.style[dimension] = 0;\\n      this._element.setAttribute('aria-expanded', true);\\n\\n      if (this._triggerArray.length) {\\n        $(this._triggerArray).removeClass(ClassName.COLLAPSED).attr('aria-expanded', true);\\n      }\\n\\n      this.setTransitioning(true);\\n\\n      var complete = function complete() {\\n        $(_this4._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).addClass(ClassName.IN);\\n\\n        _this4._element.style[dimension] = '';\\n\\n        _this4.setTransitioning(false);\\n\\n        $(_this4._element).trigger(Event.SHOWN);\\n      };\\n\\n      if (!Util.supportsTransitionEnd()) {\\n        complete();\\n        return;\\n      }\\n\\n      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\\n      var scrollSize = 'scroll' + capitalizedDimension;\\n\\n      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);\\n\\n      this._element.style[dimension] = this._element[scrollSize] + 'px';\\n    };\\n\\n    Collapse.prototype.hide = function hide() {\\n      var _this5 = this;\\n\\n      if (this._isTransitioning || !$(this._element).hasClass(ClassName.IN)) {\\n        return;\\n      }\\n\\n      var startEvent = $.Event(Event.HIDE);\\n      $(this._element).trigger(startEvent);\\n      if (startEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      var dimension = this._getDimension();\\n      var offsetDimension = dimension === Dimension.WIDTH ? 'offsetWidth' : 'offsetHeight';\\n\\n      this._element.style[dimension] = this._element[offsetDimension] + 'px';\\n\\n      Util.reflow(this._element);\\n\\n      $(this._element).addClass(ClassName.COLLAPSING).removeClass(ClassName.COLLAPSE).removeClass(ClassName.IN);\\n\\n      this._element.setAttribute('aria-expanded', false);\\n\\n      if (this._triggerArray.length) {\\n        $(this._triggerArray).addClass(ClassName.COLLAPSED).attr('aria-expanded', false);\\n      }\\n\\n      this.setTransitioning(true);\\n\\n      var complete = function complete() {\\n        _this5.setTransitioning(false);\\n        $(_this5._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).trigger(Event.HIDDEN);\\n      };\\n\\n      this._element.style[dimension] = '';\\n\\n      if (!Util.supportsTransitionEnd()) {\\n        complete();\\n        return;\\n      }\\n\\n      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);\\n    };\\n\\n    Collapse.prototype.setTransitioning = function setTransitioning(isTransitioning) {\\n      this._isTransitioning = isTransitioning;\\n    };\\n\\n    Collapse.prototype.dispose = function dispose() {\\n      $.removeData(this._element, DATA_KEY);\\n\\n      this._config = null;\\n      this._parent = null;\\n      this._element = null;\\n      this._triggerArray = null;\\n      this._isTransitioning = null;\\n    };\\n\\n    // private\\n\\n    Collapse.prototype._getConfig = function _getConfig(config) {\\n      config = $.extend({}, Default, config);\\n      config.toggle = Boolean(config.toggle); // coerce string values\\n      Util.typeCheckConfig(NAME, config, DefaultType);\\n      return config;\\n    };\\n\\n    Collapse.prototype._getDimension = function _getDimension() {\\n      var hasWidth = $(this._element).hasClass(Dimension.WIDTH);\\n      return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;\\n    };\\n\\n    Collapse.prototype._getParent = function _getParent() {\\n      var _this6 = this;\\n\\n      var parent = $(this._config.parent)[0];\\n      var selector = '[data-toggle=\\\"collapse\\\"][data-parent=\\\"' + this._config.parent + '\\\"]';\\n\\n      $(parent).find(selector).each(function (i, element) {\\n        _this6._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);\\n      });\\n\\n      return parent;\\n    };\\n\\n    Collapse.prototype._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {\\n      if (element) {\\n        var isOpen = $(element).hasClass(ClassName.IN);\\n        element.setAttribute('aria-expanded', isOpen);\\n\\n        if (triggerArray.length) {\\n          $(triggerArray).toggleClass(ClassName.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);\\n        }\\n      }\\n    };\\n\\n    // static\\n\\n    Collapse._getTargetFromElement = function _getTargetFromElement(element) {\\n      var selector = Util.getSelectorFromElement(element);\\n      return selector ? $(selector)[0] : null;\\n    };\\n\\n    Collapse._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var $this = $(this);\\n        var data = $this.data(DATA_KEY);\\n        var _config = $.extend({}, Default, $this.data(), (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config);\\n\\n        if (!data && _config.toggle && /show|hide/.test(config)) {\\n          _config.toggle = false;\\n        }\\n\\n        if (!data) {\\n          data = new Collapse(this, _config);\\n          $this.data(DATA_KEY, data);\\n        }\\n\\n        if (typeof config === 'string') {\\n          if (data[config] === undefined) {\\n            throw new Error('No method named \\\"' + config + '\\\"');\\n          }\\n          data[config]();\\n        }\\n      });\\n    };\\n\\n    _createClass(Collapse, null, [{\\n      key: 'VERSION',\\n      get: function get() {\\n        return VERSION;\\n      }\\n    }, {\\n      key: 'Default',\\n      get: function get() {\\n        return Default;\\n      }\\n    }]);\\n\\n    return Collapse;\\n  }();\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {\\n    event.preventDefault();\\n\\n    var target = Collapse._getTargetFromElement(this);\\n    var data = $(target).data(DATA_KEY);\\n    var config = data ? 'toggle' : $(this).data();\\n\\n    Collapse._jQueryInterface.call($(target), config);\\n  });\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME] = Collapse._jQueryInterface;\\n  $.fn[NAME].Constructor = Collapse;\\n  $.fn[NAME].noConflict = function () {\\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\\n    return Collapse._jQueryInterface;\\n  };\\n\\n  return Collapse;\\n}(jQuery);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v4.0.0-alpha.5): dropdown.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\nvar Dropdown = function ($) {\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME = 'dropdown';\\n  var VERSION = '4.0.0-alpha.5';\\n  var DATA_KEY = 'bs.dropdown';\\n  var EVENT_KEY = '.' + DATA_KEY;\\n  var DATA_API_KEY = '.data-api';\\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\\n  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key\\n  var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key\\n  var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key\\n  var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)\\n\\n  var Event = {\\n    HIDE: 'hide' + EVENT_KEY,\\n    HIDDEN: 'hidden' + EVENT_KEY,\\n    SHOW: 'show' + EVENT_KEY,\\n    SHOWN: 'shown' + EVENT_KEY,\\n    CLICK: 'click' + EVENT_KEY,\\n    CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY,\\n    KEYDOWN_DATA_API: 'keydown' + EVENT_KEY + DATA_API_KEY\\n  };\\n\\n  var ClassName = {\\n    BACKDROP: 'dropdown-backdrop',\\n    DISABLED: 'disabled',\\n    OPEN: 'open'\\n  };\\n\\n  var Selector = {\\n    BACKDROP: '.dropdown-backdrop',\\n    DATA_TOGGLE: '[data-toggle=\\\"dropdown\\\"]',\\n    FORM_CHILD: '.dropdown form',\\n    ROLE_MENU: '[role=\\\"menu\\\"]',\\n    ROLE_LISTBOX: '[role=\\\"listbox\\\"]',\\n    NAVBAR_NAV: '.navbar-nav',\\n    VISIBLE_ITEMS: '[role=\\\"menu\\\"] li:not(.disabled) a, ' + '[role=\\\"listbox\\\"] li:not(.disabled) a'\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Dropdown = function () {\\n    function Dropdown(element) {\\n      _classCallCheck(this, Dropdown);\\n\\n      this._element = element;\\n\\n      this._addEventListeners();\\n    }\\n\\n    // getters\\n\\n    // public\\n\\n    Dropdown.prototype.toggle = function toggle() {\\n      if (this.disabled || $(this).hasClass(ClassName.DISABLED)) {\\n        return false;\\n      }\\n\\n      var parent = Dropdown._getParentFromElement(this);\\n      var isActive = $(parent).hasClass(ClassName.OPEN);\\n\\n      Dropdown._clearMenus();\\n\\n      if (isActive) {\\n        return false;\\n      }\\n\\n      if ('ontouchstart' in document.documentElement && !$(parent).closest(Selector.NAVBAR_NAV).length) {\\n\\n        // if mobile we use a backdrop because click events don't delegate\\n        var dropdown = document.createElement('div');\\n        dropdown.className = ClassName.BACKDROP;\\n        $(dropdown).insertBefore(this);\\n        $(dropdown).on('click', Dropdown._clearMenus);\\n      }\\n\\n      var relatedTarget = { relatedTarget: this };\\n      var showEvent = $.Event(Event.SHOW, relatedTarget);\\n\\n      $(parent).trigger(showEvent);\\n\\n      if (showEvent.isDefaultPrevented()) {\\n        return false;\\n      }\\n\\n      this.focus();\\n      this.setAttribute('aria-expanded', 'true');\\n\\n      $(parent).toggleClass(ClassName.OPEN);\\n      $(parent).trigger($.Event(Event.SHOWN, relatedTarget));\\n\\n      return false;\\n    };\\n\\n    Dropdown.prototype.dispose = function dispose() {\\n      $.removeData(this._element, DATA_KEY);\\n      $(this._element).off(EVENT_KEY);\\n      this._element = null;\\n    };\\n\\n    // private\\n\\n    Dropdown.prototype._addEventListeners = function _addEventListeners() {\\n      $(this._element).on(Event.CLICK, this.toggle);\\n    };\\n\\n    // static\\n\\n    Dropdown._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var data = $(this).data(DATA_KEY);\\n\\n        if (!data) {\\n          $(this).data(DATA_KEY, data = new Dropdown(this));\\n        }\\n\\n        if (typeof config === 'string') {\\n          if (data[config] === undefined) {\\n            throw new Error('No method named \\\"' + config + '\\\"');\\n          }\\n          data[config].call(this);\\n        }\\n      });\\n    };\\n\\n    Dropdown._clearMenus = function _clearMenus(event) {\\n      if (event && event.which === RIGHT_MOUSE_BUTTON_WHICH) {\\n        return;\\n      }\\n\\n      var backdrop = $(Selector.BACKDROP)[0];\\n      if (backdrop) {\\n        backdrop.parentNode.removeChild(backdrop);\\n      }\\n\\n      var toggles = $.makeArray($(Selector.DATA_TOGGLE));\\n\\n      for (var i = 0; i < toggles.length; i++) {\\n        var parent = Dropdown._getParentFromElement(toggles[i]);\\n        var relatedTarget = { relatedTarget: toggles[i] };\\n\\n        if (!$(parent).hasClass(ClassName.OPEN)) {\\n          continue;\\n        }\\n\\n        if (event && event.type === 'click' && /input|textarea/i.test(event.target.tagName) && $.contains(parent, event.target)) {\\n          continue;\\n        }\\n\\n        var hideEvent = $.Event(Event.HIDE, relatedTarget);\\n        $(parent).trigger(hideEvent);\\n        if (hideEvent.isDefaultPrevented()) {\\n          continue;\\n        }\\n\\n        toggles[i].setAttribute('aria-expanded', 'false');\\n\\n        $(parent).removeClass(ClassName.OPEN).trigger($.Event(Event.HIDDEN, relatedTarget));\\n      }\\n    };\\n\\n    Dropdown._getParentFromElement = function _getParentFromElement(element) {\\n      var parent = void 0;\\n      var selector = Util.getSelectorFromElement(element);\\n\\n      if (selector) {\\n        parent = $(selector)[0];\\n      }\\n\\n      return parent || element.parentNode;\\n    };\\n\\n    Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {\\n      if (!/(38|40|27|32)/.test(event.which) || /input|textarea/i.test(event.target.tagName)) {\\n        return;\\n      }\\n\\n      event.preventDefault();\\n      event.stopPropagation();\\n\\n      if (this.disabled || $(this).hasClass(ClassName.DISABLED)) {\\n        return;\\n      }\\n\\n      var parent = Dropdown._getParentFromElement(this);\\n      var isActive = $(parent).hasClass(ClassName.OPEN);\\n\\n      if (!isActive && event.which !== ESCAPE_KEYCODE || isActive && event.which === ESCAPE_KEYCODE) {\\n\\n        if (event.which === ESCAPE_KEYCODE) {\\n          var toggle = $(parent).find(Selector.DATA_TOGGLE)[0];\\n          $(toggle).trigger('focus');\\n        }\\n\\n        $(this).trigger('click');\\n        return;\\n      }\\n\\n      var items = $.makeArray($(Selector.VISIBLE_ITEMS));\\n\\n      items = items.filter(function (item) {\\n        return item.offsetWidth || item.offsetHeight;\\n      });\\n\\n      if (!items.length) {\\n        return;\\n      }\\n\\n      var index = items.indexOf(event.target);\\n\\n      if (event.which === ARROW_UP_KEYCODE && index > 0) {\\n        // up\\n        index--;\\n      }\\n\\n      if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {\\n        // down\\n        index++;\\n      }\\n\\n      if (index < 0) {\\n        index = 0;\\n      }\\n\\n      items[index].focus();\\n    };\\n\\n    _createClass(Dropdown, null, [{\\n      key: 'VERSION',\\n      get: function get() {\\n        return VERSION;\\n      }\\n    }]);\\n\\n    return Dropdown;\\n  }();\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $(document).on(Event.KEYDOWN_DATA_API, Selector.DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event.KEYDOWN_DATA_API, Selector.ROLE_MENU, Dropdown._dataApiKeydownHandler).on(Event.KEYDOWN_DATA_API, Selector.ROLE_LISTBOX, Dropdown._dataApiKeydownHandler).on(Event.CLICK_DATA_API, Dropdown._clearMenus).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, Dropdown.prototype.toggle).on(Event.CLICK_DATA_API, Selector.FORM_CHILD, function (e) {\\n    e.stopPropagation();\\n  });\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME] = Dropdown._jQueryInterface;\\n  $.fn[NAME].Constructor = Dropdown;\\n  $.fn[NAME].noConflict = function () {\\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\\n    return Dropdown._jQueryInterface;\\n  };\\n\\n  return Dropdown;\\n}(jQuery);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v4.0.0-alpha.5): modal.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\nvar Modal = function ($) {\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME = 'modal';\\n  var VERSION = '4.0.0-alpha.5';\\n  var DATA_KEY = 'bs.modal';\\n  var EVENT_KEY = '.' + DATA_KEY;\\n  var DATA_API_KEY = '.data-api';\\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\\n  var TRANSITION_DURATION = 300;\\n  var BACKDROP_TRANSITION_DURATION = 150;\\n  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key\\n\\n  var Default = {\\n    backdrop: true,\\n    keyboard: true,\\n    focus: true,\\n    show: true\\n  };\\n\\n  var DefaultType = {\\n    backdrop: '(boolean|string)',\\n    keyboard: 'boolean',\\n    focus: 'boolean',\\n    show: 'boolean'\\n  };\\n\\n  var Event = {\\n    HIDE: 'hide' + EVENT_KEY,\\n    HIDDEN: 'hidden' + EVENT_KEY,\\n    SHOW: 'show' + EVENT_KEY,\\n    SHOWN: 'shown' + EVENT_KEY,\\n    FOCUSIN: 'focusin' + EVENT_KEY,\\n    RESIZE: 'resize' + EVENT_KEY,\\n    CLICK_DISMISS: 'click.dismiss' + EVENT_KEY,\\n    KEYDOWN_DISMISS: 'keydown.dismiss' + EVENT_KEY,\\n    MOUSEUP_DISMISS: 'mouseup.dismiss' + EVENT_KEY,\\n    MOUSEDOWN_DISMISS: 'mousedown.dismiss' + EVENT_KEY,\\n    CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY\\n  };\\n\\n  var ClassName = {\\n    SCROLLBAR_MEASURER: 'modal-scrollbar-measure',\\n    BACKDROP: 'modal-backdrop',\\n    OPEN: 'modal-open',\\n    FADE: 'fade',\\n    IN: 'in'\\n  };\\n\\n  var Selector = {\\n    DIALOG: '.modal-dialog',\\n    DATA_TOGGLE: '[data-toggle=\\\"modal\\\"]',\\n    DATA_DISMISS: '[data-dismiss=\\\"modal\\\"]',\\n    FIXED_CONTENT: '.navbar-fixed-top, .navbar-fixed-bottom, .is-fixed'\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Modal = function () {\\n    function Modal(element, config) {\\n      _classCallCheck(this, Modal);\\n\\n      this._config = this._getConfig(config);\\n      this._element = element;\\n      this._dialog = $(element).find(Selector.DIALOG)[0];\\n      this._backdrop = null;\\n      this._isShown = false;\\n      this._isBodyOverflowing = false;\\n      this._ignoreBackdropClick = false;\\n      this._originalBodyPadding = 0;\\n      this._scrollbarWidth = 0;\\n    }\\n\\n    // getters\\n\\n    // public\\n\\n    Modal.prototype.toggle = function toggle(relatedTarget) {\\n      return this._isShown ? this.hide() : this.show(relatedTarget);\\n    };\\n\\n    Modal.prototype.show = function show(relatedTarget) {\\n      var _this7 = this;\\n\\n      var showEvent = $.Event(Event.SHOW, {\\n        relatedTarget: relatedTarget\\n      });\\n\\n      $(this._element).trigger(showEvent);\\n\\n      if (this._isShown || showEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      this._isShown = true;\\n\\n      this._checkScrollbar();\\n      this._setScrollbar();\\n\\n      $(document.body).addClass(ClassName.OPEN);\\n\\n      this._setEscapeEvent();\\n      this._setResizeEvent();\\n\\n      $(this._element).on(Event.CLICK_DISMISS, Selector.DATA_DISMISS, $.proxy(this.hide, this));\\n\\n      $(this._dialog).on(Event.MOUSEDOWN_DISMISS, function () {\\n        $(_this7._element).one(Event.MOUSEUP_DISMISS, function (event) {\\n          if ($(event.target).is(_this7._element)) {\\n            _this7._ignoreBackdropClick = true;\\n          }\\n        });\\n      });\\n\\n      this._showBackdrop($.proxy(this._showElement, this, relatedTarget));\\n    };\\n\\n    Modal.prototype.hide = function hide(event) {\\n      if (event) {\\n        event.preventDefault();\\n      }\\n\\n      var hideEvent = $.Event(Event.HIDE);\\n\\n      $(this._element).trigger(hideEvent);\\n\\n      if (!this._isShown || hideEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      this._isShown = false;\\n\\n      this._setEscapeEvent();\\n      this._setResizeEvent();\\n\\n      $(document).off(Event.FOCUSIN);\\n\\n      $(this._element).removeClass(ClassName.IN);\\n\\n      $(this._element).off(Event.CLICK_DISMISS);\\n      $(this._dialog).off(Event.MOUSEDOWN_DISMISS);\\n\\n      if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE)) {\\n\\n        $(this._element).one(Util.TRANSITION_END, $.proxy(this._hideModal, this)).emulateTransitionEnd(TRANSITION_DURATION);\\n      } else {\\n        this._hideModal();\\n      }\\n    };\\n\\n    Modal.prototype.dispose = function dispose() {\\n      $.removeData(this._element, DATA_KEY);\\n\\n      $(window).off(EVENT_KEY);\\n      $(document).off(EVENT_KEY);\\n      $(this._element).off(EVENT_KEY);\\n      $(this._backdrop).off(EVENT_KEY);\\n\\n      this._config = null;\\n      this._element = null;\\n      this._dialog = null;\\n      this._backdrop = null;\\n      this._isShown = null;\\n      this._isBodyOverflowing = null;\\n      this._ignoreBackdropClick = null;\\n      this._originalBodyPadding = null;\\n      this._scrollbarWidth = null;\\n    };\\n\\n    // private\\n\\n    Modal.prototype._getConfig = function _getConfig(config) {\\n      config = $.extend({}, Default, config);\\n      Util.typeCheckConfig(NAME, config, DefaultType);\\n      return config;\\n    };\\n\\n    Modal.prototype._showElement = function _showElement(relatedTarget) {\\n      var _this8 = this;\\n\\n      var transition = Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE);\\n\\n      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {\\n        // don't move modals dom position\\n        document.body.appendChild(this._element);\\n      }\\n\\n      this._element.style.display = 'block';\\n      this._element.removeAttribute('aria-hidden');\\n      this._element.scrollTop = 0;\\n\\n      if (transition) {\\n        Util.reflow(this._element);\\n      }\\n\\n      $(this._element).addClass(ClassName.IN);\\n\\n      if (this._config.focus) {\\n        this._enforceFocus();\\n      }\\n\\n      var shownEvent = $.Event(Event.SHOWN, {\\n        relatedTarget: relatedTarget\\n      });\\n\\n      var transitionComplete = function transitionComplete() {\\n        if (_this8._config.focus) {\\n          _this8._element.focus();\\n        }\\n        $(_this8._element).trigger(shownEvent);\\n      };\\n\\n      if (transition) {\\n        $(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(TRANSITION_DURATION);\\n      } else {\\n        transitionComplete();\\n      }\\n    };\\n\\n    Modal.prototype._enforceFocus = function _enforceFocus() {\\n      var _this9 = this;\\n\\n      $(document).off(Event.FOCUSIN) // guard against infinite focus loop\\n      .on(Event.FOCUSIN, function (event) {\\n        if (document !== event.target && _this9._element !== event.target && !$(_this9._element).has(event.target).length) {\\n          _this9._element.focus();\\n        }\\n      });\\n    };\\n\\n    Modal.prototype._setEscapeEvent = function _setEscapeEvent() {\\n      var _this10 = this;\\n\\n      if (this._isShown && this._config.keyboard) {\\n        $(this._element).on(Event.KEYDOWN_DISMISS, function (event) {\\n          if (event.which === ESCAPE_KEYCODE) {\\n            _this10.hide();\\n          }\\n        });\\n      } else if (!this._isShown) {\\n        $(this._element).off(Event.KEYDOWN_DISMISS);\\n      }\\n    };\\n\\n    Modal.prototype._setResizeEvent = function _setResizeEvent() {\\n      if (this._isShown) {\\n        $(window).on(Event.RESIZE, $.proxy(this._handleUpdate, this));\\n      } else {\\n        $(window).off(Event.RESIZE);\\n      }\\n    };\\n\\n    Modal.prototype._hideModal = function _hideModal() {\\n      var _this11 = this;\\n\\n      this._element.style.display = 'none';\\n      this._element.setAttribute('aria-hidden', 'true');\\n      this._showBackdrop(function () {\\n        $(document.body).removeClass(ClassName.OPEN);\\n        _this11._resetAdjustments();\\n        _this11._resetScrollbar();\\n        $(_this11._element).trigger(Event.HIDDEN);\\n      });\\n    };\\n\\n    Modal.prototype._removeBackdrop = function _removeBackdrop() {\\n      if (this._backdrop) {\\n        $(this._backdrop).remove();\\n        this._backdrop = null;\\n      }\\n    };\\n\\n    Modal.prototype._showBackdrop = function _showBackdrop(callback) {\\n      var _this12 = this;\\n\\n      var animate = $(this._element).hasClass(ClassName.FADE) ? ClassName.FADE : '';\\n\\n      if (this._isShown && this._config.backdrop) {\\n        var doAnimate = Util.supportsTransitionEnd() && animate;\\n\\n        this._backdrop = document.createElement('div');\\n        this._backdrop.className = ClassName.BACKDROP;\\n\\n        if (animate) {\\n          $(this._backdrop).addClass(animate);\\n        }\\n\\n        $(this._backdrop).appendTo(document.body);\\n\\n        $(this._element).on(Event.CLICK_DISMISS, function (event) {\\n          if (_this12._ignoreBackdropClick) {\\n            _this12._ignoreBackdropClick = false;\\n            return;\\n          }\\n          if (event.target !== event.currentTarget) {\\n            return;\\n          }\\n          if (_this12._config.backdrop === 'static') {\\n            _this12._element.focus();\\n          } else {\\n            _this12.hide();\\n          }\\n        });\\n\\n        if (doAnimate) {\\n          Util.reflow(this._backdrop);\\n        }\\n\\n        $(this._backdrop).addClass(ClassName.IN);\\n\\n        if (!callback) {\\n          return;\\n        }\\n\\n        if (!doAnimate) {\\n          callback();\\n          return;\\n        }\\n\\n        $(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);\\n      } else if (!this._isShown && this._backdrop) {\\n        $(this._backdrop).removeClass(ClassName.IN);\\n\\n        var callbackRemove = function callbackRemove() {\\n          _this12._removeBackdrop();\\n          if (callback) {\\n            callback();\\n          }\\n        };\\n\\n        if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE)) {\\n          $(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);\\n        } else {\\n          callbackRemove();\\n        }\\n      } else if (callback) {\\n        callback();\\n      }\\n    };\\n\\n    // ----------------------------------------------------------------------\\n    // the following methods are used to handle overflowing modals\\n    // todo (fat): these should probably be refactored out of modal.js\\n    // ----------------------------------------------------------------------\\n\\n    Modal.prototype._handleUpdate = function _handleUpdate() {\\n      this._adjustDialog();\\n    };\\n\\n    Modal.prototype._adjustDialog = function _adjustDialog() {\\n      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\\n\\n      if (!this._isBodyOverflowing && isModalOverflowing) {\\n        this._element.style.paddingLeft = this._scrollbarWidth + 'px';\\n      }\\n\\n      if (this._isBodyOverflowing && !isModalOverflowing) {\\n        this._element.style.paddingRight = this._scrollbarWidth + 'px';\\n      }\\n    };\\n\\n    Modal.prototype._resetAdjustments = function _resetAdjustments() {\\n      this._element.style.paddingLeft = '';\\n      this._element.style.paddingRight = '';\\n    };\\n\\n    Modal.prototype._checkScrollbar = function _checkScrollbar() {\\n      this._isBodyOverflowing = document.body.clientWidth < window.innerWidth;\\n      this._scrollbarWidth = this._getScrollbarWidth();\\n    };\\n\\n    Modal.prototype._setScrollbar = function _setScrollbar() {\\n      var bodyPadding = parseInt($(Selector.FIXED_CONTENT).css('padding-right') || 0, 10);\\n\\n      this._originalBodyPadding = document.body.style.paddingRight || '';\\n\\n      if (this._isBodyOverflowing) {\\n        document.body.style.paddingRight = bodyPadding + this._scrollbarWidth + 'px';\\n      }\\n    };\\n\\n    Modal.prototype._resetScrollbar = function _resetScrollbar() {\\n      document.body.style.paddingRight = this._originalBodyPadding;\\n    };\\n\\n    Modal.prototype._getScrollbarWidth = function _getScrollbarWidth() {\\n      // thx d.walsh\\n      var scrollDiv = document.createElement('div');\\n      scrollDiv.className = ClassName.SCROLLBAR_MEASURER;\\n      document.body.appendChild(scrollDiv);\\n      var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\\n      document.body.removeChild(scrollDiv);\\n      return scrollbarWidth;\\n    };\\n\\n    // static\\n\\n    Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {\\n      return this.each(function () {\\n        var data = $(this).data(DATA_KEY);\\n        var _config = $.extend({}, Modal.Default, $(this).data(), (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config);\\n\\n        if (!data) {\\n          data = new Modal(this, _config);\\n          $(this).data(DATA_KEY, data);\\n        }\\n\\n        if (typeof config === 'string') {\\n          if (data[config] === undefined) {\\n            throw new Error('No method named \\\"' + config + '\\\"');\\n          }\\n          data[config](relatedTarget);\\n        } else if (_config.show) {\\n          data.show(relatedTarget);\\n        }\\n      });\\n    };\\n\\n    _createClass(Modal, null, [{\\n      key: 'VERSION',\\n      get: function get() {\\n        return VERSION;\\n      }\\n    }, {\\n      key: 'Default',\\n      get: function get() {\\n        return Default;\\n      }\\n    }]);\\n\\n    return Modal;\\n  }();\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {\\n    var _this13 = this;\\n\\n    var target = void 0;\\n    var selector = Util.getSelectorFromElement(this);\\n\\n    if (selector) {\\n      target = $(selector)[0];\\n    }\\n\\n    var config = $(target).data(DATA_KEY) ? 'toggle' : $.extend({}, $(target).data(), $(this).data());\\n\\n    if (this.tagName === 'A') {\\n      event.preventDefault();\\n    }\\n\\n    var $target = $(target).one(Event.SHOW, function (showEvent) {\\n      if (showEvent.isDefaultPrevented()) {\\n        // only register focus restorer if modal will actually get shown\\n        return;\\n      }\\n\\n      $target.one(Event.HIDDEN, function () {\\n        if ($(_this13).is(':visible')) {\\n          _this13.focus();\\n        }\\n      });\\n    });\\n\\n    Modal._jQueryInterface.call($(target), config, this);\\n  });\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME] = Modal._jQueryInterface;\\n  $.fn[NAME].Constructor = Modal;\\n  $.fn[NAME].noConflict = function () {\\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\\n    return Modal._jQueryInterface;\\n  };\\n\\n  return Modal;\\n}(jQuery);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v4.0.0-alpha.5): scrollspy.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\nvar ScrollSpy = function ($) {\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME = 'scrollspy';\\n  var VERSION = '4.0.0-alpha.5';\\n  var DATA_KEY = 'bs.scrollspy';\\n  var EVENT_KEY = '.' + DATA_KEY;\\n  var DATA_API_KEY = '.data-api';\\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\\n\\n  var Default = {\\n    offset: 10,\\n    method: 'auto',\\n    target: ''\\n  };\\n\\n  var DefaultType = {\\n    offset: 'number',\\n    method: 'string',\\n    target: '(string|element)'\\n  };\\n\\n  var Event = {\\n    ACTIVATE: 'activate' + EVENT_KEY,\\n    SCROLL: 'scroll' + EVENT_KEY,\\n    LOAD_DATA_API: 'load' + EVENT_KEY + DATA_API_KEY\\n  };\\n\\n  var ClassName = {\\n    DROPDOWN_ITEM: 'dropdown-item',\\n    DROPDOWN_MENU: 'dropdown-menu',\\n    NAV_LINK: 'nav-link',\\n    NAV: 'nav',\\n    ACTIVE: 'active'\\n  };\\n\\n  var Selector = {\\n    DATA_SPY: '[data-spy=\\\"scroll\\\"]',\\n    ACTIVE: '.active',\\n    LIST_ITEM: '.list-item',\\n    LI: 'li',\\n    LI_DROPDOWN: 'li.dropdown',\\n    NAV_LINKS: '.nav-link',\\n    DROPDOWN: '.dropdown',\\n    DROPDOWN_ITEMS: '.dropdown-item',\\n    DROPDOWN_TOGGLE: '.dropdown-toggle'\\n  };\\n\\n  var OffsetMethod = {\\n    OFFSET: 'offset',\\n    POSITION: 'position'\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var ScrollSpy = function () {\\n    function ScrollSpy(element, config) {\\n      _classCallCheck(this, ScrollSpy);\\n\\n      this._element = element;\\n      this._scrollElement = element.tagName === 'BODY' ? window : element;\\n      this._config = this._getConfig(config);\\n      this._selector = this._config.target + ' ' + Selector.NAV_LINKS + ',' + (this._config.target + ' ' + Selector.DROPDOWN_ITEMS);\\n      this._offsets = [];\\n      this._targets = [];\\n      this._activeTarget = null;\\n      this._scrollHeight = 0;\\n\\n      $(this._scrollElement).on(Event.SCROLL, $.proxy(this._process, this));\\n\\n      this.refresh();\\n      this._process();\\n    }\\n\\n    // getters\\n\\n    // public\\n\\n    ScrollSpy.prototype.refresh = function refresh() {\\n      var _this14 = this;\\n\\n      var autoMethod = this._scrollElement !== this._scrollElement.window ? OffsetMethod.POSITION : OffsetMethod.OFFSET;\\n\\n      var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;\\n\\n      var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;\\n\\n      this._offsets = [];\\n      this._targets = [];\\n\\n      this._scrollHeight = this._getScrollHeight();\\n\\n      var targets = $.makeArray($(this._selector));\\n\\n      targets.map(function (element) {\\n        var target = void 0;\\n        var targetSelector = Util.getSelectorFromElement(element);\\n\\n        if (targetSelector) {\\n          target = $(targetSelector)[0];\\n        }\\n\\n        if (target && (target.offsetWidth || target.offsetHeight)) {\\n          // todo (fat): remove sketch reliance on jQuery position/offset\\n          return [$(target)[offsetMethod]().top + offsetBase, targetSelector];\\n        }\\n        return null;\\n      }).filter(function (item) {\\n        return item;\\n      }).sort(function (a, b) {\\n        return a[0] - b[0];\\n      }).forEach(function (item) {\\n        _this14._offsets.push(item[0]);\\n        _this14._targets.push(item[1]);\\n      });\\n    };\\n\\n    ScrollSpy.prototype.dispose = function dispose() {\\n      $.removeData(this._element, DATA_KEY);\\n      $(this._scrollElement).off(EVENT_KEY);\\n\\n      this._element = null;\\n      this._scrollElement = null;\\n      this._config = null;\\n      this._selector = null;\\n      this._offsets = null;\\n      this._targets = null;\\n      this._activeTarget = null;\\n      this._scrollHeight = null;\\n    };\\n\\n    // private\\n\\n    ScrollSpy.prototype._getConfig = function _getConfig(config) {\\n      config = $.extend({}, Default, config);\\n\\n      if (typeof config.target !== 'string') {\\n        var id = $(config.target).attr('id');\\n        if (!id) {\\n          id = Util.getUID(NAME);\\n          $(config.target).attr('id', id);\\n        }\\n        config.target = '#' + id;\\n      }\\n\\n      Util.typeCheckConfig(NAME, config, DefaultType);\\n\\n      return config;\\n    };\\n\\n    ScrollSpy.prototype._getScrollTop = function _getScrollTop() {\\n      return this._scrollElement === window ? this._scrollElement.scrollY : this._scrollElement.scrollTop;\\n    };\\n\\n    ScrollSpy.prototype._getScrollHeight = function _getScrollHeight() {\\n      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\\n    };\\n\\n    ScrollSpy.prototype._process = function _process() {\\n      var scrollTop = this._getScrollTop() + this._config.offset;\\n      var scrollHeight = this._getScrollHeight();\\n      var maxScroll = this._config.offset + scrollHeight - this._scrollElement.offsetHeight;\\n\\n      if (this._scrollHeight !== scrollHeight) {\\n        this.refresh();\\n      }\\n\\n      if (scrollTop >= maxScroll) {\\n        var target = this._targets[this._targets.length - 1];\\n\\n        if (this._activeTarget !== target) {\\n          this._activate(target);\\n        }\\n      }\\n\\n      if (this._activeTarget && scrollTop < this._offsets[0]) {\\n        this._activeTarget = null;\\n        this._clear();\\n        return;\\n      }\\n\\n      for (var i = this._offsets.length; i--;) {\\n        var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (this._offsets[i + 1] === undefined || scrollTop < this._offsets[i + 1]);\\n\\n        if (isActiveTarget) {\\n          this._activate(this._targets[i]);\\n        }\\n      }\\n    };\\n\\n    ScrollSpy.prototype._activate = function _activate(target) {\\n      this._activeTarget = target;\\n\\n      this._clear();\\n\\n      var queries = this._selector.split(',');\\n      queries = queries.map(function (selector) {\\n        return selector + '[data-target=\\\"' + target + '\\\"],' + (selector + '[href=\\\"' + target + '\\\"]');\\n      });\\n\\n      var $link = $(queries.join(','));\\n\\n      if ($link.hasClass(ClassName.DROPDOWN_ITEM)) {\\n        $link.closest(Selector.DROPDOWN).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);\\n        $link.addClass(ClassName.ACTIVE);\\n      } else {\\n        // todo (fat) this is kinda sus...\\n        // recursively add actives to tested nav-links\\n        $link.parents(Selector.LI).find(Selector.NAV_LINKS).addClass(ClassName.ACTIVE);\\n      }\\n\\n      $(this._scrollElement).trigger(Event.ACTIVATE, {\\n        relatedTarget: target\\n      });\\n    };\\n\\n    ScrollSpy.prototype._clear = function _clear() {\\n      $(this._selector).filter(Selector.ACTIVE).removeClass(ClassName.ACTIVE);\\n    };\\n\\n    // static\\n\\n    ScrollSpy._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var data = $(this).data(DATA_KEY);\\n        var _config = (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config || null;\\n\\n        if (!data) {\\n          data = new ScrollSpy(this, _config);\\n          $(this).data(DATA_KEY, data);\\n        }\\n\\n        if (typeof config === 'string') {\\n          if (data[config] === undefined) {\\n            throw new Error('No method named \\\"' + config + '\\\"');\\n          }\\n          data[config]();\\n        }\\n      });\\n    };\\n\\n    _createClass(ScrollSpy, null, [{\\n      key: 'VERSION',\\n      get: function get() {\\n        return VERSION;\\n      }\\n    }, {\\n      key: 'Default',\\n      get: function get() {\\n        return Default;\\n      }\\n    }]);\\n\\n    return ScrollSpy;\\n  }();\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $(window).on(Event.LOAD_DATA_API, function () {\\n    var scrollSpys = $.makeArray($(Selector.DATA_SPY));\\n\\n    for (var i = scrollSpys.length; i--;) {\\n      var $spy = $(scrollSpys[i]);\\n      ScrollSpy._jQueryInterface.call($spy, $spy.data());\\n    }\\n  });\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME] = ScrollSpy._jQueryInterface;\\n  $.fn[NAME].Constructor = ScrollSpy;\\n  $.fn[NAME].noConflict = function () {\\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\\n    return ScrollSpy._jQueryInterface;\\n  };\\n\\n  return ScrollSpy;\\n}(jQuery);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v4.0.0-alpha.5): tab.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\nvar Tab = function ($) {\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME = 'tab';\\n  var VERSION = '4.0.0-alpha.5';\\n  var DATA_KEY = 'bs.tab';\\n  var EVENT_KEY = '.' + DATA_KEY;\\n  var DATA_API_KEY = '.data-api';\\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\\n  var TRANSITION_DURATION = 150;\\n\\n  var Event = {\\n    HIDE: 'hide' + EVENT_KEY,\\n    HIDDEN: 'hidden' + EVENT_KEY,\\n    SHOW: 'show' + EVENT_KEY,\\n    SHOWN: 'shown' + EVENT_KEY,\\n    CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY\\n  };\\n\\n  var ClassName = {\\n    DROPDOWN_MENU: 'dropdown-menu',\\n    ACTIVE: 'active',\\n    FADE: 'fade',\\n    IN: 'in'\\n  };\\n\\n  var Selector = {\\n    A: 'a',\\n    LI: 'li',\\n    DROPDOWN: '.dropdown',\\n    UL: 'ul:not(.dropdown-menu)',\\n    FADE_CHILD: '> .nav-item .fade, > .fade',\\n    ACTIVE: '.active',\\n    ACTIVE_CHILD: '> .nav-item > .active, > .active',\\n    DATA_TOGGLE: '[data-toggle=\\\"tab\\\"], [data-toggle=\\\"pill\\\"]',\\n    DROPDOWN_TOGGLE: '.dropdown-toggle',\\n    DROPDOWN_ACTIVE_CHILD: '> .dropdown-menu .active'\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Tab = function () {\\n    function Tab(element) {\\n      _classCallCheck(this, Tab);\\n\\n      this._element = element;\\n    }\\n\\n    // getters\\n\\n    // public\\n\\n    Tab.prototype.show = function show() {\\n      var _this15 = this;\\n\\n      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $(this._element).hasClass(ClassName.ACTIVE)) {\\n        return;\\n      }\\n\\n      var target = void 0;\\n      var previous = void 0;\\n      var ulElement = $(this._element).closest(Selector.UL)[0];\\n      var selector = Util.getSelectorFromElement(this._element);\\n\\n      if (ulElement) {\\n        previous = $.makeArray($(ulElement).find(Selector.ACTIVE));\\n        previous = previous[previous.length - 1];\\n      }\\n\\n      var hideEvent = $.Event(Event.HIDE, {\\n        relatedTarget: this._element\\n      });\\n\\n      var showEvent = $.Event(Event.SHOW, {\\n        relatedTarget: previous\\n      });\\n\\n      if (previous) {\\n        $(previous).trigger(hideEvent);\\n      }\\n\\n      $(this._element).trigger(showEvent);\\n\\n      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      if (selector) {\\n        target = $(selector)[0];\\n      }\\n\\n      this._activate(this._element, ulElement);\\n\\n      var complete = function complete() {\\n        var hiddenEvent = $.Event(Event.HIDDEN, {\\n          relatedTarget: _this15._element\\n        });\\n\\n        var shownEvent = $.Event(Event.SHOWN, {\\n          relatedTarget: previous\\n        });\\n\\n        $(previous).trigger(hiddenEvent);\\n        $(_this15._element).trigger(shownEvent);\\n      };\\n\\n      if (target) {\\n        this._activate(target, target.parentNode, complete);\\n      } else {\\n        complete();\\n      }\\n    };\\n\\n    Tab.prototype.dispose = function dispose() {\\n      $.removeClass(this._element, DATA_KEY);\\n      this._element = null;\\n    };\\n\\n    // private\\n\\n    Tab.prototype._activate = function _activate(element, container, callback) {\\n      var active = $(container).find(Selector.ACTIVE_CHILD)[0];\\n      var isTransitioning = callback && Util.supportsTransitionEnd() && (active && $(active).hasClass(ClassName.FADE) || Boolean($(container).find(Selector.FADE_CHILD)[0]));\\n\\n      var complete = $.proxy(this._transitionComplete, this, element, active, isTransitioning, callback);\\n\\n      if (active && isTransitioning) {\\n        $(active).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);\\n      } else {\\n        complete();\\n      }\\n\\n      if (active) {\\n        $(active).removeClass(ClassName.IN);\\n      }\\n    };\\n\\n    Tab.prototype._transitionComplete = function _transitionComplete(element, active, isTransitioning, callback) {\\n      if (active) {\\n        $(active).removeClass(ClassName.ACTIVE);\\n\\n        var dropdownChild = $(active).find(Selector.DROPDOWN_ACTIVE_CHILD)[0];\\n\\n        if (dropdownChild) {\\n          $(dropdownChild).removeClass(ClassName.ACTIVE);\\n        }\\n\\n        active.setAttribute('aria-expanded', false);\\n      }\\n\\n      $(element).addClass(ClassName.ACTIVE);\\n      element.setAttribute('aria-expanded', true);\\n\\n      if (isTransitioning) {\\n        Util.reflow(element);\\n        $(element).addClass(ClassName.IN);\\n      } else {\\n        $(element).removeClass(ClassName.FADE);\\n      }\\n\\n      if (element.parentNode && $(element.parentNode).hasClass(ClassName.DROPDOWN_MENU)) {\\n\\n        var dropdownElement = $(element).closest(Selector.DROPDOWN)[0];\\n        if (dropdownElement) {\\n          $(dropdownElement).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);\\n        }\\n\\n        element.setAttribute('aria-expanded', true);\\n      }\\n\\n      if (callback) {\\n        callback();\\n      }\\n    };\\n\\n    // static\\n\\n    Tab._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var $this = $(this);\\n        var data = $this.data(DATA_KEY);\\n\\n        if (!data) {\\n          data = data = new Tab(this);\\n          $this.data(DATA_KEY, data);\\n        }\\n\\n        if (typeof config === 'string') {\\n          if (data[config] === undefined) {\\n            throw new Error('No method named \\\"' + config + '\\\"');\\n          }\\n          data[config]();\\n        }\\n      });\\n    };\\n\\n    _createClass(Tab, null, [{\\n      key: 'VERSION',\\n      get: function get() {\\n        return VERSION;\\n      }\\n    }]);\\n\\n    return Tab;\\n  }();\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {\\n    event.preventDefault();\\n    Tab._jQueryInterface.call($(this), 'show');\\n  });\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME] = Tab._jQueryInterface;\\n  $.fn[NAME].Constructor = Tab;\\n  $.fn[NAME].noConflict = function () {\\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\\n    return Tab._jQueryInterface;\\n  };\\n\\n  return Tab;\\n}(jQuery);\\n\\n/* global Tether */\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v4.0.0-alpha.5): tooltip.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\nvar Tooltip = function ($) {\\n\\n  /**\\n   * Check for Tether dependency\\n   * Tether - http://tether.io/\\n   */\\n  if (window.Tether === undefined) {\\n    throw new Error('Bootstrap tooltips require Tether (http://tether.io/)');\\n  }\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME = 'tooltip';\\n  var VERSION = '4.0.0-alpha.5';\\n  var DATA_KEY = 'bs.tooltip';\\n  var EVENT_KEY = '.' + DATA_KEY;\\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\\n  var TRANSITION_DURATION = 150;\\n  var CLASS_PREFIX = 'bs-tether';\\n\\n  var Default = {\\n    animation: true,\\n    template: '<div class=\\\"tooltip\\\" role=\\\"tooltip\\\">' + '<div class=\\\"tooltip-inner\\\"></div></div>',\\n    trigger: 'hover focus',\\n    title: '',\\n    delay: 0,\\n    html: false,\\n    selector: false,\\n    placement: 'top',\\n    offset: '0 0',\\n    constraints: []\\n  };\\n\\n  var DefaultType = {\\n    animation: 'boolean',\\n    template: 'string',\\n    title: '(string|element|function)',\\n    trigger: 'string',\\n    delay: '(number|object)',\\n    html: 'boolean',\\n    selector: '(string|boolean)',\\n    placement: '(string|function)',\\n    offset: 'string',\\n    constraints: 'array'\\n  };\\n\\n  var AttachmentMap = {\\n    TOP: 'bottom center',\\n    RIGHT: 'middle left',\\n    BOTTOM: 'top center',\\n    LEFT: 'middle right'\\n  };\\n\\n  var HoverState = {\\n    IN: 'in',\\n    OUT: 'out'\\n  };\\n\\n  var Event = {\\n    HIDE: 'hide' + EVENT_KEY,\\n    HIDDEN: 'hidden' + EVENT_KEY,\\n    SHOW: 'show' + EVENT_KEY,\\n    SHOWN: 'shown' + EVENT_KEY,\\n    INSERTED: 'inserted' + EVENT_KEY,\\n    CLICK: 'click' + EVENT_KEY,\\n    FOCUSIN: 'focusin' + EVENT_KEY,\\n    FOCUSOUT: 'focusout' + EVENT_KEY,\\n    MOUSEENTER: 'mouseenter' + EVENT_KEY,\\n    MOUSELEAVE: 'mouseleave' + EVENT_KEY\\n  };\\n\\n  var ClassName = {\\n    FADE: 'fade',\\n    IN: 'in'\\n  };\\n\\n  var Selector = {\\n    TOOLTIP: '.tooltip',\\n    TOOLTIP_INNER: '.tooltip-inner'\\n  };\\n\\n  var TetherClass = {\\n    element: false,\\n    enabled: false\\n  };\\n\\n  var Trigger = {\\n    HOVER: 'hover',\\n    FOCUS: 'focus',\\n    CLICK: 'click',\\n    MANUAL: 'manual'\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Tooltip = function () {\\n    function Tooltip(element, config) {\\n      _classCallCheck(this, Tooltip);\\n\\n      // private\\n      this._isEnabled = true;\\n      this._timeout = 0;\\n      this._hoverState = '';\\n      this._activeTrigger = {};\\n      this._tether = null;\\n\\n      // protected\\n      this.element = element;\\n      this.config = this._getConfig(config);\\n      this.tip = null;\\n\\n      this._setListeners();\\n    }\\n\\n    // getters\\n\\n    // public\\n\\n    Tooltip.prototype.enable = function enable() {\\n      this._isEnabled = true;\\n    };\\n\\n    Tooltip.prototype.disable = function disable() {\\n      this._isEnabled = false;\\n    };\\n\\n    Tooltip.prototype.toggleEnabled = function toggleEnabled() {\\n      this._isEnabled = !this._isEnabled;\\n    };\\n\\n    Tooltip.prototype.toggle = function toggle(event) {\\n      if (event) {\\n        var dataKey = this.constructor.DATA_KEY;\\n        var context = $(event.currentTarget).data(dataKey);\\n\\n        if (!context) {\\n          context = new this.constructor(event.currentTarget, this._getDelegateConfig());\\n          $(event.currentTarget).data(dataKey, context);\\n        }\\n\\n        context._activeTrigger.click = !context._activeTrigger.click;\\n\\n        if (context._isWithActiveTrigger()) {\\n          context._enter(null, context);\\n        } else {\\n          context._leave(null, context);\\n        }\\n      } else {\\n\\n        if ($(this.getTipElement()).hasClass(ClassName.IN)) {\\n          this._leave(null, this);\\n          return;\\n        }\\n\\n        this._enter(null, this);\\n      }\\n    };\\n\\n    Tooltip.prototype.dispose = function dispose() {\\n      clearTimeout(this._timeout);\\n\\n      this.cleanupTether();\\n\\n      $.removeData(this.element, this.constructor.DATA_KEY);\\n\\n      $(this.element).off(this.constructor.EVENT_KEY);\\n\\n      if (this.tip) {\\n        $(this.tip).remove();\\n      }\\n\\n      this._isEnabled = null;\\n      this._timeout = null;\\n      this._hoverState = null;\\n      this._activeTrigger = null;\\n      this._tether = null;\\n\\n      this.element = null;\\n      this.config = null;\\n      this.tip = null;\\n    };\\n\\n    Tooltip.prototype.show = function show() {\\n      var _this16 = this;\\n\\n      var showEvent = $.Event(this.constructor.Event.SHOW);\\n\\n      if (this.isWithContent() && this._isEnabled) {\\n        $(this.element).trigger(showEvent);\\n\\n        var isInTheDom = $.contains(this.element.ownerDocument.documentElement, this.element);\\n\\n        if (showEvent.isDefaultPrevented() || !isInTheDom) {\\n          return;\\n        }\\n\\n        var tip = this.getTipElement();\\n        var tipId = Util.getUID(this.constructor.NAME);\\n\\n        tip.setAttribute('id', tipId);\\n        this.element.setAttribute('aria-describedby', tipId);\\n\\n        this.setContent();\\n\\n        if (this.config.animation) {\\n          $(tip).addClass(ClassName.FADE);\\n        }\\n\\n        var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;\\n\\n        var attachment = this._getAttachment(placement);\\n\\n        $(tip).data(this.constructor.DATA_KEY, this).appendTo(document.body);\\n\\n        $(this.element).trigger(this.constructor.Event.INSERTED);\\n\\n        this._tether = new Tether({\\n          attachment: attachment,\\n          element: tip,\\n          target: this.element,\\n          classes: TetherClass,\\n          classPrefix: CLASS_PREFIX,\\n          offset: this.config.offset,\\n          constraints: this.config.constraints,\\n          addTargetClasses: false\\n        });\\n\\n        Util.reflow(tip);\\n        this._tether.position();\\n\\n        $(tip).addClass(ClassName.IN);\\n\\n        var complete = function complete() {\\n          var prevHoverState = _this16._hoverState;\\n          _this16._hoverState = null;\\n\\n          $(_this16.element).trigger(_this16.constructor.Event.SHOWN);\\n\\n          if (prevHoverState === HoverState.OUT) {\\n            _this16._leave(null, _this16);\\n          }\\n        };\\n\\n        if (Util.supportsTransitionEnd() && $(this.tip).hasClass(ClassName.FADE)) {\\n          $(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(Tooltip._TRANSITION_DURATION);\\n          return;\\n        }\\n\\n        complete();\\n      }\\n    };\\n\\n    Tooltip.prototype.hide = function hide(callback) {\\n      var _this17 = this;\\n\\n      var tip = this.getTipElement();\\n      var hideEvent = $.Event(this.constructor.Event.HIDE);\\n      var complete = function complete() {\\n        if (_this17._hoverState !== HoverState.IN && tip.parentNode) {\\n          tip.parentNode.removeChild(tip);\\n        }\\n\\n        _this17.element.removeAttribute('aria-describedby');\\n        $(_this17.element).trigger(_this17.constructor.Event.HIDDEN);\\n        _this17.cleanupTether();\\n\\n        if (callback) {\\n          callback();\\n        }\\n      };\\n\\n      $(this.element).trigger(hideEvent);\\n\\n      if (hideEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      $(tip).removeClass(ClassName.IN);\\n\\n      if (Util.supportsTransitionEnd() && $(this.tip).hasClass(ClassName.FADE)) {\\n\\n        $(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);\\n      } else {\\n        complete();\\n      }\\n\\n      this._hoverState = '';\\n    };\\n\\n    // protected\\n\\n    Tooltip.prototype.isWithContent = function isWithContent() {\\n      return Boolean(this.getTitle());\\n    };\\n\\n    Tooltip.prototype.getTipElement = function getTipElement() {\\n      return this.tip = this.tip || $(this.config.template)[0];\\n    };\\n\\n    Tooltip.prototype.setContent = function setContent() {\\n      var $tip = $(this.getTipElement());\\n\\n      this.setElementContent($tip.find(Selector.TOOLTIP_INNER), this.getTitle());\\n\\n      $tip.removeClass(ClassName.FADE).removeClass(ClassName.IN);\\n\\n      this.cleanupTether();\\n    };\\n\\n    Tooltip.prototype.setElementContent = function setElementContent($element, content) {\\n      var html = this.config.html;\\n      if ((typeof content === 'undefined' ? 'undefined' : _typeof(content)) === 'object' && (content.nodeType || content.jquery)) {\\n        // content is a DOM node or a jQuery\\n        if (html) {\\n          if (!$(content).parent().is($element)) {\\n            $element.empty().append(content);\\n          }\\n        } else {\\n          $element.text($(content).text());\\n        }\\n      } else {\\n        $element[html ? 'html' : 'text'](content);\\n      }\\n    };\\n\\n    Tooltip.prototype.getTitle = function getTitle() {\\n      var title = this.element.getAttribute('data-original-title');\\n\\n      if (!title) {\\n        title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;\\n      }\\n\\n      return title;\\n    };\\n\\n    Tooltip.prototype.cleanupTether = function cleanupTether() {\\n      if (this._tether) {\\n        this._tether.destroy();\\n      }\\n    };\\n\\n    // private\\n\\n    Tooltip.prototype._getAttachment = function _getAttachment(placement) {\\n      return AttachmentMap[placement.toUpperCase()];\\n    };\\n\\n    Tooltip.prototype._setListeners = function _setListeners() {\\n      var _this18 = this;\\n\\n      var triggers = this.config.trigger.split(' ');\\n\\n      triggers.forEach(function (trigger) {\\n        if (trigger === 'click') {\\n          $(_this18.element).on(_this18.constructor.Event.CLICK, _this18.config.selector, $.proxy(_this18.toggle, _this18));\\n        } else if (trigger !== Trigger.MANUAL) {\\n          var eventIn = trigger === Trigger.HOVER ? _this18.constructor.Event.MOUSEENTER : _this18.constructor.Event.FOCUSIN;\\n          var eventOut = trigger === Trigger.HOVER ? _this18.constructor.Event.MOUSELEAVE : _this18.constructor.Event.FOCUSOUT;\\n\\n          $(_this18.element).on(eventIn, _this18.config.selector, $.proxy(_this18._enter, _this18)).on(eventOut, _this18.config.selector, $.proxy(_this18._leave, _this18));\\n        }\\n      });\\n\\n      if (this.config.selector) {\\n        this.config = $.extend({}, this.config, {\\n          trigger: 'manual',\\n          selector: ''\\n        });\\n      } else {\\n        this._fixTitle();\\n      }\\n    };\\n\\n    Tooltip.prototype._fixTitle = function _fixTitle() {\\n      var titleType = _typeof(this.element.getAttribute('data-original-title'));\\n      if (this.element.getAttribute('title') || titleType !== 'string') {\\n        this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');\\n        this.element.setAttribute('title', '');\\n      }\\n    };\\n\\n    Tooltip.prototype._enter = function _enter(event, context) {\\n      var dataKey = this.constructor.DATA_KEY;\\n\\n      context = context || $(event.currentTarget).data(dataKey);\\n\\n      if (!context) {\\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\\n        $(event.currentTarget).data(dataKey, context);\\n      }\\n\\n      if (event) {\\n        context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;\\n      }\\n\\n      if ($(context.getTipElement()).hasClass(ClassName.IN) || context._hoverState === HoverState.IN) {\\n        context._hoverState = HoverState.IN;\\n        return;\\n      }\\n\\n      clearTimeout(context._timeout);\\n\\n      context._hoverState = HoverState.IN;\\n\\n      if (!context.config.delay || !context.config.delay.show) {\\n        context.show();\\n        return;\\n      }\\n\\n      context._timeout = setTimeout(function () {\\n        if (context._hoverState === HoverState.IN) {\\n          context.show();\\n        }\\n      }, context.config.delay.show);\\n    };\\n\\n    Tooltip.prototype._leave = function _leave(event, context) {\\n      var dataKey = this.constructor.DATA_KEY;\\n\\n      context = context || $(event.currentTarget).data(dataKey);\\n\\n      if (!context) {\\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\\n        $(event.currentTarget).data(dataKey, context);\\n      }\\n\\n      if (event) {\\n        context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;\\n      }\\n\\n      if (context._isWithActiveTrigger()) {\\n        return;\\n      }\\n\\n      clearTimeout(context._timeout);\\n\\n      context._hoverState = HoverState.OUT;\\n\\n      if (!context.config.delay || !context.config.delay.hide) {\\n        context.hide();\\n        return;\\n      }\\n\\n      context._timeout = setTimeout(function () {\\n        if (context._hoverState === HoverState.OUT) {\\n          context.hide();\\n        }\\n      }, context.config.delay.hide);\\n    };\\n\\n    Tooltip.prototype._isWithActiveTrigger = function _isWithActiveTrigger() {\\n      for (var trigger in this._activeTrigger) {\\n        if (this._activeTrigger[trigger]) {\\n          return true;\\n        }\\n      }\\n\\n      return false;\\n    };\\n\\n    Tooltip.prototype._getConfig = function _getConfig(config) {\\n      config = $.extend({}, this.constructor.Default, $(this.element).data(), config);\\n\\n      if (config.delay && typeof config.delay === 'number') {\\n        config.delay = {\\n          show: config.delay,\\n          hide: config.delay\\n        };\\n      }\\n\\n      Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);\\n\\n      return config;\\n    };\\n\\n    Tooltip.prototype._getDelegateConfig = function _getDelegateConfig() {\\n      var config = {};\\n\\n      if (this.config) {\\n        for (var key in this.config) {\\n          if (this.constructor.Default[key] !== this.config[key]) {\\n            config[key] = this.config[key];\\n          }\\n        }\\n      }\\n\\n      return config;\\n    };\\n\\n    // static\\n\\n    Tooltip._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var data = $(this).data(DATA_KEY);\\n        var _config = (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' ? config : null;\\n\\n        if (!data && /dispose|hide/.test(config)) {\\n          return;\\n        }\\n\\n        if (!data) {\\n          data = new Tooltip(this, _config);\\n          $(this).data(DATA_KEY, data);\\n        }\\n\\n        if (typeof config === 'string') {\\n          if (data[config] === undefined) {\\n            throw new Error('No method named \\\"' + config + '\\\"');\\n          }\\n          data[config]();\\n        }\\n      });\\n    };\\n\\n    _createClass(Tooltip, null, [{\\n      key: 'VERSION',\\n      get: function get() {\\n        return VERSION;\\n      }\\n    }, {\\n      key: 'Default',\\n      get: function get() {\\n        return Default;\\n      }\\n    }, {\\n      key: 'NAME',\\n      get: function get() {\\n        return NAME;\\n      }\\n    }, {\\n      key: 'DATA_KEY',\\n      get: function get() {\\n        return DATA_KEY;\\n      }\\n    }, {\\n      key: 'Event',\\n      get: function get() {\\n        return Event;\\n      }\\n    }, {\\n      key: 'EVENT_KEY',\\n      get: function get() {\\n        return EVENT_KEY;\\n      }\\n    }, {\\n      key: 'DefaultType',\\n      get: function get() {\\n        return DefaultType;\\n      }\\n    }]);\\n\\n    return Tooltip;\\n  }();\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME] = Tooltip._jQueryInterface;\\n  $.fn[NAME].Constructor = Tooltip;\\n  $.fn[NAME].noConflict = function () {\\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\\n    return Tooltip._jQueryInterface;\\n  };\\n\\n  return Tooltip;\\n}(jQuery);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v4.0.0-alpha.5): popover.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\nvar Popover = function ($) {\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME = 'popover';\\n  var VERSION = '4.0.0-alpha.5';\\n  var DATA_KEY = 'bs.popover';\\n  var EVENT_KEY = '.' + DATA_KEY;\\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\\n\\n  var Default = $.extend({}, Tooltip.Default, {\\n    placement: 'right',\\n    trigger: 'click',\\n    content: '',\\n    template: '<div class=\\\"popover\\\" role=\\\"tooltip\\\">' + '<h3 class=\\\"popover-title\\\"></h3>' + '<div class=\\\"popover-content\\\"></div></div>'\\n  });\\n\\n  var DefaultType = $.extend({}, Tooltip.DefaultType, {\\n    content: '(string|element|function)'\\n  });\\n\\n  var ClassName = {\\n    FADE: 'fade',\\n    IN: 'in'\\n  };\\n\\n  var Selector = {\\n    TITLE: '.popover-title',\\n    CONTENT: '.popover-content'\\n  };\\n\\n  var Event = {\\n    HIDE: 'hide' + EVENT_KEY,\\n    HIDDEN: 'hidden' + EVENT_KEY,\\n    SHOW: 'show' + EVENT_KEY,\\n    SHOWN: 'shown' + EVENT_KEY,\\n    INSERTED: 'inserted' + EVENT_KEY,\\n    CLICK: 'click' + EVENT_KEY,\\n    FOCUSIN: 'focusin' + EVENT_KEY,\\n    FOCUSOUT: 'focusout' + EVENT_KEY,\\n    MOUSEENTER: 'mouseenter' + EVENT_KEY,\\n    MOUSELEAVE: 'mouseleave' + EVENT_KEY\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Popover = function (_Tooltip) {\\n    _inherits(Popover, _Tooltip);\\n\\n    function Popover() {\\n      _classCallCheck(this, Popover);\\n\\n      return _possibleConstructorReturn(this, _Tooltip.apply(this, arguments));\\n    }\\n\\n    // overrides\\n\\n    Popover.prototype.isWithContent = function isWithContent() {\\n      return this.getTitle() || this._getContent();\\n    };\\n\\n    Popover.prototype.getTipElement = function getTipElement() {\\n      return this.tip = this.tip || $(this.config.template)[0];\\n    };\\n\\n    Popover.prototype.setContent = function setContent() {\\n      var $tip = $(this.getTipElement());\\n\\n      // we use append for html objects to maintain js events\\n      this.setElementContent($tip.find(Selector.TITLE), this.getTitle());\\n      this.setElementContent($tip.find(Selector.CONTENT), this._getContent());\\n\\n      $tip.removeClass(ClassName.FADE).removeClass(ClassName.IN);\\n\\n      this.cleanupTether();\\n    };\\n\\n    // private\\n\\n    Popover.prototype._getContent = function _getContent() {\\n      return this.element.getAttribute('data-content') || (typeof this.config.content === 'function' ? this.config.content.call(this.element) : this.config.content);\\n    };\\n\\n    // static\\n\\n    Popover._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var data = $(this).data(DATA_KEY);\\n        var _config = (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' ? config : null;\\n\\n        if (!data && /destroy|hide/.test(config)) {\\n          return;\\n        }\\n\\n        if (!data) {\\n          data = new Popover(this, _config);\\n          $(this).data(DATA_KEY, data);\\n        }\\n\\n        if (typeof config === 'string') {\\n          if (data[config] === undefined) {\\n            throw new Error('No method named \\\"' + config + '\\\"');\\n          }\\n          data[config]();\\n        }\\n      });\\n    };\\n\\n    _createClass(Popover, null, [{\\n      key: 'VERSION',\\n\\n\\n      // getters\\n\\n      get: function get() {\\n        return VERSION;\\n      }\\n    }, {\\n      key: 'Default',\\n      get: function get() {\\n        return Default;\\n      }\\n    }, {\\n      key: 'NAME',\\n      get: function get() {\\n        return NAME;\\n      }\\n    }, {\\n      key: 'DATA_KEY',\\n      get: function get() {\\n        return DATA_KEY;\\n      }\\n    }, {\\n      key: 'Event',\\n      get: function get() {\\n        return Event;\\n      }\\n    }, {\\n      key: 'EVENT_KEY',\\n      get: function get() {\\n        return EVENT_KEY;\\n      }\\n    }, {\\n      key: 'DefaultType',\\n      get: function get() {\\n        return DefaultType;\\n      }\\n    }]);\\n\\n    return Popover;\\n  }(Tooltip);\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME] = Popover._jQueryInterface;\\n  $.fn[NAME].Constructor = Popover;\\n  $.fn[NAME].noConflict = function () {\\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\\n    return Popover._jQueryInterface;\\n  };\\n\\n  return Popover;\\n}(jQuery);\\n\\n}();\\n\"\n\n/***/ },\n\n/***/ 809:\n/***/ function(module, exports) {\n\nmodule.exports = \"/*!\\n * jQuery JavaScript Library v3.1.1\\n * https://jquery.com/\\n *\\n * Includes Sizzle.js\\n * https://sizzlejs.com/\\n *\\n * Copyright jQuery Foundation and other contributors\\n * Released under the MIT license\\n * https://jquery.org/license\\n *\\n * Date: 2016-09-22T22:30Z\\n */\\n( function( global, factory ) {\\n\\n\\t\\\"use strict\\\";\\n\\n\\tif ( typeof module === \\\"object\\\" && typeof module.exports === \\\"object\\\" ) {\\n\\n\\t\\t// For CommonJS and CommonJS-like environments where a proper `window`\\n\\t\\t// is present, execute the factory and get jQuery.\\n\\t\\t// For environments that do not have a `window` with a `document`\\n\\t\\t// (such as Node.js), expose a factory as module.exports.\\n\\t\\t// This accentuates the need for the creation of a real `window`.\\n\\t\\t// e.g. var jQuery = require(\\\"jquery\\\")(window);\\n\\t\\t// See ticket #14549 for more info.\\n\\t\\tmodule.exports = global.document ?\\n\\t\\t\\tfactory( global, true ) :\\n\\t\\t\\tfunction( w ) {\\n\\t\\t\\t\\tif ( !w.document ) {\\n\\t\\t\\t\\t\\tthrow new Error( \\\"jQuery requires a window with a document\\\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn factory( w );\\n\\t\\t\\t};\\n\\t} else {\\n\\t\\tfactory( global );\\n\\t}\\n\\n// Pass this if window is not defined yet\\n} )( typeof window !== \\\"undefined\\\" ? window : this, function( window, noGlobal ) {\\n\\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\\n// enough that all such attempts are guarded in a try block.\\n\\\"use strict\\\";\\n\\nvar arr = [];\\n\\nvar document = window.document;\\n\\nvar getProto = Object.getPrototypeOf;\\n\\nvar slice = arr.slice;\\n\\nvar concat = arr.concat;\\n\\nvar push = arr.push;\\n\\nvar indexOf = arr.indexOf;\\n\\nvar class2type = {};\\n\\nvar toString = class2type.toString;\\n\\nvar hasOwn = class2type.hasOwnProperty;\\n\\nvar fnToString = hasOwn.toString;\\n\\nvar ObjectFunctionString = fnToString.call( Object );\\n\\nvar support = {};\\n\\n\\n\\n\\tfunction DOMEval( code, doc ) {\\n\\t\\tdoc = doc || document;\\n\\n\\t\\tvar script = doc.createElement( \\\"script\\\" );\\n\\n\\t\\tscript.text = code;\\n\\t\\tdoc.head.appendChild( script ).parentNode.removeChild( script );\\n\\t}\\n/* global Symbol */\\n// Defining this global in .eslintrc.json would create a danger of using the global\\n// unguarded in another place, it seems safer to define global only for this module\\n\\n\\n\\nvar\\n\\tversion = \\\"3.1.1\\\",\\n\\n\\t// Define a local copy of jQuery\\n\\tjQuery = function( selector, context ) {\\n\\n\\t\\t// The jQuery object is actually just the init constructor 'enhanced'\\n\\t\\t// Need init if jQuery is called (just allow error to be thrown if not included)\\n\\t\\treturn new jQuery.fn.init( selector, context );\\n\\t},\\n\\n\\t// Support: Android <=4.0 only\\n\\t// Make sure we trim BOM and NBSP\\n\\trtrim = /^[\\\\s\\\\uFEFF\\\\xA0]+|[\\\\s\\\\uFEFF\\\\xA0]+$/g,\\n\\n\\t// Matches dashed string for camelizing\\n\\trmsPrefix = /^-ms-/,\\n\\trdashAlpha = /-([a-z])/g,\\n\\n\\t// Used by jQuery.camelCase as callback to replace()\\n\\tfcamelCase = function( all, letter ) {\\n\\t\\treturn letter.toUpperCase();\\n\\t};\\n\\njQuery.fn = jQuery.prototype = {\\n\\n\\t// The current version of jQuery being used\\n\\tjquery: version,\\n\\n\\tconstructor: jQuery,\\n\\n\\t// The default length of a jQuery object is 0\\n\\tlength: 0,\\n\\n\\ttoArray: function() {\\n\\t\\treturn slice.call( this );\\n\\t},\\n\\n\\t// Get the Nth element in the matched element set OR\\n\\t// Get the whole matched element set as a clean array\\n\\tget: function( num ) {\\n\\n\\t\\t// Return all the elements in a clean array\\n\\t\\tif ( num == null ) {\\n\\t\\t\\treturn slice.call( this );\\n\\t\\t}\\n\\n\\t\\t// Return just the one element from the set\\n\\t\\treturn num < 0 ? this[ num + this.length ] : this[ num ];\\n\\t},\\n\\n\\t// Take an array of elements and push it onto the stack\\n\\t// (returning the new matched element set)\\n\\tpushStack: function( elems ) {\\n\\n\\t\\t// Build a new jQuery matched element set\\n\\t\\tvar ret = jQuery.merge( this.constructor(), elems );\\n\\n\\t\\t// Add the old object onto the stack (as a reference)\\n\\t\\tret.prevObject = this;\\n\\n\\t\\t// Return the newly-formed element set\\n\\t\\treturn ret;\\n\\t},\\n\\n\\t// Execute a callback for every element in the matched set.\\n\\teach: function( callback ) {\\n\\t\\treturn jQuery.each( this, callback );\\n\\t},\\n\\n\\tmap: function( callback ) {\\n\\t\\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\\n\\t\\t\\treturn callback.call( elem, i, elem );\\n\\t\\t} ) );\\n\\t},\\n\\n\\tslice: function() {\\n\\t\\treturn this.pushStack( slice.apply( this, arguments ) );\\n\\t},\\n\\n\\tfirst: function() {\\n\\t\\treturn this.eq( 0 );\\n\\t},\\n\\n\\tlast: function() {\\n\\t\\treturn this.eq( -1 );\\n\\t},\\n\\n\\teq: function( i ) {\\n\\t\\tvar len = this.length,\\n\\t\\t\\tj = +i + ( i < 0 ? len : 0 );\\n\\t\\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\\n\\t},\\n\\n\\tend: function() {\\n\\t\\treturn this.prevObject || this.constructor();\\n\\t},\\n\\n\\t// For internal use only.\\n\\t// Behaves like an Array's method, not like a jQuery method.\\n\\tpush: push,\\n\\tsort: arr.sort,\\n\\tsplice: arr.splice\\n};\\n\\njQuery.extend = jQuery.fn.extend = function() {\\n\\tvar options, name, src, copy, copyIsArray, clone,\\n\\t\\ttarget = arguments[ 0 ] || {},\\n\\t\\ti = 1,\\n\\t\\tlength = arguments.length,\\n\\t\\tdeep = false;\\n\\n\\t// Handle a deep copy situation\\n\\tif ( typeof target === \\\"boolean\\\" ) {\\n\\t\\tdeep = target;\\n\\n\\t\\t// Skip the boolean and the target\\n\\t\\ttarget = arguments[ i ] || {};\\n\\t\\ti++;\\n\\t}\\n\\n\\t// Handle case when target is a string or something (possible in deep copy)\\n\\tif ( typeof target !== \\\"object\\\" && !jQuery.isFunction( target ) ) {\\n\\t\\ttarget = {};\\n\\t}\\n\\n\\t// Extend jQuery itself if only one argument is passed\\n\\tif ( i === length ) {\\n\\t\\ttarget = this;\\n\\t\\ti--;\\n\\t}\\n\\n\\tfor ( ; i < length; i++ ) {\\n\\n\\t\\t// Only deal with non-null/undefined values\\n\\t\\tif ( ( options = arguments[ i ] ) != null ) {\\n\\n\\t\\t\\t// Extend the base object\\n\\t\\t\\tfor ( name in options ) {\\n\\t\\t\\t\\tsrc = target[ name ];\\n\\t\\t\\t\\tcopy = options[ name ];\\n\\n\\t\\t\\t\\t// Prevent never-ending loop\\n\\t\\t\\t\\tif ( target === copy ) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Recurse if we're merging plain objects or arrays\\n\\t\\t\\t\\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\\n\\t\\t\\t\\t\\t( copyIsArray = jQuery.isArray( copy ) ) ) ) {\\n\\n\\t\\t\\t\\t\\tif ( copyIsArray ) {\\n\\t\\t\\t\\t\\t\\tcopyIsArray = false;\\n\\t\\t\\t\\t\\t\\tclone = src && jQuery.isArray( src ) ? src : [];\\n\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tclone = src && jQuery.isPlainObject( src ) ? src : {};\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Never move original objects, clone them\\n\\t\\t\\t\\t\\ttarget[ name ] = jQuery.extend( deep, clone, copy );\\n\\n\\t\\t\\t\\t// Don't bring in undefined values\\n\\t\\t\\t\\t} else if ( copy !== undefined ) {\\n\\t\\t\\t\\t\\ttarget[ name ] = copy;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the modified object\\n\\treturn target;\\n};\\n\\njQuery.extend( {\\n\\n\\t// Unique for each copy of jQuery on the page\\n\\texpando: \\\"jQuery\\\" + ( version + Math.random() ).replace( /\\\\D/g, \\\"\\\" ),\\n\\n\\t// Assume jQuery is ready without the ready module\\n\\tisReady: true,\\n\\n\\terror: function( msg ) {\\n\\t\\tthrow new Error( msg );\\n\\t},\\n\\n\\tnoop: function() {},\\n\\n\\tisFunction: function( obj ) {\\n\\t\\treturn jQuery.type( obj ) === \\\"function\\\";\\n\\t},\\n\\n\\tisArray: Array.isArray,\\n\\n\\tisWindow: function( obj ) {\\n\\t\\treturn obj != null && obj === obj.window;\\n\\t},\\n\\n\\tisNumeric: function( obj ) {\\n\\n\\t\\t// As of jQuery 3.0, isNumeric is limited to\\n\\t\\t// strings and numbers (primitives or objects)\\n\\t\\t// that can be coerced to finite numbers (gh-2662)\\n\\t\\tvar type = jQuery.type( obj );\\n\\t\\treturn ( type === \\\"number\\\" || type === \\\"string\\\" ) &&\\n\\n\\t\\t\\t// parseFloat NaNs numeric-cast false positives (\\\"\\\")\\n\\t\\t\\t// ...but misinterprets leading-number strings, particularly hex literals (\\\"0x...\\\")\\n\\t\\t\\t// subtraction forces infinities to NaN\\n\\t\\t\\t!isNaN( obj - parseFloat( obj ) );\\n\\t},\\n\\n\\tisPlainObject: function( obj ) {\\n\\t\\tvar proto, Ctor;\\n\\n\\t\\t// Detect obvious negatives\\n\\t\\t// Use toString instead of jQuery.type to catch host objects\\n\\t\\tif ( !obj || toString.call( obj ) !== \\\"[object Object]\\\" ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tproto = getProto( obj );\\n\\n\\t\\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\\n\\t\\tif ( !proto ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t// Objects with prototype are plain iff they were constructed by a global Object function\\n\\t\\tCtor = hasOwn.call( proto, \\\"constructor\\\" ) && proto.constructor;\\n\\t\\treturn typeof Ctor === \\\"function\\\" && fnToString.call( Ctor ) === ObjectFunctionString;\\n\\t},\\n\\n\\tisEmptyObject: function( obj ) {\\n\\n\\t\\t/* eslint-disable no-unused-vars */\\n\\t\\t// See https://github.com/eslint/eslint/issues/6125\\n\\t\\tvar name;\\n\\n\\t\\tfor ( name in obj ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t},\\n\\n\\ttype: function( obj ) {\\n\\t\\tif ( obj == null ) {\\n\\t\\t\\treturn obj + \\\"\\\";\\n\\t\\t}\\n\\n\\t\\t// Support: Android <=2.3 only (functionish RegExp)\\n\\t\\treturn typeof obj === \\\"object\\\" || typeof obj === \\\"function\\\" ?\\n\\t\\t\\tclass2type[ toString.call( obj ) ] || \\\"object\\\" :\\n\\t\\t\\ttypeof obj;\\n\\t},\\n\\n\\t// Evaluates a script in a global context\\n\\tglobalEval: function( code ) {\\n\\t\\tDOMEval( code );\\n\\t},\\n\\n\\t// Convert dashed to camelCase; used by the css and data modules\\n\\t// Support: IE <=9 - 11, Edge 12 - 13\\n\\t// Microsoft forgot to hump their vendor prefix (#9572)\\n\\tcamelCase: function( string ) {\\n\\t\\treturn string.replace( rmsPrefix, \\\"ms-\\\" ).replace( rdashAlpha, fcamelCase );\\n\\t},\\n\\n\\tnodeName: function( elem, name ) {\\n\\t\\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\\n\\t},\\n\\n\\teach: function( obj, callback ) {\\n\\t\\tvar length, i = 0;\\n\\n\\t\\tif ( isArrayLike( obj ) ) {\\n\\t\\t\\tlength = obj.length;\\n\\t\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\t\\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor ( i in obj ) {\\n\\t\\t\\t\\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn obj;\\n\\t},\\n\\n\\t// Support: Android <=4.0 only\\n\\ttrim: function( text ) {\\n\\t\\treturn text == null ?\\n\\t\\t\\t\\\"\\\" :\\n\\t\\t\\t( text + \\\"\\\" ).replace( rtrim, \\\"\\\" );\\n\\t},\\n\\n\\t// results is for internal usage only\\n\\tmakeArray: function( arr, results ) {\\n\\t\\tvar ret = results || [];\\n\\n\\t\\tif ( arr != null ) {\\n\\t\\t\\tif ( isArrayLike( Object( arr ) ) ) {\\n\\t\\t\\t\\tjQuery.merge( ret,\\n\\t\\t\\t\\t\\ttypeof arr === \\\"string\\\" ?\\n\\t\\t\\t\\t\\t[ arr ] : arr\\n\\t\\t\\t\\t);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpush.call( ret, arr );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ret;\\n\\t},\\n\\n\\tinArray: function( elem, arr, i ) {\\n\\t\\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\\n\\t},\\n\\n\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\tmerge: function( first, second ) {\\n\\t\\tvar len = +second.length,\\n\\t\\t\\tj = 0,\\n\\t\\t\\ti = first.length;\\n\\n\\t\\tfor ( ; j < len; j++ ) {\\n\\t\\t\\tfirst[ i++ ] = second[ j ];\\n\\t\\t}\\n\\n\\t\\tfirst.length = i;\\n\\n\\t\\treturn first;\\n\\t},\\n\\n\\tgrep: function( elems, callback, invert ) {\\n\\t\\tvar callbackInverse,\\n\\t\\t\\tmatches = [],\\n\\t\\t\\ti = 0,\\n\\t\\t\\tlength = elems.length,\\n\\t\\t\\tcallbackExpect = !invert;\\n\\n\\t\\t// Go through the array, only saving the items\\n\\t\\t// that pass the validator function\\n\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\tcallbackInverse = !callback( elems[ i ], i );\\n\\t\\t\\tif ( callbackInverse !== callbackExpect ) {\\n\\t\\t\\t\\tmatches.push( elems[ i ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn matches;\\n\\t},\\n\\n\\t// arg is for internal usage only\\n\\tmap: function( elems, callback, arg ) {\\n\\t\\tvar length, value,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tret = [];\\n\\n\\t\\t// Go through the array, translating each of the items to their new values\\n\\t\\tif ( isArrayLike( elems ) ) {\\n\\t\\t\\tlength = elems.length;\\n\\t\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\t\\tvalue = callback( elems[ i ], i, arg );\\n\\n\\t\\t\\t\\tif ( value != null ) {\\n\\t\\t\\t\\t\\tret.push( value );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Go through every key on the object,\\n\\t\\t} else {\\n\\t\\t\\tfor ( i in elems ) {\\n\\t\\t\\t\\tvalue = callback( elems[ i ], i, arg );\\n\\n\\t\\t\\t\\tif ( value != null ) {\\n\\t\\t\\t\\t\\tret.push( value );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Flatten any nested arrays\\n\\t\\treturn concat.apply( [], ret );\\n\\t},\\n\\n\\t// A global GUID counter for objects\\n\\tguid: 1,\\n\\n\\t// Bind a function to a context, optionally partially applying any\\n\\t// arguments.\\n\\tproxy: function( fn, context ) {\\n\\t\\tvar tmp, args, proxy;\\n\\n\\t\\tif ( typeof context === \\\"string\\\" ) {\\n\\t\\t\\ttmp = fn[ context ];\\n\\t\\t\\tcontext = fn;\\n\\t\\t\\tfn = tmp;\\n\\t\\t}\\n\\n\\t\\t// Quick check to determine if target is callable, in the spec\\n\\t\\t// this throws a TypeError, but we will just return undefined.\\n\\t\\tif ( !jQuery.isFunction( fn ) ) {\\n\\t\\t\\treturn undefined;\\n\\t\\t}\\n\\n\\t\\t// Simulated bind\\n\\t\\targs = slice.call( arguments, 2 );\\n\\t\\tproxy = function() {\\n\\t\\t\\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\\n\\t\\t};\\n\\n\\t\\t// Set the guid of unique handler to the same of original handler, so it can be removed\\n\\t\\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\\n\\n\\t\\treturn proxy;\\n\\t},\\n\\n\\tnow: Date.now,\\n\\n\\t// jQuery.support is not used in Core but other projects attach their\\n\\t// properties to it so it needs to exist.\\n\\tsupport: support\\n} );\\n\\nif ( typeof Symbol === \\\"function\\\" ) {\\n\\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\\n}\\n\\n// Populate the class2type map\\njQuery.each( \\\"Boolean Number String Function Array Date RegExp Object Error Symbol\\\".split( \\\" \\\" ),\\nfunction( i, name ) {\\n\\tclass2type[ \\\"[object \\\" + name + \\\"]\\\" ] = name.toLowerCase();\\n} );\\n\\nfunction isArrayLike( obj ) {\\n\\n\\t// Support: real iOS 8.2 only (not reproducible in simulator)\\n\\t// `in` check used to prevent JIT error (gh-2145)\\n\\t// hasOwn isn't used here due to false negatives\\n\\t// regarding Nodelist length in IE\\n\\tvar length = !!obj && \\\"length\\\" in obj && obj.length,\\n\\t\\ttype = jQuery.type( obj );\\n\\n\\tif ( type === \\\"function\\\" || jQuery.isWindow( obj ) ) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn type === \\\"array\\\" || length === 0 ||\\n\\t\\ttypeof length === \\\"number\\\" && length > 0 && ( length - 1 ) in obj;\\n}\\nvar Sizzle =\\n/*!\\n * Sizzle CSS Selector Engine v2.3.3\\n * https://sizzlejs.com/\\n *\\n * Copyright jQuery Foundation and other contributors\\n * Released under the MIT license\\n * http://jquery.org/license\\n *\\n * Date: 2016-08-08\\n */\\n(function( window ) {\\n\\nvar i,\\n\\tsupport,\\n\\tExpr,\\n\\tgetText,\\n\\tisXML,\\n\\ttokenize,\\n\\tcompile,\\n\\tselect,\\n\\toutermostContext,\\n\\tsortInput,\\n\\thasDuplicate,\\n\\n\\t// Local document vars\\n\\tsetDocument,\\n\\tdocument,\\n\\tdocElem,\\n\\tdocumentIsHTML,\\n\\trbuggyQSA,\\n\\trbuggyMatches,\\n\\tmatches,\\n\\tcontains,\\n\\n\\t// Instance-specific data\\n\\texpando = \\\"sizzle\\\" + 1 * new Date(),\\n\\tpreferredDoc = window.document,\\n\\tdirruns = 0,\\n\\tdone = 0,\\n\\tclassCache = createCache(),\\n\\ttokenCache = createCache(),\\n\\tcompilerCache = createCache(),\\n\\tsortOrder = function( a, b ) {\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t},\\n\\n\\t// Instance methods\\n\\thasOwn = ({}).hasOwnProperty,\\n\\tarr = [],\\n\\tpop = arr.pop,\\n\\tpush_native = arr.push,\\n\\tpush = arr.push,\\n\\tslice = arr.slice,\\n\\t// Use a stripped-down indexOf as it's faster than native\\n\\t// https://jsperf.com/thor-indexof-vs-for/5\\n\\tindexOf = function( list, elem ) {\\n\\t\\tvar i = 0,\\n\\t\\t\\tlen = list.length;\\n\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\tif ( list[i] === elem ) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t},\\n\\n\\tbooleans = \\\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\\\",\\n\\n\\t// Regular expressions\\n\\n\\t// http://www.w3.org/TR/css3-selectors/#whitespace\\n\\twhitespace = \\\"[\\\\\\\\x20\\\\\\\\t\\\\\\\\r\\\\\\\\n\\\\\\\\f]\\\",\\n\\n\\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\\n\\tidentifier = \\\"(?:\\\\\\\\\\\\\\\\.|[\\\\\\\\w-]|[^\\\\0-\\\\\\\\xa0])+\\\",\\n\\n\\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\\n\\tattributes = \\\"\\\\\\\\[\\\" + whitespace + \\\"*(\\\" + identifier + \\\")(?:\\\" + whitespace +\\n\\t\\t// Operator (capture 2)\\n\\t\\t\\\"*([*^$|!~]?=)\\\" + whitespace +\\n\\t\\t// \\\"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\\\"\\n\\t\\t\\\"*(?:'((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\'])*)'|\\\\\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\"])*)\\\\\\\"|(\\\" + identifier + \\\"))|)\\\" + whitespace +\\n\\t\\t\\\"*\\\\\\\\]\\\",\\n\\n\\tpseudos = \\\":(\\\" + identifier + \\\")(?:\\\\\\\\((\\\" +\\n\\t\\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\\n\\t\\t// 1. quoted (capture 3; capture 4 or capture 5)\\n\\t\\t\\\"('((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\'])*)'|\\\\\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\"])*)\\\\\\\")|\\\" +\\n\\t\\t// 2. simple (capture 6)\\n\\t\\t\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\()[\\\\\\\\]]|\\\" + attributes + \\\")*)|\\\" +\\n\\t\\t// 3. anything else (capture 2)\\n\\t\\t\\\".*\\\" +\\n\\t\\t\\\")\\\\\\\\)|)\\\",\\n\\n\\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\\n\\trwhitespace = new RegExp( whitespace + \\\"+\\\", \\\"g\\\" ),\\n\\trtrim = new RegExp( \\\"^\\\" + whitespace + \\\"+|((?:^|[^\\\\\\\\\\\\\\\\])(?:\\\\\\\\\\\\\\\\.)*)\\\" + whitespace + \\\"+$\\\", \\\"g\\\" ),\\n\\n\\trcomma = new RegExp( \\\"^\\\" + whitespace + \\\"*,\\\" + whitespace + \\\"*\\\" ),\\n\\trcombinators = new RegExp( \\\"^\\\" + whitespace + \\\"*([>+~]|\\\" + whitespace + \\\")\\\" + whitespace + \\\"*\\\" ),\\n\\n\\trattributeQuotes = new RegExp( \\\"=\\\" + whitespace + \\\"*([^\\\\\\\\]'\\\\\\\"]*?)\\\" + whitespace + \\\"*\\\\\\\\]\\\", \\\"g\\\" ),\\n\\n\\trpseudo = new RegExp( pseudos ),\\n\\tridentifier = new RegExp( \\\"^\\\" + identifier + \\\"$\\\" ),\\n\\n\\tmatchExpr = {\\n\\t\\t\\\"ID\\\": new RegExp( \\\"^#(\\\" + identifier + \\\")\\\" ),\\n\\t\\t\\\"CLASS\\\": new RegExp( \\\"^\\\\\\\\.(\\\" + identifier + \\\")\\\" ),\\n\\t\\t\\\"TAG\\\": new RegExp( \\\"^(\\\" + identifier + \\\"|[*])\\\" ),\\n\\t\\t\\\"ATTR\\\": new RegExp( \\\"^\\\" + attributes ),\\n\\t\\t\\\"PSEUDO\\\": new RegExp( \\\"^\\\" + pseudos ),\\n\\t\\t\\\"CHILD\\\": new RegExp( \\\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\\\\\(\\\" + whitespace +\\n\\t\\t\\t\\\"*(even|odd|(([+-]|)(\\\\\\\\d*)n|)\\\" + whitespace + \\\"*(?:([+-]|)\\\" + whitespace +\\n\\t\\t\\t\\\"*(\\\\\\\\d+)|))\\\" + whitespace + \\\"*\\\\\\\\)|)\\\", \\\"i\\\" ),\\n\\t\\t\\\"bool\\\": new RegExp( \\\"^(?:\\\" + booleans + \\\")$\\\", \\\"i\\\" ),\\n\\t\\t// For use in libraries implementing .is()\\n\\t\\t// We use this for POS matching in `select`\\n\\t\\t\\\"needsContext\\\": new RegExp( \\\"^\\\" + whitespace + \\\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\\\\\(\\\" +\\n\\t\\t\\twhitespace + \\\"*((?:-\\\\\\\\d)?\\\\\\\\d*)\\\" + whitespace + \\\"*\\\\\\\\)|)(?=[^-]|$)\\\", \\\"i\\\" )\\n\\t},\\n\\n\\trinputs = /^(?:input|select|textarea|button)$/i,\\n\\trheader = /^h\\\\d$/i,\\n\\n\\trnative = /^[^{]+\\\\{\\\\s*\\\\[native \\\\w/,\\n\\n\\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\\n\\trquickExpr = /^(?:#([\\\\w-]+)|(\\\\w+)|\\\\.([\\\\w-]+))$/,\\n\\n\\trsibling = /[+~]/,\\n\\n\\t// CSS escapes\\n\\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\\n\\trunescape = new RegExp( \\\"\\\\\\\\\\\\\\\\([\\\\\\\\da-f]{1,6}\\\" + whitespace + \\\"?|(\\\" + whitespace + \\\")|.)\\\", \\\"ig\\\" ),\\n\\tfunescape = function( _, escaped, escapedWhitespace ) {\\n\\t\\tvar high = \\\"0x\\\" + escaped - 0x10000;\\n\\t\\t// NaN means non-codepoint\\n\\t\\t// Support: Firefox<24\\n\\t\\t// Workaround erroneous numeric interpretation of +\\\"0x\\\"\\n\\t\\treturn high !== high || escapedWhitespace ?\\n\\t\\t\\tescaped :\\n\\t\\t\\thigh < 0 ?\\n\\t\\t\\t\\t// BMP codepoint\\n\\t\\t\\t\\tString.fromCharCode( high + 0x10000 ) :\\n\\t\\t\\t\\t// Supplemental Plane codepoint (surrogate pair)\\n\\t\\t\\t\\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\\n\\t},\\n\\n\\t// CSS string/identifier serialization\\n\\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\\n\\trcssescape = /([\\\\0-\\\\x1f\\\\x7f]|^-?\\\\d)|^-$|[^\\\\0-\\\\x1f\\\\x7f-\\\\uFFFF\\\\w-]/g,\\n\\tfcssescape = function( ch, asCodePoint ) {\\n\\t\\tif ( asCodePoint ) {\\n\\n\\t\\t\\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\\n\\t\\t\\tif ( ch === \\\"\\\\0\\\" ) {\\n\\t\\t\\t\\treturn \\\"\\\\uFFFD\\\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Control characters and (dependent upon position) numbers get escaped as code points\\n\\t\\t\\treturn ch.slice( 0, -1 ) + \\\"\\\\\\\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \\\" \\\";\\n\\t\\t}\\n\\n\\t\\t// Other potentially-special ASCII characters get backslash-escaped\\n\\t\\treturn \\\"\\\\\\\\\\\" + ch;\\n\\t},\\n\\n\\t// Used for iframes\\n\\t// See setDocument()\\n\\t// Removing the function wrapper causes a \\\"Permission Denied\\\"\\n\\t// error in IE\\n\\tunloadHandler = function() {\\n\\t\\tsetDocument();\\n\\t},\\n\\n\\tdisabledAncestor = addCombinator(\\n\\t\\tfunction( elem ) {\\n\\t\\t\\treturn elem.disabled === true && (\\\"form\\\" in elem || \\\"label\\\" in elem);\\n\\t\\t},\\n\\t\\t{ dir: \\\"parentNode\\\", next: \\\"legend\\\" }\\n\\t);\\n\\n// Optimize for push.apply( _, NodeList )\\ntry {\\n\\tpush.apply(\\n\\t\\t(arr = slice.call( preferredDoc.childNodes )),\\n\\t\\tpreferredDoc.childNodes\\n\\t);\\n\\t// Support: Android<4.0\\n\\t// Detect silently failing push.apply\\n\\tarr[ preferredDoc.childNodes.length ].nodeType;\\n} catch ( e ) {\\n\\tpush = { apply: arr.length ?\\n\\n\\t\\t// Leverage slice if possible\\n\\t\\tfunction( target, els ) {\\n\\t\\t\\tpush_native.apply( target, slice.call(els) );\\n\\t\\t} :\\n\\n\\t\\t// Support: IE<9\\n\\t\\t// Otherwise append directly\\n\\t\\tfunction( target, els ) {\\n\\t\\t\\tvar j = target.length,\\n\\t\\t\\t\\ti = 0;\\n\\t\\t\\t// Can't trust NodeList.length\\n\\t\\t\\twhile ( (target[j++] = els[i++]) ) {}\\n\\t\\t\\ttarget.length = j - 1;\\n\\t\\t}\\n\\t};\\n}\\n\\nfunction Sizzle( selector, context, results, seed ) {\\n\\tvar m, i, elem, nid, match, groups, newSelector,\\n\\t\\tnewContext = context && context.ownerDocument,\\n\\n\\t\\t// nodeType defaults to 9, since context defaults to document\\n\\t\\tnodeType = context ? context.nodeType : 9;\\n\\n\\tresults = results || [];\\n\\n\\t// Return early from calls with invalid selector or context\\n\\tif ( typeof selector !== \\\"string\\\" || !selector ||\\n\\t\\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\\n\\n\\t\\treturn results;\\n\\t}\\n\\n\\t// Try to shortcut find operations (as opposed to filters) in HTML documents\\n\\tif ( !seed ) {\\n\\n\\t\\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\\n\\t\\t\\tsetDocument( context );\\n\\t\\t}\\n\\t\\tcontext = context || document;\\n\\n\\t\\tif ( documentIsHTML ) {\\n\\n\\t\\t\\t// If the selector is sufficiently simple, try using a \\\"get*By*\\\" DOM method\\n\\t\\t\\t// (excepting DocumentFragment context, where the methods don't exist)\\n\\t\\t\\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\\n\\n\\t\\t\\t\\t// ID selector\\n\\t\\t\\t\\tif ( (m = match[1]) ) {\\n\\n\\t\\t\\t\\t\\t// Document context\\n\\t\\t\\t\\t\\tif ( nodeType === 9 ) {\\n\\t\\t\\t\\t\\t\\tif ( (elem = context.getElementById( m )) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: IE, Opera, Webkit\\n\\t\\t\\t\\t\\t\\t\\t// TODO: identify versions\\n\\t\\t\\t\\t\\t\\t\\t// getElementById can match elements by name instead of ID\\n\\t\\t\\t\\t\\t\\t\\tif ( elem.id === m ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Element context\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE, Opera, Webkit\\n\\t\\t\\t\\t\\t\\t// TODO: identify versions\\n\\t\\t\\t\\t\\t\\t// getElementById can match elements by name instead of ID\\n\\t\\t\\t\\t\\t\\tif ( newContext && (elem = newContext.getElementById( m )) &&\\n\\t\\t\\t\\t\\t\\t\\tcontains( context, elem ) &&\\n\\t\\t\\t\\t\\t\\t\\telem.id === m ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Type selector\\n\\t\\t\\t\\t} else if ( match[2] ) {\\n\\t\\t\\t\\t\\tpush.apply( results, context.getElementsByTagName( selector ) );\\n\\t\\t\\t\\t\\treturn results;\\n\\n\\t\\t\\t\\t// Class selector\\n\\t\\t\\t\\t} else if ( (m = match[3]) && support.getElementsByClassName &&\\n\\t\\t\\t\\t\\tcontext.getElementsByClassName ) {\\n\\n\\t\\t\\t\\t\\tpush.apply( results, context.getElementsByClassName( m ) );\\n\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Take advantage of querySelectorAll\\n\\t\\t\\tif ( support.qsa &&\\n\\t\\t\\t\\t!compilerCache[ selector + \\\" \\\" ] &&\\n\\t\\t\\t\\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\\n\\n\\t\\t\\t\\tif ( nodeType !== 1 ) {\\n\\t\\t\\t\\t\\tnewContext = context;\\n\\t\\t\\t\\t\\tnewSelector = selector;\\n\\n\\t\\t\\t\\t// qSA looks outside Element context, which is not what we want\\n\\t\\t\\t\\t// Thanks to Andrew Dupont for this workaround technique\\n\\t\\t\\t\\t// Support: IE <=8\\n\\t\\t\\t\\t// Exclude object elements\\n\\t\\t\\t\\t} else if ( context.nodeName.toLowerCase() !== \\\"object\\\" ) {\\n\\n\\t\\t\\t\\t\\t// Capture the context ID, setting it first if necessary\\n\\t\\t\\t\\t\\tif ( (nid = context.getAttribute( \\\"id\\\" )) ) {\\n\\t\\t\\t\\t\\t\\tnid = nid.replace( rcssescape, fcssescape );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcontext.setAttribute( \\\"id\\\", (nid = expando) );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Prefix every selector in the list\\n\\t\\t\\t\\t\\tgroups = tokenize( selector );\\n\\t\\t\\t\\t\\ti = groups.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tgroups[i] = \\\"#\\\" + nid + \\\" \\\" + toSelector( groups[i] );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnewSelector = groups.join( \\\",\\\" );\\n\\n\\t\\t\\t\\t\\t// Expand context for sibling selectors\\n\\t\\t\\t\\t\\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\\n\\t\\t\\t\\t\\t\\tcontext;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( newSelector ) {\\n\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\tpush.apply( results,\\n\\t\\t\\t\\t\\t\\t\\tnewContext.querySelectorAll( newSelector )\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t} catch ( qsaError ) {\\n\\t\\t\\t\\t\\t} finally {\\n\\t\\t\\t\\t\\t\\tif ( nid === expando ) {\\n\\t\\t\\t\\t\\t\\t\\tcontext.removeAttribute( \\\"id\\\" );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// All others\\n\\treturn select( selector.replace( rtrim, \\\"$1\\\" ), context, results, seed );\\n}\\n\\n/**\\n * Create key-value caches of limited size\\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\\n *\\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\\n *\\tdeleting the oldest entry\\n */\\nfunction createCache() {\\n\\tvar keys = [];\\n\\n\\tfunction cache( key, value ) {\\n\\t\\t// Use (key + \\\" \\\") to avoid collision with native prototype properties (see Issue #157)\\n\\t\\tif ( keys.push( key + \\\" \\\" ) > Expr.cacheLength ) {\\n\\t\\t\\t// Only keep the most recent entries\\n\\t\\t\\tdelete cache[ keys.shift() ];\\n\\t\\t}\\n\\t\\treturn (cache[ key + \\\" \\\" ] = value);\\n\\t}\\n\\treturn cache;\\n}\\n\\n/**\\n * Mark a function for special use by Sizzle\\n * @param {Function} fn The function to mark\\n */\\nfunction markFunction( fn ) {\\n\\tfn[ expando ] = true;\\n\\treturn fn;\\n}\\n\\n/**\\n * Support testing using an element\\n * @param {Function} fn Passed the created element and returns a boolean result\\n */\\nfunction assert( fn ) {\\n\\tvar el = document.createElement(\\\"fieldset\\\");\\n\\n\\ttry {\\n\\t\\treturn !!fn( el );\\n\\t} catch (e) {\\n\\t\\treturn false;\\n\\t} finally {\\n\\t\\t// Remove from its parent by default\\n\\t\\tif ( el.parentNode ) {\\n\\t\\t\\tel.parentNode.removeChild( el );\\n\\t\\t}\\n\\t\\t// release memory in IE\\n\\t\\tel = null;\\n\\t}\\n}\\n\\n/**\\n * Adds the same handler for all of the specified attrs\\n * @param {String} attrs Pipe-separated list of attributes\\n * @param {Function} handler The method that will be applied\\n */\\nfunction addHandle( attrs, handler ) {\\n\\tvar arr = attrs.split(\\\"|\\\"),\\n\\t\\ti = arr.length;\\n\\n\\twhile ( i-- ) {\\n\\t\\tExpr.attrHandle[ arr[i] ] = handler;\\n\\t}\\n}\\n\\n/**\\n * Checks document order of two siblings\\n * @param {Element} a\\n * @param {Element} b\\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\\n */\\nfunction siblingCheck( a, b ) {\\n\\tvar cur = b && a,\\n\\t\\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\\n\\t\\t\\ta.sourceIndex - b.sourceIndex;\\n\\n\\t// Use IE sourceIndex if available on both nodes\\n\\tif ( diff ) {\\n\\t\\treturn diff;\\n\\t}\\n\\n\\t// Check if b follows a\\n\\tif ( cur ) {\\n\\t\\twhile ( (cur = cur.nextSibling) ) {\\n\\t\\t\\tif ( cur === b ) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn a ? 1 : -1;\\n}\\n\\n/**\\n * Returns a function to use in pseudos for input types\\n * @param {String} type\\n */\\nfunction createInputPseudo( type ) {\\n\\treturn function( elem ) {\\n\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\treturn name === \\\"input\\\" && elem.type === type;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for buttons\\n * @param {String} type\\n */\\nfunction createButtonPseudo( type ) {\\n\\treturn function( elem ) {\\n\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\treturn (name === \\\"input\\\" || name === \\\"button\\\") && elem.type === type;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for :enabled/:disabled\\n * @param {Boolean} disabled true for :disabled; false for :enabled\\n */\\nfunction createDisabledPseudo( disabled ) {\\n\\n\\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\\n\\treturn function( elem ) {\\n\\n\\t\\t// Only certain elements can match :enabled or :disabled\\n\\t\\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\\n\\t\\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\\n\\t\\tif ( \\\"form\\\" in elem ) {\\n\\n\\t\\t\\t// Check for inherited disabledness on relevant non-disabled elements:\\n\\t\\t\\t// * listed form-associated elements in a disabled fieldset\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\\n\\t\\t\\t// * option elements in a disabled optgroup\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\\n\\t\\t\\t// All such elements have a \\\"form\\\" property.\\n\\t\\t\\tif ( elem.parentNode && elem.disabled === false ) {\\n\\n\\t\\t\\t\\t// Option elements defer to a parent optgroup if present\\n\\t\\t\\t\\tif ( \\\"label\\\" in elem ) {\\n\\t\\t\\t\\t\\tif ( \\\"label\\\" in elem.parentNode ) {\\n\\t\\t\\t\\t\\t\\treturn elem.parentNode.disabled === disabled;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn elem.disabled === disabled;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Support: IE 6 - 11\\n\\t\\t\\t\\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\\n\\t\\t\\t\\treturn elem.isDisabled === disabled ||\\n\\n\\t\\t\\t\\t\\t// Where there is no isDisabled, check manually\\n\\t\\t\\t\\t\\t/* jshint -W018 */\\n\\t\\t\\t\\t\\telem.isDisabled !== !disabled &&\\n\\t\\t\\t\\t\\t\\tdisabledAncestor( elem ) === disabled;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn elem.disabled === disabled;\\n\\n\\t\\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\\n\\t\\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\\n\\t\\t// even exist on them, let alone have a boolean value.\\n\\t\\t} else if ( \\\"label\\\" in elem ) {\\n\\t\\t\\treturn elem.disabled === disabled;\\n\\t\\t}\\n\\n\\t\\t// Remaining elements are neither :enabled nor :disabled\\n\\t\\treturn false;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for positionals\\n * @param {Function} fn\\n */\\nfunction createPositionalPseudo( fn ) {\\n\\treturn markFunction(function( argument ) {\\n\\t\\targument = +argument;\\n\\t\\treturn markFunction(function( seed, matches ) {\\n\\t\\t\\tvar j,\\n\\t\\t\\t\\tmatchIndexes = fn( [], seed.length, argument ),\\n\\t\\t\\t\\ti = matchIndexes.length;\\n\\n\\t\\t\\t// Match elements found at the specified indexes\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( seed[ (j = matchIndexes[i]) ] ) {\\n\\t\\t\\t\\t\\tseed[j] = !(matches[j] = seed[j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t});\\n}\\n\\n/**\\n * Checks a node for validity as a Sizzle context\\n * @param {Element|Object=} context\\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\\n */\\nfunction testContext( context ) {\\n\\treturn context && typeof context.getElementsByTagName !== \\\"undefined\\\" && context;\\n}\\n\\n// Expose support vars for convenience\\nsupport = Sizzle.support = {};\\n\\n/**\\n * Detects XML nodes\\n * @param {Element|Object} elem An element or a document\\n * @returns {Boolean} True iff elem is a non-HTML XML node\\n */\\nisXML = Sizzle.isXML = function( elem ) {\\n\\t// documentElement is verified for cases where it doesn't yet exist\\n\\t// (such as loading iframes in IE - #4833)\\n\\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\\n\\treturn documentElement ? documentElement.nodeName !== \\\"HTML\\\" : false;\\n};\\n\\n/**\\n * Sets document-related variables once based on the current document\\n * @param {Element|Object} [doc] An element or document object to use to set the document\\n * @returns {Object} Returns the current document\\n */\\nsetDocument = Sizzle.setDocument = function( node ) {\\n\\tvar hasCompare, subWindow,\\n\\t\\tdoc = node ? node.ownerDocument || node : preferredDoc;\\n\\n\\t// Return early if doc is invalid or already selected\\n\\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\\n\\t\\treturn document;\\n\\t}\\n\\n\\t// Update global variables\\n\\tdocument = doc;\\n\\tdocElem = document.documentElement;\\n\\tdocumentIsHTML = !isXML( document );\\n\\n\\t// Support: IE 9-11, Edge\\n\\t// Accessing iframe documents after unload throws \\\"permission denied\\\" errors (jQuery #13936)\\n\\tif ( preferredDoc !== document &&\\n\\t\\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\\n\\n\\t\\t// Support: IE 11, Edge\\n\\t\\tif ( subWindow.addEventListener ) {\\n\\t\\t\\tsubWindow.addEventListener( \\\"unload\\\", unloadHandler, false );\\n\\n\\t\\t// Support: IE 9 - 10 only\\n\\t\\t} else if ( subWindow.attachEvent ) {\\n\\t\\t\\tsubWindow.attachEvent( \\\"onunload\\\", unloadHandler );\\n\\t\\t}\\n\\t}\\n\\n\\t/* Attributes\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Support: IE<8\\n\\t// Verify that getAttribute really returns attributes and not properties\\n\\t// (excepting IE8 booleans)\\n\\tsupport.attributes = assert(function( el ) {\\n\\t\\tel.className = \\\"i\\\";\\n\\t\\treturn !el.getAttribute(\\\"className\\\");\\n\\t});\\n\\n\\t/* getElement(s)By*\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Check if getElementsByTagName(\\\"*\\\") returns only elements\\n\\tsupport.getElementsByTagName = assert(function( el ) {\\n\\t\\tel.appendChild( document.createComment(\\\"\\\") );\\n\\t\\treturn !el.getElementsByTagName(\\\"*\\\").length;\\n\\t});\\n\\n\\t// Support: IE<9\\n\\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\\n\\n\\t// Support: IE<10\\n\\t// Check if getElementById returns elements by name\\n\\t// The broken getElementById methods don't pick up programmatically-set names,\\n\\t// so use a roundabout getElementsByName test\\n\\tsupport.getById = assert(function( el ) {\\n\\t\\tdocElem.appendChild( el ).id = expando;\\n\\t\\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\\n\\t});\\n\\n\\t// ID filter and find\\n\\tif ( support.getById ) {\\n\\t\\tExpr.filter[\\\"ID\\\"] = function( id ) {\\n\\t\\t\\tvar attrId = id.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn elem.getAttribute(\\\"id\\\") === attrId;\\n\\t\\t\\t};\\n\\t\\t};\\n\\t\\tExpr.find[\\\"ID\\\"] = function( id, context ) {\\n\\t\\t\\tif ( typeof context.getElementById !== \\\"undefined\\\" && documentIsHTML ) {\\n\\t\\t\\t\\tvar elem = context.getElementById( id );\\n\\t\\t\\t\\treturn elem ? [ elem ] : [];\\n\\t\\t\\t}\\n\\t\\t};\\n\\t} else {\\n\\t\\tExpr.filter[\\\"ID\\\"] =  function( id ) {\\n\\t\\t\\tvar attrId = id.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar node = typeof elem.getAttributeNode !== \\\"undefined\\\" &&\\n\\t\\t\\t\\t\\telem.getAttributeNode(\\\"id\\\");\\n\\t\\t\\t\\treturn node && node.value === attrId;\\n\\t\\t\\t};\\n\\t\\t};\\n\\n\\t\\t// Support: IE 6 - 7 only\\n\\t\\t// getElementById is not reliable as a find shortcut\\n\\t\\tExpr.find[\\\"ID\\\"] = function( id, context ) {\\n\\t\\t\\tif ( typeof context.getElementById !== \\\"undefined\\\" && documentIsHTML ) {\\n\\t\\t\\t\\tvar node, i, elems,\\n\\t\\t\\t\\t\\telem = context.getElementById( id );\\n\\n\\t\\t\\t\\tif ( elem ) {\\n\\n\\t\\t\\t\\t\\t// Verify the id attribute\\n\\t\\t\\t\\t\\tnode = elem.getAttributeNode(\\\"id\\\");\\n\\t\\t\\t\\t\\tif ( node && node.value === id ) {\\n\\t\\t\\t\\t\\t\\treturn [ elem ];\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Fall back on getElementsByName\\n\\t\\t\\t\\t\\telems = context.getElementsByName( id );\\n\\t\\t\\t\\t\\ti = 0;\\n\\t\\t\\t\\t\\twhile ( (elem = elems[i++]) ) {\\n\\t\\t\\t\\t\\t\\tnode = elem.getAttributeNode(\\\"id\\\");\\n\\t\\t\\t\\t\\t\\tif ( node && node.value === id ) {\\n\\t\\t\\t\\t\\t\\t\\treturn [ elem ];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn [];\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\n\\t// Tag\\n\\tExpr.find[\\\"TAG\\\"] = support.getElementsByTagName ?\\n\\t\\tfunction( tag, context ) {\\n\\t\\t\\tif ( typeof context.getElementsByTagName !== \\\"undefined\\\" ) {\\n\\t\\t\\t\\treturn context.getElementsByTagName( tag );\\n\\n\\t\\t\\t// DocumentFragment nodes don't have gEBTN\\n\\t\\t\\t} else if ( support.qsa ) {\\n\\t\\t\\t\\treturn context.querySelectorAll( tag );\\n\\t\\t\\t}\\n\\t\\t} :\\n\\n\\t\\tfunction( tag, context ) {\\n\\t\\t\\tvar elem,\\n\\t\\t\\t\\ttmp = [],\\n\\t\\t\\t\\ti = 0,\\n\\t\\t\\t\\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\\n\\t\\t\\t\\tresults = context.getElementsByTagName( tag );\\n\\n\\t\\t\\t// Filter out possible comments\\n\\t\\t\\tif ( tag === \\\"*\\\" ) {\\n\\t\\t\\t\\twhile ( (elem = results[i++]) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\t\\t\\t\\ttmp.push( elem );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn tmp;\\n\\t\\t\\t}\\n\\t\\t\\treturn results;\\n\\t\\t};\\n\\n\\t// Class\\n\\tExpr.find[\\\"CLASS\\\"] = support.getElementsByClassName && function( className, context ) {\\n\\t\\tif ( typeof context.getElementsByClassName !== \\\"undefined\\\" && documentIsHTML ) {\\n\\t\\t\\treturn context.getElementsByClassName( className );\\n\\t\\t}\\n\\t};\\n\\n\\t/* QSA/matchesSelector\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// QSA and matchesSelector support\\n\\n\\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\\n\\trbuggyMatches = [];\\n\\n\\t// qSa(:focus) reports false when true (Chrome 21)\\n\\t// We allow this because of a bug in IE8/9 that throws an error\\n\\t// whenever `document.activeElement` is accessed on an iframe\\n\\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\\n\\t// See https://bugs.jquery.com/ticket/13378\\n\\trbuggyQSA = [];\\n\\n\\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\\n\\t\\t// Build QSA regex\\n\\t\\t// Regex strategy adopted from Diego Perini\\n\\t\\tassert(function( el ) {\\n\\t\\t\\t// Select is set to empty string on purpose\\n\\t\\t\\t// This is to test IE's treatment of not explicitly\\n\\t\\t\\t// setting a boolean content attribute,\\n\\t\\t\\t// since its presence should be enough\\n\\t\\t\\t// https://bugs.jquery.com/ticket/12359\\n\\t\\t\\tdocElem.appendChild( el ).innerHTML = \\\"<a id='\\\" + expando + \\\"'></a>\\\" +\\n\\t\\t\\t\\t\\\"<select id='\\\" + expando + \\\"-\\\\r\\\\\\\\' msallowcapture=''>\\\" +\\n\\t\\t\\t\\t\\\"<option selected=''></option></select>\\\";\\n\\n\\t\\t\\t// Support: IE8, Opera 11-12.16\\n\\t\\t\\t// Nothing should be selected when empty strings follow ^= or $= or *=\\n\\t\\t\\t// The test attribute must be unknown in Opera but \\\"safe\\\" for WinRT\\n\\t\\t\\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\\n\\t\\t\\tif ( el.querySelectorAll(\\\"[msallowcapture^='']\\\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\\"[*^$]=\\\" + whitespace + \\\"*(?:''|\\\\\\\"\\\\\\\")\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: IE8\\n\\t\\t\\t// Boolean attributes and \\\"value\\\" are not treated correctly\\n\\t\\t\\tif ( !el.querySelectorAll(\\\"[selected]\\\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\\"\\\\\\\\[\\\" + whitespace + \\\"*(?:value|\\\" + booleans + \\\")\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\\n\\t\\t\\tif ( !el.querySelectorAll( \\\"[id~=\\\" + expando + \\\"-]\\\" ).length ) {\\n\\t\\t\\t\\trbuggyQSA.push(\\\"~=\\\");\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Webkit/Opera - :checked should return selected option elements\\n\\t\\t\\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\\n\\t\\t\\t// IE8 throws error here and will not see later tests\\n\\t\\t\\tif ( !el.querySelectorAll(\\\":checked\\\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push(\\\":checked\\\");\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: Safari 8+, iOS 8+\\n\\t\\t\\t// https://bugs.webkit.org/show_bug.cgi?id=136851\\n\\t\\t\\t// In-page `selector#id sibling-combinator selector` fails\\n\\t\\t\\tif ( !el.querySelectorAll( \\\"a#\\\" + expando + \\\"+*\\\" ).length ) {\\n\\t\\t\\t\\trbuggyQSA.push(\\\".#.+[+~]\\\");\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tassert(function( el ) {\\n\\t\\t\\tel.innerHTML = \\\"<a href='' disabled='disabled'></a>\\\" +\\n\\t\\t\\t\\t\\\"<select disabled='disabled'><option/></select>\\\";\\n\\n\\t\\t\\t// Support: Windows 8 Native Apps\\n\\t\\t\\t// The type and name attributes are restricted during .innerHTML assignment\\n\\t\\t\\tvar input = document.createElement(\\\"input\\\");\\n\\t\\t\\tinput.setAttribute( \\\"type\\\", \\\"hidden\\\" );\\n\\t\\t\\tel.appendChild( input ).setAttribute( \\\"name\\\", \\\"D\\\" );\\n\\n\\t\\t\\t// Support: IE8\\n\\t\\t\\t// Enforce case-sensitivity of name attribute\\n\\t\\t\\tif ( el.querySelectorAll(\\\"[name=d]\\\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\\"name\\\" + whitespace + \\\"*[*^$|!~]?=\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\\n\\t\\t\\t// IE8 throws error here and will not see later tests\\n\\t\\t\\tif ( el.querySelectorAll(\\\":enabled\\\").length !== 2 ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\\":enabled\\\", \\\":disabled\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: IE9-11+\\n\\t\\t\\t// IE's :disabled selector does not pick up the children of disabled fieldsets\\n\\t\\t\\tdocElem.appendChild( el ).disabled = true;\\n\\t\\t\\tif ( el.querySelectorAll(\\\":disabled\\\").length !== 2 ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\\":enabled\\\", \\\":disabled\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Opera 10-11 does not throw on post-comma invalid pseudos\\n\\t\\t\\tel.querySelectorAll(\\\"*,:x\\\");\\n\\t\\t\\trbuggyQSA.push(\\\",.*:\\\");\\n\\t\\t});\\n\\t}\\n\\n\\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\\n\\t\\tdocElem.webkitMatchesSelector ||\\n\\t\\tdocElem.mozMatchesSelector ||\\n\\t\\tdocElem.oMatchesSelector ||\\n\\t\\tdocElem.msMatchesSelector) )) ) {\\n\\n\\t\\tassert(function( el ) {\\n\\t\\t\\t// Check to see if it's possible to do matchesSelector\\n\\t\\t\\t// on a disconnected node (IE 9)\\n\\t\\t\\tsupport.disconnectedMatch = matches.call( el, \\\"*\\\" );\\n\\n\\t\\t\\t// This should fail with an exception\\n\\t\\t\\t// Gecko does not error, returns false instead\\n\\t\\t\\tmatches.call( el, \\\"[s!='']:x\\\" );\\n\\t\\t\\trbuggyMatches.push( \\\"!=\\\", pseudos );\\n\\t\\t});\\n\\t}\\n\\n\\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\\\"|\\\") );\\n\\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\\\"|\\\") );\\n\\n\\t/* Contains\\n\\t---------------------------------------------------------------------- */\\n\\thasCompare = rnative.test( docElem.compareDocumentPosition );\\n\\n\\t// Element contains another\\n\\t// Purposefully self-exclusive\\n\\t// As in, an element does not contain itself\\n\\tcontains = hasCompare || rnative.test( docElem.contains ) ?\\n\\t\\tfunction( a, b ) {\\n\\t\\t\\tvar adown = a.nodeType === 9 ? a.documentElement : a,\\n\\t\\t\\t\\tbup = b && b.parentNode;\\n\\t\\t\\treturn a === bup || !!( bup && bup.nodeType === 1 && (\\n\\t\\t\\t\\tadown.contains ?\\n\\t\\t\\t\\t\\tadown.contains( bup ) :\\n\\t\\t\\t\\t\\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\\n\\t\\t\\t));\\n\\t\\t} :\\n\\t\\tfunction( a, b ) {\\n\\t\\t\\tif ( b ) {\\n\\t\\t\\t\\twhile ( (b = b.parentNode) ) {\\n\\t\\t\\t\\t\\tif ( b === a ) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t};\\n\\n\\t/* Sorting\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Document order sorting\\n\\tsortOrder = hasCompare ?\\n\\tfunction( a, b ) {\\n\\n\\t\\t// Flag for duplicate removal\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\t// Sort on method existence if only one input has compareDocumentPosition\\n\\t\\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\\n\\t\\tif ( compare ) {\\n\\t\\t\\treturn compare;\\n\\t\\t}\\n\\n\\t\\t// Calculate position if both inputs belong to the same document\\n\\t\\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\\n\\t\\t\\ta.compareDocumentPosition( b ) :\\n\\n\\t\\t\\t// Otherwise we know they are disconnected\\n\\t\\t\\t1;\\n\\n\\t\\t// Disconnected nodes\\n\\t\\tif ( compare & 1 ||\\n\\t\\t\\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\\n\\n\\t\\t\\t// Choose the first element that is related to our preferred document\\n\\t\\t\\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Maintain original order\\n\\t\\t\\treturn sortInput ?\\n\\t\\t\\t\\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\\n\\t\\t\\t\\t0;\\n\\t\\t}\\n\\n\\t\\treturn compare & 4 ? -1 : 1;\\n\\t} :\\n\\tfunction( a, b ) {\\n\\t\\t// Exit early if the nodes are identical\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tvar cur,\\n\\t\\t\\ti = 0,\\n\\t\\t\\taup = a.parentNode,\\n\\t\\t\\tbup = b.parentNode,\\n\\t\\t\\tap = [ a ],\\n\\t\\t\\tbp = [ b ];\\n\\n\\t\\t// Parentless nodes are either documents or disconnected\\n\\t\\tif ( !aup || !bup ) {\\n\\t\\t\\treturn a === document ? -1 :\\n\\t\\t\\t\\tb === document ? 1 :\\n\\t\\t\\t\\taup ? -1 :\\n\\t\\t\\t\\tbup ? 1 :\\n\\t\\t\\t\\tsortInput ?\\n\\t\\t\\t\\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\\n\\t\\t\\t\\t0;\\n\\n\\t\\t// If the nodes are siblings, we can do a quick check\\n\\t\\t} else if ( aup === bup ) {\\n\\t\\t\\treturn siblingCheck( a, b );\\n\\t\\t}\\n\\n\\t\\t// Otherwise we need full lists of their ancestors for comparison\\n\\t\\tcur = a;\\n\\t\\twhile ( (cur = cur.parentNode) ) {\\n\\t\\t\\tap.unshift( cur );\\n\\t\\t}\\n\\t\\tcur = b;\\n\\t\\twhile ( (cur = cur.parentNode) ) {\\n\\t\\t\\tbp.unshift( cur );\\n\\t\\t}\\n\\n\\t\\t// Walk down the tree looking for a discrepancy\\n\\t\\twhile ( ap[i] === bp[i] ) {\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\treturn i ?\\n\\t\\t\\t// Do a sibling check if the nodes have a common ancestor\\n\\t\\t\\tsiblingCheck( ap[i], bp[i] ) :\\n\\n\\t\\t\\t// Otherwise nodes in our document sort first\\n\\t\\t\\tap[i] === preferredDoc ? -1 :\\n\\t\\t\\tbp[i] === preferredDoc ? 1 :\\n\\t\\t\\t0;\\n\\t};\\n\\n\\treturn document;\\n};\\n\\nSizzle.matches = function( expr, elements ) {\\n\\treturn Sizzle( expr, null, null, elements );\\n};\\n\\nSizzle.matchesSelector = function( elem, expr ) {\\n\\t// Set document vars if needed\\n\\tif ( ( elem.ownerDocument || elem ) !== document ) {\\n\\t\\tsetDocument( elem );\\n\\t}\\n\\n\\t// Make sure that attribute selectors are quoted\\n\\texpr = expr.replace( rattributeQuotes, \\\"='$1']\\\" );\\n\\n\\tif ( support.matchesSelector && documentIsHTML &&\\n\\t\\t!compilerCache[ expr + \\\" \\\" ] &&\\n\\t\\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\\n\\t\\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\\n\\n\\t\\ttry {\\n\\t\\t\\tvar ret = matches.call( elem, expr );\\n\\n\\t\\t\\t// IE 9's matchesSelector returns false on disconnected nodes\\n\\t\\t\\tif ( ret || support.disconnectedMatch ||\\n\\t\\t\\t\\t\\t// As well, disconnected nodes are said to be in a document\\n\\t\\t\\t\\t\\t// fragment in IE 9\\n\\t\\t\\t\\t\\telem.document && elem.document.nodeType !== 11 ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {}\\n\\t}\\n\\n\\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\\n};\\n\\nSizzle.contains = function( context, elem ) {\\n\\t// Set document vars if needed\\n\\tif ( ( context.ownerDocument || context ) !== document ) {\\n\\t\\tsetDocument( context );\\n\\t}\\n\\treturn contains( context, elem );\\n};\\n\\nSizzle.attr = function( elem, name ) {\\n\\t// Set document vars if needed\\n\\tif ( ( elem.ownerDocument || elem ) !== document ) {\\n\\t\\tsetDocument( elem );\\n\\t}\\n\\n\\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\\n\\t\\t// Don't get fooled by Object.prototype properties (jQuery #13807)\\n\\t\\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\\n\\t\\t\\tfn( elem, name, !documentIsHTML ) :\\n\\t\\t\\tundefined;\\n\\n\\treturn val !== undefined ?\\n\\t\\tval :\\n\\t\\tsupport.attributes || !documentIsHTML ?\\n\\t\\t\\telem.getAttribute( name ) :\\n\\t\\t\\t(val = elem.getAttributeNode(name)) && val.specified ?\\n\\t\\t\\t\\tval.value :\\n\\t\\t\\t\\tnull;\\n};\\n\\nSizzle.escape = function( sel ) {\\n\\treturn (sel + \\\"\\\").replace( rcssescape, fcssescape );\\n};\\n\\nSizzle.error = function( msg ) {\\n\\tthrow new Error( \\\"Syntax error, unrecognized expression: \\\" + msg );\\n};\\n\\n/**\\n * Document sorting and removing duplicates\\n * @param {ArrayLike} results\\n */\\nSizzle.uniqueSort = function( results ) {\\n\\tvar elem,\\n\\t\\tduplicates = [],\\n\\t\\tj = 0,\\n\\t\\ti = 0;\\n\\n\\t// Unless we *know* we can detect duplicates, assume their presence\\n\\thasDuplicate = !support.detectDuplicates;\\n\\tsortInput = !support.sortStable && results.slice( 0 );\\n\\tresults.sort( sortOrder );\\n\\n\\tif ( hasDuplicate ) {\\n\\t\\twhile ( (elem = results[i++]) ) {\\n\\t\\t\\tif ( elem === results[ i ] ) {\\n\\t\\t\\t\\tj = duplicates.push( i );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile ( j-- ) {\\n\\t\\t\\tresults.splice( duplicates[ j ], 1 );\\n\\t\\t}\\n\\t}\\n\\n\\t// Clear input after sorting to release objects\\n\\t// See https://github.com/jquery/sizzle/pull/225\\n\\tsortInput = null;\\n\\n\\treturn results;\\n};\\n\\n/**\\n * Utility function for retrieving the text value of an array of DOM nodes\\n * @param {Array|Element} elem\\n */\\ngetText = Sizzle.getText = function( elem ) {\\n\\tvar node,\\n\\t\\tret = \\\"\\\",\\n\\t\\ti = 0,\\n\\t\\tnodeType = elem.nodeType;\\n\\n\\tif ( !nodeType ) {\\n\\t\\t// If no nodeType, this is expected to be an array\\n\\t\\twhile ( (node = elem[i++]) ) {\\n\\t\\t\\t// Do not traverse comment nodes\\n\\t\\t\\tret += getText( node );\\n\\t\\t}\\n\\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\\n\\t\\t// Use textContent for elements\\n\\t\\t// innerText usage removed for consistency of new lines (jQuery #11153)\\n\\t\\tif ( typeof elem.textContent === \\\"string\\\" ) {\\n\\t\\t\\treturn elem.textContent;\\n\\t\\t} else {\\n\\t\\t\\t// Traverse its children\\n\\t\\t\\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\\n\\t\\t\\t\\tret += getText( elem );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else if ( nodeType === 3 || nodeType === 4 ) {\\n\\t\\treturn elem.nodeValue;\\n\\t}\\n\\t// Do not include comment or processing instruction nodes\\n\\n\\treturn ret;\\n};\\n\\nExpr = Sizzle.selectors = {\\n\\n\\t// Can be adjusted by the user\\n\\tcacheLength: 50,\\n\\n\\tcreatePseudo: markFunction,\\n\\n\\tmatch: matchExpr,\\n\\n\\tattrHandle: {},\\n\\n\\tfind: {},\\n\\n\\trelative: {\\n\\t\\t\\\">\\\": { dir: \\\"parentNode\\\", first: true },\\n\\t\\t\\\" \\\": { dir: \\\"parentNode\\\" },\\n\\t\\t\\\"+\\\": { dir: \\\"previousSibling\\\", first: true },\\n\\t\\t\\\"~\\\": { dir: \\\"previousSibling\\\" }\\n\\t},\\n\\n\\tpreFilter: {\\n\\t\\t\\\"ATTR\\\": function( match ) {\\n\\t\\t\\tmatch[1] = match[1].replace( runescape, funescape );\\n\\n\\t\\t\\t// Move the given value to match[3] whether quoted or unquoted\\n\\t\\t\\tmatch[3] = ( match[3] || match[4] || match[5] || \\\"\\\" ).replace( runescape, funescape );\\n\\n\\t\\t\\tif ( match[2] === \\\"~=\\\" ) {\\n\\t\\t\\t\\tmatch[3] = \\\" \\\" + match[3] + \\\" \\\";\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn match.slice( 0, 4 );\\n\\t\\t},\\n\\n\\t\\t\\\"CHILD\\\": function( match ) {\\n\\t\\t\\t/* matches from matchExpr[\\\"CHILD\\\"]\\n\\t\\t\\t\\t1 type (only|nth|...)\\n\\t\\t\\t\\t2 what (child|of-type)\\n\\t\\t\\t\\t3 argument (even|odd|\\\\d*|\\\\d*n([+-]\\\\d+)?|...)\\n\\t\\t\\t\\t4 xn-component of xn+y argument ([+-]?\\\\d*n|)\\n\\t\\t\\t\\t5 sign of xn-component\\n\\t\\t\\t\\t6 x of xn-component\\n\\t\\t\\t\\t7 sign of y-component\\n\\t\\t\\t\\t8 y of y-component\\n\\t\\t\\t*/\\n\\t\\t\\tmatch[1] = match[1].toLowerCase();\\n\\n\\t\\t\\tif ( match[1].slice( 0, 3 ) === \\\"nth\\\" ) {\\n\\t\\t\\t\\t// nth-* requires argument\\n\\t\\t\\t\\tif ( !match[3] ) {\\n\\t\\t\\t\\t\\tSizzle.error( match[0] );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// numeric x and y parameters for Expr.filter.CHILD\\n\\t\\t\\t\\t// remember that false/true cast respectively to 0/1\\n\\t\\t\\t\\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \\\"even\\\" || match[3] === \\\"odd\\\" ) );\\n\\t\\t\\t\\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \\\"odd\\\" );\\n\\n\\t\\t\\t// other types prohibit arguments\\n\\t\\t\\t} else if ( match[3] ) {\\n\\t\\t\\t\\tSizzle.error( match[0] );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn match;\\n\\t\\t},\\n\\n\\t\\t\\\"PSEUDO\\\": function( match ) {\\n\\t\\t\\tvar excess,\\n\\t\\t\\t\\tunquoted = !match[6] && match[2];\\n\\n\\t\\t\\tif ( matchExpr[\\\"CHILD\\\"].test( match[0] ) ) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Accept quoted arguments as-is\\n\\t\\t\\tif ( match[3] ) {\\n\\t\\t\\t\\tmatch[2] = match[4] || match[5] || \\\"\\\";\\n\\n\\t\\t\\t// Strip excess characters from unquoted arguments\\n\\t\\t\\t} else if ( unquoted && rpseudo.test( unquoted ) &&\\n\\t\\t\\t\\t// Get excess from tokenize (recursively)\\n\\t\\t\\t\\t(excess = tokenize( unquoted, true )) &&\\n\\t\\t\\t\\t// advance to the next closing parenthesis\\n\\t\\t\\t\\t(excess = unquoted.indexOf( \\\")\\\", unquoted.length - excess ) - unquoted.length) ) {\\n\\n\\t\\t\\t\\t// excess is a negative index\\n\\t\\t\\t\\tmatch[0] = match[0].slice( 0, excess );\\n\\t\\t\\t\\tmatch[2] = unquoted.slice( 0, excess );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Return only captures needed by the pseudo filter method (type and argument)\\n\\t\\t\\treturn match.slice( 0, 3 );\\n\\t\\t}\\n\\t},\\n\\n\\tfilter: {\\n\\n\\t\\t\\\"TAG\\\": function( nodeNameSelector ) {\\n\\t\\t\\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\\n\\t\\t\\treturn nodeNameSelector === \\\"*\\\" ?\\n\\t\\t\\t\\tfunction() { return true; } :\\n\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\\n\\t\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\\\"CLASS\\\": function( className ) {\\n\\t\\t\\tvar pattern = classCache[ className + \\\" \\\" ];\\n\\n\\t\\t\\treturn pattern ||\\n\\t\\t\\t\\t(pattern = new RegExp( \\\"(^|\\\" + whitespace + \\\")\\\" + className + \\\"(\\\" + whitespace + \\\"|$)\\\" )) &&\\n\\t\\t\\t\\tclassCache( className, function( elem ) {\\n\\t\\t\\t\\t\\treturn pattern.test( typeof elem.className === \\\"string\\\" && elem.className || typeof elem.getAttribute !== \\\"undefined\\\" && elem.getAttribute(\\\"class\\\") || \\\"\\\" );\\n\\t\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\t\\\"ATTR\\\": function( name, operator, check ) {\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar result = Sizzle.attr( elem, name );\\n\\n\\t\\t\\t\\tif ( result == null ) {\\n\\t\\t\\t\\t\\treturn operator === \\\"!=\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( !operator ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tresult += \\\"\\\";\\n\\n\\t\\t\\t\\treturn operator === \\\"=\\\" ? result === check :\\n\\t\\t\\t\\t\\toperator === \\\"!=\\\" ? result !== check :\\n\\t\\t\\t\\t\\toperator === \\\"^=\\\" ? check && result.indexOf( check ) === 0 :\\n\\t\\t\\t\\t\\toperator === \\\"*=\\\" ? check && result.indexOf( check ) > -1 :\\n\\t\\t\\t\\t\\toperator === \\\"$=\\\" ? check && result.slice( -check.length ) === check :\\n\\t\\t\\t\\t\\toperator === \\\"~=\\\" ? ( \\\" \\\" + result.replace( rwhitespace, \\\" \\\" ) + \\\" \\\" ).indexOf( check ) > -1 :\\n\\t\\t\\t\\t\\toperator === \\\"|=\\\" ? result === check || result.slice( 0, check.length + 1 ) === check + \\\"-\\\" :\\n\\t\\t\\t\\t\\tfalse;\\n\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\\\"CHILD\\\": function( type, what, argument, first, last ) {\\n\\t\\t\\tvar simple = type.slice( 0, 3 ) !== \\\"nth\\\",\\n\\t\\t\\t\\tforward = type.slice( -4 ) !== \\\"last\\\",\\n\\t\\t\\t\\tofType = what === \\\"of-type\\\";\\n\\n\\t\\t\\treturn first === 1 && last === 0 ?\\n\\n\\t\\t\\t\\t// Shortcut for :nth-*(n)\\n\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\treturn !!elem.parentNode;\\n\\t\\t\\t\\t} :\\n\\n\\t\\t\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\t\\t\\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\\n\\t\\t\\t\\t\\t\\tdir = simple !== forward ? \\\"nextSibling\\\" : \\\"previousSibling\\\",\\n\\t\\t\\t\\t\\t\\tparent = elem.parentNode,\\n\\t\\t\\t\\t\\t\\tname = ofType && elem.nodeName.toLowerCase(),\\n\\t\\t\\t\\t\\t\\tuseCache = !xml && !ofType,\\n\\t\\t\\t\\t\\t\\tdiff = false;\\n\\n\\t\\t\\t\\t\\tif ( parent ) {\\n\\n\\t\\t\\t\\t\\t\\t// :(first|last|only)-(child|of-type)\\n\\t\\t\\t\\t\\t\\tif ( simple ) {\\n\\t\\t\\t\\t\\t\\t\\twhile ( dir ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tnode = elem;\\n\\t\\t\\t\\t\\t\\t\\t\\twhile ( (node = node[ dir ]) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( ofType ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeName.toLowerCase() === name :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeType === 1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t// Reverse direction for :only-* (if we haven't yet done so)\\n\\t\\t\\t\\t\\t\\t\\t\\tstart = dir = type === \\\"only\\\" && !start && \\\"nextSibling\\\";\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tstart = [ forward ? parent.firstChild : parent.lastChild ];\\n\\n\\t\\t\\t\\t\\t\\t// non-xml :nth-child(...) stores cache data on `parent`\\n\\t\\t\\t\\t\\t\\tif ( forward && useCache ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Seek `elem` from a previously-cached index\\n\\n\\t\\t\\t\\t\\t\\t\\t// ...in a gzip-friendly way\\n\\t\\t\\t\\t\\t\\t\\tnode = parent;\\n\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || (node[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t(outerCache[ node.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\tcache = uniqueCache[ type ] || [];\\n\\t\\t\\t\\t\\t\\t\\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\\n\\t\\t\\t\\t\\t\\t\\tdiff = nodeIndex && cache[ 2 ];\\n\\t\\t\\t\\t\\t\\t\\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Fallback to seeking `elem` from the start\\n\\t\\t\\t\\t\\t\\t\\t\\t(diff = nodeIndex = 0) || start.pop()) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// When found, cache indexes on `parent` and break\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( node.nodeType === 1 && ++diff && node === elem ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t// Use previously-cached element index if available\\n\\t\\t\\t\\t\\t\\t\\tif ( useCache ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t// ...in a gzip-friendly way\\n\\t\\t\\t\\t\\t\\t\\t\\tnode = elem;\\n\\t\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || (node[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(outerCache[ node.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcache = uniqueCache[ type ] || [];\\n\\t\\t\\t\\t\\t\\t\\t\\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\\n\\t\\t\\t\\t\\t\\t\\t\\tdiff = nodeIndex;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t// xml :nth-child(...)\\n\\t\\t\\t\\t\\t\\t\\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\\n\\t\\t\\t\\t\\t\\t\\tif ( diff === false ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t// Use the same loop as above to seek `elem` from the start\\n\\t\\t\\t\\t\\t\\t\\t\\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(diff = nodeIndex = 0) || start.pop()) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( ( ofType ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeName.toLowerCase() === name :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeType === 1 ) &&\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t++diff ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Cache the index of each encountered element\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( useCache ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || (node[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(outerCache[ node.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache[ type ] = [ dirruns, diff ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( node === elem ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Incorporate the offset, then check against cycle size\\n\\t\\t\\t\\t\\t\\tdiff -= last;\\n\\t\\t\\t\\t\\t\\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\\\"PSEUDO\\\": function( pseudo, argument ) {\\n\\t\\t\\t// pseudo-class names are case-insensitive\\n\\t\\t\\t// http://www.w3.org/TR/selectors/#pseudo-classes\\n\\t\\t\\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\\n\\t\\t\\t// Remember that setFilters inherits from pseudos\\n\\t\\t\\tvar args,\\n\\t\\t\\t\\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\\n\\t\\t\\t\\t\\tSizzle.error( \\\"unsupported pseudo: \\\" + pseudo );\\n\\n\\t\\t\\t// The user may use createPseudo to indicate that\\n\\t\\t\\t// arguments are needed to create the filter function\\n\\t\\t\\t// just as Sizzle does\\n\\t\\t\\tif ( fn[ expando ] ) {\\n\\t\\t\\t\\treturn fn( argument );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// But maintain support for old signatures\\n\\t\\t\\tif ( fn.length > 1 ) {\\n\\t\\t\\t\\targs = [ pseudo, pseudo, \\\"\\\", argument ];\\n\\t\\t\\t\\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\\n\\t\\t\\t\\t\\tmarkFunction(function( seed, matches ) {\\n\\t\\t\\t\\t\\t\\tvar idx,\\n\\t\\t\\t\\t\\t\\t\\tmatched = fn( seed, argument ),\\n\\t\\t\\t\\t\\t\\t\\ti = matched.length;\\n\\t\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\t\\tidx = indexOf( seed, matched[i] );\\n\\t\\t\\t\\t\\t\\t\\tseed[ idx ] = !( matches[ idx ] = matched[i] );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}) :\\n\\t\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\t\\treturn fn( elem, 0, args );\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn fn;\\n\\t\\t}\\n\\t},\\n\\n\\tpseudos: {\\n\\t\\t// Potentially complex pseudos\\n\\t\\t\\\"not\\\": markFunction(function( selector ) {\\n\\t\\t\\t// Trim the selector passed to compile\\n\\t\\t\\t// to avoid treating leading and trailing\\n\\t\\t\\t// spaces as combinators\\n\\t\\t\\tvar input = [],\\n\\t\\t\\t\\tresults = [],\\n\\t\\t\\t\\tmatcher = compile( selector.replace( rtrim, \\\"$1\\\" ) );\\n\\n\\t\\t\\treturn matcher[ expando ] ?\\n\\t\\t\\t\\tmarkFunction(function( seed, matches, context, xml ) {\\n\\t\\t\\t\\t\\tvar elem,\\n\\t\\t\\t\\t\\t\\tunmatched = matcher( seed, null, xml, [] ),\\n\\t\\t\\t\\t\\t\\ti = seed.length;\\n\\n\\t\\t\\t\\t\\t// Match elements unmatched by `matcher`\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tif ( (elem = unmatched[i]) ) {\\n\\t\\t\\t\\t\\t\\t\\tseed[i] = !(matches[i] = elem);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}) :\\n\\t\\t\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\t\\t\\tinput[0] = elem;\\n\\t\\t\\t\\t\\tmatcher( input, null, xml, results );\\n\\t\\t\\t\\t\\t// Don't keep the element (issue #299)\\n\\t\\t\\t\\t\\tinput[0] = null;\\n\\t\\t\\t\\t\\treturn !results.pop();\\n\\t\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t\\\"has\\\": markFunction(function( selector ) {\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn Sizzle( selector, elem ).length > 0;\\n\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t\\\"contains\\\": markFunction(function( text ) {\\n\\t\\t\\ttext = text.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\\n\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t// \\\"Whether an element is represented by a :lang() selector\\n\\t\\t// is based solely on the element's language value\\n\\t\\t// being equal to the identifier C,\\n\\t\\t// or beginning with the identifier C immediately followed by \\\"-\\\".\\n\\t\\t// The matching of C against the element's language value is performed case-insensitively.\\n\\t\\t// The identifier C does not have to be a valid language name.\\\"\\n\\t\\t// http://www.w3.org/TR/selectors/#lang-pseudo\\n\\t\\t\\\"lang\\\": markFunction( function( lang ) {\\n\\t\\t\\t// lang value must be a valid identifier\\n\\t\\t\\tif ( !ridentifier.test(lang || \\\"\\\") ) {\\n\\t\\t\\t\\tSizzle.error( \\\"unsupported lang: \\\" + lang );\\n\\t\\t\\t}\\n\\t\\t\\tlang = lang.replace( runescape, funescape ).toLowerCase();\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar elemLang;\\n\\t\\t\\t\\tdo {\\n\\t\\t\\t\\t\\tif ( (elemLang = documentIsHTML ?\\n\\t\\t\\t\\t\\t\\telem.lang :\\n\\t\\t\\t\\t\\t\\telem.getAttribute(\\\"xml:lang\\\") || elem.getAttribute(\\\"lang\\\")) ) {\\n\\n\\t\\t\\t\\t\\t\\telemLang = elemLang.toLowerCase();\\n\\t\\t\\t\\t\\t\\treturn elemLang === lang || elemLang.indexOf( lang + \\\"-\\\" ) === 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t// Miscellaneous\\n\\t\\t\\\"target\\\": function( elem ) {\\n\\t\\t\\tvar hash = window.location && window.location.hash;\\n\\t\\t\\treturn hash && hash.slice( 1 ) === elem.id;\\n\\t\\t},\\n\\n\\t\\t\\\"root\\\": function( elem ) {\\n\\t\\t\\treturn elem === docElem;\\n\\t\\t},\\n\\n\\t\\t\\\"focus\\\": function( elem ) {\\n\\t\\t\\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\\n\\t\\t},\\n\\n\\t\\t// Boolean properties\\n\\t\\t\\\"enabled\\\": createDisabledPseudo( false ),\\n\\t\\t\\\"disabled\\\": createDisabledPseudo( true ),\\n\\n\\t\\t\\\"checked\\\": function( elem ) {\\n\\t\\t\\t// In CSS3, :checked should return both checked and selected elements\\n\\t\\t\\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\\n\\t\\t\\tvar nodeName = elem.nodeName.toLowerCase();\\n\\t\\t\\treturn (nodeName === \\\"input\\\" && !!elem.checked) || (nodeName === \\\"option\\\" && !!elem.selected);\\n\\t\\t},\\n\\n\\t\\t\\\"selected\\\": function( elem ) {\\n\\t\\t\\t// Accessing this property makes selected-by-default\\n\\t\\t\\t// options in Safari work properly\\n\\t\\t\\tif ( elem.parentNode ) {\\n\\t\\t\\t\\telem.parentNode.selectedIndex;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn elem.selected === true;\\n\\t\\t},\\n\\n\\t\\t// Contents\\n\\t\\t\\\"empty\\\": function( elem ) {\\n\\t\\t\\t// http://www.w3.org/TR/selectors/#empty-pseudo\\n\\t\\t\\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\\n\\t\\t\\t//   but not by others (comment: 8; processing instruction: 7; etc.)\\n\\t\\t\\t// nodeType < 6 works because attributes (2) do not appear as children\\n\\t\\t\\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\\n\\t\\t\\t\\tif ( elem.nodeType < 6 ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t},\\n\\n\\t\\t\\\"parent\\\": function( elem ) {\\n\\t\\t\\treturn !Expr.pseudos[\\\"empty\\\"]( elem );\\n\\t\\t},\\n\\n\\t\\t// Element/input types\\n\\t\\t\\\"header\\\": function( elem ) {\\n\\t\\t\\treturn rheader.test( elem.nodeName );\\n\\t\\t},\\n\\n\\t\\t\\\"input\\\": function( elem ) {\\n\\t\\t\\treturn rinputs.test( elem.nodeName );\\n\\t\\t},\\n\\n\\t\\t\\\"button\\\": function( elem ) {\\n\\t\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\t\\treturn name === \\\"input\\\" && elem.type === \\\"button\\\" || name === \\\"button\\\";\\n\\t\\t},\\n\\n\\t\\t\\\"text\\\": function( elem ) {\\n\\t\\t\\tvar attr;\\n\\t\\t\\treturn elem.nodeName.toLowerCase() === \\\"input\\\" &&\\n\\t\\t\\t\\telem.type === \\\"text\\\" &&\\n\\n\\t\\t\\t\\t// Support: IE<8\\n\\t\\t\\t\\t// New HTML5 attribute values (e.g., \\\"search\\\") appear with elem.type === \\\"text\\\"\\n\\t\\t\\t\\t( (attr = elem.getAttribute(\\\"type\\\")) == null || attr.toLowerCase() === \\\"text\\\" );\\n\\t\\t},\\n\\n\\t\\t// Position-in-collection\\n\\t\\t\\\"first\\\": createPositionalPseudo(function() {\\n\\t\\t\\treturn [ 0 ];\\n\\t\\t}),\\n\\n\\t\\t\\\"last\\\": createPositionalPseudo(function( matchIndexes, length ) {\\n\\t\\t\\treturn [ length - 1 ];\\n\\t\\t}),\\n\\n\\t\\t\\\"eq\\\": createPositionalPseudo(function( matchIndexes, length, argument ) {\\n\\t\\t\\treturn [ argument < 0 ? argument + length : argument ];\\n\\t\\t}),\\n\\n\\t\\t\\\"even\\\": createPositionalPseudo(function( matchIndexes, length ) {\\n\\t\\t\\tvar i = 0;\\n\\t\\t\\tfor ( ; i < length; i += 2 ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t}),\\n\\n\\t\\t\\\"odd\\\": createPositionalPseudo(function( matchIndexes, length ) {\\n\\t\\t\\tvar i = 1;\\n\\t\\t\\tfor ( ; i < length; i += 2 ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t}),\\n\\n\\t\\t\\\"lt\\\": createPositionalPseudo(function( matchIndexes, length, argument ) {\\n\\t\\t\\tvar i = argument < 0 ? argument + length : argument;\\n\\t\\t\\tfor ( ; --i >= 0; ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t}),\\n\\n\\t\\t\\\"gt\\\": createPositionalPseudo(function( matchIndexes, length, argument ) {\\n\\t\\t\\tvar i = argument < 0 ? argument + length : argument;\\n\\t\\t\\tfor ( ; ++i < length; ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t})\\n\\t}\\n};\\n\\nExpr.pseudos[\\\"nth\\\"] = Expr.pseudos[\\\"eq\\\"];\\n\\n// Add button/input type pseudos\\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\\n\\tExpr.pseudos[ i ] = createInputPseudo( i );\\n}\\nfor ( i in { submit: true, reset: true } ) {\\n\\tExpr.pseudos[ i ] = createButtonPseudo( i );\\n}\\n\\n// Easy API for creating new setFilters\\nfunction setFilters() {}\\nsetFilters.prototype = Expr.filters = Expr.pseudos;\\nExpr.setFilters = new setFilters();\\n\\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\\n\\tvar matched, match, tokens, type,\\n\\t\\tsoFar, groups, preFilters,\\n\\t\\tcached = tokenCache[ selector + \\\" \\\" ];\\n\\n\\tif ( cached ) {\\n\\t\\treturn parseOnly ? 0 : cached.slice( 0 );\\n\\t}\\n\\n\\tsoFar = selector;\\n\\tgroups = [];\\n\\tpreFilters = Expr.preFilter;\\n\\n\\twhile ( soFar ) {\\n\\n\\t\\t// Comma and first run\\n\\t\\tif ( !matched || (match = rcomma.exec( soFar )) ) {\\n\\t\\t\\tif ( match ) {\\n\\t\\t\\t\\t// Don't consume trailing commas as valid\\n\\t\\t\\t\\tsoFar = soFar.slice( match[0].length ) || soFar;\\n\\t\\t\\t}\\n\\t\\t\\tgroups.push( (tokens = []) );\\n\\t\\t}\\n\\n\\t\\tmatched = false;\\n\\n\\t\\t// Combinators\\n\\t\\tif ( (match = rcombinators.exec( soFar )) ) {\\n\\t\\t\\tmatched = match.shift();\\n\\t\\t\\ttokens.push({\\n\\t\\t\\t\\tvalue: matched,\\n\\t\\t\\t\\t// Cast descendant combinators to space\\n\\t\\t\\t\\ttype: match[0].replace( rtrim, \\\" \\\" )\\n\\t\\t\\t});\\n\\t\\t\\tsoFar = soFar.slice( matched.length );\\n\\t\\t}\\n\\n\\t\\t// Filters\\n\\t\\tfor ( type in Expr.filter ) {\\n\\t\\t\\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\\n\\t\\t\\t\\t(match = preFilters[ type ]( match ))) ) {\\n\\t\\t\\t\\tmatched = match.shift();\\n\\t\\t\\t\\ttokens.push({\\n\\t\\t\\t\\t\\tvalue: matched,\\n\\t\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\t\\tmatches: match\\n\\t\\t\\t\\t});\\n\\t\\t\\t\\tsoFar = soFar.slice( matched.length );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( !matched ) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the length of the invalid excess\\n\\t// if we're just parsing\\n\\t// Otherwise, throw an error or return tokens\\n\\treturn parseOnly ?\\n\\t\\tsoFar.length :\\n\\t\\tsoFar ?\\n\\t\\t\\tSizzle.error( selector ) :\\n\\t\\t\\t// Cache the tokens\\n\\t\\t\\ttokenCache( selector, groups ).slice( 0 );\\n};\\n\\nfunction toSelector( tokens ) {\\n\\tvar i = 0,\\n\\t\\tlen = tokens.length,\\n\\t\\tselector = \\\"\\\";\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tselector += tokens[i].value;\\n\\t}\\n\\treturn selector;\\n}\\n\\nfunction addCombinator( matcher, combinator, base ) {\\n\\tvar dir = combinator.dir,\\n\\t\\tskip = combinator.next,\\n\\t\\tkey = skip || dir,\\n\\t\\tcheckNonElements = base && key === \\\"parentNode\\\",\\n\\t\\tdoneName = done++;\\n\\n\\treturn combinator.first ?\\n\\t\\t// Check against closest ancestor/preceding element\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\twhile ( (elem = elem[ dir ]) ) {\\n\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\treturn matcher( elem, context, xml );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t} :\\n\\n\\t\\t// Check against all ancestor/preceding elements\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\tvar oldCache, uniqueCache, outerCache,\\n\\t\\t\\t\\tnewCache = [ dirruns, doneName ];\\n\\n\\t\\t\\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\\n\\t\\t\\tif ( xml ) {\\n\\t\\t\\t\\twhile ( (elem = elem[ dir ]) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\t\\tif ( matcher( elem, context, xml ) ) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twhile ( (elem = elem[ dir ]) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\t\\touterCache = elem[ expando ] || (elem[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\\n\\t\\t\\t\\t\\t\\t\\telem = elem[ dir ] || elem;\\n\\t\\t\\t\\t\\t\\t} else if ( (oldCache = uniqueCache[ key ]) &&\\n\\t\\t\\t\\t\\t\\t\\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Assign to newCache so results back-propagate to previous elements\\n\\t\\t\\t\\t\\t\\t\\treturn (newCache[ 2 ] = oldCache[ 2 ]);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t// Reuse newcache so results back-propagate to previous elements\\n\\t\\t\\t\\t\\t\\t\\tuniqueCache[ key ] = newCache;\\n\\n\\t\\t\\t\\t\\t\\t\\t// A match means we're done; a fail means we have to keep checking\\n\\t\\t\\t\\t\\t\\t\\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t};\\n}\\n\\nfunction elementMatcher( matchers ) {\\n\\treturn matchers.length > 1 ?\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\tvar i = matchers.length;\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( !matchers[i]( elem, context, xml ) ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t} :\\n\\t\\tmatchers[0];\\n}\\n\\nfunction multipleContexts( selector, contexts, results ) {\\n\\tvar i = 0,\\n\\t\\tlen = contexts.length;\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tSizzle( selector, contexts[i], results );\\n\\t}\\n\\treturn results;\\n}\\n\\nfunction condense( unmatched, map, filter, context, xml ) {\\n\\tvar elem,\\n\\t\\tnewUnmatched = [],\\n\\t\\ti = 0,\\n\\t\\tlen = unmatched.length,\\n\\t\\tmapped = map != null;\\n\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tif ( (elem = unmatched[i]) ) {\\n\\t\\t\\tif ( !filter || filter( elem, context, xml ) ) {\\n\\t\\t\\t\\tnewUnmatched.push( elem );\\n\\t\\t\\t\\tif ( mapped ) {\\n\\t\\t\\t\\t\\tmap.push( i );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn newUnmatched;\\n}\\n\\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\\n\\tif ( postFilter && !postFilter[ expando ] ) {\\n\\t\\tpostFilter = setMatcher( postFilter );\\n\\t}\\n\\tif ( postFinder && !postFinder[ expando ] ) {\\n\\t\\tpostFinder = setMatcher( postFinder, postSelector );\\n\\t}\\n\\treturn markFunction(function( seed, results, context, xml ) {\\n\\t\\tvar temp, i, elem,\\n\\t\\t\\tpreMap = [],\\n\\t\\t\\tpostMap = [],\\n\\t\\t\\tpreexisting = results.length,\\n\\n\\t\\t\\t// Get initial elements from seed or context\\n\\t\\t\\telems = seed || multipleContexts( selector || \\\"*\\\", context.nodeType ? [ context ] : context, [] ),\\n\\n\\t\\t\\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\\n\\t\\t\\tmatcherIn = preFilter && ( seed || !selector ) ?\\n\\t\\t\\t\\tcondense( elems, preMap, preFilter, context, xml ) :\\n\\t\\t\\t\\telems,\\n\\n\\t\\t\\tmatcherOut = matcher ?\\n\\t\\t\\t\\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\\n\\t\\t\\t\\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\\n\\n\\t\\t\\t\\t\\t// ...intermediate processing is necessary\\n\\t\\t\\t\\t\\t[] :\\n\\n\\t\\t\\t\\t\\t// ...otherwise use results directly\\n\\t\\t\\t\\t\\tresults :\\n\\t\\t\\t\\tmatcherIn;\\n\\n\\t\\t// Find primary matches\\n\\t\\tif ( matcher ) {\\n\\t\\t\\tmatcher( matcherIn, matcherOut, context, xml );\\n\\t\\t}\\n\\n\\t\\t// Apply postFilter\\n\\t\\tif ( postFilter ) {\\n\\t\\t\\ttemp = condense( matcherOut, postMap );\\n\\t\\t\\tpostFilter( temp, [], context, xml );\\n\\n\\t\\t\\t// Un-match failing elements by moving them back to matcherIn\\n\\t\\t\\ti = temp.length;\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( (elem = temp[i]) ) {\\n\\t\\t\\t\\t\\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( seed ) {\\n\\t\\t\\tif ( postFinder || preFilter ) {\\n\\t\\t\\t\\tif ( postFinder ) {\\n\\t\\t\\t\\t\\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\\n\\t\\t\\t\\t\\ttemp = [];\\n\\t\\t\\t\\t\\ti = matcherOut.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tif ( (elem = matcherOut[i]) ) {\\n\\t\\t\\t\\t\\t\\t\\t// Restore matcherIn since elem is not yet a final match\\n\\t\\t\\t\\t\\t\\t\\ttemp.push( (matcherIn[i] = elem) );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tpostFinder( null, (matcherOut = []), temp, xml );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Move matched elements from seed to results to keep them synchronized\\n\\t\\t\\t\\ti = matcherOut.length;\\n\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\tif ( (elem = matcherOut[i]) &&\\n\\t\\t\\t\\t\\t\\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\\n\\n\\t\\t\\t\\t\\t\\tseed[temp] = !(results[temp] = elem);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Add elements to results, through postFinder if defined\\n\\t\\t} else {\\n\\t\\t\\tmatcherOut = condense(\\n\\t\\t\\t\\tmatcherOut === results ?\\n\\t\\t\\t\\t\\tmatcherOut.splice( preexisting, matcherOut.length ) :\\n\\t\\t\\t\\t\\tmatcherOut\\n\\t\\t\\t);\\n\\t\\t\\tif ( postFinder ) {\\n\\t\\t\\t\\tpostFinder( null, results, matcherOut, xml );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpush.apply( results, matcherOut );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n}\\n\\nfunction matcherFromTokens( tokens ) {\\n\\tvar checkContext, matcher, j,\\n\\t\\tlen = tokens.length,\\n\\t\\tleadingRelative = Expr.relative[ tokens[0].type ],\\n\\t\\timplicitRelative = leadingRelative || Expr.relative[\\\" \\\"],\\n\\t\\ti = leadingRelative ? 1 : 0,\\n\\n\\t\\t// The foundational matcher ensures that elements are reachable from top-level context(s)\\n\\t\\tmatchContext = addCombinator( function( elem ) {\\n\\t\\t\\treturn elem === checkContext;\\n\\t\\t}, implicitRelative, true ),\\n\\t\\tmatchAnyContext = addCombinator( function( elem ) {\\n\\t\\t\\treturn indexOf( checkContext, elem ) > -1;\\n\\t\\t}, implicitRelative, true ),\\n\\t\\tmatchers = [ function( elem, context, xml ) {\\n\\t\\t\\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\\n\\t\\t\\t\\t(checkContext = context).nodeType ?\\n\\t\\t\\t\\t\\tmatchContext( elem, context, xml ) :\\n\\t\\t\\t\\t\\tmatchAnyContext( elem, context, xml ) );\\n\\t\\t\\t// Avoid hanging onto element (issue #299)\\n\\t\\t\\tcheckContext = null;\\n\\t\\t\\treturn ret;\\n\\t\\t} ];\\n\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\\n\\t\\t\\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\\n\\t\\t} else {\\n\\t\\t\\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\\n\\n\\t\\t\\t// Return special upon seeing a positional matcher\\n\\t\\t\\tif ( matcher[ expando ] ) {\\n\\t\\t\\t\\t// Find the next relative operator (if any) for proper handling\\n\\t\\t\\t\\tj = ++i;\\n\\t\\t\\t\\tfor ( ; j < len; j++ ) {\\n\\t\\t\\t\\t\\tif ( Expr.relative[ tokens[j].type ] ) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn setMatcher(\\n\\t\\t\\t\\t\\ti > 1 && elementMatcher( matchers ),\\n\\t\\t\\t\\t\\ti > 1 && toSelector(\\n\\t\\t\\t\\t\\t\\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\\n\\t\\t\\t\\t\\t\\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \\\" \\\" ? \\\"*\\\" : \\\"\\\" })\\n\\t\\t\\t\\t\\t).replace( rtrim, \\\"$1\\\" ),\\n\\t\\t\\t\\t\\tmatcher,\\n\\t\\t\\t\\t\\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\\n\\t\\t\\t\\t\\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\\n\\t\\t\\t\\t\\tj < len && toSelector( tokens )\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t\\tmatchers.push( matcher );\\n\\t\\t}\\n\\t}\\n\\n\\treturn elementMatcher( matchers );\\n}\\n\\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\\n\\tvar bySet = setMatchers.length > 0,\\n\\t\\tbyElement = elementMatchers.length > 0,\\n\\t\\tsuperMatcher = function( seed, context, xml, results, outermost ) {\\n\\t\\t\\tvar elem, j, matcher,\\n\\t\\t\\t\\tmatchedCount = 0,\\n\\t\\t\\t\\ti = \\\"0\\\",\\n\\t\\t\\t\\tunmatched = seed && [],\\n\\t\\t\\t\\tsetMatched = [],\\n\\t\\t\\t\\tcontextBackup = outermostContext,\\n\\t\\t\\t\\t// We must always have either seed elements or outermost context\\n\\t\\t\\t\\telems = seed || byElement && Expr.find[\\\"TAG\\\"]( \\\"*\\\", outermost ),\\n\\t\\t\\t\\t// Use integer dirruns iff this is the outermost matcher\\n\\t\\t\\t\\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\\n\\t\\t\\t\\tlen = elems.length;\\n\\n\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\toutermostContext = context === document || context || outermost;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add elements passing elementMatchers directly to results\\n\\t\\t\\t// Support: IE<9, Safari\\n\\t\\t\\t// Tolerate NodeList properties (IE: \\\"length\\\"; Safari: <number>) matching elements by id\\n\\t\\t\\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\\n\\t\\t\\t\\tif ( byElement && elem ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\tif ( !context && elem.ownerDocument !== document ) {\\n\\t\\t\\t\\t\\t\\tsetDocument( elem );\\n\\t\\t\\t\\t\\t\\txml = !documentIsHTML;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\twhile ( (matcher = elementMatchers[j++]) ) {\\n\\t\\t\\t\\t\\t\\tif ( matcher( elem, context || document, xml) ) {\\n\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\t\\t\\tdirruns = dirrunsUnique;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Track unmatched elements for set filters\\n\\t\\t\\t\\tif ( bySet ) {\\n\\t\\t\\t\\t\\t// They will have gone through all possible matchers\\n\\t\\t\\t\\t\\tif ( (elem = !matcher && elem) ) {\\n\\t\\t\\t\\t\\t\\tmatchedCount--;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Lengthen the array for every element, matched or not\\n\\t\\t\\t\\t\\tif ( seed ) {\\n\\t\\t\\t\\t\\t\\tunmatched.push( elem );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\\n\\t\\t\\t// makes the latter nonnegative.\\n\\t\\t\\tmatchedCount += i;\\n\\n\\t\\t\\t// Apply set filters to unmatched elements\\n\\t\\t\\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\\n\\t\\t\\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\\n\\t\\t\\t// no element matchers and no seed.\\n\\t\\t\\t// Incrementing an initially-string \\\"0\\\" `i` allows `i` to remain a string only in that\\n\\t\\t\\t// case, which will result in a \\\"00\\\" `matchedCount` that differs from `i` but is also\\n\\t\\t\\t// numerically zero.\\n\\t\\t\\tif ( bySet && i !== matchedCount ) {\\n\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\twhile ( (matcher = setMatchers[j++]) ) {\\n\\t\\t\\t\\t\\tmatcher( unmatched, setMatched, context, xml );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( seed ) {\\n\\t\\t\\t\\t\\t// Reintegrate element matches to eliminate the need for sorting\\n\\t\\t\\t\\t\\tif ( matchedCount > 0 ) {\\n\\t\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( !(unmatched[i] || setMatched[i]) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tsetMatched[i] = pop.call( results );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Discard index placeholder values to get only actual matches\\n\\t\\t\\t\\t\\tsetMatched = condense( setMatched );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Add matches to results\\n\\t\\t\\t\\tpush.apply( results, setMatched );\\n\\n\\t\\t\\t\\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\\n\\t\\t\\t\\tif ( outermost && !seed && setMatched.length > 0 &&\\n\\t\\t\\t\\t\\t( matchedCount + setMatchers.length ) > 1 ) {\\n\\n\\t\\t\\t\\t\\tSizzle.uniqueSort( results );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Override manipulation of globals by nested matchers\\n\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\tdirruns = dirrunsUnique;\\n\\t\\t\\t\\toutermostContext = contextBackup;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn unmatched;\\n\\t\\t};\\n\\n\\treturn bySet ?\\n\\t\\tmarkFunction( superMatcher ) :\\n\\t\\tsuperMatcher;\\n}\\n\\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\\n\\tvar i,\\n\\t\\tsetMatchers = [],\\n\\t\\telementMatchers = [],\\n\\t\\tcached = compilerCache[ selector + \\\" \\\" ];\\n\\n\\tif ( !cached ) {\\n\\t\\t// Generate a function of recursive functions that can be used to check each element\\n\\t\\tif ( !match ) {\\n\\t\\t\\tmatch = tokenize( selector );\\n\\t\\t}\\n\\t\\ti = match.length;\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\tcached = matcherFromTokens( match[i] );\\n\\t\\t\\tif ( cached[ expando ] ) {\\n\\t\\t\\t\\tsetMatchers.push( cached );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\telementMatchers.push( cached );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Cache the compiled function\\n\\t\\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\\n\\n\\t\\t// Save selector and tokenization\\n\\t\\tcached.selector = selector;\\n\\t}\\n\\treturn cached;\\n};\\n\\n/**\\n * A low-level selection function that works with Sizzle's compiled\\n *  selector functions\\n * @param {String|Function} selector A selector or a pre-compiled\\n *  selector function built with Sizzle.compile\\n * @param {Element} context\\n * @param {Array} [results]\\n * @param {Array} [seed] A set of elements to match against\\n */\\nselect = Sizzle.select = function( selector, context, results, seed ) {\\n\\tvar i, tokens, token, type, find,\\n\\t\\tcompiled = typeof selector === \\\"function\\\" && selector,\\n\\t\\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\\n\\n\\tresults = results || [];\\n\\n\\t// Try to minimize operations if there is only one selector in the list and no seed\\n\\t// (the latter of which guarantees us context)\\n\\tif ( match.length === 1 ) {\\n\\n\\t\\t// Reduce context if the leading compound selector is an ID\\n\\t\\ttokens = match[0] = match[0].slice( 0 );\\n\\t\\tif ( tokens.length > 2 && (token = tokens[0]).type === \\\"ID\\\" &&\\n\\t\\t\\t\\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\\n\\n\\t\\t\\tcontext = ( Expr.find[\\\"ID\\\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\\n\\t\\t\\tif ( !context ) {\\n\\t\\t\\t\\treturn results;\\n\\n\\t\\t\\t// Precompiled matchers will still verify ancestry, so step up a level\\n\\t\\t\\t} else if ( compiled ) {\\n\\t\\t\\t\\tcontext = context.parentNode;\\n\\t\\t\\t}\\n\\n\\t\\t\\tselector = selector.slice( tokens.shift().value.length );\\n\\t\\t}\\n\\n\\t\\t// Fetch a seed set for right-to-left matching\\n\\t\\ti = matchExpr[\\\"needsContext\\\"].test( selector ) ? 0 : tokens.length;\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\ttoken = tokens[i];\\n\\n\\t\\t\\t// Abort if we hit a combinator\\n\\t\\t\\tif ( Expr.relative[ (type = token.type) ] ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif ( (find = Expr.find[ type ]) ) {\\n\\t\\t\\t\\t// Search, expanding context for leading sibling combinators\\n\\t\\t\\t\\tif ( (seed = find(\\n\\t\\t\\t\\t\\ttoken.matches[0].replace( runescape, funescape ),\\n\\t\\t\\t\\t\\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\\n\\t\\t\\t\\t)) ) {\\n\\n\\t\\t\\t\\t\\t// If seed is empty or no tokens remain, we can return early\\n\\t\\t\\t\\t\\ttokens.splice( i, 1 );\\n\\t\\t\\t\\t\\tselector = seed.length && toSelector( tokens );\\n\\t\\t\\t\\t\\tif ( !selector ) {\\n\\t\\t\\t\\t\\t\\tpush.apply( results, seed );\\n\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Compile and execute a filtering function if one is not provided\\n\\t// Provide `match` to avoid retokenization if we modified the selector above\\n\\t( compiled || compile( selector, match ) )(\\n\\t\\tseed,\\n\\t\\tcontext,\\n\\t\\t!documentIsHTML,\\n\\t\\tresults,\\n\\t\\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\\n\\t);\\n\\treturn results;\\n};\\n\\n// One-time assignments\\n\\n// Sort stability\\nsupport.sortStable = expando.split(\\\"\\\").sort( sortOrder ).join(\\\"\\\") === expando;\\n\\n// Support: Chrome 14-35+\\n// Always assume duplicates if they aren't passed to the comparison function\\nsupport.detectDuplicates = !!hasDuplicate;\\n\\n// Initialize against the default document\\nsetDocument();\\n\\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\\n// Detached nodes confoundingly follow *each other*\\nsupport.sortDetached = assert(function( el ) {\\n\\t// Should return 1, but returns 4 (following)\\n\\treturn el.compareDocumentPosition( document.createElement(\\\"fieldset\\\") ) & 1;\\n});\\n\\n// Support: IE<8\\n// Prevent attribute/property \\\"interpolation\\\"\\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\\nif ( !assert(function( el ) {\\n\\tel.innerHTML = \\\"<a href='#'></a>\\\";\\n\\treturn el.firstChild.getAttribute(\\\"href\\\") === \\\"#\\\" ;\\n}) ) {\\n\\taddHandle( \\\"type|href|height|width\\\", function( elem, name, isXML ) {\\n\\t\\tif ( !isXML ) {\\n\\t\\t\\treturn elem.getAttribute( name, name.toLowerCase() === \\\"type\\\" ? 1 : 2 );\\n\\t\\t}\\n\\t});\\n}\\n\\n// Support: IE<9\\n// Use defaultValue in place of getAttribute(\\\"value\\\")\\nif ( !support.attributes || !assert(function( el ) {\\n\\tel.innerHTML = \\\"<input/>\\\";\\n\\tel.firstChild.setAttribute( \\\"value\\\", \\\"\\\" );\\n\\treturn el.firstChild.getAttribute( \\\"value\\\" ) === \\\"\\\";\\n}) ) {\\n\\taddHandle( \\\"value\\\", function( elem, name, isXML ) {\\n\\t\\tif ( !isXML && elem.nodeName.toLowerCase() === \\\"input\\\" ) {\\n\\t\\t\\treturn elem.defaultValue;\\n\\t\\t}\\n\\t});\\n}\\n\\n// Support: IE<9\\n// Use getAttributeNode to fetch booleans when getAttribute lies\\nif ( !assert(function( el ) {\\n\\treturn el.getAttribute(\\\"disabled\\\") == null;\\n}) ) {\\n\\taddHandle( booleans, function( elem, name, isXML ) {\\n\\t\\tvar val;\\n\\t\\tif ( !isXML ) {\\n\\t\\t\\treturn elem[ name ] === true ? name.toLowerCase() :\\n\\t\\t\\t\\t\\t(val = elem.getAttributeNode( name )) && val.specified ?\\n\\t\\t\\t\\t\\tval.value :\\n\\t\\t\\t\\tnull;\\n\\t\\t}\\n\\t});\\n}\\n\\nreturn Sizzle;\\n\\n})( window );\\n\\n\\n\\njQuery.find = Sizzle;\\njQuery.expr = Sizzle.selectors;\\n\\n// Deprecated\\njQuery.expr[ \\\":\\\" ] = jQuery.expr.pseudos;\\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\\njQuery.text = Sizzle.getText;\\njQuery.isXMLDoc = Sizzle.isXML;\\njQuery.contains = Sizzle.contains;\\njQuery.escapeSelector = Sizzle.escape;\\n\\n\\n\\n\\nvar dir = function( elem, dir, until ) {\\n\\tvar matched = [],\\n\\t\\ttruncate = until !== undefined;\\n\\n\\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\\n\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\tif ( truncate && jQuery( elem ).is( until ) ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tmatched.push( elem );\\n\\t\\t}\\n\\t}\\n\\treturn matched;\\n};\\n\\n\\nvar siblings = function( n, elem ) {\\n\\tvar matched = [];\\n\\n\\tfor ( ; n; n = n.nextSibling ) {\\n\\t\\tif ( n.nodeType === 1 && n !== elem ) {\\n\\t\\t\\tmatched.push( n );\\n\\t\\t}\\n\\t}\\n\\n\\treturn matched;\\n};\\n\\n\\nvar rneedsContext = jQuery.expr.match.needsContext;\\n\\nvar rsingleTag = ( /^<([a-z][^\\\\/\\\\0>:\\\\x20\\\\t\\\\r\\\\n\\\\f]*)[\\\\x20\\\\t\\\\r\\\\n\\\\f]*\\\\/?>(?:<\\\\/\\\\1>|)$/i );\\n\\n\\n\\nvar risSimple = /^.[^:#\\\\[\\\\.,]*$/;\\n\\n// Implement the identical functionality for filter and not\\nfunction winnow( elements, qualifier, not ) {\\n\\tif ( jQuery.isFunction( qualifier ) ) {\\n\\t\\treturn jQuery.grep( elements, function( elem, i ) {\\n\\t\\t\\treturn !!qualifier.call( elem, i, elem ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Single element\\n\\tif ( qualifier.nodeType ) {\\n\\t\\treturn jQuery.grep( elements, function( elem ) {\\n\\t\\t\\treturn ( elem === qualifier ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Arraylike of elements (jQuery, arguments, Array)\\n\\tif ( typeof qualifier !== \\\"string\\\" ) {\\n\\t\\treturn jQuery.grep( elements, function( elem ) {\\n\\t\\t\\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Simple selector that can be filtered directly, removing non-Elements\\n\\tif ( risSimple.test( qualifier ) ) {\\n\\t\\treturn jQuery.filter( qualifier, elements, not );\\n\\t}\\n\\n\\t// Complex selector, compare the two sets, removing non-Elements\\n\\tqualifier = jQuery.filter( qualifier, elements );\\n\\treturn jQuery.grep( elements, function( elem ) {\\n\\t\\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;\\n\\t} );\\n}\\n\\njQuery.filter = function( expr, elems, not ) {\\n\\tvar elem = elems[ 0 ];\\n\\n\\tif ( not ) {\\n\\t\\texpr = \\\":not(\\\" + expr + \\\")\\\";\\n\\t}\\n\\n\\tif ( elems.length === 1 && elem.nodeType === 1 ) {\\n\\t\\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\\n\\t}\\n\\n\\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\\n\\t\\treturn elem.nodeType === 1;\\n\\t} ) );\\n};\\n\\njQuery.fn.extend( {\\n\\tfind: function( selector ) {\\n\\t\\tvar i, ret,\\n\\t\\t\\tlen = this.length,\\n\\t\\t\\tself = this;\\n\\n\\t\\tif ( typeof selector !== \\\"string\\\" ) {\\n\\t\\t\\treturn this.pushStack( jQuery( selector ).filter( function() {\\n\\t\\t\\t\\tfor ( i = 0; i < len; i++ ) {\\n\\t\\t\\t\\t\\tif ( jQuery.contains( self[ i ], this ) ) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} ) );\\n\\t\\t}\\n\\n\\t\\tret = this.pushStack( [] );\\n\\n\\t\\tfor ( i = 0; i < len; i++ ) {\\n\\t\\t\\tjQuery.find( selector, self[ i ], ret );\\n\\t\\t}\\n\\n\\t\\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\\n\\t},\\n\\tfilter: function( selector ) {\\n\\t\\treturn this.pushStack( winnow( this, selector || [], false ) );\\n\\t},\\n\\tnot: function( selector ) {\\n\\t\\treturn this.pushStack( winnow( this, selector || [], true ) );\\n\\t},\\n\\tis: function( selector ) {\\n\\t\\treturn !!winnow(\\n\\t\\t\\tthis,\\n\\n\\t\\t\\t// If this is a positional/relative selector, check membership in the returned set\\n\\t\\t\\t// so $(\\\"p:first\\\").is(\\\"p:last\\\") won't return true for a doc with two \\\"p\\\".\\n\\t\\t\\ttypeof selector === \\\"string\\\" && rneedsContext.test( selector ) ?\\n\\t\\t\\t\\tjQuery( selector ) :\\n\\t\\t\\t\\tselector || [],\\n\\t\\t\\tfalse\\n\\t\\t).length;\\n\\t}\\n} );\\n\\n\\n// Initialize a jQuery object\\n\\n\\n// A central reference to the root jQuery(document)\\nvar rootjQuery,\\n\\n\\t// A simple way to check for HTML strings\\n\\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\\n\\t// Strict HTML recognition (#11290: must start with <)\\n\\t// Shortcut simple #id case for speed\\n\\trquickExpr = /^(?:\\\\s*(<[\\\\w\\\\W]+>)[^>]*|#([\\\\w-]+))$/,\\n\\n\\tinit = jQuery.fn.init = function( selector, context, root ) {\\n\\t\\tvar match, elem;\\n\\n\\t\\t// HANDLE: $(\\\"\\\"), $(null), $(undefined), $(false)\\n\\t\\tif ( !selector ) {\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\n\\t\\t// Method init() accepts an alternate rootjQuery\\n\\t\\t// so migrate can support jQuery.sub (gh-2101)\\n\\t\\troot = root || rootjQuery;\\n\\n\\t\\t// Handle HTML strings\\n\\t\\tif ( typeof selector === \\\"string\\\" ) {\\n\\t\\t\\tif ( selector[ 0 ] === \\\"<\\\" &&\\n\\t\\t\\t\\tselector[ selector.length - 1 ] === \\\">\\\" &&\\n\\t\\t\\t\\tselector.length >= 3 ) {\\n\\n\\t\\t\\t\\t// Assume that strings that start and end with <> are HTML and skip the regex check\\n\\t\\t\\t\\tmatch = [ null, selector, null ];\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmatch = rquickExpr.exec( selector );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Match html or make sure no context is specified for #id\\n\\t\\t\\tif ( match && ( match[ 1 ] || !context ) ) {\\n\\n\\t\\t\\t\\t// HANDLE: $(html) -> $(array)\\n\\t\\t\\t\\tif ( match[ 1 ] ) {\\n\\t\\t\\t\\t\\tcontext = context instanceof jQuery ? context[ 0 ] : context;\\n\\n\\t\\t\\t\\t\\t// Option to run scripts is true for back-compat\\n\\t\\t\\t\\t\\t// Intentionally let the error be thrown if parseHTML is not present\\n\\t\\t\\t\\t\\tjQuery.merge( this, jQuery.parseHTML(\\n\\t\\t\\t\\t\\t\\tmatch[ 1 ],\\n\\t\\t\\t\\t\\t\\tcontext && context.nodeType ? context.ownerDocument || context : document,\\n\\t\\t\\t\\t\\t\\ttrue\\n\\t\\t\\t\\t\\t) );\\n\\n\\t\\t\\t\\t\\t// HANDLE: $(html, props)\\n\\t\\t\\t\\t\\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\\n\\t\\t\\t\\t\\t\\tfor ( match in context ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Properties of context are called as methods if possible\\n\\t\\t\\t\\t\\t\\t\\tif ( jQuery.isFunction( this[ match ] ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tthis[ match ]( context[ match ] );\\n\\n\\t\\t\\t\\t\\t\\t\\t// ...and otherwise set as attributes\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tthis.attr( match, context[ match ] );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t\\t// HANDLE: $(#id)\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\telem = document.getElementById( match[ 2 ] );\\n\\n\\t\\t\\t\\t\\tif ( elem ) {\\n\\n\\t\\t\\t\\t\\t\\t// Inject the element directly into the jQuery object\\n\\t\\t\\t\\t\\t\\tthis[ 0 ] = elem;\\n\\t\\t\\t\\t\\t\\tthis.length = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t// HANDLE: $(expr, $(...))\\n\\t\\t\\t} else if ( !context || context.jquery ) {\\n\\t\\t\\t\\treturn ( context || root ).find( selector );\\n\\n\\t\\t\\t// HANDLE: $(expr, context)\\n\\t\\t\\t// (which is just equivalent to: $(context).find(expr)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this.constructor( context ).find( selector );\\n\\t\\t\\t}\\n\\n\\t\\t// HANDLE: $(DOMElement)\\n\\t\\t} else if ( selector.nodeType ) {\\n\\t\\t\\tthis[ 0 ] = selector;\\n\\t\\t\\tthis.length = 1;\\n\\t\\t\\treturn this;\\n\\n\\t\\t// HANDLE: $(function)\\n\\t\\t// Shortcut for document ready\\n\\t\\t} else if ( jQuery.isFunction( selector ) ) {\\n\\t\\t\\treturn root.ready !== undefined ?\\n\\t\\t\\t\\troot.ready( selector ) :\\n\\n\\t\\t\\t\\t// Execute immediately if ready is not present\\n\\t\\t\\t\\tselector( jQuery );\\n\\t\\t}\\n\\n\\t\\treturn jQuery.makeArray( selector, this );\\n\\t};\\n\\n// Give the init function the jQuery prototype for later instantiation\\ninit.prototype = jQuery.fn;\\n\\n// Initialize central reference\\nrootjQuery = jQuery( document );\\n\\n\\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\\n\\n\\t// Methods guaranteed to produce a unique set when starting from a unique set\\n\\tguaranteedUnique = {\\n\\t\\tchildren: true,\\n\\t\\tcontents: true,\\n\\t\\tnext: true,\\n\\t\\tprev: true\\n\\t};\\n\\njQuery.fn.extend( {\\n\\thas: function( target ) {\\n\\t\\tvar targets = jQuery( target, this ),\\n\\t\\t\\tl = targets.length;\\n\\n\\t\\treturn this.filter( function() {\\n\\t\\t\\tvar i = 0;\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tif ( jQuery.contains( this, targets[ i ] ) ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tclosest: function( selectors, context ) {\\n\\t\\tvar cur,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tl = this.length,\\n\\t\\t\\tmatched = [],\\n\\t\\t\\ttargets = typeof selectors !== \\\"string\\\" && jQuery( selectors );\\n\\n\\t\\t// Positional selectors never match, since there's no _selection_ context\\n\\t\\tif ( !rneedsContext.test( selectors ) ) {\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\\n\\n\\t\\t\\t\\t\\t// Always skip document fragments\\n\\t\\t\\t\\t\\tif ( cur.nodeType < 11 && ( targets ?\\n\\t\\t\\t\\t\\t\\ttargets.index( cur ) > -1 :\\n\\n\\t\\t\\t\\t\\t\\t// Don't pass non-elements to Sizzle\\n\\t\\t\\t\\t\\t\\tcur.nodeType === 1 &&\\n\\t\\t\\t\\t\\t\\t\\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\tmatched.push( cur );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\\n\\t},\\n\\n\\t// Determine the position of an element within the set\\n\\tindex: function( elem ) {\\n\\n\\t\\t// No argument, return index in parent\\n\\t\\tif ( !elem ) {\\n\\t\\t\\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\\n\\t\\t}\\n\\n\\t\\t// Index in selector\\n\\t\\tif ( typeof elem === \\\"string\\\" ) {\\n\\t\\t\\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\\n\\t\\t}\\n\\n\\t\\t// Locate the position of the desired element\\n\\t\\treturn indexOf.call( this,\\n\\n\\t\\t\\t// If it receives a jQuery object, the first element is used\\n\\t\\t\\telem.jquery ? elem[ 0 ] : elem\\n\\t\\t);\\n\\t},\\n\\n\\tadd: function( selector, context ) {\\n\\t\\treturn this.pushStack(\\n\\t\\t\\tjQuery.uniqueSort(\\n\\t\\t\\t\\tjQuery.merge( this.get(), jQuery( selector, context ) )\\n\\t\\t\\t)\\n\\t\\t);\\n\\t},\\n\\n\\taddBack: function( selector ) {\\n\\t\\treturn this.add( selector == null ?\\n\\t\\t\\tthis.prevObject : this.prevObject.filter( selector )\\n\\t\\t);\\n\\t}\\n} );\\n\\nfunction sibling( cur, dir ) {\\n\\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\\n\\treturn cur;\\n}\\n\\njQuery.each( {\\n\\tparent: function( elem ) {\\n\\t\\tvar parent = elem.parentNode;\\n\\t\\treturn parent && parent.nodeType !== 11 ? parent : null;\\n\\t},\\n\\tparents: function( elem ) {\\n\\t\\treturn dir( elem, \\\"parentNode\\\" );\\n\\t},\\n\\tparentsUntil: function( elem, i, until ) {\\n\\t\\treturn dir( elem, \\\"parentNode\\\", until );\\n\\t},\\n\\tnext: function( elem ) {\\n\\t\\treturn sibling( elem, \\\"nextSibling\\\" );\\n\\t},\\n\\tprev: function( elem ) {\\n\\t\\treturn sibling( elem, \\\"previousSibling\\\" );\\n\\t},\\n\\tnextAll: function( elem ) {\\n\\t\\treturn dir( elem, \\\"nextSibling\\\" );\\n\\t},\\n\\tprevAll: function( elem ) {\\n\\t\\treturn dir( elem, \\\"previousSibling\\\" );\\n\\t},\\n\\tnextUntil: function( elem, i, until ) {\\n\\t\\treturn dir( elem, \\\"nextSibling\\\", until );\\n\\t},\\n\\tprevUntil: function( elem, i, until ) {\\n\\t\\treturn dir( elem, \\\"previousSibling\\\", until );\\n\\t},\\n\\tsiblings: function( elem ) {\\n\\t\\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\\n\\t},\\n\\tchildren: function( elem ) {\\n\\t\\treturn siblings( elem.firstChild );\\n\\t},\\n\\tcontents: function( elem ) {\\n\\t\\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\\n\\t}\\n}, function( name, fn ) {\\n\\tjQuery.fn[ name ] = function( until, selector ) {\\n\\t\\tvar matched = jQuery.map( this, fn, until );\\n\\n\\t\\tif ( name.slice( -5 ) !== \\\"Until\\\" ) {\\n\\t\\t\\tselector = until;\\n\\t\\t}\\n\\n\\t\\tif ( selector && typeof selector === \\\"string\\\" ) {\\n\\t\\t\\tmatched = jQuery.filter( selector, matched );\\n\\t\\t}\\n\\n\\t\\tif ( this.length > 1 ) {\\n\\n\\t\\t\\t// Remove duplicates\\n\\t\\t\\tif ( !guaranteedUnique[ name ] ) {\\n\\t\\t\\t\\tjQuery.uniqueSort( matched );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Reverse order for parents* and prev-derivatives\\n\\t\\t\\tif ( rparentsprev.test( name ) ) {\\n\\t\\t\\t\\tmatched.reverse();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( matched );\\n\\t};\\n} );\\nvar rnothtmlwhite = ( /[^\\\\x20\\\\t\\\\r\\\\n\\\\f]+/g );\\n\\n\\n\\n// Convert String-formatted options into Object-formatted ones\\nfunction createOptions( options ) {\\n\\tvar object = {};\\n\\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\\n\\t\\tobject[ flag ] = true;\\n\\t} );\\n\\treturn object;\\n}\\n\\n/*\\n * Create a callback list using the following parameters:\\n *\\n *\\toptions: an optional list of space-separated options that will change how\\n *\\t\\t\\tthe callback list behaves or a more traditional option object\\n *\\n * By default a callback list will act like an event callback list and can be\\n * \\\"fired\\\" multiple times.\\n *\\n * Possible options:\\n *\\n *\\tonce:\\t\\t\\twill ensure the callback list can only be fired once (like a Deferred)\\n *\\n *\\tmemory:\\t\\t\\twill keep track of previous values and will call any callback added\\n *\\t\\t\\t\\t\\tafter the list has been fired right away with the latest \\\"memorized\\\"\\n *\\t\\t\\t\\t\\tvalues (like a Deferred)\\n *\\n *\\tunique:\\t\\t\\twill ensure a callback can only be added once (no duplicate in the list)\\n *\\n *\\tstopOnFalse:\\tinterrupt callings when a callback returns false\\n *\\n */\\njQuery.Callbacks = function( options ) {\\n\\n\\t// Convert options from String-formatted to Object-formatted if needed\\n\\t// (we check in cache first)\\n\\toptions = typeof options === \\\"string\\\" ?\\n\\t\\tcreateOptions( options ) :\\n\\t\\tjQuery.extend( {}, options );\\n\\n\\tvar // Flag to know if list is currently firing\\n\\t\\tfiring,\\n\\n\\t\\t// Last fire value for non-forgettable lists\\n\\t\\tmemory,\\n\\n\\t\\t// Flag to know if list was already fired\\n\\t\\tfired,\\n\\n\\t\\t// Flag to prevent firing\\n\\t\\tlocked,\\n\\n\\t\\t// Actual callback list\\n\\t\\tlist = [],\\n\\n\\t\\t// Queue of execution data for repeatable lists\\n\\t\\tqueue = [],\\n\\n\\t\\t// Index of currently firing callback (modified by add/remove as needed)\\n\\t\\tfiringIndex = -1,\\n\\n\\t\\t// Fire callbacks\\n\\t\\tfire = function() {\\n\\n\\t\\t\\t// Enforce single-firing\\n\\t\\t\\tlocked = options.once;\\n\\n\\t\\t\\t// Execute callbacks for all pending executions,\\n\\t\\t\\t// respecting firingIndex overrides and runtime changes\\n\\t\\t\\tfired = firing = true;\\n\\t\\t\\tfor ( ; queue.length; firingIndex = -1 ) {\\n\\t\\t\\t\\tmemory = queue.shift();\\n\\t\\t\\t\\twhile ( ++firingIndex < list.length ) {\\n\\n\\t\\t\\t\\t\\t// Run callback and check for early termination\\n\\t\\t\\t\\t\\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\\n\\t\\t\\t\\t\\t\\toptions.stopOnFalse ) {\\n\\n\\t\\t\\t\\t\\t\\t// Jump to end and forget the data so .add doesn't re-fire\\n\\t\\t\\t\\t\\t\\tfiringIndex = list.length;\\n\\t\\t\\t\\t\\t\\tmemory = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Forget the data if we're done with it\\n\\t\\t\\tif ( !options.memory ) {\\n\\t\\t\\t\\tmemory = false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfiring = false;\\n\\n\\t\\t\\t// Clean up if we're done firing for good\\n\\t\\t\\tif ( locked ) {\\n\\n\\t\\t\\t\\t// Keep an empty list if we have data for future add calls\\n\\t\\t\\t\\tif ( memory ) {\\n\\t\\t\\t\\t\\tlist = [];\\n\\n\\t\\t\\t\\t// Otherwise, this object is spent\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tlist = \\\"\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t// Actual Callbacks object\\n\\t\\tself = {\\n\\n\\t\\t\\t// Add a callback or a collection of callbacks to the list\\n\\t\\t\\tadd: function() {\\n\\t\\t\\t\\tif ( list ) {\\n\\n\\t\\t\\t\\t\\t// If we have memory from a past run, we should fire after adding\\n\\t\\t\\t\\t\\tif ( memory && !firing ) {\\n\\t\\t\\t\\t\\t\\tfiringIndex = list.length - 1;\\n\\t\\t\\t\\t\\t\\tqueue.push( memory );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t( function add( args ) {\\n\\t\\t\\t\\t\\t\\tjQuery.each( args, function( _, arg ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( jQuery.isFunction( arg ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( !options.unique || !self.has( arg ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tlist.push( arg );\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} else if ( arg && arg.length && jQuery.type( arg ) !== \\\"string\\\" ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Inspect recursively\\n\\t\\t\\t\\t\\t\\t\\t\\tadd( arg );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t} )( arguments );\\n\\n\\t\\t\\t\\t\\tif ( memory && !firing ) {\\n\\t\\t\\t\\t\\t\\tfire();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Remove a callback from the list\\n\\t\\t\\tremove: function() {\\n\\t\\t\\t\\tjQuery.each( arguments, function( _, arg ) {\\n\\t\\t\\t\\t\\tvar index;\\n\\t\\t\\t\\t\\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\\n\\t\\t\\t\\t\\t\\tlist.splice( index, 1 );\\n\\n\\t\\t\\t\\t\\t\\t// Handle firing indexes\\n\\t\\t\\t\\t\\t\\tif ( index <= firingIndex ) {\\n\\t\\t\\t\\t\\t\\t\\tfiringIndex--;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Check if a given callback is in the list.\\n\\t\\t\\t// If no argument is given, return whether or not list has callbacks attached.\\n\\t\\t\\thas: function( fn ) {\\n\\t\\t\\t\\treturn fn ?\\n\\t\\t\\t\\t\\tjQuery.inArray( fn, list ) > -1 :\\n\\t\\t\\t\\t\\tlist.length > 0;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Remove all callbacks from the list\\n\\t\\t\\tempty: function() {\\n\\t\\t\\t\\tif ( list ) {\\n\\t\\t\\t\\t\\tlist = [];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Disable .fire and .add\\n\\t\\t\\t// Abort any current/pending executions\\n\\t\\t\\t// Clear all callbacks and values\\n\\t\\t\\tdisable: function() {\\n\\t\\t\\t\\tlocked = queue = [];\\n\\t\\t\\t\\tlist = memory = \\\"\\\";\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\t\\t\\tdisabled: function() {\\n\\t\\t\\t\\treturn !list;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Disable .fire\\n\\t\\t\\t// Also disable .add unless we have memory (since it would have no effect)\\n\\t\\t\\t// Abort any pending executions\\n\\t\\t\\tlock: function() {\\n\\t\\t\\t\\tlocked = queue = [];\\n\\t\\t\\t\\tif ( !memory && !firing ) {\\n\\t\\t\\t\\t\\tlist = memory = \\\"\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\t\\t\\tlocked: function() {\\n\\t\\t\\t\\treturn !!locked;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Call all callbacks with the given context and arguments\\n\\t\\t\\tfireWith: function( context, args ) {\\n\\t\\t\\t\\tif ( !locked ) {\\n\\t\\t\\t\\t\\targs = args || [];\\n\\t\\t\\t\\t\\targs = [ context, args.slice ? args.slice() : args ];\\n\\t\\t\\t\\t\\tqueue.push( args );\\n\\t\\t\\t\\t\\tif ( !firing ) {\\n\\t\\t\\t\\t\\t\\tfire();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Call all the callbacks with the given arguments\\n\\t\\t\\tfire: function() {\\n\\t\\t\\t\\tself.fireWith( this, arguments );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// To know if the callbacks have already been called at least once\\n\\t\\t\\tfired: function() {\\n\\t\\t\\t\\treturn !!fired;\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\treturn self;\\n};\\n\\n\\nfunction Identity( v ) {\\n\\treturn v;\\n}\\nfunction Thrower( ex ) {\\n\\tthrow ex;\\n}\\n\\nfunction adoptValue( value, resolve, reject ) {\\n\\tvar method;\\n\\n\\ttry {\\n\\n\\t\\t// Check for promise aspect first to privilege synchronous behavior\\n\\t\\tif ( value && jQuery.isFunction( ( method = value.promise ) ) ) {\\n\\t\\t\\tmethod.call( value ).done( resolve ).fail( reject );\\n\\n\\t\\t// Other thenables\\n\\t\\t} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {\\n\\t\\t\\tmethod.call( value, resolve, reject );\\n\\n\\t\\t// Other non-thenables\\n\\t\\t} else {\\n\\n\\t\\t\\t// Support: Android 4.0 only\\n\\t\\t\\t// Strict mode functions invoked without .call/.apply get global-object context\\n\\t\\t\\tresolve.call( undefined, value );\\n\\t\\t}\\n\\n\\t// For Promises/A+, convert exceptions into rejections\\n\\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\\n\\t// Deferred#then to conditionally suppress rejection.\\n\\t} catch ( value ) {\\n\\n\\t\\t// Support: Android 4.0 only\\n\\t\\t// Strict mode functions invoked without .call/.apply get global-object context\\n\\t\\treject.call( undefined, value );\\n\\t}\\n}\\n\\njQuery.extend( {\\n\\n\\tDeferred: function( func ) {\\n\\t\\tvar tuples = [\\n\\n\\t\\t\\t\\t// action, add listener, callbacks,\\n\\t\\t\\t\\t// ... .then handlers, argument index, [final state]\\n\\t\\t\\t\\t[ \\\"notify\\\", \\\"progress\\\", jQuery.Callbacks( \\\"memory\\\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \\\"memory\\\" ), 2 ],\\n\\t\\t\\t\\t[ \\\"resolve\\\", \\\"done\\\", jQuery.Callbacks( \\\"once memory\\\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \\\"once memory\\\" ), 0, \\\"resolved\\\" ],\\n\\t\\t\\t\\t[ \\\"reject\\\", \\\"fail\\\", jQuery.Callbacks( \\\"once memory\\\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \\\"once memory\\\" ), 1, \\\"rejected\\\" ]\\n\\t\\t\\t],\\n\\t\\t\\tstate = \\\"pending\\\",\\n\\t\\t\\tpromise = {\\n\\t\\t\\t\\tstate: function() {\\n\\t\\t\\t\\t\\treturn state;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\talways: function() {\\n\\t\\t\\t\\t\\tdeferred.done( arguments ).fail( arguments );\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\\"catch\\\": function( fn ) {\\n\\t\\t\\t\\t\\treturn promise.then( null, fn );\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Keep pipe for back-compat\\n\\t\\t\\t\\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\\n\\t\\t\\t\\t\\tvar fns = arguments;\\n\\n\\t\\t\\t\\t\\treturn jQuery.Deferred( function( newDefer ) {\\n\\t\\t\\t\\t\\t\\tjQuery.each( tuples, function( i, tuple ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\\n\\t\\t\\t\\t\\t\\t\\tvar fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\\n\\n\\t\\t\\t\\t\\t\\t\\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\\n\\t\\t\\t\\t\\t\\t\\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\\n\\t\\t\\t\\t\\t\\t\\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\\n\\t\\t\\t\\t\\t\\t\\tdeferred[ tuple[ 1 ] ]( function() {\\n\\t\\t\\t\\t\\t\\t\\t\\tvar returned = fn && fn.apply( this, arguments );\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( returned && jQuery.isFunction( returned.promise ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturned.promise()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.progress( newDefer.notify )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.done( newDefer.resolve )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.fail( newDefer.reject );\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnewDefer[ tuple[ 0 ] + \\\"With\\\" ](\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthis,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfn ? [ returned ] : arguments\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\tfns = null;\\n\\t\\t\\t\\t\\t} ).promise();\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tthen: function( onFulfilled, onRejected, onProgress ) {\\n\\t\\t\\t\\t\\tvar maxDepth = 0;\\n\\t\\t\\t\\t\\tfunction resolve( depth, deferred, handler, special ) {\\n\\t\\t\\t\\t\\t\\treturn function() {\\n\\t\\t\\t\\t\\t\\t\\tvar that = this,\\n\\t\\t\\t\\t\\t\\t\\t\\targs = arguments,\\n\\t\\t\\t\\t\\t\\t\\t\\tmightThrow = function() {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvar returned, then;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.3\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-59\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Ignore double-resolution attempts\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( depth < maxDepth ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturned = handler.apply( that, args );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-48\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( returned === deferred.promise() ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthrow new TypeError( \\\"Thenable self-resolution\\\" );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ sections 2.3.3.1, 3.5\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-54\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-75\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Retrieve `then` only once\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthen = returned &&\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-64\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only check objects and functions for thenability\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t( typeof returned === \\\"object\\\" ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttypeof returned === \\\"function\\\" ) &&\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned.then;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Handle a returned thenable\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( jQuery.isFunction( then ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Special processors (notify) just wait for resolution\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( special ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthen.call(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Thrower, special )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Normal processors (resolve) also hook into progress\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// ...and disregard older resolution values\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmaxDepth++;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthen.call(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Thrower, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tdeferred.notifyWith )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Handle all other returned values\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only substitute handlers pass on context\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// and multiple values (non-spec behavior)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( handler !== Identity ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthat = undefined;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\targs = [ returned ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Process the value(s)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Default process is resolve\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t( special || deferred.resolveWith )( that, args );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Only normal processors (resolve) catch and reject exceptions\\n\\t\\t\\t\\t\\t\\t\\t\\tprocess = special ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tmightThrow :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmightThrow();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( jQuery.Deferred.exceptionHook ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tjQuery.Deferred.exceptionHook( e,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tprocess.stackTrace );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.4.1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-61\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Ignore post-resolution exceptions\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( depth + 1 >= maxDepth ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only substitute handlers pass on context\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// and multiple values (non-spec behavior)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( handler !== Thrower ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthat = undefined;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\targs = [ e ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tdeferred.rejectWith( that, args );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.1\\n\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-57\\n\\t\\t\\t\\t\\t\\t\\t// Re-resolve promises immediately to dodge false rejection from\\n\\t\\t\\t\\t\\t\\t\\t// subsequent errors\\n\\t\\t\\t\\t\\t\\t\\tif ( depth ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tprocess();\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Call an optional hook to record the stack, in case of exception\\n\\t\\t\\t\\t\\t\\t\\t\\t// since it's otherwise lost when execution goes async\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( jQuery.Deferred.getStackHook ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tprocess.stackTrace = jQuery.Deferred.getStackHook();\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\twindow.setTimeout( process );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn jQuery.Deferred( function( newDefer ) {\\n\\n\\t\\t\\t\\t\\t\\t// progress_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 0 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.isFunction( onProgress ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonProgress :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tIdentity,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer.notifyWith\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t// fulfilled_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 1 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.isFunction( onFulfilled ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonFulfilled :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tIdentity\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t// rejected_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 2 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.isFunction( onRejected ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonRejected :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tThrower\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t} ).promise();\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Get a promise for this deferred\\n\\t\\t\\t\\t// If obj is provided, the promise aspect is added to the object\\n\\t\\t\\t\\tpromise: function( obj ) {\\n\\t\\t\\t\\t\\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tdeferred = {};\\n\\n\\t\\t// Add list-specific methods\\n\\t\\tjQuery.each( tuples, function( i, tuple ) {\\n\\t\\t\\tvar list = tuple[ 2 ],\\n\\t\\t\\t\\tstateString = tuple[ 5 ];\\n\\n\\t\\t\\t// promise.progress = list.add\\n\\t\\t\\t// promise.done = list.add\\n\\t\\t\\t// promise.fail = list.add\\n\\t\\t\\tpromise[ tuple[ 1 ] ] = list.add;\\n\\n\\t\\t\\t// Handle state\\n\\t\\t\\tif ( stateString ) {\\n\\t\\t\\t\\tlist.add(\\n\\t\\t\\t\\t\\tfunction() {\\n\\n\\t\\t\\t\\t\\t\\t// state = \\\"resolved\\\" (i.e., fulfilled)\\n\\t\\t\\t\\t\\t\\t// state = \\\"rejected\\\"\\n\\t\\t\\t\\t\\t\\tstate = stateString;\\n\\t\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t\\t// rejected_callbacks.disable\\n\\t\\t\\t\\t\\t// fulfilled_callbacks.disable\\n\\t\\t\\t\\t\\ttuples[ 3 - i ][ 2 ].disable,\\n\\n\\t\\t\\t\\t\\t// progress_callbacks.lock\\n\\t\\t\\t\\t\\ttuples[ 0 ][ 2 ].lock\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// progress_handlers.fire\\n\\t\\t\\t// fulfilled_handlers.fire\\n\\t\\t\\t// rejected_handlers.fire\\n\\t\\t\\tlist.add( tuple[ 3 ].fire );\\n\\n\\t\\t\\t// deferred.notify = function() { deferred.notifyWith(...) }\\n\\t\\t\\t// deferred.resolve = function() { deferred.resolveWith(...) }\\n\\t\\t\\t// deferred.reject = function() { deferred.rejectWith(...) }\\n\\t\\t\\tdeferred[ tuple[ 0 ] ] = function() {\\n\\t\\t\\t\\tdeferred[ tuple[ 0 ] + \\\"With\\\" ]( this === deferred ? undefined : this, arguments );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t};\\n\\n\\t\\t\\t// deferred.notifyWith = list.fireWith\\n\\t\\t\\t// deferred.resolveWith = list.fireWith\\n\\t\\t\\t// deferred.rejectWith = list.fireWith\\n\\t\\t\\tdeferred[ tuple[ 0 ] + \\\"With\\\" ] = list.fireWith;\\n\\t\\t} );\\n\\n\\t\\t// Make the deferred a promise\\n\\t\\tpromise.promise( deferred );\\n\\n\\t\\t// Call given func if any\\n\\t\\tif ( func ) {\\n\\t\\t\\tfunc.call( deferred, deferred );\\n\\t\\t}\\n\\n\\t\\t// All done!\\n\\t\\treturn deferred;\\n\\t},\\n\\n\\t// Deferred helper\\n\\twhen: function( singleValue ) {\\n\\t\\tvar\\n\\n\\t\\t\\t// count of uncompleted subordinates\\n\\t\\t\\tremaining = arguments.length,\\n\\n\\t\\t\\t// count of unprocessed arguments\\n\\t\\t\\ti = remaining,\\n\\n\\t\\t\\t// subordinate fulfillment data\\n\\t\\t\\tresolveContexts = Array( i ),\\n\\t\\t\\tresolveValues = slice.call( arguments ),\\n\\n\\t\\t\\t// the master Deferred\\n\\t\\t\\tmaster = jQuery.Deferred(),\\n\\n\\t\\t\\t// subordinate callback factory\\n\\t\\t\\tupdateFunc = function( i ) {\\n\\t\\t\\t\\treturn function( value ) {\\n\\t\\t\\t\\t\\tresolveContexts[ i ] = this;\\n\\t\\t\\t\\t\\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\\n\\t\\t\\t\\t\\tif ( !( --remaining ) ) {\\n\\t\\t\\t\\t\\t\\tmaster.resolveWith( resolveContexts, resolveValues );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\t\\t\\t};\\n\\n\\t\\t// Single- and empty arguments are adopted like Promise.resolve\\n\\t\\tif ( remaining <= 1 ) {\\n\\t\\t\\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );\\n\\n\\t\\t\\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\\n\\t\\t\\tif ( master.state() === \\\"pending\\\" ||\\n\\t\\t\\t\\tjQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\\n\\n\\t\\t\\t\\treturn master.then();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Multiple arguments are aggregated like Promise.all array elements\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\\n\\t\\t}\\n\\n\\t\\treturn master.promise();\\n\\t}\\n} );\\n\\n\\n// These usually indicate a programmer mistake during development,\\n// warn about them ASAP rather than swallowing them by default.\\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\\n\\njQuery.Deferred.exceptionHook = function( error, stack ) {\\n\\n\\t// Support: IE 8 - 9 only\\n\\t// Console exists when dev tools are open, which can happen at any time\\n\\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\\n\\t\\twindow.console.warn( \\\"jQuery.Deferred exception: \\\" + error.message, error.stack, stack );\\n\\t}\\n};\\n\\n\\n\\n\\njQuery.readyException = function( error ) {\\n\\twindow.setTimeout( function() {\\n\\t\\tthrow error;\\n\\t} );\\n};\\n\\n\\n\\n\\n// The deferred used on DOM ready\\nvar readyList = jQuery.Deferred();\\n\\njQuery.fn.ready = function( fn ) {\\n\\n\\treadyList\\n\\t\\t.then( fn )\\n\\n\\t\\t// Wrap jQuery.readyException in a function so that the lookup\\n\\t\\t// happens at the time of error handling instead of callback\\n\\t\\t// registration.\\n\\t\\t.catch( function( error ) {\\n\\t\\t\\tjQuery.readyException( error );\\n\\t\\t} );\\n\\n\\treturn this;\\n};\\n\\njQuery.extend( {\\n\\n\\t// Is the DOM ready to be used? Set to true once it occurs.\\n\\tisReady: false,\\n\\n\\t// A counter to track how many items to wait for before\\n\\t// the ready event fires. See #6781\\n\\treadyWait: 1,\\n\\n\\t// Hold (or release) the ready event\\n\\tholdReady: function( hold ) {\\n\\t\\tif ( hold ) {\\n\\t\\t\\tjQuery.readyWait++;\\n\\t\\t} else {\\n\\t\\t\\tjQuery.ready( true );\\n\\t\\t}\\n\\t},\\n\\n\\t// Handle when the DOM is ready\\n\\tready: function( wait ) {\\n\\n\\t\\t// Abort if there are pending holds or we're already ready\\n\\t\\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Remember that the DOM is ready\\n\\t\\tjQuery.isReady = true;\\n\\n\\t\\t// If a normal DOM Ready event fired, decrement, and wait if need be\\n\\t\\tif ( wait !== true && --jQuery.readyWait > 0 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// If there are functions bound, to execute\\n\\t\\treadyList.resolveWith( document, [ jQuery ] );\\n\\t}\\n} );\\n\\njQuery.ready.then = readyList.then;\\n\\n// The ready event handler and self cleanup method\\nfunction completed() {\\n\\tdocument.removeEventListener( \\\"DOMContentLoaded\\\", completed );\\n\\twindow.removeEventListener( \\\"load\\\", completed );\\n\\tjQuery.ready();\\n}\\n\\n// Catch cases where $(document).ready() is called\\n// after the browser event has already occurred.\\n// Support: IE <=9 - 10 only\\n// Older IE sometimes signals \\\"interactive\\\" too soon\\nif ( document.readyState === \\\"complete\\\" ||\\n\\t( document.readyState !== \\\"loading\\\" && !document.documentElement.doScroll ) ) {\\n\\n\\t// Handle it asynchronously to allow scripts the opportunity to delay ready\\n\\twindow.setTimeout( jQuery.ready );\\n\\n} else {\\n\\n\\t// Use the handy event callback\\n\\tdocument.addEventListener( \\\"DOMContentLoaded\\\", completed );\\n\\n\\t// A fallback to window.onload, that will always work\\n\\twindow.addEventListener( \\\"load\\\", completed );\\n}\\n\\n\\n\\n\\n// Multifunctional method to get and set values of a collection\\n// The value/s can optionally be executed if it's a function\\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\\n\\tvar i = 0,\\n\\t\\tlen = elems.length,\\n\\t\\tbulk = key == null;\\n\\n\\t// Sets many values\\n\\tif ( jQuery.type( key ) === \\\"object\\\" ) {\\n\\t\\tchainable = true;\\n\\t\\tfor ( i in key ) {\\n\\t\\t\\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\\n\\t\\t}\\n\\n\\t// Sets one value\\n\\t} else if ( value !== undefined ) {\\n\\t\\tchainable = true;\\n\\n\\t\\tif ( !jQuery.isFunction( value ) ) {\\n\\t\\t\\traw = true;\\n\\t\\t}\\n\\n\\t\\tif ( bulk ) {\\n\\n\\t\\t\\t// Bulk operations run against the entire set\\n\\t\\t\\tif ( raw ) {\\n\\t\\t\\t\\tfn.call( elems, value );\\n\\t\\t\\t\\tfn = null;\\n\\n\\t\\t\\t// ...except when executing function values\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbulk = fn;\\n\\t\\t\\t\\tfn = function( elem, key, value ) {\\n\\t\\t\\t\\t\\treturn bulk.call( jQuery( elem ), value );\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( fn ) {\\n\\t\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\t\\tfn(\\n\\t\\t\\t\\t\\telems[ i ], key, raw ?\\n\\t\\t\\t\\t\\tvalue :\\n\\t\\t\\t\\t\\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif ( chainable ) {\\n\\t\\treturn elems;\\n\\t}\\n\\n\\t// Gets\\n\\tif ( bulk ) {\\n\\t\\treturn fn.call( elems );\\n\\t}\\n\\n\\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\\n};\\nvar acceptData = function( owner ) {\\n\\n\\t// Accepts only:\\n\\t//  - Node\\n\\t//    - Node.ELEMENT_NODE\\n\\t//    - Node.DOCUMENT_NODE\\n\\t//  - Object\\n\\t//    - Any\\n\\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\\n};\\n\\n\\n\\n\\nfunction Data() {\\n\\tthis.expando = jQuery.expando + Data.uid++;\\n}\\n\\nData.uid = 1;\\n\\nData.prototype = {\\n\\n\\tcache: function( owner ) {\\n\\n\\t\\t// Check if the owner object already has a cache\\n\\t\\tvar value = owner[ this.expando ];\\n\\n\\t\\t// If not, create one\\n\\t\\tif ( !value ) {\\n\\t\\t\\tvalue = {};\\n\\n\\t\\t\\t// We can accept data for non-element nodes in modern browsers,\\n\\t\\t\\t// but we should not, see #8335.\\n\\t\\t\\t// Always return an empty object.\\n\\t\\t\\tif ( acceptData( owner ) ) {\\n\\n\\t\\t\\t\\t// If it is a node unlikely to be stringify-ed or looped over\\n\\t\\t\\t\\t// use plain assignment\\n\\t\\t\\t\\tif ( owner.nodeType ) {\\n\\t\\t\\t\\t\\towner[ this.expando ] = value;\\n\\n\\t\\t\\t\\t// Otherwise secure it in a non-enumerable property\\n\\t\\t\\t\\t// configurable must be true to allow the property to be\\n\\t\\t\\t\\t// deleted when data is removed\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tObject.defineProperty( owner, this.expando, {\\n\\t\\t\\t\\t\\t\\tvalue: value,\\n\\t\\t\\t\\t\\t\\tconfigurable: true\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn value;\\n\\t},\\n\\tset: function( owner, data, value ) {\\n\\t\\tvar prop,\\n\\t\\t\\tcache = this.cache( owner );\\n\\n\\t\\t// Handle: [ owner, key, value ] args\\n\\t\\t// Always use camelCase key (gh-2257)\\n\\t\\tif ( typeof data === \\\"string\\\" ) {\\n\\t\\t\\tcache[ jQuery.camelCase( data ) ] = value;\\n\\n\\t\\t// Handle: [ owner, { properties } ] args\\n\\t\\t} else {\\n\\n\\t\\t\\t// Copy the properties one-by-one to the cache object\\n\\t\\t\\tfor ( prop in data ) {\\n\\t\\t\\t\\tcache[ jQuery.camelCase( prop ) ] = data[ prop ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cache;\\n\\t},\\n\\tget: function( owner, key ) {\\n\\t\\treturn key === undefined ?\\n\\t\\t\\tthis.cache( owner ) :\\n\\n\\t\\t\\t// Always use camelCase key (gh-2257)\\n\\t\\t\\towner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];\\n\\t},\\n\\taccess: function( owner, key, value ) {\\n\\n\\t\\t// In cases where either:\\n\\t\\t//\\n\\t\\t//   1. No key was specified\\n\\t\\t//   2. A string key was specified, but no value provided\\n\\t\\t//\\n\\t\\t// Take the \\\"read\\\" path and allow the get method to determine\\n\\t\\t// which value to return, respectively either:\\n\\t\\t//\\n\\t\\t//   1. The entire cache object\\n\\t\\t//   2. The data stored at the key\\n\\t\\t//\\n\\t\\tif ( key === undefined ||\\n\\t\\t\\t\\t( ( key && typeof key === \\\"string\\\" ) && value === undefined ) ) {\\n\\n\\t\\t\\treturn this.get( owner, key );\\n\\t\\t}\\n\\n\\t\\t// When the key is not a string, or both a key and value\\n\\t\\t// are specified, set or extend (existing objects) with either:\\n\\t\\t//\\n\\t\\t//   1. An object of properties\\n\\t\\t//   2. A key and value\\n\\t\\t//\\n\\t\\tthis.set( owner, key, value );\\n\\n\\t\\t// Since the \\\"set\\\" path can have two possible entry points\\n\\t\\t// return the expected data based on which path was taken[*]\\n\\t\\treturn value !== undefined ? value : key;\\n\\t},\\n\\tremove: function( owner, key ) {\\n\\t\\tvar i,\\n\\t\\t\\tcache = owner[ this.expando ];\\n\\n\\t\\tif ( cache === undefined ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( key !== undefined ) {\\n\\n\\t\\t\\t// Support array or space separated string of keys\\n\\t\\t\\tif ( jQuery.isArray( key ) ) {\\n\\n\\t\\t\\t\\t// If key is an array of keys...\\n\\t\\t\\t\\t// We always set camelCase keys, so remove that.\\n\\t\\t\\t\\tkey = key.map( jQuery.camelCase );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tkey = jQuery.camelCase( key );\\n\\n\\t\\t\\t\\t// If a key with the spaces exists, use it.\\n\\t\\t\\t\\t// Otherwise, create an array by matching non-whitespace\\n\\t\\t\\t\\tkey = key in cache ?\\n\\t\\t\\t\\t\\t[ key ] :\\n\\t\\t\\t\\t\\t( key.match( rnothtmlwhite ) || [] );\\n\\t\\t\\t}\\n\\n\\t\\t\\ti = key.length;\\n\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tdelete cache[ key[ i ] ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Remove the expando if there's no more data\\n\\t\\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\\n\\n\\t\\t\\t// Support: Chrome <=35 - 45\\n\\t\\t\\t// Webkit & Blink performance suffers when deleting properties\\n\\t\\t\\t// from DOM nodes, so set to undefined instead\\n\\t\\t\\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\\n\\t\\t\\tif ( owner.nodeType ) {\\n\\t\\t\\t\\towner[ this.expando ] = undefined;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdelete owner[ this.expando ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\thasData: function( owner ) {\\n\\t\\tvar cache = owner[ this.expando ];\\n\\t\\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\\n\\t}\\n};\\nvar dataPriv = new Data();\\n\\nvar dataUser = new Data();\\n\\n\\n\\n//\\tImplementation Summary\\n//\\n//\\t1. Enforce API surface and semantic compatibility with 1.9.x branch\\n//\\t2. Improve the module's maintainability by reducing the storage\\n//\\t\\tpaths to a single mechanism.\\n//\\t3. Use the same single mechanism to support \\\"private\\\" and \\\"user\\\" data.\\n//\\t4. _Never_ expose \\\"private\\\" data to user code (TODO: Drop _data, _removeData)\\n//\\t5. Avoid exposing implementation details on user objects (eg. expando properties)\\n//\\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\\n\\nvar rbrace = /^(?:\\\\{[\\\\w\\\\W]*\\\\}|\\\\[[\\\\w\\\\W]*\\\\])$/,\\n\\trmultiDash = /[A-Z]/g;\\n\\nfunction getData( data ) {\\n\\tif ( data === \\\"true\\\" ) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif ( data === \\\"false\\\" ) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif ( data === \\\"null\\\" ) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// Only convert to a number if it doesn't change the string\\n\\tif ( data === +data + \\\"\\\" ) {\\n\\t\\treturn +data;\\n\\t}\\n\\n\\tif ( rbrace.test( data ) ) {\\n\\t\\treturn JSON.parse( data );\\n\\t}\\n\\n\\treturn data;\\n}\\n\\nfunction dataAttr( elem, key, data ) {\\n\\tvar name;\\n\\n\\t// If nothing was found internally, try to fetch any\\n\\t// data from the HTML5 data-* attribute\\n\\tif ( data === undefined && elem.nodeType === 1 ) {\\n\\t\\tname = \\\"data-\\\" + key.replace( rmultiDash, \\\"-$&\\\" ).toLowerCase();\\n\\t\\tdata = elem.getAttribute( name );\\n\\n\\t\\tif ( typeof data === \\\"string\\\" ) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tdata = getData( data );\\n\\t\\t\\t} catch ( e ) {}\\n\\n\\t\\t\\t// Make sure we set the data so it isn't changed later\\n\\t\\t\\tdataUser.set( elem, key, data );\\n\\t\\t} else {\\n\\t\\t\\tdata = undefined;\\n\\t\\t}\\n\\t}\\n\\treturn data;\\n}\\n\\njQuery.extend( {\\n\\thasData: function( elem ) {\\n\\t\\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\\n\\t},\\n\\n\\tdata: function( elem, name, data ) {\\n\\t\\treturn dataUser.access( elem, name, data );\\n\\t},\\n\\n\\tremoveData: function( elem, name ) {\\n\\t\\tdataUser.remove( elem, name );\\n\\t},\\n\\n\\t// TODO: Now that all calls to _data and _removeData have been replaced\\n\\t// with direct calls to dataPriv methods, these can be deprecated.\\n\\t_data: function( elem, name, data ) {\\n\\t\\treturn dataPriv.access( elem, name, data );\\n\\t},\\n\\n\\t_removeData: function( elem, name ) {\\n\\t\\tdataPriv.remove( elem, name );\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tdata: function( key, value ) {\\n\\t\\tvar i, name, data,\\n\\t\\t\\telem = this[ 0 ],\\n\\t\\t\\tattrs = elem && elem.attributes;\\n\\n\\t\\t// Gets all values\\n\\t\\tif ( key === undefined ) {\\n\\t\\t\\tif ( this.length ) {\\n\\t\\t\\t\\tdata = dataUser.get( elem );\\n\\n\\t\\t\\t\\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \\\"hasDataAttrs\\\" ) ) {\\n\\t\\t\\t\\t\\ti = attrs.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE 11 only\\n\\t\\t\\t\\t\\t\\t// The attrs elements can be null (#14894)\\n\\t\\t\\t\\t\\t\\tif ( attrs[ i ] ) {\\n\\t\\t\\t\\t\\t\\t\\tname = attrs[ i ].name;\\n\\t\\t\\t\\t\\t\\t\\tif ( name.indexOf( \\\"data-\\\" ) === 0 ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tname = jQuery.camelCase( name.slice( 5 ) );\\n\\t\\t\\t\\t\\t\\t\\t\\tdataAttr( elem, name, data[ name ] );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdataPriv.set( elem, \\\"hasDataAttrs\\\", true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\t\\t}\\n\\n\\t\\t// Sets multiple values\\n\\t\\tif ( typeof key === \\\"object\\\" ) {\\n\\t\\t\\treturn this.each( function() {\\n\\t\\t\\t\\tdataUser.set( this, key );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\tvar data;\\n\\n\\t\\t\\t// The calling jQuery object (element matches) is not empty\\n\\t\\t\\t// (and therefore has an element appears at this[ 0 ]) and the\\n\\t\\t\\t// `value` parameter was not undefined. An empty jQuery object\\n\\t\\t\\t// will result in `undefined` for elem = this[ 0 ] which will\\n\\t\\t\\t// throw an exception if an attempt to read a data cache is made.\\n\\t\\t\\tif ( elem && value === undefined ) {\\n\\n\\t\\t\\t\\t// Attempt to get data from the cache\\n\\t\\t\\t\\t// The key will always be camelCased in Data\\n\\t\\t\\t\\tdata = dataUser.get( elem, key );\\n\\t\\t\\t\\tif ( data !== undefined ) {\\n\\t\\t\\t\\t\\treturn data;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Attempt to \\\"discover\\\" the data in\\n\\t\\t\\t\\t// HTML5 custom data-* attrs\\n\\t\\t\\t\\tdata = dataAttr( elem, key );\\n\\t\\t\\t\\tif ( data !== undefined ) {\\n\\t\\t\\t\\t\\treturn data;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// We tried really hard, but the data doesn't exist.\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set the data...\\n\\t\\t\\tthis.each( function() {\\n\\n\\t\\t\\t\\t// We always store the camelCased key\\n\\t\\t\\t\\tdataUser.set( this, key, value );\\n\\t\\t\\t} );\\n\\t\\t}, null, value, arguments.length > 1, null, true );\\n\\t},\\n\\n\\tremoveData: function( key ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tdataUser.remove( this, key );\\n\\t\\t} );\\n\\t}\\n} );\\n\\n\\njQuery.extend( {\\n\\tqueue: function( elem, type, data ) {\\n\\t\\tvar queue;\\n\\n\\t\\tif ( elem ) {\\n\\t\\t\\ttype = ( type || \\\"fx\\\" ) + \\\"queue\\\";\\n\\t\\t\\tqueue = dataPriv.get( elem, type );\\n\\n\\t\\t\\t// Speed up dequeue by getting out quickly if this is just a lookup\\n\\t\\t\\tif ( data ) {\\n\\t\\t\\t\\tif ( !queue || jQuery.isArray( data ) ) {\\n\\t\\t\\t\\t\\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tqueue.push( data );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn queue || [];\\n\\t\\t}\\n\\t},\\n\\n\\tdequeue: function( elem, type ) {\\n\\t\\ttype = type || \\\"fx\\\";\\n\\n\\t\\tvar queue = jQuery.queue( elem, type ),\\n\\t\\t\\tstartLength = queue.length,\\n\\t\\t\\tfn = queue.shift(),\\n\\t\\t\\thooks = jQuery._queueHooks( elem, type ),\\n\\t\\t\\tnext = function() {\\n\\t\\t\\t\\tjQuery.dequeue( elem, type );\\n\\t\\t\\t};\\n\\n\\t\\t// If the fx queue is dequeued, always remove the progress sentinel\\n\\t\\tif ( fn === \\\"inprogress\\\" ) {\\n\\t\\t\\tfn = queue.shift();\\n\\t\\t\\tstartLength--;\\n\\t\\t}\\n\\n\\t\\tif ( fn ) {\\n\\n\\t\\t\\t// Add a progress sentinel to prevent the fx queue from being\\n\\t\\t\\t// automatically dequeued\\n\\t\\t\\tif ( type === \\\"fx\\\" ) {\\n\\t\\t\\t\\tqueue.unshift( \\\"inprogress\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Clear up the last queue stop function\\n\\t\\t\\tdelete hooks.stop;\\n\\t\\t\\tfn.call( elem, next, hooks );\\n\\t\\t}\\n\\n\\t\\tif ( !startLength && hooks ) {\\n\\t\\t\\thooks.empty.fire();\\n\\t\\t}\\n\\t},\\n\\n\\t// Not public - generate a queueHooks object, or return the current one\\n\\t_queueHooks: function( elem, type ) {\\n\\t\\tvar key = type + \\\"queueHooks\\\";\\n\\t\\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\\n\\t\\t\\tempty: jQuery.Callbacks( \\\"once memory\\\" ).add( function() {\\n\\t\\t\\t\\tdataPriv.remove( elem, [ type + \\\"queue\\\", key ] );\\n\\t\\t\\t} )\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tqueue: function( type, data ) {\\n\\t\\tvar setter = 2;\\n\\n\\t\\tif ( typeof type !== \\\"string\\\" ) {\\n\\t\\t\\tdata = type;\\n\\t\\t\\ttype = \\\"fx\\\";\\n\\t\\t\\tsetter--;\\n\\t\\t}\\n\\n\\t\\tif ( arguments.length < setter ) {\\n\\t\\t\\treturn jQuery.queue( this[ 0 ], type );\\n\\t\\t}\\n\\n\\t\\treturn data === undefined ?\\n\\t\\t\\tthis :\\n\\t\\t\\tthis.each( function() {\\n\\t\\t\\t\\tvar queue = jQuery.queue( this, type, data );\\n\\n\\t\\t\\t\\t// Ensure a hooks for this queue\\n\\t\\t\\t\\tjQuery._queueHooks( this, type );\\n\\n\\t\\t\\t\\tif ( type === \\\"fx\\\" && queue[ 0 ] !== \\\"inprogress\\\" ) {\\n\\t\\t\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t},\\n\\tdequeue: function( type ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t} );\\n\\t},\\n\\tclearQueue: function( type ) {\\n\\t\\treturn this.queue( type || \\\"fx\\\", [] );\\n\\t},\\n\\n\\t// Get a promise resolved when queues of a certain type\\n\\t// are emptied (fx is the type by default)\\n\\tpromise: function( type, obj ) {\\n\\t\\tvar tmp,\\n\\t\\t\\tcount = 1,\\n\\t\\t\\tdefer = jQuery.Deferred(),\\n\\t\\t\\telements = this,\\n\\t\\t\\ti = this.length,\\n\\t\\t\\tresolve = function() {\\n\\t\\t\\t\\tif ( !( --count ) ) {\\n\\t\\t\\t\\t\\tdefer.resolveWith( elements, [ elements ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\tif ( typeof type !== \\\"string\\\" ) {\\n\\t\\t\\tobj = type;\\n\\t\\t\\ttype = undefined;\\n\\t\\t}\\n\\t\\ttype = type || \\\"fx\\\";\\n\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\ttmp = dataPriv.get( elements[ i ], type + \\\"queueHooks\\\" );\\n\\t\\t\\tif ( tmp && tmp.empty ) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\ttmp.empty.add( resolve );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresolve();\\n\\t\\treturn defer.promise( obj );\\n\\t}\\n} );\\nvar pnum = ( /[+-]?(?:\\\\d*\\\\.|)\\\\d+(?:[eE][+-]?\\\\d+|)/ ).source;\\n\\nvar rcssNum = new RegExp( \\\"^(?:([+-])=|)(\\\" + pnum + \\\")([a-z%]*)$\\\", \\\"i\\\" );\\n\\n\\nvar cssExpand = [ \\\"Top\\\", \\\"Right\\\", \\\"Bottom\\\", \\\"Left\\\" ];\\n\\nvar isHiddenWithinTree = function( elem, el ) {\\n\\n\\t\\t// isHiddenWithinTree might be called from jQuery#filter function;\\n\\t\\t// in that case, element will be second argument\\n\\t\\telem = el || elem;\\n\\n\\t\\t// Inline style trumps all\\n\\t\\treturn elem.style.display === \\\"none\\\" ||\\n\\t\\t\\telem.style.display === \\\"\\\" &&\\n\\n\\t\\t\\t// Otherwise, check computed style\\n\\t\\t\\t// Support: Firefox <=43 - 45\\n\\t\\t\\t// Disconnected elements can have computed display: none, so first confirm that elem is\\n\\t\\t\\t// in the document.\\n\\t\\t\\tjQuery.contains( elem.ownerDocument, elem ) &&\\n\\n\\t\\t\\tjQuery.css( elem, \\\"display\\\" ) === \\\"none\\\";\\n\\t};\\n\\nvar swap = function( elem, options, callback, args ) {\\n\\tvar ret, name,\\n\\t\\told = {};\\n\\n\\t// Remember the old values, and insert the new ones\\n\\tfor ( name in options ) {\\n\\t\\told[ name ] = elem.style[ name ];\\n\\t\\telem.style[ name ] = options[ name ];\\n\\t}\\n\\n\\tret = callback.apply( elem, args || [] );\\n\\n\\t// Revert the old values\\n\\tfor ( name in options ) {\\n\\t\\telem.style[ name ] = old[ name ];\\n\\t}\\n\\n\\treturn ret;\\n};\\n\\n\\n\\n\\nfunction adjustCSS( elem, prop, valueParts, tween ) {\\n\\tvar adjusted,\\n\\t\\tscale = 1,\\n\\t\\tmaxIterations = 20,\\n\\t\\tcurrentValue = tween ?\\n\\t\\t\\tfunction() {\\n\\t\\t\\t\\treturn tween.cur();\\n\\t\\t\\t} :\\n\\t\\t\\tfunction() {\\n\\t\\t\\t\\treturn jQuery.css( elem, prop, \\\"\\\" );\\n\\t\\t\\t},\\n\\t\\tinitial = currentValue(),\\n\\t\\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \\\"\\\" : \\\"px\\\" ),\\n\\n\\t\\t// Starting value computation is required for potential unit mismatches\\n\\t\\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \\\"px\\\" && +initial ) &&\\n\\t\\t\\trcssNum.exec( jQuery.css( elem, prop ) );\\n\\n\\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\\n\\n\\t\\t// Trust units reported by jQuery.css\\n\\t\\tunit = unit || initialInUnit[ 3 ];\\n\\n\\t\\t// Make sure we update the tween properties later on\\n\\t\\tvalueParts = valueParts || [];\\n\\n\\t\\t// Iteratively approximate from a nonzero starting point\\n\\t\\tinitialInUnit = +initial || 1;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\t// If previous iteration zeroed out, double until we get *something*.\\n\\t\\t\\t// Use string for doubling so we don't accidentally see scale as unchanged below\\n\\t\\t\\tscale = scale || \\\".5\\\";\\n\\n\\t\\t\\t// Adjust and apply\\n\\t\\t\\tinitialInUnit = initialInUnit / scale;\\n\\t\\t\\tjQuery.style( elem, prop, initialInUnit + unit );\\n\\n\\t\\t// Update scale, tolerating zero or NaN from tween.cur()\\n\\t\\t// Break the loop if scale is unchanged or perfect, or if we've just had enough.\\n\\t\\t} while (\\n\\t\\t\\tscale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\\n\\t\\t);\\n\\t}\\n\\n\\tif ( valueParts ) {\\n\\t\\tinitialInUnit = +initialInUnit || +initial || 0;\\n\\n\\t\\t// Apply relative offset (+=/-=) if specified\\n\\t\\tadjusted = valueParts[ 1 ] ?\\n\\t\\t\\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\\n\\t\\t\\t+valueParts[ 2 ];\\n\\t\\tif ( tween ) {\\n\\t\\t\\ttween.unit = unit;\\n\\t\\t\\ttween.start = initialInUnit;\\n\\t\\t\\ttween.end = adjusted;\\n\\t\\t}\\n\\t}\\n\\treturn adjusted;\\n}\\n\\n\\nvar defaultDisplayMap = {};\\n\\nfunction getDefaultDisplay( elem ) {\\n\\tvar temp,\\n\\t\\tdoc = elem.ownerDocument,\\n\\t\\tnodeName = elem.nodeName,\\n\\t\\tdisplay = defaultDisplayMap[ nodeName ];\\n\\n\\tif ( display ) {\\n\\t\\treturn display;\\n\\t}\\n\\n\\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\\n\\tdisplay = jQuery.css( temp, \\\"display\\\" );\\n\\n\\ttemp.parentNode.removeChild( temp );\\n\\n\\tif ( display === \\\"none\\\" ) {\\n\\t\\tdisplay = \\\"block\\\";\\n\\t}\\n\\tdefaultDisplayMap[ nodeName ] = display;\\n\\n\\treturn display;\\n}\\n\\nfunction showHide( elements, show ) {\\n\\tvar display, elem,\\n\\t\\tvalues = [],\\n\\t\\tindex = 0,\\n\\t\\tlength = elements.length;\\n\\n\\t// Determine new display value for elements that need to change\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\telem = elements[ index ];\\n\\t\\tif ( !elem.style ) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tdisplay = elem.style.display;\\n\\t\\tif ( show ) {\\n\\n\\t\\t\\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\\n\\t\\t\\t// check is required in this first loop unless we have a nonempty display value (either\\n\\t\\t\\t// inline or about-to-be-restored)\\n\\t\\t\\tif ( display === \\\"none\\\" ) {\\n\\t\\t\\t\\tvalues[ index ] = dataPriv.get( elem, \\\"display\\\" ) || null;\\n\\t\\t\\t\\tif ( !values[ index ] ) {\\n\\t\\t\\t\\t\\telem.style.display = \\\"\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif ( elem.style.display === \\\"\\\" && isHiddenWithinTree( elem ) ) {\\n\\t\\t\\t\\tvalues[ index ] = getDefaultDisplay( elem );\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif ( display !== \\\"none\\\" ) {\\n\\t\\t\\t\\tvalues[ index ] = \\\"none\\\";\\n\\n\\t\\t\\t\\t// Remember what we're overwriting\\n\\t\\t\\t\\tdataPriv.set( elem, \\\"display\\\", display );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Set the display of the elements in a second loop to avoid constant reflow\\n\\tfor ( index = 0; index < length; index++ ) {\\n\\t\\tif ( values[ index ] != null ) {\\n\\t\\t\\telements[ index ].style.display = values[ index ];\\n\\t\\t}\\n\\t}\\n\\n\\treturn elements;\\n}\\n\\njQuery.fn.extend( {\\n\\tshow: function() {\\n\\t\\treturn showHide( this, true );\\n\\t},\\n\\thide: function() {\\n\\t\\treturn showHide( this );\\n\\t},\\n\\ttoggle: function( state ) {\\n\\t\\tif ( typeof state === \\\"boolean\\\" ) {\\n\\t\\t\\treturn state ? this.show() : this.hide();\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tif ( isHiddenWithinTree( this ) ) {\\n\\t\\t\\t\\tjQuery( this ).show();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tjQuery( this ).hide();\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t}\\n} );\\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\\n\\nvar rtagName = ( /<([a-z][^\\\\/\\\\0>\\\\x20\\\\t\\\\r\\\\n\\\\f]+)/i );\\n\\nvar rscriptType = ( /^$|\\\\/(?:java|ecma)script/i );\\n\\n\\n\\n// We have to close these tags to support XHTML (#13200)\\nvar wrapMap = {\\n\\n\\t// Support: IE <=9 only\\n\\toption: [ 1, \\\"<select multiple='multiple'>\\\", \\\"</select>\\\" ],\\n\\n\\t// XHTML parsers do not magically insert elements in the\\n\\t// same way that tag soup parsers do. So we cannot shorten\\n\\t// this by omitting <tbody> or other required elements.\\n\\tthead: [ 1, \\\"<table>\\\", \\\"</table>\\\" ],\\n\\tcol: [ 2, \\\"<table><colgroup>\\\", \\\"</colgroup></table>\\\" ],\\n\\ttr: [ 2, \\\"<table><tbody>\\\", \\\"</tbody></table>\\\" ],\\n\\ttd: [ 3, \\\"<table><tbody><tr>\\\", \\\"</tr></tbody></table>\\\" ],\\n\\n\\t_default: [ 0, \\\"\\\", \\\"\\\" ]\\n};\\n\\n// Support: IE <=9 only\\nwrapMap.optgroup = wrapMap.option;\\n\\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\\nwrapMap.th = wrapMap.td;\\n\\n\\nfunction getAll( context, tag ) {\\n\\n\\t// Support: IE <=9 - 11 only\\n\\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\\n\\tvar ret;\\n\\n\\tif ( typeof context.getElementsByTagName !== \\\"undefined\\\" ) {\\n\\t\\tret = context.getElementsByTagName( tag || \\\"*\\\" );\\n\\n\\t} else if ( typeof context.querySelectorAll !== \\\"undefined\\\" ) {\\n\\t\\tret = context.querySelectorAll( tag || \\\"*\\\" );\\n\\n\\t} else {\\n\\t\\tret = [];\\n\\t}\\n\\n\\tif ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {\\n\\t\\treturn jQuery.merge( [ context ], ret );\\n\\t}\\n\\n\\treturn ret;\\n}\\n\\n\\n// Mark scripts as having already been evaluated\\nfunction setGlobalEval( elems, refElements ) {\\n\\tvar i = 0,\\n\\t\\tl = elems.length;\\n\\n\\tfor ( ; i < l; i++ ) {\\n\\t\\tdataPriv.set(\\n\\t\\t\\telems[ i ],\\n\\t\\t\\t\\\"globalEval\\\",\\n\\t\\t\\t!refElements || dataPriv.get( refElements[ i ], \\\"globalEval\\\" )\\n\\t\\t);\\n\\t}\\n}\\n\\n\\nvar rhtml = /<|&#?\\\\w+;/;\\n\\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\\n\\tvar elem, tmp, tag, wrap, contains, j,\\n\\t\\tfragment = context.createDocumentFragment(),\\n\\t\\tnodes = [],\\n\\t\\ti = 0,\\n\\t\\tl = elems.length;\\n\\n\\tfor ( ; i < l; i++ ) {\\n\\t\\telem = elems[ i ];\\n\\n\\t\\tif ( elem || elem === 0 ) {\\n\\n\\t\\t\\t// Add nodes directly\\n\\t\\t\\tif ( jQuery.type( elem ) === \\\"object\\\" ) {\\n\\n\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\\n\\n\\t\\t\\t// Convert non-html into a text node\\n\\t\\t\\t} else if ( !rhtml.test( elem ) ) {\\n\\t\\t\\t\\tnodes.push( context.createTextNode( elem ) );\\n\\n\\t\\t\\t// Convert html into DOM nodes\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttmp = tmp || fragment.appendChild( context.createElement( \\\"div\\\" ) );\\n\\n\\t\\t\\t\\t// Deserialize a standard representation\\n\\t\\t\\t\\ttag = ( rtagName.exec( elem ) || [ \\\"\\\", \\\"\\\" ] )[ 1 ].toLowerCase();\\n\\t\\t\\t\\twrap = wrapMap[ tag ] || wrapMap._default;\\n\\t\\t\\t\\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\\n\\n\\t\\t\\t\\t// Descend through wrappers to the right content\\n\\t\\t\\t\\tj = wrap[ 0 ];\\n\\t\\t\\t\\twhile ( j-- ) {\\n\\t\\t\\t\\t\\ttmp = tmp.lastChild;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\tjQuery.merge( nodes, tmp.childNodes );\\n\\n\\t\\t\\t\\t// Remember the top-level container\\n\\t\\t\\t\\ttmp = fragment.firstChild;\\n\\n\\t\\t\\t\\t// Ensure the created nodes are orphaned (#12392)\\n\\t\\t\\t\\ttmp.textContent = \\\"\\\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Remove wrapper from fragment\\n\\tfragment.textContent = \\\"\\\";\\n\\n\\ti = 0;\\n\\twhile ( ( elem = nodes[ i++ ] ) ) {\\n\\n\\t\\t// Skip elements already in the context collection (trac-4087)\\n\\t\\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\\n\\t\\t\\tif ( ignored ) {\\n\\t\\t\\t\\tignored.push( elem );\\n\\t\\t\\t}\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tcontains = jQuery.contains( elem.ownerDocument, elem );\\n\\n\\t\\t// Append to fragment\\n\\t\\ttmp = getAll( fragment.appendChild( elem ), \\\"script\\\" );\\n\\n\\t\\t// Preserve script evaluation history\\n\\t\\tif ( contains ) {\\n\\t\\t\\tsetGlobalEval( tmp );\\n\\t\\t}\\n\\n\\t\\t// Capture executables\\n\\t\\tif ( scripts ) {\\n\\t\\t\\tj = 0;\\n\\t\\t\\twhile ( ( elem = tmp[ j++ ] ) ) {\\n\\t\\t\\t\\tif ( rscriptType.test( elem.type || \\\"\\\" ) ) {\\n\\t\\t\\t\\t\\tscripts.push( elem );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn fragment;\\n}\\n\\n\\n( function() {\\n\\tvar fragment = document.createDocumentFragment(),\\n\\t\\tdiv = fragment.appendChild( document.createElement( \\\"div\\\" ) ),\\n\\t\\tinput = document.createElement( \\\"input\\\" );\\n\\n\\t// Support: Android 4.0 - 4.3 only\\n\\t// Check state lost if the name is set (#11217)\\n\\t// Support: Windows Web Apps (WWA)\\n\\t// `name` and `type` must use .setAttribute for WWA (#14901)\\n\\tinput.setAttribute( \\\"type\\\", \\\"radio\\\" );\\n\\tinput.setAttribute( \\\"checked\\\", \\\"checked\\\" );\\n\\tinput.setAttribute( \\\"name\\\", \\\"t\\\" );\\n\\n\\tdiv.appendChild( input );\\n\\n\\t// Support: Android <=4.1 only\\n\\t// Older WebKit doesn't clone checked state correctly in fragments\\n\\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\\n\\n\\t// Support: IE <=11 only\\n\\t// Make sure textarea (and checkbox) defaultValue is properly cloned\\n\\tdiv.innerHTML = \\\"<textarea>x</textarea>\\\";\\n\\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\\n} )();\\nvar documentElement = document.documentElement;\\n\\n\\n\\nvar\\n\\trkeyEvent = /^key/,\\n\\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\\n\\trtypenamespace = /^([^.]*)(?:\\\\.(.+)|)/;\\n\\nfunction returnTrue() {\\n\\treturn true;\\n}\\n\\nfunction returnFalse() {\\n\\treturn false;\\n}\\n\\n// Support: IE <=9 only\\n// See #13393 for more info\\nfunction safeActiveElement() {\\n\\ttry {\\n\\t\\treturn document.activeElement;\\n\\t} catch ( err ) { }\\n}\\n\\nfunction on( elem, types, selector, data, fn, one ) {\\n\\tvar origFn, type;\\n\\n\\t// Types can be a map of types/handlers\\n\\tif ( typeof types === \\\"object\\\" ) {\\n\\n\\t\\t// ( types-Object, selector, data )\\n\\t\\tif ( typeof selector !== \\\"string\\\" ) {\\n\\n\\t\\t\\t// ( types-Object, data )\\n\\t\\t\\tdata = data || selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t\\tfor ( type in types ) {\\n\\t\\t\\ton( elem, type, selector, data, types[ type ], one );\\n\\t\\t}\\n\\t\\treturn elem;\\n\\t}\\n\\n\\tif ( data == null && fn == null ) {\\n\\n\\t\\t// ( types, fn )\\n\\t\\tfn = selector;\\n\\t\\tdata = selector = undefined;\\n\\t} else if ( fn == null ) {\\n\\t\\tif ( typeof selector === \\\"string\\\" ) {\\n\\n\\t\\t\\t// ( types, selector, fn )\\n\\t\\t\\tfn = data;\\n\\t\\t\\tdata = undefined;\\n\\t\\t} else {\\n\\n\\t\\t\\t// ( types, data, fn )\\n\\t\\t\\tfn = data;\\n\\t\\t\\tdata = selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t}\\n\\tif ( fn === false ) {\\n\\t\\tfn = returnFalse;\\n\\t} else if ( !fn ) {\\n\\t\\treturn elem;\\n\\t}\\n\\n\\tif ( one === 1 ) {\\n\\t\\torigFn = fn;\\n\\t\\tfn = function( event ) {\\n\\n\\t\\t\\t// Can use an empty set, since event contains the info\\n\\t\\t\\tjQuery().off( event );\\n\\t\\t\\treturn origFn.apply( this, arguments );\\n\\t\\t};\\n\\n\\t\\t// Use same guid so caller can remove using origFn\\n\\t\\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\\n\\t}\\n\\treturn elem.each( function() {\\n\\t\\tjQuery.event.add( this, types, fn, data, selector );\\n\\t} );\\n}\\n\\n/*\\n * Helper functions for managing events -- not part of the public interface.\\n * Props to Dean Edwards' addEvent library for many of the ideas.\\n */\\njQuery.event = {\\n\\n\\tglobal: {},\\n\\n\\tadd: function( elem, types, handler, data, selector ) {\\n\\n\\t\\tvar handleObjIn, eventHandle, tmp,\\n\\t\\t\\tevents, t, handleObj,\\n\\t\\t\\tspecial, handlers, type, namespaces, origType,\\n\\t\\t\\telemData = dataPriv.get( elem );\\n\\n\\t\\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\\n\\t\\tif ( !elemData ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Caller can pass in an object of custom data in lieu of the handler\\n\\t\\tif ( handler.handler ) {\\n\\t\\t\\thandleObjIn = handler;\\n\\t\\t\\thandler = handleObjIn.handler;\\n\\t\\t\\tselector = handleObjIn.selector;\\n\\t\\t}\\n\\n\\t\\t// Ensure that invalid selectors throw exceptions at attach time\\n\\t\\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\\n\\t\\tif ( selector ) {\\n\\t\\t\\tjQuery.find.matchesSelector( documentElement, selector );\\n\\t\\t}\\n\\n\\t\\t// Make sure that the handler has a unique ID, used to find/remove it later\\n\\t\\tif ( !handler.guid ) {\\n\\t\\t\\thandler.guid = jQuery.guid++;\\n\\t\\t}\\n\\n\\t\\t// Init the element's event structure and main handler, if this is the first\\n\\t\\tif ( !( events = elemData.events ) ) {\\n\\t\\t\\tevents = elemData.events = {};\\n\\t\\t}\\n\\t\\tif ( !( eventHandle = elemData.handle ) ) {\\n\\t\\t\\teventHandle = elemData.handle = function( e ) {\\n\\n\\t\\t\\t\\t// Discard the second event of a jQuery.event.trigger() and\\n\\t\\t\\t\\t// when an event is called after a page has unloaded\\n\\t\\t\\t\\treturn typeof jQuery !== \\\"undefined\\\" && jQuery.event.triggered !== e.type ?\\n\\t\\t\\t\\t\\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\t// Handle multiple events separated by a space\\n\\t\\ttypes = ( types || \\\"\\\" ).match( rnothtmlwhite ) || [ \\\"\\\" ];\\n\\t\\tt = types.length;\\n\\t\\twhile ( t-- ) {\\n\\t\\t\\ttmp = rtypenamespace.exec( types[ t ] ) || [];\\n\\t\\t\\ttype = origType = tmp[ 1 ];\\n\\t\\t\\tnamespaces = ( tmp[ 2 ] || \\\"\\\" ).split( \\\".\\\" ).sort();\\n\\n\\t\\t\\t// There *must* be a type, no attaching namespace-only handlers\\n\\t\\t\\tif ( !type ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If event changes its type, use the special event handlers for the changed type\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\n\\t\\t\\t// If selector defined, determine special event api type, otherwise given type\\n\\t\\t\\ttype = ( selector ? special.delegateType : special.bindType ) || type;\\n\\n\\t\\t\\t// Update special based on newly reset type\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\n\\t\\t\\t// handleObj is passed to all event handlers\\n\\t\\t\\thandleObj = jQuery.extend( {\\n\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\torigType: origType,\\n\\t\\t\\t\\tdata: data,\\n\\t\\t\\t\\thandler: handler,\\n\\t\\t\\t\\tguid: handler.guid,\\n\\t\\t\\t\\tselector: selector,\\n\\t\\t\\t\\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\\n\\t\\t\\t\\tnamespace: namespaces.join( \\\".\\\" )\\n\\t\\t\\t}, handleObjIn );\\n\\n\\t\\t\\t// Init the event handler queue if we're the first\\n\\t\\t\\tif ( !( handlers = events[ type ] ) ) {\\n\\t\\t\\t\\thandlers = events[ type ] = [];\\n\\t\\t\\t\\thandlers.delegateCount = 0;\\n\\n\\t\\t\\t\\t// Only use addEventListener if the special events handler returns false\\n\\t\\t\\t\\tif ( !special.setup ||\\n\\t\\t\\t\\t\\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\\n\\n\\t\\t\\t\\t\\tif ( elem.addEventListener ) {\\n\\t\\t\\t\\t\\t\\telem.addEventListener( type, eventHandle );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( special.add ) {\\n\\t\\t\\t\\tspecial.add.call( elem, handleObj );\\n\\n\\t\\t\\t\\tif ( !handleObj.handler.guid ) {\\n\\t\\t\\t\\t\\thandleObj.handler.guid = handler.guid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add to the element's handler list, delegates in front\\n\\t\\t\\tif ( selector ) {\\n\\t\\t\\t\\thandlers.splice( handlers.delegateCount++, 0, handleObj );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thandlers.push( handleObj );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Keep track of which events have ever been used, for event optimization\\n\\t\\t\\tjQuery.event.global[ type ] = true;\\n\\t\\t}\\n\\n\\t},\\n\\n\\t// Detach an event or set of events from an element\\n\\tremove: function( elem, types, handler, selector, mappedTypes ) {\\n\\n\\t\\tvar j, origCount, tmp,\\n\\t\\t\\tevents, t, handleObj,\\n\\t\\t\\tspecial, handlers, type, namespaces, origType,\\n\\t\\t\\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\\n\\n\\t\\tif ( !elemData || !( events = elemData.events ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Once for each type.namespace in types; type may be omitted\\n\\t\\ttypes = ( types || \\\"\\\" ).match( rnothtmlwhite ) || [ \\\"\\\" ];\\n\\t\\tt = types.length;\\n\\t\\twhile ( t-- ) {\\n\\t\\t\\ttmp = rtypenamespace.exec( types[ t ] ) || [];\\n\\t\\t\\ttype = origType = tmp[ 1 ];\\n\\t\\t\\tnamespaces = ( tmp[ 2 ] || \\\"\\\" ).split( \\\".\\\" ).sort();\\n\\n\\t\\t\\t// Unbind all events (on this namespace, if provided) for the element\\n\\t\\t\\tif ( !type ) {\\n\\t\\t\\t\\tfor ( type in events ) {\\n\\t\\t\\t\\t\\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\t\\t\\ttype = ( selector ? special.delegateType : special.bindType ) || type;\\n\\t\\t\\thandlers = events[ type ] || [];\\n\\t\\t\\ttmp = tmp[ 2 ] &&\\n\\t\\t\\t\\tnew RegExp( \\\"(^|\\\\\\\\.)\\\" + namespaces.join( \\\"\\\\\\\\.(?:.*\\\\\\\\.|)\\\" ) + \\\"(\\\\\\\\.|$)\\\" );\\n\\n\\t\\t\\t// Remove matching events\\n\\t\\t\\torigCount = j = handlers.length;\\n\\t\\t\\twhile ( j-- ) {\\n\\t\\t\\t\\thandleObj = handlers[ j ];\\n\\n\\t\\t\\t\\tif ( ( mappedTypes || origType === handleObj.origType ) &&\\n\\t\\t\\t\\t\\t( !handler || handler.guid === handleObj.guid ) &&\\n\\t\\t\\t\\t\\t( !tmp || tmp.test( handleObj.namespace ) ) &&\\n\\t\\t\\t\\t\\t( !selector || selector === handleObj.selector ||\\n\\t\\t\\t\\t\\t\\tselector === \\\"**\\\" && handleObj.selector ) ) {\\n\\t\\t\\t\\t\\thandlers.splice( j, 1 );\\n\\n\\t\\t\\t\\t\\tif ( handleObj.selector ) {\\n\\t\\t\\t\\t\\t\\thandlers.delegateCount--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( special.remove ) {\\n\\t\\t\\t\\t\\t\\tspecial.remove.call( elem, handleObj );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Remove generic event handler if we removed something and no more handlers exist\\n\\t\\t\\t// (avoids potential for endless recursion during removal of special event handlers)\\n\\t\\t\\tif ( origCount && !handlers.length ) {\\n\\t\\t\\t\\tif ( !special.teardown ||\\n\\t\\t\\t\\t\\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\\n\\n\\t\\t\\t\\t\\tjQuery.removeEvent( elem, type, elemData.handle );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdelete events[ type ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Remove data and the expando if it's no longer used\\n\\t\\tif ( jQuery.isEmptyObject( events ) ) {\\n\\t\\t\\tdataPriv.remove( elem, \\\"handle events\\\" );\\n\\t\\t}\\n\\t},\\n\\n\\tdispatch: function( nativeEvent ) {\\n\\n\\t\\t// Make a writable jQuery.Event from the native event object\\n\\t\\tvar event = jQuery.event.fix( nativeEvent );\\n\\n\\t\\tvar i, j, ret, matched, handleObj, handlerQueue,\\n\\t\\t\\targs = new Array( arguments.length ),\\n\\t\\t\\thandlers = ( dataPriv.get( this, \\\"events\\\" ) || {} )[ event.type ] || [],\\n\\t\\t\\tspecial = jQuery.event.special[ event.type ] || {};\\n\\n\\t\\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\\n\\t\\targs[ 0 ] = event;\\n\\n\\t\\tfor ( i = 1; i < arguments.length; i++ ) {\\n\\t\\t\\targs[ i ] = arguments[ i ];\\n\\t\\t}\\n\\n\\t\\tevent.delegateTarget = this;\\n\\n\\t\\t// Call the preDispatch hook for the mapped type, and let it bail if desired\\n\\t\\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Determine handlers\\n\\t\\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\\n\\n\\t\\t// Run delegates first; they may want to stop propagation beneath us\\n\\t\\ti = 0;\\n\\t\\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\\n\\t\\t\\tevent.currentTarget = matched.elem;\\n\\n\\t\\t\\tj = 0;\\n\\t\\t\\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\\n\\t\\t\\t\\t!event.isImmediatePropagationStopped() ) {\\n\\n\\t\\t\\t\\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\\n\\t\\t\\t\\t// a subset or equal to those in the bound event (both can have no namespace).\\n\\t\\t\\t\\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\\n\\n\\t\\t\\t\\t\\tevent.handleObj = handleObj;\\n\\t\\t\\t\\t\\tevent.data = handleObj.data;\\n\\n\\t\\t\\t\\t\\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\\n\\t\\t\\t\\t\\t\\thandleObj.handler ).apply( matched.elem, args );\\n\\n\\t\\t\\t\\t\\tif ( ret !== undefined ) {\\n\\t\\t\\t\\t\\t\\tif ( ( event.result = ret ) === false ) {\\n\\t\\t\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\t\\t\\tevent.stopPropagation();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Call the postDispatch hook for the mapped type\\n\\t\\tif ( special.postDispatch ) {\\n\\t\\t\\tspecial.postDispatch.call( this, event );\\n\\t\\t}\\n\\n\\t\\treturn event.result;\\n\\t},\\n\\n\\thandlers: function( event, handlers ) {\\n\\t\\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\\n\\t\\t\\thandlerQueue = [],\\n\\t\\t\\tdelegateCount = handlers.delegateCount,\\n\\t\\t\\tcur = event.target;\\n\\n\\t\\t// Find delegate handlers\\n\\t\\tif ( delegateCount &&\\n\\n\\t\\t\\t// Support: IE <=9\\n\\t\\t\\t// Black-hole SVG <use> instance trees (trac-13180)\\n\\t\\t\\tcur.nodeType &&\\n\\n\\t\\t\\t// Support: Firefox <=42\\n\\t\\t\\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\\n\\t\\t\\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\\n\\t\\t\\t// Support: IE 11 only\\n\\t\\t\\t// ...but not arrow key \\\"clicks\\\" of radio inputs, which can have `button` -1 (gh-2343)\\n\\t\\t\\t!( event.type === \\\"click\\\" && event.button >= 1 ) ) {\\n\\n\\t\\t\\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\\n\\n\\t\\t\\t\\t// Don't check non-elements (#13208)\\n\\t\\t\\t\\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\\n\\t\\t\\t\\tif ( cur.nodeType === 1 && !( event.type === \\\"click\\\" && cur.disabled === true ) ) {\\n\\t\\t\\t\\t\\tmatchedHandlers = [];\\n\\t\\t\\t\\t\\tmatchedSelectors = {};\\n\\t\\t\\t\\t\\tfor ( i = 0; i < delegateCount; i++ ) {\\n\\t\\t\\t\\t\\t\\thandleObj = handlers[ i ];\\n\\n\\t\\t\\t\\t\\t\\t// Don't conflict with Object.prototype properties (#13203)\\n\\t\\t\\t\\t\\t\\tsel = handleObj.selector + \\\" \\\";\\n\\n\\t\\t\\t\\t\\t\\tif ( matchedSelectors[ sel ] === undefined ) {\\n\\t\\t\\t\\t\\t\\t\\tmatchedSelectors[ sel ] = handleObj.needsContext ?\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery( sel, this ).index( cur ) > -1 :\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.find( sel, this, null, [ cur ] ).length;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif ( matchedSelectors[ sel ] ) {\\n\\t\\t\\t\\t\\t\\t\\tmatchedHandlers.push( handleObj );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( matchedHandlers.length ) {\\n\\t\\t\\t\\t\\t\\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Add the remaining (directly-bound) handlers\\n\\t\\tcur = this;\\n\\t\\tif ( delegateCount < handlers.length ) {\\n\\t\\t\\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\\n\\t\\t}\\n\\n\\t\\treturn handlerQueue;\\n\\t},\\n\\n\\taddProp: function( name, hook ) {\\n\\t\\tObject.defineProperty( jQuery.Event.prototype, name, {\\n\\t\\t\\tenumerable: true,\\n\\t\\t\\tconfigurable: true,\\n\\n\\t\\t\\tget: jQuery.isFunction( hook ) ?\\n\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\tif ( this.originalEvent ) {\\n\\t\\t\\t\\t\\t\\t\\treturn hook( this.originalEvent );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} :\\n\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\tif ( this.originalEvent ) {\\n\\t\\t\\t\\t\\t\\t\\treturn this.originalEvent[ name ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\tset: function( value ) {\\n\\t\\t\\t\\tObject.defineProperty( this, name, {\\n\\t\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\t\\tconfigurable: true,\\n\\t\\t\\t\\t\\twritable: true,\\n\\t\\t\\t\\t\\tvalue: value\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tfix: function( originalEvent ) {\\n\\t\\treturn originalEvent[ jQuery.expando ] ?\\n\\t\\t\\toriginalEvent :\\n\\t\\t\\tnew jQuery.Event( originalEvent );\\n\\t},\\n\\n\\tspecial: {\\n\\t\\tload: {\\n\\n\\t\\t\\t// Prevent triggered image.load events from bubbling to window.load\\n\\t\\t\\tnoBubble: true\\n\\t\\t},\\n\\t\\tfocus: {\\n\\n\\t\\t\\t// Fire native event if possible so blur/focus sequence is correct\\n\\t\\t\\ttrigger: function() {\\n\\t\\t\\t\\tif ( this !== safeActiveElement() && this.focus ) {\\n\\t\\t\\t\\t\\tthis.focus();\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tdelegateType: \\\"focusin\\\"\\n\\t\\t},\\n\\t\\tblur: {\\n\\t\\t\\ttrigger: function() {\\n\\t\\t\\t\\tif ( this === safeActiveElement() && this.blur ) {\\n\\t\\t\\t\\t\\tthis.blur();\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tdelegateType: \\\"focusout\\\"\\n\\t\\t},\\n\\t\\tclick: {\\n\\n\\t\\t\\t// For checkbox, fire native event so checked state will be right\\n\\t\\t\\ttrigger: function() {\\n\\t\\t\\t\\tif ( this.type === \\\"checkbox\\\" && this.click && jQuery.nodeName( this, \\\"input\\\" ) ) {\\n\\t\\t\\t\\t\\tthis.click();\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\t// For cross-browser consistency, don't fire native .click() on links\\n\\t\\t\\t_default: function( event ) {\\n\\t\\t\\t\\treturn jQuery.nodeName( event.target, \\\"a\\\" );\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tbeforeunload: {\\n\\t\\t\\tpostDispatch: function( event ) {\\n\\n\\t\\t\\t\\t// Support: Firefox 20+\\n\\t\\t\\t\\t// Firefox doesn't alert if the returnValue field is not set.\\n\\t\\t\\t\\tif ( event.result !== undefined && event.originalEvent ) {\\n\\t\\t\\t\\t\\tevent.originalEvent.returnValue = event.result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.removeEvent = function( elem, type, handle ) {\\n\\n\\t// This \\\"if\\\" is needed for plain objects\\n\\tif ( elem.removeEventListener ) {\\n\\t\\telem.removeEventListener( type, handle );\\n\\t}\\n};\\n\\njQuery.Event = function( src, props ) {\\n\\n\\t// Allow instantiation without the 'new' keyword\\n\\tif ( !( this instanceof jQuery.Event ) ) {\\n\\t\\treturn new jQuery.Event( src, props );\\n\\t}\\n\\n\\t// Event object\\n\\tif ( src && src.type ) {\\n\\t\\tthis.originalEvent = src;\\n\\t\\tthis.type = src.type;\\n\\n\\t\\t// Events bubbling up the document may have been marked as prevented\\n\\t\\t// by a handler lower down the tree; reflect the correct value.\\n\\t\\tthis.isDefaultPrevented = src.defaultPrevented ||\\n\\t\\t\\t\\tsrc.defaultPrevented === undefined &&\\n\\n\\t\\t\\t\\t// Support: Android <=2.3 only\\n\\t\\t\\t\\tsrc.returnValue === false ?\\n\\t\\t\\treturnTrue :\\n\\t\\t\\treturnFalse;\\n\\n\\t\\t// Create target properties\\n\\t\\t// Support: Safari <=6 - 7 only\\n\\t\\t// Target should not be a text node (#504, #13143)\\n\\t\\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\\n\\t\\t\\tsrc.target.parentNode :\\n\\t\\t\\tsrc.target;\\n\\n\\t\\tthis.currentTarget = src.currentTarget;\\n\\t\\tthis.relatedTarget = src.relatedTarget;\\n\\n\\t// Event type\\n\\t} else {\\n\\t\\tthis.type = src;\\n\\t}\\n\\n\\t// Put explicitly provided properties onto the event object\\n\\tif ( props ) {\\n\\t\\tjQuery.extend( this, props );\\n\\t}\\n\\n\\t// Create a timestamp if incoming event doesn't have one\\n\\tthis.timeStamp = src && src.timeStamp || jQuery.now();\\n\\n\\t// Mark it as fixed\\n\\tthis[ jQuery.expando ] = true;\\n};\\n\\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\\njQuery.Event.prototype = {\\n\\tconstructor: jQuery.Event,\\n\\tisDefaultPrevented: returnFalse,\\n\\tisPropagationStopped: returnFalse,\\n\\tisImmediatePropagationStopped: returnFalse,\\n\\tisSimulated: false,\\n\\n\\tpreventDefault: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isDefaultPrevented = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.preventDefault();\\n\\t\\t}\\n\\t},\\n\\tstopPropagation: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isPropagationStopped = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.stopPropagation();\\n\\t\\t}\\n\\t},\\n\\tstopImmediatePropagation: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isImmediatePropagationStopped = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.stopImmediatePropagation();\\n\\t\\t}\\n\\n\\t\\tthis.stopPropagation();\\n\\t}\\n};\\n\\n// Includes all common event props including KeyEvent and MouseEvent specific props\\njQuery.each( {\\n\\taltKey: true,\\n\\tbubbles: true,\\n\\tcancelable: true,\\n\\tchangedTouches: true,\\n\\tctrlKey: true,\\n\\tdetail: true,\\n\\teventPhase: true,\\n\\tmetaKey: true,\\n\\tpageX: true,\\n\\tpageY: true,\\n\\tshiftKey: true,\\n\\tview: true,\\n\\t\\\"char\\\": true,\\n\\tcharCode: true,\\n\\tkey: true,\\n\\tkeyCode: true,\\n\\tbutton: true,\\n\\tbuttons: true,\\n\\tclientX: true,\\n\\tclientY: true,\\n\\toffsetX: true,\\n\\toffsetY: true,\\n\\tpointerId: true,\\n\\tpointerType: true,\\n\\tscreenX: true,\\n\\tscreenY: true,\\n\\ttargetTouches: true,\\n\\ttoElement: true,\\n\\ttouches: true,\\n\\n\\twhich: function( event ) {\\n\\t\\tvar button = event.button;\\n\\n\\t\\t// Add which for key events\\n\\t\\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\\n\\t\\t\\treturn event.charCode != null ? event.charCode : event.keyCode;\\n\\t\\t}\\n\\n\\t\\t// Add which for click: 1 === left; 2 === middle; 3 === right\\n\\t\\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\\n\\t\\t\\tif ( button & 1 ) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( button & 2 ) {\\n\\t\\t\\t\\treturn 3;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( button & 4 ) {\\n\\t\\t\\t\\treturn 2;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\treturn event.which;\\n\\t}\\n}, jQuery.event.addProp );\\n\\n// Create mouseenter/leave events using mouseover/out and event-time checks\\n// so that event delegation works in jQuery.\\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\\n//\\n// Support: Safari 7 only\\n// Safari sends mouseenter too often; see:\\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\\n// for the description of the bug (it existed in older Chrome versions as well).\\njQuery.each( {\\n\\tmouseenter: \\\"mouseover\\\",\\n\\tmouseleave: \\\"mouseout\\\",\\n\\tpointerenter: \\\"pointerover\\\",\\n\\tpointerleave: \\\"pointerout\\\"\\n}, function( orig, fix ) {\\n\\tjQuery.event.special[ orig ] = {\\n\\t\\tdelegateType: fix,\\n\\t\\tbindType: fix,\\n\\n\\t\\thandle: function( event ) {\\n\\t\\t\\tvar ret,\\n\\t\\t\\t\\ttarget = this,\\n\\t\\t\\t\\trelated = event.relatedTarget,\\n\\t\\t\\t\\thandleObj = event.handleObj;\\n\\n\\t\\t\\t// For mouseenter/leave call the handler if related is outside the target.\\n\\t\\t\\t// NB: No relatedTarget if the mouse left/entered the browser window\\n\\t\\t\\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\\n\\t\\t\\t\\tevent.type = handleObj.origType;\\n\\t\\t\\t\\tret = handleObj.handler.apply( this, arguments );\\n\\t\\t\\t\\tevent.type = fix;\\n\\t\\t\\t}\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\t};\\n} );\\n\\njQuery.fn.extend( {\\n\\n\\ton: function( types, selector, data, fn ) {\\n\\t\\treturn on( this, types, selector, data, fn );\\n\\t},\\n\\tone: function( types, selector, data, fn ) {\\n\\t\\treturn on( this, types, selector, data, fn, 1 );\\n\\t},\\n\\toff: function( types, selector, fn ) {\\n\\t\\tvar handleObj, type;\\n\\t\\tif ( types && types.preventDefault && types.handleObj ) {\\n\\n\\t\\t\\t// ( event )  dispatched jQuery.Event\\n\\t\\t\\thandleObj = types.handleObj;\\n\\t\\t\\tjQuery( types.delegateTarget ).off(\\n\\t\\t\\t\\thandleObj.namespace ?\\n\\t\\t\\t\\t\\thandleObj.origType + \\\".\\\" + handleObj.namespace :\\n\\t\\t\\t\\t\\thandleObj.origType,\\n\\t\\t\\t\\thandleObj.selector,\\n\\t\\t\\t\\thandleObj.handler\\n\\t\\t\\t);\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t\\tif ( typeof types === \\\"object\\\" ) {\\n\\n\\t\\t\\t// ( types-object [, selector] )\\n\\t\\t\\tfor ( type in types ) {\\n\\t\\t\\t\\tthis.off( type, selector, types[ type ] );\\n\\t\\t\\t}\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t\\tif ( selector === false || typeof selector === \\\"function\\\" ) {\\n\\n\\t\\t\\t// ( types [, fn] )\\n\\t\\t\\tfn = selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t\\tif ( fn === false ) {\\n\\t\\t\\tfn = returnFalse;\\n\\t\\t}\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.event.remove( this, types, fn, selector );\\n\\t\\t} );\\n\\t}\\n} );\\n\\n\\nvar\\n\\n\\t/* eslint-disable max-len */\\n\\n\\t// See https://github.com/eslint/eslint/issues/3229\\n\\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\\\/\\\\0>\\\\x20\\\\t\\\\r\\\\n\\\\f]*)[^>]*)\\\\/>/gi,\\n\\n\\t/* eslint-enable */\\n\\n\\t// Support: IE <=10 - 11, Edge 12 - 13\\n\\t// In IE/Edge using regex groups here causes severe slowdowns.\\n\\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\\n\\trnoInnerhtml = /<script|<style|<link/i,\\n\\n\\t// checked=\\\"checked\\\" or checked\\n\\trchecked = /checked\\\\s*(?:[^=]|=\\\\s*.checked.)/i,\\n\\trscriptTypeMasked = /^true\\\\/(.*)/,\\n\\trcleanScript = /^\\\\s*<!(?:\\\\[CDATA\\\\[|--)|(?:\\\\]\\\\]|--)>\\\\s*$/g;\\n\\nfunction manipulationTarget( elem, content ) {\\n\\tif ( jQuery.nodeName( elem, \\\"table\\\" ) &&\\n\\t\\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \\\"tr\\\" ) ) {\\n\\n\\t\\treturn elem.getElementsByTagName( \\\"tbody\\\" )[ 0 ] || elem;\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\n// Replace/restore the type attribute of script elements for safe DOM manipulation\\nfunction disableScript( elem ) {\\n\\telem.type = ( elem.getAttribute( \\\"type\\\" ) !== null ) + \\\"/\\\" + elem.type;\\n\\treturn elem;\\n}\\nfunction restoreScript( elem ) {\\n\\tvar match = rscriptTypeMasked.exec( elem.type );\\n\\n\\tif ( match ) {\\n\\t\\telem.type = match[ 1 ];\\n\\t} else {\\n\\t\\telem.removeAttribute( \\\"type\\\" );\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\nfunction cloneCopyEvent( src, dest ) {\\n\\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\\n\\n\\tif ( dest.nodeType !== 1 ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// 1. Copy private data: events, handlers, etc.\\n\\tif ( dataPriv.hasData( src ) ) {\\n\\t\\tpdataOld = dataPriv.access( src );\\n\\t\\tpdataCur = dataPriv.set( dest, pdataOld );\\n\\t\\tevents = pdataOld.events;\\n\\n\\t\\tif ( events ) {\\n\\t\\t\\tdelete pdataCur.handle;\\n\\t\\t\\tpdataCur.events = {};\\n\\n\\t\\t\\tfor ( type in events ) {\\n\\t\\t\\t\\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\\n\\t\\t\\t\\t\\tjQuery.event.add( dest, type, events[ type ][ i ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// 2. Copy user data\\n\\tif ( dataUser.hasData( src ) ) {\\n\\t\\tudataOld = dataUser.access( src );\\n\\t\\tudataCur = jQuery.extend( {}, udataOld );\\n\\n\\t\\tdataUser.set( dest, udataCur );\\n\\t}\\n}\\n\\n// Fix IE bugs, see support tests\\nfunction fixInput( src, dest ) {\\n\\tvar nodeName = dest.nodeName.toLowerCase();\\n\\n\\t// Fails to persist the checked state of a cloned checkbox or radio button.\\n\\tif ( nodeName === \\\"input\\\" && rcheckableType.test( src.type ) ) {\\n\\t\\tdest.checked = src.checked;\\n\\n\\t// Fails to return the selected option to the default selected state when cloning options\\n\\t} else if ( nodeName === \\\"input\\\" || nodeName === \\\"textarea\\\" ) {\\n\\t\\tdest.defaultValue = src.defaultValue;\\n\\t}\\n}\\n\\nfunction domManip( collection, args, callback, ignored ) {\\n\\n\\t// Flatten any nested arrays\\n\\targs = concat.apply( [], args );\\n\\n\\tvar fragment, first, scripts, hasScripts, node, doc,\\n\\t\\ti = 0,\\n\\t\\tl = collection.length,\\n\\t\\tiNoClone = l - 1,\\n\\t\\tvalue = args[ 0 ],\\n\\t\\tisFunction = jQuery.isFunction( value );\\n\\n\\t// We can't cloneNode fragments that contain checked, in WebKit\\n\\tif ( isFunction ||\\n\\t\\t\\t( l > 1 && typeof value === \\\"string\\\" &&\\n\\t\\t\\t\\t!support.checkClone && rchecked.test( value ) ) ) {\\n\\t\\treturn collection.each( function( index ) {\\n\\t\\t\\tvar self = collection.eq( index );\\n\\t\\t\\tif ( isFunction ) {\\n\\t\\t\\t\\targs[ 0 ] = value.call( this, index, self.html() );\\n\\t\\t\\t}\\n\\t\\t\\tdomManip( self, args, callback, ignored );\\n\\t\\t} );\\n\\t}\\n\\n\\tif ( l ) {\\n\\t\\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\\n\\t\\tfirst = fragment.firstChild;\\n\\n\\t\\tif ( fragment.childNodes.length === 1 ) {\\n\\t\\t\\tfragment = first;\\n\\t\\t}\\n\\n\\t\\t// Require either new content or an interest in ignored elements to invoke the callback\\n\\t\\tif ( first || ignored ) {\\n\\t\\t\\tscripts = jQuery.map( getAll( fragment, \\\"script\\\" ), disableScript );\\n\\t\\t\\thasScripts = scripts.length;\\n\\n\\t\\t\\t// Use the original fragment for the last item\\n\\t\\t\\t// instead of the first because it can end up\\n\\t\\t\\t// being emptied incorrectly in certain situations (#8070).\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tnode = fragment;\\n\\n\\t\\t\\t\\tif ( i !== iNoClone ) {\\n\\t\\t\\t\\t\\tnode = jQuery.clone( node, true, true );\\n\\n\\t\\t\\t\\t\\t// Keep references to cloned scripts for later restoration\\n\\t\\t\\t\\t\\tif ( hasScripts ) {\\n\\n\\t\\t\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\t\\t\\tjQuery.merge( scripts, getAll( node, \\\"script\\\" ) );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcallback.call( collection[ i ], node, i );\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( hasScripts ) {\\n\\t\\t\\t\\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\\n\\n\\t\\t\\t\\t// Reenable scripts\\n\\t\\t\\t\\tjQuery.map( scripts, restoreScript );\\n\\n\\t\\t\\t\\t// Evaluate executable scripts on first document insertion\\n\\t\\t\\t\\tfor ( i = 0; i < hasScripts; i++ ) {\\n\\t\\t\\t\\t\\tnode = scripts[ i ];\\n\\t\\t\\t\\t\\tif ( rscriptType.test( node.type || \\\"\\\" ) &&\\n\\t\\t\\t\\t\\t\\t!dataPriv.access( node, \\\"globalEval\\\" ) &&\\n\\t\\t\\t\\t\\t\\tjQuery.contains( doc, node ) ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( node.src ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Optional AJAX dependency, but won't run scripts if not present\\n\\t\\t\\t\\t\\t\\t\\tif ( jQuery._evalUrl ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery._evalUrl( node.src );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tDOMEval( node.textContent.replace( rcleanScript, \\\"\\\" ), doc );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn collection;\\n}\\n\\nfunction remove( elem, selector, keepData ) {\\n\\tvar node,\\n\\t\\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\\n\\t\\ti = 0;\\n\\n\\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\\n\\t\\tif ( !keepData && node.nodeType === 1 ) {\\n\\t\\t\\tjQuery.cleanData( getAll( node ) );\\n\\t\\t}\\n\\n\\t\\tif ( node.parentNode ) {\\n\\t\\t\\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\\n\\t\\t\\t\\tsetGlobalEval( getAll( node, \\\"script\\\" ) );\\n\\t\\t\\t}\\n\\t\\t\\tnode.parentNode.removeChild( node );\\n\\t\\t}\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\njQuery.extend( {\\n\\thtmlPrefilter: function( html ) {\\n\\t\\treturn html.replace( rxhtmlTag, \\\"<$1></$2>\\\" );\\n\\t},\\n\\n\\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\\n\\t\\tvar i, l, srcElements, destElements,\\n\\t\\t\\tclone = elem.cloneNode( true ),\\n\\t\\t\\tinPage = jQuery.contains( elem.ownerDocument, elem );\\n\\n\\t\\t// Fix IE cloning issues\\n\\t\\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\\n\\t\\t\\t\\t!jQuery.isXMLDoc( elem ) ) {\\n\\n\\t\\t\\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\\n\\t\\t\\tdestElements = getAll( clone );\\n\\t\\t\\tsrcElements = getAll( elem );\\n\\n\\t\\t\\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\\n\\t\\t\\t\\tfixInput( srcElements[ i ], destElements[ i ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Copy the events from the original to the clone\\n\\t\\tif ( dataAndEvents ) {\\n\\t\\t\\tif ( deepDataAndEvents ) {\\n\\t\\t\\t\\tsrcElements = srcElements || getAll( elem );\\n\\t\\t\\t\\tdestElements = destElements || getAll( clone );\\n\\n\\t\\t\\t\\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcloneCopyEvent( elem, clone );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Preserve script evaluation history\\n\\t\\tdestElements = getAll( clone, \\\"script\\\" );\\n\\t\\tif ( destElements.length > 0 ) {\\n\\t\\t\\tsetGlobalEval( destElements, !inPage && getAll( elem, \\\"script\\\" ) );\\n\\t\\t}\\n\\n\\t\\t// Return the cloned set\\n\\t\\treturn clone;\\n\\t},\\n\\n\\tcleanData: function( elems ) {\\n\\t\\tvar data, elem, type,\\n\\t\\t\\tspecial = jQuery.event.special,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\\n\\t\\t\\tif ( acceptData( elem ) ) {\\n\\t\\t\\t\\tif ( ( data = elem[ dataPriv.expando ] ) ) {\\n\\t\\t\\t\\t\\tif ( data.events ) {\\n\\t\\t\\t\\t\\t\\tfor ( type in data.events ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( special[ type ] ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.event.remove( elem, type );\\n\\n\\t\\t\\t\\t\\t\\t\\t// This is a shortcut to avoid jQuery.event.remove's overhead\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.removeEvent( elem, type, data.handle );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Support: Chrome <=35 - 45+\\n\\t\\t\\t\\t\\t// Assign undefined instead of using delete, see Data#remove\\n\\t\\t\\t\\t\\telem[ dataPriv.expando ] = undefined;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( elem[ dataUser.expando ] ) {\\n\\n\\t\\t\\t\\t\\t// Support: Chrome <=35 - 45+\\n\\t\\t\\t\\t\\t// Assign undefined instead of using delete, see Data#remove\\n\\t\\t\\t\\t\\telem[ dataUser.expando ] = undefined;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tdetach: function( selector ) {\\n\\t\\treturn remove( this, selector, true );\\n\\t},\\n\\n\\tremove: function( selector ) {\\n\\t\\treturn remove( this, selector );\\n\\t},\\n\\n\\ttext: function( value ) {\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\treturn value === undefined ?\\n\\t\\t\\t\\tjQuery.text( this ) :\\n\\t\\t\\t\\tthis.empty().each( function() {\\n\\t\\t\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\t\\t\\tthis.textContent = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} );\\n\\t\\t}, null, value, arguments.length );\\n\\t},\\n\\n\\tappend: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\tvar target = manipulationTarget( this, elem );\\n\\t\\t\\t\\ttarget.appendChild( elem );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tprepend: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\tvar target = manipulationTarget( this, elem );\\n\\t\\t\\t\\ttarget.insertBefore( elem, target.firstChild );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tbefore: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.parentNode ) {\\n\\t\\t\\t\\tthis.parentNode.insertBefore( elem, this );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tafter: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.parentNode ) {\\n\\t\\t\\t\\tthis.parentNode.insertBefore( elem, this.nextSibling );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tempty: function() {\\n\\t\\tvar elem,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\\n\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\n\\t\\t\\t\\t// Prevent memory leaks\\n\\t\\t\\t\\tjQuery.cleanData( getAll( elem, false ) );\\n\\n\\t\\t\\t\\t// Remove any remaining nodes\\n\\t\\t\\t\\telem.textContent = \\\"\\\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\tclone: function( dataAndEvents, deepDataAndEvents ) {\\n\\t\\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\\n\\t\\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\\n\\n\\t\\treturn this.map( function() {\\n\\t\\t\\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\\n\\t\\t} );\\n\\t},\\n\\n\\thtml: function( value ) {\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\tvar elem = this[ 0 ] || {},\\n\\t\\t\\t\\ti = 0,\\n\\t\\t\\t\\tl = this.length;\\n\\n\\t\\t\\tif ( value === undefined && elem.nodeType === 1 ) {\\n\\t\\t\\t\\treturn elem.innerHTML;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// See if we can take a shortcut and just use innerHTML\\n\\t\\t\\tif ( typeof value === \\\"string\\\" && !rnoInnerhtml.test( value ) &&\\n\\t\\t\\t\\t!wrapMap[ ( rtagName.exec( value ) || [ \\\"\\\", \\\"\\\" ] )[ 1 ].toLowerCase() ] ) {\\n\\n\\t\\t\\t\\tvalue = jQuery.htmlPrefilter( value );\\n\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\t\\t\\telem = this[ i ] || {};\\n\\n\\t\\t\\t\\t\\t\\t// Remove element nodes and prevent memory leaks\\n\\t\\t\\t\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\t\\t\\t\\t\\tjQuery.cleanData( getAll( elem, false ) );\\n\\t\\t\\t\\t\\t\\t\\telem.innerHTML = value;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telem = 0;\\n\\n\\t\\t\\t\\t// If using innerHTML throws an exception, use the fallback method\\n\\t\\t\\t\\t} catch ( e ) {}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( elem ) {\\n\\t\\t\\t\\tthis.empty().append( value );\\n\\t\\t\\t}\\n\\t\\t}, null, value, arguments.length );\\n\\t},\\n\\n\\treplaceWith: function() {\\n\\t\\tvar ignored = [];\\n\\n\\t\\t// Make the changes, replacing each non-ignored context element with the new content\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tvar parent = this.parentNode;\\n\\n\\t\\t\\tif ( jQuery.inArray( this, ignored ) < 0 ) {\\n\\t\\t\\t\\tjQuery.cleanData( getAll( this ) );\\n\\t\\t\\t\\tif ( parent ) {\\n\\t\\t\\t\\t\\tparent.replaceChild( elem, this );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Force callback invocation\\n\\t\\t}, ignored );\\n\\t}\\n} );\\n\\njQuery.each( {\\n\\tappendTo: \\\"append\\\",\\n\\tprependTo: \\\"prepend\\\",\\n\\tinsertBefore: \\\"before\\\",\\n\\tinsertAfter: \\\"after\\\",\\n\\treplaceAll: \\\"replaceWith\\\"\\n}, function( name, original ) {\\n\\tjQuery.fn[ name ] = function( selector ) {\\n\\t\\tvar elems,\\n\\t\\t\\tret = [],\\n\\t\\t\\tinsert = jQuery( selector ),\\n\\t\\t\\tlast = insert.length - 1,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; i <= last; i++ ) {\\n\\t\\t\\telems = i === last ? this : this.clone( true );\\n\\t\\t\\tjQuery( insert[ i ] )[ original ]( elems );\\n\\n\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\tpush.apply( ret, elems.get() );\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( ret );\\n\\t};\\n} );\\nvar rmargin = ( /^margin/ );\\n\\nvar rnumnonpx = new RegExp( \\\"^(\\\" + pnum + \\\")(?!px)[a-z%]+$\\\", \\\"i\\\" );\\n\\nvar getStyles = function( elem ) {\\n\\n\\t\\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\\n\\t\\t// IE throws on elements created in popups\\n\\t\\t// FF meanwhile throws on frame elements through \\\"defaultView.getComputedStyle\\\"\\n\\t\\tvar view = elem.ownerDocument.defaultView;\\n\\n\\t\\tif ( !view || !view.opener ) {\\n\\t\\t\\tview = window;\\n\\t\\t}\\n\\n\\t\\treturn view.getComputedStyle( elem );\\n\\t};\\n\\n\\n\\n( function() {\\n\\n\\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\\n\\t// so they're executed at the same time to save the second computation.\\n\\tfunction computeStyleTests() {\\n\\n\\t\\t// This is a singleton, we need to execute it only once\\n\\t\\tif ( !div ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tdiv.style.cssText =\\n\\t\\t\\t\\\"box-sizing:border-box;\\\" +\\n\\t\\t\\t\\\"position:relative;display:block;\\\" +\\n\\t\\t\\t\\\"margin:auto;border:1px;padding:1px;\\\" +\\n\\t\\t\\t\\\"top:1%;width:50%\\\";\\n\\t\\tdiv.innerHTML = \\\"\\\";\\n\\t\\tdocumentElement.appendChild( container );\\n\\n\\t\\tvar divStyle = window.getComputedStyle( div );\\n\\t\\tpixelPositionVal = divStyle.top !== \\\"1%\\\";\\n\\n\\t\\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\\n\\t\\treliableMarginLeftVal = divStyle.marginLeft === \\\"2px\\\";\\n\\t\\tboxSizingReliableVal = divStyle.width === \\\"4px\\\";\\n\\n\\t\\t// Support: Android 4.0 - 4.3 only\\n\\t\\t// Some styles come back with percentage values, even though they shouldn't\\n\\t\\tdiv.style.marginRight = \\\"50%\\\";\\n\\t\\tpixelMarginRightVal = divStyle.marginRight === \\\"4px\\\";\\n\\n\\t\\tdocumentElement.removeChild( container );\\n\\n\\t\\t// Nullify the div so it wouldn't be stored in the memory and\\n\\t\\t// it will also be a sign that checks already performed\\n\\t\\tdiv = null;\\n\\t}\\n\\n\\tvar pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,\\n\\t\\tcontainer = document.createElement( \\\"div\\\" ),\\n\\t\\tdiv = document.createElement( \\\"div\\\" );\\n\\n\\t// Finish early in limited (non-browser) environments\\n\\tif ( !div.style ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// Support: IE <=9 - 11 only\\n\\t// Style of cloned element affects source element cloned (#8908)\\n\\tdiv.style.backgroundClip = \\\"content-box\\\";\\n\\tdiv.cloneNode( true ).style.backgroundClip = \\\"\\\";\\n\\tsupport.clearCloneStyle = div.style.backgroundClip === \\\"content-box\\\";\\n\\n\\tcontainer.style.cssText = \\\"border:0;width:8px;height:0;top:0;left:-9999px;\\\" +\\n\\t\\t\\\"padding:0;margin-top:1px;position:absolute\\\";\\n\\tcontainer.appendChild( div );\\n\\n\\tjQuery.extend( support, {\\n\\t\\tpixelPosition: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn pixelPositionVal;\\n\\t\\t},\\n\\t\\tboxSizingReliable: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn boxSizingReliableVal;\\n\\t\\t},\\n\\t\\tpixelMarginRight: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn pixelMarginRightVal;\\n\\t\\t},\\n\\t\\treliableMarginLeft: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn reliableMarginLeftVal;\\n\\t\\t}\\n\\t} );\\n} )();\\n\\n\\nfunction curCSS( elem, name, computed ) {\\n\\tvar width, minWidth, maxWidth, ret,\\n\\t\\tstyle = elem.style;\\n\\n\\tcomputed = computed || getStyles( elem );\\n\\n\\t// Support: IE <=9 only\\n\\t// getPropertyValue is only needed for .css('filter') (#12537)\\n\\tif ( computed ) {\\n\\t\\tret = computed.getPropertyValue( name ) || computed[ name ];\\n\\n\\t\\tif ( ret === \\\"\\\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\\n\\t\\t\\tret = jQuery.style( elem, name );\\n\\t\\t}\\n\\n\\t\\t// A tribute to the \\\"awesome hack by Dean Edwards\\\"\\n\\t\\t// Android Browser returns percentage for some values,\\n\\t\\t// but width seems to be reliably pixels.\\n\\t\\t// This is against the CSSOM draft spec:\\n\\t\\t// https://drafts.csswg.org/cssom/#resolved-values\\n\\t\\tif ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\\n\\n\\t\\t\\t// Remember the original values\\n\\t\\t\\twidth = style.width;\\n\\t\\t\\tminWidth = style.minWidth;\\n\\t\\t\\tmaxWidth = style.maxWidth;\\n\\n\\t\\t\\t// Put in the new values to get a computed value out\\n\\t\\t\\tstyle.minWidth = style.maxWidth = style.width = ret;\\n\\t\\t\\tret = computed.width;\\n\\n\\t\\t\\t// Revert the changed values\\n\\t\\t\\tstyle.width = width;\\n\\t\\t\\tstyle.minWidth = minWidth;\\n\\t\\t\\tstyle.maxWidth = maxWidth;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ret !== undefined ?\\n\\n\\t\\t// Support: IE <=9 - 11 only\\n\\t\\t// IE returns zIndex value as an integer.\\n\\t\\tret + \\\"\\\" :\\n\\t\\tret;\\n}\\n\\n\\nfunction addGetHookIf( conditionFn, hookFn ) {\\n\\n\\t// Define the hook, we'll check on the first run if it's really needed.\\n\\treturn {\\n\\t\\tget: function() {\\n\\t\\t\\tif ( conditionFn() ) {\\n\\n\\t\\t\\t\\t// Hook not needed (or it's not possible to use it due\\n\\t\\t\\t\\t// to missing dependency), remove it.\\n\\t\\t\\t\\tdelete this.get;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Hook needed; redefine it so that the support test is not executed again.\\n\\t\\t\\treturn ( this.get = hookFn ).apply( this, arguments );\\n\\t\\t}\\n\\t};\\n}\\n\\n\\nvar\\n\\n\\t// Swappable if display is none or starts with table\\n\\t// except \\\"table\\\", \\\"table-cell\\\", or \\\"table-caption\\\"\\n\\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\\n\\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\\n\\tcssShow = { position: \\\"absolute\\\", visibility: \\\"hidden\\\", display: \\\"block\\\" },\\n\\tcssNormalTransform = {\\n\\t\\tletterSpacing: \\\"0\\\",\\n\\t\\tfontWeight: \\\"400\\\"\\n\\t},\\n\\n\\tcssPrefixes = [ \\\"Webkit\\\", \\\"Moz\\\", \\\"ms\\\" ],\\n\\temptyStyle = document.createElement( \\\"div\\\" ).style;\\n\\n// Return a css property mapped to a potentially vendor prefixed property\\nfunction vendorPropName( name ) {\\n\\n\\t// Shortcut for names that are not vendor prefixed\\n\\tif ( name in emptyStyle ) {\\n\\t\\treturn name;\\n\\t}\\n\\n\\t// Check for vendor prefixed names\\n\\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\\n\\t\\ti = cssPrefixes.length;\\n\\n\\twhile ( i-- ) {\\n\\t\\tname = cssPrefixes[ i ] + capName;\\n\\t\\tif ( name in emptyStyle ) {\\n\\t\\t\\treturn name;\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction setPositiveNumber( elem, value, subtract ) {\\n\\n\\t// Any relative (+/-) values have already been\\n\\t// normalized at this point\\n\\tvar matches = rcssNum.exec( value );\\n\\treturn matches ?\\n\\n\\t\\t// Guard against undefined \\\"subtract\\\", e.g., when used as in cssHooks\\n\\t\\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \\\"px\\\" ) :\\n\\t\\tvalue;\\n}\\n\\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\\n\\tvar i,\\n\\t\\tval = 0;\\n\\n\\t// If we already have the right measurement, avoid augmentation\\n\\tif ( extra === ( isBorderBox ? \\\"border\\\" : \\\"content\\\" ) ) {\\n\\t\\ti = 4;\\n\\n\\t// Otherwise initialize for horizontal or vertical properties\\n\\t} else {\\n\\t\\ti = name === \\\"width\\\" ? 1 : 0;\\n\\t}\\n\\n\\tfor ( ; i < 4; i += 2 ) {\\n\\n\\t\\t// Both box models exclude margin, so add it if we want it\\n\\t\\tif ( extra === \\\"margin\\\" ) {\\n\\t\\t\\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\\n\\t\\t}\\n\\n\\t\\tif ( isBorderBox ) {\\n\\n\\t\\t\\t// border-box includes padding, so remove it if we want content\\n\\t\\t\\tif ( extra === \\\"content\\\" ) {\\n\\t\\t\\t\\tval -= jQuery.css( elem, \\\"padding\\\" + cssExpand[ i ], true, styles );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// At this point, extra isn't border nor margin, so remove border\\n\\t\\t\\tif ( extra !== \\\"margin\\\" ) {\\n\\t\\t\\t\\tval -= jQuery.css( elem, \\\"border\\\" + cssExpand[ i ] + \\\"Width\\\", true, styles );\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\n\\t\\t\\t// At this point, extra isn't content, so add padding\\n\\t\\t\\tval += jQuery.css( elem, \\\"padding\\\" + cssExpand[ i ], true, styles );\\n\\n\\t\\t\\t// At this point, extra isn't content nor padding, so add border\\n\\t\\t\\tif ( extra !== \\\"padding\\\" ) {\\n\\t\\t\\t\\tval += jQuery.css( elem, \\\"border\\\" + cssExpand[ i ] + \\\"Width\\\", true, styles );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn val;\\n}\\n\\nfunction getWidthOrHeight( elem, name, extra ) {\\n\\n\\t// Start with offset property, which is equivalent to the border-box value\\n\\tvar val,\\n\\t\\tvalueIsBorderBox = true,\\n\\t\\tstyles = getStyles( elem ),\\n\\t\\tisBorderBox = jQuery.css( elem, \\\"boxSizing\\\", false, styles ) === \\\"border-box\\\";\\n\\n\\t// Support: IE <=11 only\\n\\t// Running getBoundingClientRect on a disconnected node\\n\\t// in IE throws an error.\\n\\tif ( elem.getClientRects().length ) {\\n\\t\\tval = elem.getBoundingClientRect()[ name ];\\n\\t}\\n\\n\\t// Some non-html elements return undefined for offsetWidth, so check for null/undefined\\n\\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\\n\\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\\n\\tif ( val <= 0 || val == null ) {\\n\\n\\t\\t// Fall back to computed then uncomputed css if necessary\\n\\t\\tval = curCSS( elem, name, styles );\\n\\t\\tif ( val < 0 || val == null ) {\\n\\t\\t\\tval = elem.style[ name ];\\n\\t\\t}\\n\\n\\t\\t// Computed unit is not pixels. Stop here and return.\\n\\t\\tif ( rnumnonpx.test( val ) ) {\\n\\t\\t\\treturn val;\\n\\t\\t}\\n\\n\\t\\t// Check for style in case a browser which returns unreliable values\\n\\t\\t// for getComputedStyle silently falls back to the reliable elem.style\\n\\t\\tvalueIsBorderBox = isBorderBox &&\\n\\t\\t\\t( support.boxSizingReliable() || val === elem.style[ name ] );\\n\\n\\t\\t// Normalize \\\"\\\", auto, and prepare for extra\\n\\t\\tval = parseFloat( val ) || 0;\\n\\t}\\n\\n\\t// Use the active box-sizing model to add/subtract irrelevant styles\\n\\treturn ( val +\\n\\t\\taugmentWidthOrHeight(\\n\\t\\t\\telem,\\n\\t\\t\\tname,\\n\\t\\t\\textra || ( isBorderBox ? \\\"border\\\" : \\\"content\\\" ),\\n\\t\\t\\tvalueIsBorderBox,\\n\\t\\t\\tstyles\\n\\t\\t)\\n\\t) + \\\"px\\\";\\n}\\n\\njQuery.extend( {\\n\\n\\t// Add in style property hooks for overriding the default\\n\\t// behavior of getting and setting a style property\\n\\tcssHooks: {\\n\\t\\topacity: {\\n\\t\\t\\tget: function( elem, computed ) {\\n\\t\\t\\t\\tif ( computed ) {\\n\\n\\t\\t\\t\\t\\t// We should always get a number back from opacity\\n\\t\\t\\t\\t\\tvar ret = curCSS( elem, \\\"opacity\\\" );\\n\\t\\t\\t\\t\\treturn ret === \\\"\\\" ? \\\"1\\\" : ret;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\t// Don't automatically add \\\"px\\\" to these possibly-unitless properties\\n\\tcssNumber: {\\n\\t\\t\\\"animationIterationCount\\\": true,\\n\\t\\t\\\"columnCount\\\": true,\\n\\t\\t\\\"fillOpacity\\\": true,\\n\\t\\t\\\"flexGrow\\\": true,\\n\\t\\t\\\"flexShrink\\\": true,\\n\\t\\t\\\"fontWeight\\\": true,\\n\\t\\t\\\"lineHeight\\\": true,\\n\\t\\t\\\"opacity\\\": true,\\n\\t\\t\\\"order\\\": true,\\n\\t\\t\\\"orphans\\\": true,\\n\\t\\t\\\"widows\\\": true,\\n\\t\\t\\\"zIndex\\\": true,\\n\\t\\t\\\"zoom\\\": true\\n\\t},\\n\\n\\t// Add in properties whose names you wish to fix before\\n\\t// setting or getting the value\\n\\tcssProps: {\\n\\t\\t\\\"float\\\": \\\"cssFloat\\\"\\n\\t},\\n\\n\\t// Get and set the style property on a DOM Node\\n\\tstyle: function( elem, name, value, extra ) {\\n\\n\\t\\t// Don't set styles on text and comment nodes\\n\\t\\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Make sure that we're working with the right name\\n\\t\\tvar ret, type, hooks,\\n\\t\\t\\torigName = jQuery.camelCase( name ),\\n\\t\\t\\tstyle = elem.style;\\n\\n\\t\\tname = jQuery.cssProps[ origName ] ||\\n\\t\\t\\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\\n\\n\\t\\t// Gets hook for the prefixed version, then unprefixed version\\n\\t\\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\\n\\n\\t\\t// Check if we're setting a value\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\ttype = typeof value;\\n\\n\\t\\t\\t// Convert \\\"+=\\\" or \\\"-=\\\" to relative numbers (#7345)\\n\\t\\t\\tif ( type === \\\"string\\\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\\n\\t\\t\\t\\tvalue = adjustCSS( elem, name, ret );\\n\\n\\t\\t\\t\\t// Fixes bug #9237\\n\\t\\t\\t\\ttype = \\\"number\\\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Make sure that null and NaN values aren't set (#7116)\\n\\t\\t\\tif ( value == null || value !== value ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If a number was passed in, add the unit (except for certain CSS properties)\\n\\t\\t\\tif ( type === \\\"number\\\" ) {\\n\\t\\t\\t\\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \\\"\\\" : \\\"px\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// background-* props affect original clone's values\\n\\t\\t\\tif ( !support.clearCloneStyle && value === \\\"\\\" && name.indexOf( \\\"background\\\" ) === 0 ) {\\n\\t\\t\\t\\tstyle[ name ] = \\\"inherit\\\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If a hook was provided, use that value, otherwise just set the specified value\\n\\t\\t\\tif ( !hooks || !( \\\"set\\\" in hooks ) ||\\n\\t\\t\\t\\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\\n\\n\\t\\t\\t\\tstyle[ name ] = value;\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t// If a hook was provided get the non-computed value from there\\n\\t\\t\\tif ( hooks && \\\"get\\\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\\n\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Otherwise just get the value from the style object\\n\\t\\t\\treturn style[ name ];\\n\\t\\t}\\n\\t},\\n\\n\\tcss: function( elem, name, extra, styles ) {\\n\\t\\tvar val, num, hooks,\\n\\t\\t\\torigName = jQuery.camelCase( name );\\n\\n\\t\\t// Make sure that we're working with the right name\\n\\t\\tname = jQuery.cssProps[ origName ] ||\\n\\t\\t\\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\\n\\n\\t\\t// Try prefixed name followed by the unprefixed name\\n\\t\\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\\n\\n\\t\\t// If a hook was provided get the computed value from there\\n\\t\\tif ( hooks && \\\"get\\\" in hooks ) {\\n\\t\\t\\tval = hooks.get( elem, true, extra );\\n\\t\\t}\\n\\n\\t\\t// Otherwise, if a way to get the computed value exists, use that\\n\\t\\tif ( val === undefined ) {\\n\\t\\t\\tval = curCSS( elem, name, styles );\\n\\t\\t}\\n\\n\\t\\t// Convert \\\"normal\\\" to computed value\\n\\t\\tif ( val === \\\"normal\\\" && name in cssNormalTransform ) {\\n\\t\\t\\tval = cssNormalTransform[ name ];\\n\\t\\t}\\n\\n\\t\\t// Make numeric if forced or a qualifier was provided and val looks numeric\\n\\t\\tif ( extra === \\\"\\\" || extra ) {\\n\\t\\t\\tnum = parseFloat( val );\\n\\t\\t\\treturn extra === true || isFinite( num ) ? num || 0 : val;\\n\\t\\t}\\n\\t\\treturn val;\\n\\t}\\n} );\\n\\njQuery.each( [ \\\"height\\\", \\\"width\\\" ], function( i, name ) {\\n\\tjQuery.cssHooks[ name ] = {\\n\\t\\tget: function( elem, computed, extra ) {\\n\\t\\t\\tif ( computed ) {\\n\\n\\t\\t\\t\\t// Certain elements can have dimension info if we invisibly show them\\n\\t\\t\\t\\t// but it must have a current display style that would benefit\\n\\t\\t\\t\\treturn rdisplayswap.test( jQuery.css( elem, \\\"display\\\" ) ) &&\\n\\n\\t\\t\\t\\t\\t// Support: Safari 8+\\n\\t\\t\\t\\t\\t// Table columns in Safari have non-zero offsetWidth & zero\\n\\t\\t\\t\\t\\t// getBoundingClientRect().width unless display is changed.\\n\\t\\t\\t\\t\\t// Support: IE <=11 only\\n\\t\\t\\t\\t\\t// Running getBoundingClientRect on a disconnected node\\n\\t\\t\\t\\t\\t// in IE throws an error.\\n\\t\\t\\t\\t\\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\\n\\t\\t\\t\\t\\t\\tswap( elem, cssShow, function() {\\n\\t\\t\\t\\t\\t\\t\\treturn getWidthOrHeight( elem, name, extra );\\n\\t\\t\\t\\t\\t\\t} ) :\\n\\t\\t\\t\\t\\t\\tgetWidthOrHeight( elem, name, extra );\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tset: function( elem, value, extra ) {\\n\\t\\t\\tvar matches,\\n\\t\\t\\t\\tstyles = extra && getStyles( elem ),\\n\\t\\t\\t\\tsubtract = extra && augmentWidthOrHeight(\\n\\t\\t\\t\\t\\telem,\\n\\t\\t\\t\\t\\tname,\\n\\t\\t\\t\\t\\textra,\\n\\t\\t\\t\\t\\tjQuery.css( elem, \\\"boxSizing\\\", false, styles ) === \\\"border-box\\\",\\n\\t\\t\\t\\t\\tstyles\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t// Convert to pixels if value adjustment is needed\\n\\t\\t\\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\\n\\t\\t\\t\\t( matches[ 3 ] || \\\"px\\\" ) !== \\\"px\\\" ) {\\n\\n\\t\\t\\t\\telem.style[ name ] = value;\\n\\t\\t\\t\\tvalue = jQuery.css( elem, name );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn setPositiveNumber( elem, value, subtract );\\n\\t\\t}\\n\\t};\\n} );\\n\\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\\n\\tfunction( elem, computed ) {\\n\\t\\tif ( computed ) {\\n\\t\\t\\treturn ( parseFloat( curCSS( elem, \\\"marginLeft\\\" ) ) ||\\n\\t\\t\\t\\telem.getBoundingClientRect().left -\\n\\t\\t\\t\\t\\tswap( elem, { marginLeft: 0 }, function() {\\n\\t\\t\\t\\t\\t\\treturn elem.getBoundingClientRect().left;\\n\\t\\t\\t\\t\\t} )\\n\\t\\t\\t\\t) + \\\"px\\\";\\n\\t\\t}\\n\\t}\\n);\\n\\n// These hooks are used by animate to expand properties\\njQuery.each( {\\n\\tmargin: \\\"\\\",\\n\\tpadding: \\\"\\\",\\n\\tborder: \\\"Width\\\"\\n}, function( prefix, suffix ) {\\n\\tjQuery.cssHooks[ prefix + suffix ] = {\\n\\t\\texpand: function( value ) {\\n\\t\\t\\tvar i = 0,\\n\\t\\t\\t\\texpanded = {},\\n\\n\\t\\t\\t\\t// Assumes a single number if not a string\\n\\t\\t\\t\\tparts = typeof value === \\\"string\\\" ? value.split( \\\" \\\" ) : [ value ];\\n\\n\\t\\t\\tfor ( ; i < 4; i++ ) {\\n\\t\\t\\t\\texpanded[ prefix + cssExpand[ i ] + suffix ] =\\n\\t\\t\\t\\t\\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn expanded;\\n\\t\\t}\\n\\t};\\n\\n\\tif ( !rmargin.test( prefix ) ) {\\n\\t\\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tcss: function( name, value ) {\\n\\t\\treturn access( this, function( elem, name, value ) {\\n\\t\\t\\tvar styles, len,\\n\\t\\t\\t\\tmap = {},\\n\\t\\t\\t\\ti = 0;\\n\\n\\t\\t\\tif ( jQuery.isArray( name ) ) {\\n\\t\\t\\t\\tstyles = getStyles( elem );\\n\\t\\t\\t\\tlen = name.length;\\n\\n\\t\\t\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\t\\t\\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn map;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn value !== undefined ?\\n\\t\\t\\t\\tjQuery.style( elem, name, value ) :\\n\\t\\t\\t\\tjQuery.css( elem, name );\\n\\t\\t}, name, value, arguments.length > 1 );\\n\\t}\\n} );\\n\\n\\nfunction Tween( elem, options, prop, end, easing ) {\\n\\treturn new Tween.prototype.init( elem, options, prop, end, easing );\\n}\\njQuery.Tween = Tween;\\n\\nTween.prototype = {\\n\\tconstructor: Tween,\\n\\tinit: function( elem, options, prop, end, easing, unit ) {\\n\\t\\tthis.elem = elem;\\n\\t\\tthis.prop = prop;\\n\\t\\tthis.easing = easing || jQuery.easing._default;\\n\\t\\tthis.options = options;\\n\\t\\tthis.start = this.now = this.cur();\\n\\t\\tthis.end = end;\\n\\t\\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \\\"\\\" : \\\"px\\\" );\\n\\t},\\n\\tcur: function() {\\n\\t\\tvar hooks = Tween.propHooks[ this.prop ];\\n\\n\\t\\treturn hooks && hooks.get ?\\n\\t\\t\\thooks.get( this ) :\\n\\t\\t\\tTween.propHooks._default.get( this );\\n\\t},\\n\\trun: function( percent ) {\\n\\t\\tvar eased,\\n\\t\\t\\thooks = Tween.propHooks[ this.prop ];\\n\\n\\t\\tif ( this.options.duration ) {\\n\\t\\t\\tthis.pos = eased = jQuery.easing[ this.easing ](\\n\\t\\t\\t\\tpercent, this.options.duration * percent, 0, 1, this.options.duration\\n\\t\\t\\t);\\n\\t\\t} else {\\n\\t\\t\\tthis.pos = eased = percent;\\n\\t\\t}\\n\\t\\tthis.now = ( this.end - this.start ) * eased + this.start;\\n\\n\\t\\tif ( this.options.step ) {\\n\\t\\t\\tthis.options.step.call( this.elem, this.now, this );\\n\\t\\t}\\n\\n\\t\\tif ( hooks && hooks.set ) {\\n\\t\\t\\thooks.set( this );\\n\\t\\t} else {\\n\\t\\t\\tTween.propHooks._default.set( this );\\n\\t\\t}\\n\\t\\treturn this;\\n\\t}\\n};\\n\\nTween.prototype.init.prototype = Tween.prototype;\\n\\nTween.propHooks = {\\n\\t_default: {\\n\\t\\tget: function( tween ) {\\n\\t\\t\\tvar result;\\n\\n\\t\\t\\t// Use a property on the element directly when it is not a DOM element,\\n\\t\\t\\t// or when there is no matching style property that exists.\\n\\t\\t\\tif ( tween.elem.nodeType !== 1 ||\\n\\t\\t\\t\\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\\n\\t\\t\\t\\treturn tween.elem[ tween.prop ];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Passing an empty string as a 3rd parameter to .css will automatically\\n\\t\\t\\t// attempt a parseFloat and fallback to a string if the parse fails.\\n\\t\\t\\t// Simple values such as \\\"10px\\\" are parsed to Float;\\n\\t\\t\\t// complex values such as \\\"rotate(1rad)\\\" are returned as-is.\\n\\t\\t\\tresult = jQuery.css( tween.elem, tween.prop, \\\"\\\" );\\n\\n\\t\\t\\t// Empty strings, null, undefined and \\\"auto\\\" are converted to 0.\\n\\t\\t\\treturn !result || result === \\\"auto\\\" ? 0 : result;\\n\\t\\t},\\n\\t\\tset: function( tween ) {\\n\\n\\t\\t\\t// Use step hook for back compat.\\n\\t\\t\\t// Use cssHook if its there.\\n\\t\\t\\t// Use .style if available and use plain properties where available.\\n\\t\\t\\tif ( jQuery.fx.step[ tween.prop ] ) {\\n\\t\\t\\t\\tjQuery.fx.step[ tween.prop ]( tween );\\n\\t\\t\\t} else if ( tween.elem.nodeType === 1 &&\\n\\t\\t\\t\\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\\n\\t\\t\\t\\t\\tjQuery.cssHooks[ tween.prop ] ) ) {\\n\\t\\t\\t\\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttween.elem[ tween.prop ] = tween.now;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\n// Support: IE <=9 only\\n// Panic based approach to setting things on disconnected nodes\\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\\n\\tset: function( tween ) {\\n\\t\\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\\n\\t\\t\\ttween.elem[ tween.prop ] = tween.now;\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.easing = {\\n\\tlinear: function( p ) {\\n\\t\\treturn p;\\n\\t},\\n\\tswing: function( p ) {\\n\\t\\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\\n\\t},\\n\\t_default: \\\"swing\\\"\\n};\\n\\njQuery.fx = Tween.prototype.init;\\n\\n// Back compat <1.8 extension point\\njQuery.fx.step = {};\\n\\n\\n\\n\\nvar\\n\\tfxNow, timerId,\\n\\trfxtypes = /^(?:toggle|show|hide)$/,\\n\\trrun = /queueHooks$/;\\n\\nfunction raf() {\\n\\tif ( timerId ) {\\n\\t\\twindow.requestAnimationFrame( raf );\\n\\t\\tjQuery.fx.tick();\\n\\t}\\n}\\n\\n// Animations created synchronously will run synchronously\\nfunction createFxNow() {\\n\\twindow.setTimeout( function() {\\n\\t\\tfxNow = undefined;\\n\\t} );\\n\\treturn ( fxNow = jQuery.now() );\\n}\\n\\n// Generate parameters to create a standard animation\\nfunction genFx( type, includeWidth ) {\\n\\tvar which,\\n\\t\\ti = 0,\\n\\t\\tattrs = { height: type };\\n\\n\\t// If we include width, step value is 1 to do all cssExpand values,\\n\\t// otherwise step value is 2 to skip over Left and Right\\n\\tincludeWidth = includeWidth ? 1 : 0;\\n\\tfor ( ; i < 4; i += 2 - includeWidth ) {\\n\\t\\twhich = cssExpand[ i ];\\n\\t\\tattrs[ \\\"margin\\\" + which ] = attrs[ \\\"padding\\\" + which ] = type;\\n\\t}\\n\\n\\tif ( includeWidth ) {\\n\\t\\tattrs.opacity = attrs.width = type;\\n\\t}\\n\\n\\treturn attrs;\\n}\\n\\nfunction createTween( value, prop, animation ) {\\n\\tvar tween,\\n\\t\\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \\\"*\\\" ] ),\\n\\t\\tindex = 0,\\n\\t\\tlength = collection.length;\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\\n\\n\\t\\t\\t// We're done with this property\\n\\t\\t\\treturn tween;\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction defaultPrefilter( elem, props, opts ) {\\n\\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\\n\\t\\tisBox = \\\"width\\\" in props || \\\"height\\\" in props,\\n\\t\\tanim = this,\\n\\t\\torig = {},\\n\\t\\tstyle = elem.style,\\n\\t\\thidden = elem.nodeType && isHiddenWithinTree( elem ),\\n\\t\\tdataShow = dataPriv.get( elem, \\\"fxshow\\\" );\\n\\n\\t// Queue-skipping animations hijack the fx hooks\\n\\tif ( !opts.queue ) {\\n\\t\\thooks = jQuery._queueHooks( elem, \\\"fx\\\" );\\n\\t\\tif ( hooks.unqueued == null ) {\\n\\t\\t\\thooks.unqueued = 0;\\n\\t\\t\\toldfire = hooks.empty.fire;\\n\\t\\t\\thooks.empty.fire = function() {\\n\\t\\t\\t\\tif ( !hooks.unqueued ) {\\n\\t\\t\\t\\t\\toldfire();\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\thooks.unqueued++;\\n\\n\\t\\tanim.always( function() {\\n\\n\\t\\t\\t// Ensure the complete handler is called before this completes\\n\\t\\t\\tanim.always( function() {\\n\\t\\t\\t\\thooks.unqueued--;\\n\\t\\t\\t\\tif ( !jQuery.queue( elem, \\\"fx\\\" ).length ) {\\n\\t\\t\\t\\t\\thooks.empty.fire();\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t} );\\n\\t}\\n\\n\\t// Detect show/hide animations\\n\\tfor ( prop in props ) {\\n\\t\\tvalue = props[ prop ];\\n\\t\\tif ( rfxtypes.test( value ) ) {\\n\\t\\t\\tdelete props[ prop ];\\n\\t\\t\\ttoggle = toggle || value === \\\"toggle\\\";\\n\\t\\t\\tif ( value === ( hidden ? \\\"hide\\\" : \\\"show\\\" ) ) {\\n\\n\\t\\t\\t\\t// Pretend to be hidden if this is a \\\"show\\\" and\\n\\t\\t\\t\\t// there is still data from a stopped show/hide\\n\\t\\t\\t\\tif ( value === \\\"show\\\" && dataShow && dataShow[ prop ] !== undefined ) {\\n\\t\\t\\t\\t\\thidden = true;\\n\\n\\t\\t\\t\\t// Ignore all other no-op show/hide data\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\\n\\t\\t}\\n\\t}\\n\\n\\t// Bail out if this is a no-op like .hide().hide()\\n\\tpropTween = !jQuery.isEmptyObject( props );\\n\\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// Restrict \\\"overflow\\\" and \\\"display\\\" styles during box animations\\n\\tif ( isBox && elem.nodeType === 1 ) {\\n\\n\\t\\t// Support: IE <=9 - 11, Edge 12 - 13\\n\\t\\t// Record all 3 overflow attributes because IE does not infer the shorthand\\n\\t\\t// from identically-valued overflowX and overflowY\\n\\t\\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\\n\\n\\t\\t// Identify a display type, preferring old show/hide data over the CSS cascade\\n\\t\\trestoreDisplay = dataShow && dataShow.display;\\n\\t\\tif ( restoreDisplay == null ) {\\n\\t\\t\\trestoreDisplay = dataPriv.get( elem, \\\"display\\\" );\\n\\t\\t}\\n\\t\\tdisplay = jQuery.css( elem, \\\"display\\\" );\\n\\t\\tif ( display === \\\"none\\\" ) {\\n\\t\\t\\tif ( restoreDisplay ) {\\n\\t\\t\\t\\tdisplay = restoreDisplay;\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Get nonempty value(s) by temporarily forcing visibility\\n\\t\\t\\t\\tshowHide( [ elem ], true );\\n\\t\\t\\t\\trestoreDisplay = elem.style.display || restoreDisplay;\\n\\t\\t\\t\\tdisplay = jQuery.css( elem, \\\"display\\\" );\\n\\t\\t\\t\\tshowHide( [ elem ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Animate inline elements as inline-block\\n\\t\\tif ( display === \\\"inline\\\" || display === \\\"inline-block\\\" && restoreDisplay != null ) {\\n\\t\\t\\tif ( jQuery.css( elem, \\\"float\\\" ) === \\\"none\\\" ) {\\n\\n\\t\\t\\t\\t// Restore the original display value at the end of pure show/hide animations\\n\\t\\t\\t\\tif ( !propTween ) {\\n\\t\\t\\t\\t\\tanim.done( function() {\\n\\t\\t\\t\\t\\t\\tstyle.display = restoreDisplay;\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\tif ( restoreDisplay == null ) {\\n\\t\\t\\t\\t\\t\\tdisplay = style.display;\\n\\t\\t\\t\\t\\t\\trestoreDisplay = display === \\\"none\\\" ? \\\"\\\" : display;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstyle.display = \\\"inline-block\\\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif ( opts.overflow ) {\\n\\t\\tstyle.overflow = \\\"hidden\\\";\\n\\t\\tanim.always( function() {\\n\\t\\t\\tstyle.overflow = opts.overflow[ 0 ];\\n\\t\\t\\tstyle.overflowX = opts.overflow[ 1 ];\\n\\t\\t\\tstyle.overflowY = opts.overflow[ 2 ];\\n\\t\\t} );\\n\\t}\\n\\n\\t// Implement show/hide animations\\n\\tpropTween = false;\\n\\tfor ( prop in orig ) {\\n\\n\\t\\t// General show/hide setup for this element animation\\n\\t\\tif ( !propTween ) {\\n\\t\\t\\tif ( dataShow ) {\\n\\t\\t\\t\\tif ( \\\"hidden\\\" in dataShow ) {\\n\\t\\t\\t\\t\\thidden = dataShow.hidden;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdataShow = dataPriv.access( elem, \\\"fxshow\\\", { display: restoreDisplay } );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Store hidden/visible for toggle so `.stop().toggle()` \\\"reverses\\\"\\n\\t\\t\\tif ( toggle ) {\\n\\t\\t\\t\\tdataShow.hidden = !hidden;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Show elements before animating them\\n\\t\\t\\tif ( hidden ) {\\n\\t\\t\\t\\tshowHide( [ elem ], true );\\n\\t\\t\\t}\\n\\n\\t\\t\\t/* eslint-disable no-loop-func */\\n\\n\\t\\t\\tanim.done( function() {\\n\\n\\t\\t\\t/* eslint-enable no-loop-func */\\n\\n\\t\\t\\t\\t// The final step of a \\\"hide\\\" animation is actually hiding the element\\n\\t\\t\\t\\tif ( !hidden ) {\\n\\t\\t\\t\\t\\tshowHide( [ elem ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdataPriv.remove( elem, \\\"fxshow\\\" );\\n\\t\\t\\t\\tfor ( prop in orig ) {\\n\\t\\t\\t\\t\\tjQuery.style( elem, prop, orig[ prop ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\t// Per-property setup\\n\\t\\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\\n\\t\\tif ( !( prop in dataShow ) ) {\\n\\t\\t\\tdataShow[ prop ] = propTween.start;\\n\\t\\t\\tif ( hidden ) {\\n\\t\\t\\t\\tpropTween.end = propTween.start;\\n\\t\\t\\t\\tpropTween.start = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction propFilter( props, specialEasing ) {\\n\\tvar index, name, easing, value, hooks;\\n\\n\\t// camelCase, specialEasing and expand cssHook pass\\n\\tfor ( index in props ) {\\n\\t\\tname = jQuery.camelCase( index );\\n\\t\\teasing = specialEasing[ name ];\\n\\t\\tvalue = props[ index ];\\n\\t\\tif ( jQuery.isArray( value ) ) {\\n\\t\\t\\teasing = value[ 1 ];\\n\\t\\t\\tvalue = props[ index ] = value[ 0 ];\\n\\t\\t}\\n\\n\\t\\tif ( index !== name ) {\\n\\t\\t\\tprops[ name ] = value;\\n\\t\\t\\tdelete props[ index ];\\n\\t\\t}\\n\\n\\t\\thooks = jQuery.cssHooks[ name ];\\n\\t\\tif ( hooks && \\\"expand\\\" in hooks ) {\\n\\t\\t\\tvalue = hooks.expand( value );\\n\\t\\t\\tdelete props[ name ];\\n\\n\\t\\t\\t// Not quite $.extend, this won't overwrite existing keys.\\n\\t\\t\\t// Reusing 'index' because we have the correct \\\"name\\\"\\n\\t\\t\\tfor ( index in value ) {\\n\\t\\t\\t\\tif ( !( index in props ) ) {\\n\\t\\t\\t\\t\\tprops[ index ] = value[ index ];\\n\\t\\t\\t\\t\\tspecialEasing[ index ] = easing;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tspecialEasing[ name ] = easing;\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction Animation( elem, properties, options ) {\\n\\tvar result,\\n\\t\\tstopped,\\n\\t\\tindex = 0,\\n\\t\\tlength = Animation.prefilters.length,\\n\\t\\tdeferred = jQuery.Deferred().always( function() {\\n\\n\\t\\t\\t// Don't match elem in the :animated selector\\n\\t\\t\\tdelete tick.elem;\\n\\t\\t} ),\\n\\t\\ttick = function() {\\n\\t\\t\\tif ( stopped ) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tvar currentTime = fxNow || createFxNow(),\\n\\t\\t\\t\\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\\n\\n\\t\\t\\t\\t// Support: Android 2.3 only\\n\\t\\t\\t\\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\\n\\t\\t\\t\\ttemp = remaining / animation.duration || 0,\\n\\t\\t\\t\\tpercent = 1 - temp,\\n\\t\\t\\t\\tindex = 0,\\n\\t\\t\\t\\tlength = animation.tweens.length;\\n\\n\\t\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\t\\tanimation.tweens[ index ].run( percent );\\n\\t\\t\\t}\\n\\n\\t\\t\\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\\n\\n\\t\\t\\tif ( percent < 1 && length ) {\\n\\t\\t\\t\\treturn remaining;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdeferred.resolveWith( elem, [ animation ] );\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tanimation = deferred.promise( {\\n\\t\\t\\telem: elem,\\n\\t\\t\\tprops: jQuery.extend( {}, properties ),\\n\\t\\t\\topts: jQuery.extend( true, {\\n\\t\\t\\t\\tspecialEasing: {},\\n\\t\\t\\t\\teasing: jQuery.easing._default\\n\\t\\t\\t}, options ),\\n\\t\\t\\toriginalProperties: properties,\\n\\t\\t\\toriginalOptions: options,\\n\\t\\t\\tstartTime: fxNow || createFxNow(),\\n\\t\\t\\tduration: options.duration,\\n\\t\\t\\ttweens: [],\\n\\t\\t\\tcreateTween: function( prop, end ) {\\n\\t\\t\\t\\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\\n\\t\\t\\t\\t\\t\\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\\n\\t\\t\\t\\tanimation.tweens.push( tween );\\n\\t\\t\\t\\treturn tween;\\n\\t\\t\\t},\\n\\t\\t\\tstop: function( gotoEnd ) {\\n\\t\\t\\t\\tvar index = 0,\\n\\n\\t\\t\\t\\t\\t// If we are going to the end, we want to run all the tweens\\n\\t\\t\\t\\t\\t// otherwise we skip this part\\n\\t\\t\\t\\t\\tlength = gotoEnd ? animation.tweens.length : 0;\\n\\t\\t\\t\\tif ( stopped ) {\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstopped = true;\\n\\t\\t\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\t\\t\\tanimation.tweens[ index ].run( 1 );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Resolve when we played the last frame; otherwise, reject\\n\\t\\t\\t\\tif ( gotoEnd ) {\\n\\t\\t\\t\\t\\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\\n\\t\\t\\t\\t\\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t} ),\\n\\t\\tprops = animation.props;\\n\\n\\tpropFilter( props, animation.opts.specialEasing );\\n\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\\n\\t\\tif ( result ) {\\n\\t\\t\\tif ( jQuery.isFunction( result.stop ) ) {\\n\\t\\t\\t\\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\\n\\t\\t\\t\\t\\tjQuery.proxy( result.stop, result );\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\n\\tjQuery.map( props, createTween, animation );\\n\\n\\tif ( jQuery.isFunction( animation.opts.start ) ) {\\n\\t\\tanimation.opts.start.call( elem, animation );\\n\\t}\\n\\n\\tjQuery.fx.timer(\\n\\t\\tjQuery.extend( tick, {\\n\\t\\t\\telem: elem,\\n\\t\\t\\tanim: animation,\\n\\t\\t\\tqueue: animation.opts.queue\\n\\t\\t} )\\n\\t);\\n\\n\\t// attach callbacks from options\\n\\treturn animation.progress( animation.opts.progress )\\n\\t\\t.done( animation.opts.done, animation.opts.complete )\\n\\t\\t.fail( animation.opts.fail )\\n\\t\\t.always( animation.opts.always );\\n}\\n\\njQuery.Animation = jQuery.extend( Animation, {\\n\\n\\ttweeners: {\\n\\t\\t\\\"*\\\": [ function( prop, value ) {\\n\\t\\t\\tvar tween = this.createTween( prop, value );\\n\\t\\t\\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\\n\\t\\t\\treturn tween;\\n\\t\\t} ]\\n\\t},\\n\\n\\ttweener: function( props, callback ) {\\n\\t\\tif ( jQuery.isFunction( props ) ) {\\n\\t\\t\\tcallback = props;\\n\\t\\t\\tprops = [ \\\"*\\\" ];\\n\\t\\t} else {\\n\\t\\t\\tprops = props.match( rnothtmlwhite );\\n\\t\\t}\\n\\n\\t\\tvar prop,\\n\\t\\t\\tindex = 0,\\n\\t\\t\\tlength = props.length;\\n\\n\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\tprop = props[ index ];\\n\\t\\t\\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\\n\\t\\t\\tAnimation.tweeners[ prop ].unshift( callback );\\n\\t\\t}\\n\\t},\\n\\n\\tprefilters: [ defaultPrefilter ],\\n\\n\\tprefilter: function( callback, prepend ) {\\n\\t\\tif ( prepend ) {\\n\\t\\t\\tAnimation.prefilters.unshift( callback );\\n\\t\\t} else {\\n\\t\\t\\tAnimation.prefilters.push( callback );\\n\\t\\t}\\n\\t}\\n} );\\n\\njQuery.speed = function( speed, easing, fn ) {\\n\\tvar opt = speed && typeof speed === \\\"object\\\" ? jQuery.extend( {}, speed ) : {\\n\\t\\tcomplete: fn || !fn && easing ||\\n\\t\\t\\tjQuery.isFunction( speed ) && speed,\\n\\t\\tduration: speed,\\n\\t\\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\\n\\t};\\n\\n\\t// Go to the end state if fx are off or if document is hidden\\n\\tif ( jQuery.fx.off || document.hidden ) {\\n\\t\\topt.duration = 0;\\n\\n\\t} else {\\n\\t\\tif ( typeof opt.duration !== \\\"number\\\" ) {\\n\\t\\t\\tif ( opt.duration in jQuery.fx.speeds ) {\\n\\t\\t\\t\\topt.duration = jQuery.fx.speeds[ opt.duration ];\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\topt.duration = jQuery.fx.speeds._default;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Normalize opt.queue - true/undefined/null -> \\\"fx\\\"\\n\\tif ( opt.queue == null || opt.queue === true ) {\\n\\t\\topt.queue = \\\"fx\\\";\\n\\t}\\n\\n\\t// Queueing\\n\\topt.old = opt.complete;\\n\\n\\topt.complete = function() {\\n\\t\\tif ( jQuery.isFunction( opt.old ) ) {\\n\\t\\t\\topt.old.call( this );\\n\\t\\t}\\n\\n\\t\\tif ( opt.queue ) {\\n\\t\\t\\tjQuery.dequeue( this, opt.queue );\\n\\t\\t}\\n\\t};\\n\\n\\treturn opt;\\n};\\n\\njQuery.fn.extend( {\\n\\tfadeTo: function( speed, to, easing, callback ) {\\n\\n\\t\\t// Show any hidden elements after setting opacity to 0\\n\\t\\treturn this.filter( isHiddenWithinTree ).css( \\\"opacity\\\", 0 ).show()\\n\\n\\t\\t\\t// Animate to the value specified\\n\\t\\t\\t.end().animate( { opacity: to }, speed, easing, callback );\\n\\t},\\n\\tanimate: function( prop, speed, easing, callback ) {\\n\\t\\tvar empty = jQuery.isEmptyObject( prop ),\\n\\t\\t\\toptall = jQuery.speed( speed, easing, callback ),\\n\\t\\t\\tdoAnimation = function() {\\n\\n\\t\\t\\t\\t// Operate on a copy of prop so per-property easing won't be lost\\n\\t\\t\\t\\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\\n\\n\\t\\t\\t\\t// Empty animations, or finishing resolves immediately\\n\\t\\t\\t\\tif ( empty || dataPriv.get( this, \\\"finish\\\" ) ) {\\n\\t\\t\\t\\t\\tanim.stop( true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tdoAnimation.finish = doAnimation;\\n\\n\\t\\treturn empty || optall.queue === false ?\\n\\t\\t\\tthis.each( doAnimation ) :\\n\\t\\t\\tthis.queue( optall.queue, doAnimation );\\n\\t},\\n\\tstop: function( type, clearQueue, gotoEnd ) {\\n\\t\\tvar stopQueue = function( hooks ) {\\n\\t\\t\\tvar stop = hooks.stop;\\n\\t\\t\\tdelete hooks.stop;\\n\\t\\t\\tstop( gotoEnd );\\n\\t\\t};\\n\\n\\t\\tif ( typeof type !== \\\"string\\\" ) {\\n\\t\\t\\tgotoEnd = clearQueue;\\n\\t\\t\\tclearQueue = type;\\n\\t\\t\\ttype = undefined;\\n\\t\\t}\\n\\t\\tif ( clearQueue && type !== false ) {\\n\\t\\t\\tthis.queue( type || \\\"fx\\\", [] );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar dequeue = true,\\n\\t\\t\\t\\tindex = type != null && type + \\\"queueHooks\\\",\\n\\t\\t\\t\\ttimers = jQuery.timers,\\n\\t\\t\\t\\tdata = dataPriv.get( this );\\n\\n\\t\\t\\tif ( index ) {\\n\\t\\t\\t\\tif ( data[ index ] && data[ index ].stop ) {\\n\\t\\t\\t\\t\\tstopQueue( data[ index ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor ( index in data ) {\\n\\t\\t\\t\\t\\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\\n\\t\\t\\t\\t\\t\\tstopQueue( data[ index ] );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( index = timers.length; index--; ) {\\n\\t\\t\\t\\tif ( timers[ index ].elem === this &&\\n\\t\\t\\t\\t\\t( type == null || timers[ index ].queue === type ) ) {\\n\\n\\t\\t\\t\\t\\ttimers[ index ].anim.stop( gotoEnd );\\n\\t\\t\\t\\t\\tdequeue = false;\\n\\t\\t\\t\\t\\ttimers.splice( index, 1 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Start the next in the queue if the last step wasn't forced.\\n\\t\\t\\t// Timers currently will call their complete callbacks, which\\n\\t\\t\\t// will dequeue but only if they were gotoEnd.\\n\\t\\t\\tif ( dequeue || !gotoEnd ) {\\n\\t\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\tfinish: function( type ) {\\n\\t\\tif ( type !== false ) {\\n\\t\\t\\ttype = type || \\\"fx\\\";\\n\\t\\t}\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar index,\\n\\t\\t\\t\\tdata = dataPriv.get( this ),\\n\\t\\t\\t\\tqueue = data[ type + \\\"queue\\\" ],\\n\\t\\t\\t\\thooks = data[ type + \\\"queueHooks\\\" ],\\n\\t\\t\\t\\ttimers = jQuery.timers,\\n\\t\\t\\t\\tlength = queue ? queue.length : 0;\\n\\n\\t\\t\\t// Enable finishing flag on private data\\n\\t\\t\\tdata.finish = true;\\n\\n\\t\\t\\t// Empty the queue first\\n\\t\\t\\tjQuery.queue( this, type, [] );\\n\\n\\t\\t\\tif ( hooks && hooks.stop ) {\\n\\t\\t\\t\\thooks.stop.call( this, true );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Look for any active animations, and finish them\\n\\t\\t\\tfor ( index = timers.length; index--; ) {\\n\\t\\t\\t\\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\\n\\t\\t\\t\\t\\ttimers[ index ].anim.stop( true );\\n\\t\\t\\t\\t\\ttimers.splice( index, 1 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Look for any animations in the old queue and finish them\\n\\t\\t\\tfor ( index = 0; index < length; index++ ) {\\n\\t\\t\\t\\tif ( queue[ index ] && queue[ index ].finish ) {\\n\\t\\t\\t\\t\\tqueue[ index ].finish.call( this );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Turn off finishing flag\\n\\t\\t\\tdelete data.finish;\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.each( [ \\\"toggle\\\", \\\"show\\\", \\\"hide\\\" ], function( i, name ) {\\n\\tvar cssFn = jQuery.fn[ name ];\\n\\tjQuery.fn[ name ] = function( speed, easing, callback ) {\\n\\t\\treturn speed == null || typeof speed === \\\"boolean\\\" ?\\n\\t\\t\\tcssFn.apply( this, arguments ) :\\n\\t\\t\\tthis.animate( genFx( name, true ), speed, easing, callback );\\n\\t};\\n} );\\n\\n// Generate shortcuts for custom animations\\njQuery.each( {\\n\\tslideDown: genFx( \\\"show\\\" ),\\n\\tslideUp: genFx( \\\"hide\\\" ),\\n\\tslideToggle: genFx( \\\"toggle\\\" ),\\n\\tfadeIn: { opacity: \\\"show\\\" },\\n\\tfadeOut: { opacity: \\\"hide\\\" },\\n\\tfadeToggle: { opacity: \\\"toggle\\\" }\\n}, function( name, props ) {\\n\\tjQuery.fn[ name ] = function( speed, easing, callback ) {\\n\\t\\treturn this.animate( props, speed, easing, callback );\\n\\t};\\n} );\\n\\njQuery.timers = [];\\njQuery.fx.tick = function() {\\n\\tvar timer,\\n\\t\\ti = 0,\\n\\t\\ttimers = jQuery.timers;\\n\\n\\tfxNow = jQuery.now();\\n\\n\\tfor ( ; i < timers.length; i++ ) {\\n\\t\\ttimer = timers[ i ];\\n\\n\\t\\t// Checks the timer has not already been removed\\n\\t\\tif ( !timer() && timers[ i ] === timer ) {\\n\\t\\t\\ttimers.splice( i--, 1 );\\n\\t\\t}\\n\\t}\\n\\n\\tif ( !timers.length ) {\\n\\t\\tjQuery.fx.stop();\\n\\t}\\n\\tfxNow = undefined;\\n};\\n\\njQuery.fx.timer = function( timer ) {\\n\\tjQuery.timers.push( timer );\\n\\tif ( timer() ) {\\n\\t\\tjQuery.fx.start();\\n\\t} else {\\n\\t\\tjQuery.timers.pop();\\n\\t}\\n};\\n\\njQuery.fx.interval = 13;\\njQuery.fx.start = function() {\\n\\tif ( !timerId ) {\\n\\t\\ttimerId = window.requestAnimationFrame ?\\n\\t\\t\\twindow.requestAnimationFrame( raf ) :\\n\\t\\t\\twindow.setInterval( jQuery.fx.tick, jQuery.fx.interval );\\n\\t}\\n};\\n\\njQuery.fx.stop = function() {\\n\\tif ( window.cancelAnimationFrame ) {\\n\\t\\twindow.cancelAnimationFrame( timerId );\\n\\t} else {\\n\\t\\twindow.clearInterval( timerId );\\n\\t}\\n\\n\\ttimerId = null;\\n};\\n\\njQuery.fx.speeds = {\\n\\tslow: 600,\\n\\tfast: 200,\\n\\n\\t// Default speed\\n\\t_default: 400\\n};\\n\\n\\n// Based off of the plugin by Clint Helfers, with permission.\\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\\njQuery.fn.delay = function( time, type ) {\\n\\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\\n\\ttype = type || \\\"fx\\\";\\n\\n\\treturn this.queue( type, function( next, hooks ) {\\n\\t\\tvar timeout = window.setTimeout( next, time );\\n\\t\\thooks.stop = function() {\\n\\t\\t\\twindow.clearTimeout( timeout );\\n\\t\\t};\\n\\t} );\\n};\\n\\n\\n( function() {\\n\\tvar input = document.createElement( \\\"input\\\" ),\\n\\t\\tselect = document.createElement( \\\"select\\\" ),\\n\\t\\topt = select.appendChild( document.createElement( \\\"option\\\" ) );\\n\\n\\tinput.type = \\\"checkbox\\\";\\n\\n\\t// Support: Android <=4.3 only\\n\\t// Default value for a checkbox should be \\\"on\\\"\\n\\tsupport.checkOn = input.value !== \\\"\\\";\\n\\n\\t// Support: IE <=11 only\\n\\t// Must access selectedIndex to make default options select\\n\\tsupport.optSelected = opt.selected;\\n\\n\\t// Support: IE <=11 only\\n\\t// An input loses its value after becoming a radio\\n\\tinput = document.createElement( \\\"input\\\" );\\n\\tinput.value = \\\"t\\\";\\n\\tinput.type = \\\"radio\\\";\\n\\tsupport.radioValue = input.value === \\\"t\\\";\\n} )();\\n\\n\\nvar boolHook,\\n\\tattrHandle = jQuery.expr.attrHandle;\\n\\njQuery.fn.extend( {\\n\\tattr: function( name, value ) {\\n\\t\\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\\n\\t},\\n\\n\\tremoveAttr: function( name ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.removeAttr( this, name );\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tattr: function( elem, name, value ) {\\n\\t\\tvar ret, hooks,\\n\\t\\t\\tnType = elem.nodeType;\\n\\n\\t\\t// Don't get/set attributes on text, comment and attribute nodes\\n\\t\\tif ( nType === 3 || nType === 8 || nType === 2 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Fallback to prop when attributes are not supported\\n\\t\\tif ( typeof elem.getAttribute === \\\"undefined\\\" ) {\\n\\t\\t\\treturn jQuery.prop( elem, name, value );\\n\\t\\t}\\n\\n\\t\\t// Attribute hooks are determined by the lowercase version\\n\\t\\t// Grab necessary hook if one is defined\\n\\t\\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\\n\\t\\t\\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\\n\\t\\t\\t\\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\\n\\t\\t}\\n\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\tif ( value === null ) {\\n\\t\\t\\t\\tjQuery.removeAttr( elem, name );\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( hooks && \\\"set\\\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\telem.setAttribute( name, value + \\\"\\\" );\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\n\\t\\tif ( hooks && \\\"get\\\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\n\\t\\tret = jQuery.find.attr( elem, name );\\n\\n\\t\\t// Non-existent attributes return null, we normalize to undefined\\n\\t\\treturn ret == null ? undefined : ret;\\n\\t},\\n\\n\\tattrHooks: {\\n\\t\\ttype: {\\n\\t\\t\\tset: function( elem, value ) {\\n\\t\\t\\t\\tif ( !support.radioValue && value === \\\"radio\\\" &&\\n\\t\\t\\t\\t\\tjQuery.nodeName( elem, \\\"input\\\" ) ) {\\n\\t\\t\\t\\t\\tvar val = elem.value;\\n\\t\\t\\t\\t\\telem.setAttribute( \\\"type\\\", value );\\n\\t\\t\\t\\t\\tif ( val ) {\\n\\t\\t\\t\\t\\t\\telem.value = val;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\tremoveAttr: function( elem, value ) {\\n\\t\\tvar name,\\n\\t\\t\\ti = 0,\\n\\n\\t\\t\\t// Attribute names can contain non-HTML whitespace characters\\n\\t\\t\\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\\n\\t\\t\\tattrNames = value && value.match( rnothtmlwhite );\\n\\n\\t\\tif ( attrNames && elem.nodeType === 1 ) {\\n\\t\\t\\twhile ( ( name = attrNames[ i++ ] ) ) {\\n\\t\\t\\t\\telem.removeAttribute( name );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Hooks for boolean attributes\\nboolHook = {\\n\\tset: function( elem, value, name ) {\\n\\t\\tif ( value === false ) {\\n\\n\\t\\t\\t// Remove boolean attributes when set to false\\n\\t\\t\\tjQuery.removeAttr( elem, name );\\n\\t\\t} else {\\n\\t\\t\\telem.setAttribute( name, name );\\n\\t\\t}\\n\\t\\treturn name;\\n\\t}\\n};\\n\\njQuery.each( jQuery.expr.match.bool.source.match( /\\\\w+/g ), function( i, name ) {\\n\\tvar getter = attrHandle[ name ] || jQuery.find.attr;\\n\\n\\tattrHandle[ name ] = function( elem, name, isXML ) {\\n\\t\\tvar ret, handle,\\n\\t\\t\\tlowercaseName = name.toLowerCase();\\n\\n\\t\\tif ( !isXML ) {\\n\\n\\t\\t\\t// Avoid an infinite loop by temporarily removing this function from the getter\\n\\t\\t\\thandle = attrHandle[ lowercaseName ];\\n\\t\\t\\tattrHandle[ lowercaseName ] = ret;\\n\\t\\t\\tret = getter( elem, name, isXML ) != null ?\\n\\t\\t\\t\\tlowercaseName :\\n\\t\\t\\t\\tnull;\\n\\t\\t\\tattrHandle[ lowercaseName ] = handle;\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t};\\n} );\\n\\n\\n\\n\\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\\n\\trclickable = /^(?:a|area)$/i;\\n\\njQuery.fn.extend( {\\n\\tprop: function( name, value ) {\\n\\t\\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\\n\\t},\\n\\n\\tremoveProp: function( name ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tdelete this[ jQuery.propFix[ name ] || name ];\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tprop: function( elem, name, value ) {\\n\\t\\tvar ret, hooks,\\n\\t\\t\\tnType = elem.nodeType;\\n\\n\\t\\t// Don't get/set properties on text, comment and attribute nodes\\n\\t\\tif ( nType === 3 || nType === 8 || nType === 2 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\\n\\n\\t\\t\\t// Fix name and attach hooks\\n\\t\\t\\tname = jQuery.propFix[ name ] || name;\\n\\t\\t\\thooks = jQuery.propHooks[ name ];\\n\\t\\t}\\n\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\tif ( hooks && \\\"set\\\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ( elem[ name ] = value );\\n\\t\\t}\\n\\n\\t\\tif ( hooks && \\\"get\\\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\n\\t\\treturn elem[ name ];\\n\\t},\\n\\n\\tpropHooks: {\\n\\t\\ttabIndex: {\\n\\t\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t\\t// Support: IE <=9 - 11 only\\n\\t\\t\\t\\t// elem.tabIndex doesn't always return the\\n\\t\\t\\t\\t// correct value when it hasn't been explicitly set\\n\\t\\t\\t\\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\\n\\t\\t\\t\\t// Use proper attribute retrieval(#12072)\\n\\t\\t\\t\\tvar tabindex = jQuery.find.attr( elem, \\\"tabindex\\\" );\\n\\n\\t\\t\\t\\tif ( tabindex ) {\\n\\t\\t\\t\\t\\treturn parseInt( tabindex, 10 );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\trfocusable.test( elem.nodeName ) ||\\n\\t\\t\\t\\t\\trclickable.test( elem.nodeName ) &&\\n\\t\\t\\t\\t\\telem.href\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\tpropFix: {\\n\\t\\t\\\"for\\\": \\\"htmlFor\\\",\\n\\t\\t\\\"class\\\": \\\"className\\\"\\n\\t}\\n} );\\n\\n// Support: IE <=11 only\\n// Accessing the selectedIndex property\\n// forces the browser to respect setting selected\\n// on the option\\n// The getter ensures a default option is selected\\n// when in an optgroup\\n// eslint rule \\\"no-unused-expressions\\\" is disabled for this code\\n// since it considers such accessions noop\\nif ( !support.optSelected ) {\\n\\tjQuery.propHooks.selected = {\\n\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t/* eslint no-unused-expressions: \\\"off\\\" */\\n\\n\\t\\t\\tvar parent = elem.parentNode;\\n\\t\\t\\tif ( parent && parent.parentNode ) {\\n\\t\\t\\t\\tparent.parentNode.selectedIndex;\\n\\t\\t\\t}\\n\\t\\t\\treturn null;\\n\\t\\t},\\n\\t\\tset: function( elem ) {\\n\\n\\t\\t\\t/* eslint no-unused-expressions: \\\"off\\\" */\\n\\n\\t\\t\\tvar parent = elem.parentNode;\\n\\t\\t\\tif ( parent ) {\\n\\t\\t\\t\\tparent.selectedIndex;\\n\\n\\t\\t\\t\\tif ( parent.parentNode ) {\\n\\t\\t\\t\\t\\tparent.parentNode.selectedIndex;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n}\\n\\njQuery.each( [\\n\\t\\\"tabIndex\\\",\\n\\t\\\"readOnly\\\",\\n\\t\\\"maxLength\\\",\\n\\t\\\"cellSpacing\\\",\\n\\t\\\"cellPadding\\\",\\n\\t\\\"rowSpan\\\",\\n\\t\\\"colSpan\\\",\\n\\t\\\"useMap\\\",\\n\\t\\\"frameBorder\\\",\\n\\t\\\"contentEditable\\\"\\n], function() {\\n\\tjQuery.propFix[ this.toLowerCase() ] = this;\\n} );\\n\\n\\n\\n\\n\\t// Strip and collapse whitespace according to HTML spec\\n\\t// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\\n\\tfunction stripAndCollapse( value ) {\\n\\t\\tvar tokens = value.match( rnothtmlwhite ) || [];\\n\\t\\treturn tokens.join( \\\" \\\" );\\n\\t}\\n\\n\\nfunction getClass( elem ) {\\n\\treturn elem.getAttribute && elem.getAttribute( \\\"class\\\" ) || \\\"\\\";\\n}\\n\\njQuery.fn.extend( {\\n\\taddClass: function( value ) {\\n\\t\\tvar classes, elem, cur, curValue, clazz, j, finalValue,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tif ( jQuery.isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( j ) {\\n\\t\\t\\t\\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tif ( typeof value === \\\"string\\\" && value ) {\\n\\t\\t\\tclasses = value.match( rnothtmlwhite ) || [];\\n\\n\\t\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\t\\tcurValue = getClass( elem );\\n\\t\\t\\t\\tcur = elem.nodeType === 1 && ( \\\" \\\" + stripAndCollapse( curValue ) + \\\" \\\" );\\n\\n\\t\\t\\t\\tif ( cur ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\twhile ( ( clazz = classes[ j++ ] ) ) {\\n\\t\\t\\t\\t\\t\\tif ( cur.indexOf( \\\" \\\" + clazz + \\\" \\\" ) < 0 ) {\\n\\t\\t\\t\\t\\t\\t\\tcur += clazz + \\\" \\\";\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Only assign if different to avoid unneeded rendering.\\n\\t\\t\\t\\t\\tfinalValue = stripAndCollapse( cur );\\n\\t\\t\\t\\t\\tif ( curValue !== finalValue ) {\\n\\t\\t\\t\\t\\t\\telem.setAttribute( \\\"class\\\", finalValue );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\tremoveClass: function( value ) {\\n\\t\\tvar classes, elem, cur, curValue, clazz, j, finalValue,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tif ( jQuery.isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( j ) {\\n\\t\\t\\t\\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tif ( !arguments.length ) {\\n\\t\\t\\treturn this.attr( \\\"class\\\", \\\"\\\" );\\n\\t\\t}\\n\\n\\t\\tif ( typeof value === \\\"string\\\" && value ) {\\n\\t\\t\\tclasses = value.match( rnothtmlwhite ) || [];\\n\\n\\t\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\t\\tcurValue = getClass( elem );\\n\\n\\t\\t\\t\\t// This expression is here for better compressibility (see addClass)\\n\\t\\t\\t\\tcur = elem.nodeType === 1 && ( \\\" \\\" + stripAndCollapse( curValue ) + \\\" \\\" );\\n\\n\\t\\t\\t\\tif ( cur ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\twhile ( ( clazz = classes[ j++ ] ) ) {\\n\\n\\t\\t\\t\\t\\t\\t// Remove *all* instances\\n\\t\\t\\t\\t\\t\\twhile ( cur.indexOf( \\\" \\\" + clazz + \\\" \\\" ) > -1 ) {\\n\\t\\t\\t\\t\\t\\t\\tcur = cur.replace( \\\" \\\" + clazz + \\\" \\\", \\\" \\\" );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Only assign if different to avoid unneeded rendering.\\n\\t\\t\\t\\t\\tfinalValue = stripAndCollapse( cur );\\n\\t\\t\\t\\t\\tif ( curValue !== finalValue ) {\\n\\t\\t\\t\\t\\t\\telem.setAttribute( \\\"class\\\", finalValue );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\ttoggleClass: function( value, stateVal ) {\\n\\t\\tvar type = typeof value;\\n\\n\\t\\tif ( typeof stateVal === \\\"boolean\\\" && type === \\\"string\\\" ) {\\n\\t\\t\\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\\n\\t\\t}\\n\\n\\t\\tif ( jQuery.isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( i ) {\\n\\t\\t\\t\\tjQuery( this ).toggleClass(\\n\\t\\t\\t\\t\\tvalue.call( this, i, getClass( this ), stateVal ),\\n\\t\\t\\t\\t\\tstateVal\\n\\t\\t\\t\\t);\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar className, i, self, classNames;\\n\\n\\t\\t\\tif ( type === \\\"string\\\" ) {\\n\\n\\t\\t\\t\\t// Toggle individual class names\\n\\t\\t\\t\\ti = 0;\\n\\t\\t\\t\\tself = jQuery( this );\\n\\t\\t\\t\\tclassNames = value.match( rnothtmlwhite ) || [];\\n\\n\\t\\t\\t\\twhile ( ( className = classNames[ i++ ] ) ) {\\n\\n\\t\\t\\t\\t\\t// Check each className given, space separated list\\n\\t\\t\\t\\t\\tif ( self.hasClass( className ) ) {\\n\\t\\t\\t\\t\\t\\tself.removeClass( className );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tself.addClass( className );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t// Toggle whole class name\\n\\t\\t\\t} else if ( value === undefined || type === \\\"boolean\\\" ) {\\n\\t\\t\\t\\tclassName = getClass( this );\\n\\t\\t\\t\\tif ( className ) {\\n\\n\\t\\t\\t\\t\\t// Store className if set\\n\\t\\t\\t\\t\\tdataPriv.set( this, \\\"__className__\\\", className );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// If the element has a class name or if we're passed `false`,\\n\\t\\t\\t\\t// then remove the whole classname (if there was one, the above saved it).\\n\\t\\t\\t\\t// Otherwise bring back whatever was previously saved (if anything),\\n\\t\\t\\t\\t// falling back to the empty string if nothing was stored.\\n\\t\\t\\t\\tif ( this.setAttribute ) {\\n\\t\\t\\t\\t\\tthis.setAttribute( \\\"class\\\",\\n\\t\\t\\t\\t\\t\\tclassName || value === false ?\\n\\t\\t\\t\\t\\t\\t\\\"\\\" :\\n\\t\\t\\t\\t\\t\\tdataPriv.get( this, \\\"__className__\\\" ) || \\\"\\\"\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\thasClass: function( selector ) {\\n\\t\\tvar className, elem,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tclassName = \\\" \\\" + selector + \\\" \\\";\\n\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\tif ( elem.nodeType === 1 &&\\n\\t\\t\\t\\t( \\\" \\\" + stripAndCollapse( getClass( elem ) ) + \\\" \\\" ).indexOf( className ) > -1 ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n} );\\n\\n\\n\\n\\nvar rreturn = /\\\\r/g;\\n\\njQuery.fn.extend( {\\n\\tval: function( value ) {\\n\\t\\tvar hooks, ret, isFunction,\\n\\t\\t\\telem = this[ 0 ];\\n\\n\\t\\tif ( !arguments.length ) {\\n\\t\\t\\tif ( elem ) {\\n\\t\\t\\t\\thooks = jQuery.valHooks[ elem.type ] ||\\n\\t\\t\\t\\t\\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\\n\\n\\t\\t\\t\\tif ( hooks &&\\n\\t\\t\\t\\t\\t\\\"get\\\" in hooks &&\\n\\t\\t\\t\\t\\t( ret = hooks.get( elem, \\\"value\\\" ) ) !== undefined\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\treturn ret;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tret = elem.value;\\n\\n\\t\\t\\t\\t// Handle most common string cases\\n\\t\\t\\t\\tif ( typeof ret === \\\"string\\\" ) {\\n\\t\\t\\t\\t\\treturn ret.replace( rreturn, \\\"\\\" );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Handle cases where value is null/undef or number\\n\\t\\t\\t\\treturn ret == null ? \\\"\\\" : ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tisFunction = jQuery.isFunction( value );\\n\\n\\t\\treturn this.each( function( i ) {\\n\\t\\t\\tvar val;\\n\\n\\t\\t\\tif ( this.nodeType !== 1 ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( isFunction ) {\\n\\t\\t\\t\\tval = value.call( this, i, jQuery( this ).val() );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tval = value;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Treat null/undefined as \\\"\\\"; convert numbers to string\\n\\t\\t\\tif ( val == null ) {\\n\\t\\t\\t\\tval = \\\"\\\";\\n\\n\\t\\t\\t} else if ( typeof val === \\\"number\\\" ) {\\n\\t\\t\\t\\tval += \\\"\\\";\\n\\n\\t\\t\\t} else if ( jQuery.isArray( val ) ) {\\n\\t\\t\\t\\tval = jQuery.map( val, function( value ) {\\n\\t\\t\\t\\t\\treturn value == null ? \\\"\\\" : value + \\\"\\\";\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\n\\t\\t\\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\\n\\n\\t\\t\\t// If set returns undefined, fall back to normal setting\\n\\t\\t\\tif ( !hooks || !( \\\"set\\\" in hooks ) || hooks.set( this, val, \\\"value\\\" ) === undefined ) {\\n\\t\\t\\t\\tthis.value = val;\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tvalHooks: {\\n\\t\\toption: {\\n\\t\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t\\tvar val = jQuery.find.attr( elem, \\\"value\\\" );\\n\\t\\t\\t\\treturn val != null ?\\n\\t\\t\\t\\t\\tval :\\n\\n\\t\\t\\t\\t\\t// Support: IE <=10 - 11 only\\n\\t\\t\\t\\t\\t// option.text throws exceptions (#14686, #14858)\\n\\t\\t\\t\\t\\t// Strip and collapse whitespace\\n\\t\\t\\t\\t\\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\\n\\t\\t\\t\\t\\tstripAndCollapse( jQuery.text( elem ) );\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tselect: {\\n\\t\\t\\tget: function( elem ) {\\n\\t\\t\\t\\tvar value, option, i,\\n\\t\\t\\t\\t\\toptions = elem.options,\\n\\t\\t\\t\\t\\tindex = elem.selectedIndex,\\n\\t\\t\\t\\t\\tone = elem.type === \\\"select-one\\\",\\n\\t\\t\\t\\t\\tvalues = one ? null : [],\\n\\t\\t\\t\\t\\tmax = one ? index + 1 : options.length;\\n\\n\\t\\t\\t\\tif ( index < 0 ) {\\n\\t\\t\\t\\t\\ti = max;\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ti = one ? index : 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Loop through all the selected options\\n\\t\\t\\t\\tfor ( ; i < max; i++ ) {\\n\\t\\t\\t\\t\\toption = options[ i ];\\n\\n\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t// IE8-9 doesn't update selected after form reset (#2551)\\n\\t\\t\\t\\t\\tif ( ( option.selected || i === index ) &&\\n\\n\\t\\t\\t\\t\\t\\t\\t// Don't return options that are disabled or in a disabled optgroup\\n\\t\\t\\t\\t\\t\\t\\t!option.disabled &&\\n\\t\\t\\t\\t\\t\\t\\t( !option.parentNode.disabled ||\\n\\t\\t\\t\\t\\t\\t\\t\\t!jQuery.nodeName( option.parentNode, \\\"optgroup\\\" ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\t// Get the specific value for the option\\n\\t\\t\\t\\t\\t\\tvalue = jQuery( option ).val();\\n\\n\\t\\t\\t\\t\\t\\t// We don't need an array for one selects\\n\\t\\t\\t\\t\\t\\tif ( one ) {\\n\\t\\t\\t\\t\\t\\t\\treturn value;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Multi-Selects return an array\\n\\t\\t\\t\\t\\t\\tvalues.push( value );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn values;\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function( elem, value ) {\\n\\t\\t\\t\\tvar optionSet, option,\\n\\t\\t\\t\\t\\toptions = elem.options,\\n\\t\\t\\t\\t\\tvalues = jQuery.makeArray( value ),\\n\\t\\t\\t\\t\\ti = options.length;\\n\\n\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\toption = options[ i ];\\n\\n\\t\\t\\t\\t\\t/* eslint-disable no-cond-assign */\\n\\n\\t\\t\\t\\t\\tif ( option.selected =\\n\\t\\t\\t\\t\\t\\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\\n\\t\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t\\toptionSet = true;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t/* eslint-enable no-cond-assign */\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Force browsers to behave consistently when non-matching value is set\\n\\t\\t\\t\\tif ( !optionSet ) {\\n\\t\\t\\t\\t\\telem.selectedIndex = -1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn values;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Radios and checkboxes getter/setter\\njQuery.each( [ \\\"radio\\\", \\\"checkbox\\\" ], function() {\\n\\tjQuery.valHooks[ this ] = {\\n\\t\\tset: function( elem, value ) {\\n\\t\\t\\tif ( jQuery.isArray( value ) ) {\\n\\t\\t\\t\\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\tif ( !support.checkOn ) {\\n\\t\\tjQuery.valHooks[ this ].get = function( elem ) {\\n\\t\\t\\treturn elem.getAttribute( \\\"value\\\" ) === null ? \\\"on\\\" : elem.value;\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\n// Return jQuery for attributes-only inclusion\\n\\n\\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\\n\\njQuery.extend( jQuery.event, {\\n\\n\\ttrigger: function( event, data, elem, onlyHandlers ) {\\n\\n\\t\\tvar i, cur, tmp, bubbleType, ontype, handle, special,\\n\\t\\t\\teventPath = [ elem || document ],\\n\\t\\t\\ttype = hasOwn.call( event, \\\"type\\\" ) ? event.type : event,\\n\\t\\t\\tnamespaces = hasOwn.call( event, \\\"namespace\\\" ) ? event.namespace.split( \\\".\\\" ) : [];\\n\\n\\t\\tcur = tmp = elem = elem || document;\\n\\n\\t\\t// Don't do events on text and comment nodes\\n\\t\\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\\n\\t\\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( type.indexOf( \\\".\\\" ) > -1 ) {\\n\\n\\t\\t\\t// Namespaced trigger; create a regexp to match event type in handle()\\n\\t\\t\\tnamespaces = type.split( \\\".\\\" );\\n\\t\\t\\ttype = namespaces.shift();\\n\\t\\t\\tnamespaces.sort();\\n\\t\\t}\\n\\t\\tontype = type.indexOf( \\\":\\\" ) < 0 && \\\"on\\\" + type;\\n\\n\\t\\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\\n\\t\\tevent = event[ jQuery.expando ] ?\\n\\t\\t\\tevent :\\n\\t\\t\\tnew jQuery.Event( type, typeof event === \\\"object\\\" && event );\\n\\n\\t\\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\\n\\t\\tevent.isTrigger = onlyHandlers ? 2 : 3;\\n\\t\\tevent.namespace = namespaces.join( \\\".\\\" );\\n\\t\\tevent.rnamespace = event.namespace ?\\n\\t\\t\\tnew RegExp( \\\"(^|\\\\\\\\.)\\\" + namespaces.join( \\\"\\\\\\\\.(?:.*\\\\\\\\.|)\\\" ) + \\\"(\\\\\\\\.|$)\\\" ) :\\n\\t\\t\\tnull;\\n\\n\\t\\t// Clean up the event in case it is being reused\\n\\t\\tevent.result = undefined;\\n\\t\\tif ( !event.target ) {\\n\\t\\t\\tevent.target = elem;\\n\\t\\t}\\n\\n\\t\\t// Clone any incoming data and prepend the event, creating the handler arg list\\n\\t\\tdata = data == null ?\\n\\t\\t\\t[ event ] :\\n\\t\\t\\tjQuery.makeArray( data, [ event ] );\\n\\n\\t\\t// Allow special events to draw outside the lines\\n\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\t\\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Determine event propagation path in advance, per W3C events spec (#9951)\\n\\t\\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\\n\\t\\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\\n\\n\\t\\t\\tbubbleType = special.delegateType || type;\\n\\t\\t\\tif ( !rfocusMorph.test( bubbleType + type ) ) {\\n\\t\\t\\t\\tcur = cur.parentNode;\\n\\t\\t\\t}\\n\\t\\t\\tfor ( ; cur; cur = cur.parentNode ) {\\n\\t\\t\\t\\teventPath.push( cur );\\n\\t\\t\\t\\ttmp = cur;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\\n\\t\\t\\tif ( tmp === ( elem.ownerDocument || document ) ) {\\n\\t\\t\\t\\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Fire handlers on the event path\\n\\t\\ti = 0;\\n\\t\\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\\n\\n\\t\\t\\tevent.type = i > 1 ?\\n\\t\\t\\t\\tbubbleType :\\n\\t\\t\\t\\tspecial.bindType || type;\\n\\n\\t\\t\\t// jQuery handler\\n\\t\\t\\thandle = ( dataPriv.get( cur, \\\"events\\\" ) || {} )[ event.type ] &&\\n\\t\\t\\t\\tdataPriv.get( cur, \\\"handle\\\" );\\n\\t\\t\\tif ( handle ) {\\n\\t\\t\\t\\thandle.apply( cur, data );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Native handler\\n\\t\\t\\thandle = ontype && cur[ ontype ];\\n\\t\\t\\tif ( handle && handle.apply && acceptData( cur ) ) {\\n\\t\\t\\t\\tevent.result = handle.apply( cur, data );\\n\\t\\t\\t\\tif ( event.result === false ) {\\n\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tevent.type = type;\\n\\n\\t\\t// If nobody prevented the default action, do it now\\n\\t\\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\\n\\n\\t\\t\\tif ( ( !special._default ||\\n\\t\\t\\t\\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\\n\\t\\t\\t\\tacceptData( elem ) ) {\\n\\n\\t\\t\\t\\t// Call a native DOM method on the target with the same name as the event.\\n\\t\\t\\t\\t// Don't do default actions on window, that's where global variables be (#6170)\\n\\t\\t\\t\\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\\n\\n\\t\\t\\t\\t\\t// Don't re-trigger an onFOO event when we call its FOO() method\\n\\t\\t\\t\\t\\ttmp = elem[ ontype ];\\n\\n\\t\\t\\t\\t\\tif ( tmp ) {\\n\\t\\t\\t\\t\\t\\telem[ ontype ] = null;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Prevent re-triggering of the same event, since we already bubbled it above\\n\\t\\t\\t\\t\\tjQuery.event.triggered = type;\\n\\t\\t\\t\\t\\telem[ type ]();\\n\\t\\t\\t\\t\\tjQuery.event.triggered = undefined;\\n\\n\\t\\t\\t\\t\\tif ( tmp ) {\\n\\t\\t\\t\\t\\t\\telem[ ontype ] = tmp;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn event.result;\\n\\t},\\n\\n\\t// Piggyback on a donor event to simulate a different one\\n\\t// Used only for `focus(in | out)` events\\n\\tsimulate: function( type, elem, event ) {\\n\\t\\tvar e = jQuery.extend(\\n\\t\\t\\tnew jQuery.Event(),\\n\\t\\t\\tevent,\\n\\t\\t\\t{\\n\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\tisSimulated: true\\n\\t\\t\\t}\\n\\t\\t);\\n\\n\\t\\tjQuery.event.trigger( e, null, elem );\\n\\t}\\n\\n} );\\n\\njQuery.fn.extend( {\\n\\n\\ttrigger: function( type, data ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.event.trigger( type, data, this );\\n\\t\\t} );\\n\\t},\\n\\ttriggerHandler: function( type, data ) {\\n\\t\\tvar elem = this[ 0 ];\\n\\t\\tif ( elem ) {\\n\\t\\t\\treturn jQuery.event.trigger( type, data, elem, true );\\n\\t\\t}\\n\\t}\\n} );\\n\\n\\njQuery.each( ( \\\"blur focus focusin focusout resize scroll click dblclick \\\" +\\n\\t\\\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \\\" +\\n\\t\\\"change select submit keydown keypress keyup contextmenu\\\" ).split( \\\" \\\" ),\\n\\tfunction( i, name ) {\\n\\n\\t// Handle event binding\\n\\tjQuery.fn[ name ] = function( data, fn ) {\\n\\t\\treturn arguments.length > 0 ?\\n\\t\\t\\tthis.on( name, null, data, fn ) :\\n\\t\\t\\tthis.trigger( name );\\n\\t};\\n} );\\n\\njQuery.fn.extend( {\\n\\thover: function( fnOver, fnOut ) {\\n\\t\\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\\n\\t}\\n} );\\n\\n\\n\\n\\nsupport.focusin = \\\"onfocusin\\\" in window;\\n\\n\\n// Support: Firefox <=44\\n// Firefox doesn't have focus(in | out) events\\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\\n//\\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\\n// focus(in | out) events fire after focus & blur events,\\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\\nif ( !support.focusin ) {\\n\\tjQuery.each( { focus: \\\"focusin\\\", blur: \\\"focusout\\\" }, function( orig, fix ) {\\n\\n\\t\\t// Attach a single capturing handler on the document while someone wants focusin/focusout\\n\\t\\tvar handler = function( event ) {\\n\\t\\t\\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\\n\\t\\t};\\n\\n\\t\\tjQuery.event.special[ fix ] = {\\n\\t\\t\\tsetup: function() {\\n\\t\\t\\t\\tvar doc = this.ownerDocument || this,\\n\\t\\t\\t\\t\\tattaches = dataPriv.access( doc, fix );\\n\\n\\t\\t\\t\\tif ( !attaches ) {\\n\\t\\t\\t\\t\\tdoc.addEventListener( orig, handler, true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\\n\\t\\t\\t},\\n\\t\\t\\tteardown: function() {\\n\\t\\t\\t\\tvar doc = this.ownerDocument || this,\\n\\t\\t\\t\\t\\tattaches = dataPriv.access( doc, fix ) - 1;\\n\\n\\t\\t\\t\\tif ( !attaches ) {\\n\\t\\t\\t\\t\\tdoc.removeEventListener( orig, handler, true );\\n\\t\\t\\t\\t\\tdataPriv.remove( doc, fix );\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdataPriv.access( doc, fix, attaches );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t} );\\n}\\nvar location = window.location;\\n\\nvar nonce = jQuery.now();\\n\\nvar rquery = ( /\\\\?/ );\\n\\n\\n\\n// Cross-browser xml parsing\\njQuery.parseXML = function( data ) {\\n\\tvar xml;\\n\\tif ( !data || typeof data !== \\\"string\\\" ) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// Support: IE 9 - 11 only\\n\\t// IE throws on parseFromString with invalid input.\\n\\ttry {\\n\\t\\txml = ( new window.DOMParser() ).parseFromString( data, \\\"text/xml\\\" );\\n\\t} catch ( e ) {\\n\\t\\txml = undefined;\\n\\t}\\n\\n\\tif ( !xml || xml.getElementsByTagName( \\\"parsererror\\\" ).length ) {\\n\\t\\tjQuery.error( \\\"Invalid XML: \\\" + data );\\n\\t}\\n\\treturn xml;\\n};\\n\\n\\nvar\\n\\trbracket = /\\\\[\\\\]$/,\\n\\trCRLF = /\\\\r?\\\\n/g,\\n\\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\\n\\trsubmittable = /^(?:input|select|textarea|keygen)/i;\\n\\nfunction buildParams( prefix, obj, traditional, add ) {\\n\\tvar name;\\n\\n\\tif ( jQuery.isArray( obj ) ) {\\n\\n\\t\\t// Serialize array item.\\n\\t\\tjQuery.each( obj, function( i, v ) {\\n\\t\\t\\tif ( traditional || rbracket.test( prefix ) ) {\\n\\n\\t\\t\\t\\t// Treat each array item as a scalar.\\n\\t\\t\\t\\tadd( prefix, v );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Item is non-scalar (array or object), encode its numeric index.\\n\\t\\t\\t\\tbuildParams(\\n\\t\\t\\t\\t\\tprefix + \\\"[\\\" + ( typeof v === \\\"object\\\" && v != null ? i : \\\"\\\" ) + \\\"]\\\",\\n\\t\\t\\t\\t\\tv,\\n\\t\\t\\t\\t\\ttraditional,\\n\\t\\t\\t\\t\\tadd\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t} else if ( !traditional && jQuery.type( obj ) === \\\"object\\\" ) {\\n\\n\\t\\t// Serialize object item.\\n\\t\\tfor ( name in obj ) {\\n\\t\\t\\tbuildParams( prefix + \\\"[\\\" + name + \\\"]\\\", obj[ name ], traditional, add );\\n\\t\\t}\\n\\n\\t} else {\\n\\n\\t\\t// Serialize scalar item.\\n\\t\\tadd( prefix, obj );\\n\\t}\\n}\\n\\n// Serialize an array of form elements or a set of\\n// key/values into a query string\\njQuery.param = function( a, traditional ) {\\n\\tvar prefix,\\n\\t\\ts = [],\\n\\t\\tadd = function( key, valueOrFunction ) {\\n\\n\\t\\t\\t// If value is a function, invoke it and use its return value\\n\\t\\t\\tvar value = jQuery.isFunction( valueOrFunction ) ?\\n\\t\\t\\t\\tvalueOrFunction() :\\n\\t\\t\\t\\tvalueOrFunction;\\n\\n\\t\\t\\ts[ s.length ] = encodeURIComponent( key ) + \\\"=\\\" +\\n\\t\\t\\t\\tencodeURIComponent( value == null ? \\\"\\\" : value );\\n\\t\\t};\\n\\n\\t// If an array was passed in, assume that it is an array of form elements.\\n\\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\\n\\n\\t\\t// Serialize the form elements\\n\\t\\tjQuery.each( a, function() {\\n\\t\\t\\tadd( this.name, this.value );\\n\\t\\t} );\\n\\n\\t} else {\\n\\n\\t\\t// If traditional, encode the \\\"old\\\" way (the way 1.3.2 or older\\n\\t\\t// did it), otherwise encode params recursively.\\n\\t\\tfor ( prefix in a ) {\\n\\t\\t\\tbuildParams( prefix, a[ prefix ], traditional, add );\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the resulting serialization\\n\\treturn s.join( \\\"&\\\" );\\n};\\n\\njQuery.fn.extend( {\\n\\tserialize: function() {\\n\\t\\treturn jQuery.param( this.serializeArray() );\\n\\t},\\n\\tserializeArray: function() {\\n\\t\\treturn this.map( function() {\\n\\n\\t\\t\\t// Can add propHook for \\\"elements\\\" to filter or add form elements\\n\\t\\t\\tvar elements = jQuery.prop( this, \\\"elements\\\" );\\n\\t\\t\\treturn elements ? jQuery.makeArray( elements ) : this;\\n\\t\\t} )\\n\\t\\t.filter( function() {\\n\\t\\t\\tvar type = this.type;\\n\\n\\t\\t\\t// Use .is( \\\":disabled\\\" ) so that fieldset[disabled] works\\n\\t\\t\\treturn this.name && !jQuery( this ).is( \\\":disabled\\\" ) &&\\n\\t\\t\\t\\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\\n\\t\\t\\t\\t( this.checked || !rcheckableType.test( type ) );\\n\\t\\t} )\\n\\t\\t.map( function( i, elem ) {\\n\\t\\t\\tvar val = jQuery( this ).val();\\n\\n\\t\\t\\tif ( val == null ) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( jQuery.isArray( val ) ) {\\n\\t\\t\\t\\treturn jQuery.map( val, function( val ) {\\n\\t\\t\\t\\t\\treturn { name: elem.name, value: val.replace( rCRLF, \\\"\\\\r\\\\n\\\" ) };\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn { name: elem.name, value: val.replace( rCRLF, \\\"\\\\r\\\\n\\\" ) };\\n\\t\\t} ).get();\\n\\t}\\n} );\\n\\n\\nvar\\n\\tr20 = /%20/g,\\n\\trhash = /#.*$/,\\n\\trantiCache = /([?&])_=[^&]*/,\\n\\trheaders = /^(.*?):[ \\\\t]*([^\\\\r\\\\n]*)$/mg,\\n\\n\\t// #7653, #8125, #8152: local protocol detection\\n\\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\\n\\trnoContent = /^(?:GET|HEAD)$/,\\n\\trprotocol = /^\\\\/\\\\//,\\n\\n\\t/* Prefilters\\n\\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\\n\\t * 2) These are called:\\n\\t *    - BEFORE asking for a transport\\n\\t *    - AFTER param serialization (s.data is a string if s.processData is true)\\n\\t * 3) key is the dataType\\n\\t * 4) the catchall symbol \\\"*\\\" can be used\\n\\t * 5) execution will start with transport dataType and THEN continue down to \\\"*\\\" if needed\\n\\t */\\n\\tprefilters = {},\\n\\n\\t/* Transports bindings\\n\\t * 1) key is the dataType\\n\\t * 2) the catchall symbol \\\"*\\\" can be used\\n\\t * 3) selection will start with transport dataType and THEN go to \\\"*\\\" if needed\\n\\t */\\n\\ttransports = {},\\n\\n\\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\\n\\tallTypes = \\\"*/\\\".concat( \\\"*\\\" ),\\n\\n\\t// Anchor tag for parsing the document origin\\n\\toriginAnchor = document.createElement( \\\"a\\\" );\\n\\toriginAnchor.href = location.href;\\n\\n// Base \\\"constructor\\\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\\nfunction addToPrefiltersOrTransports( structure ) {\\n\\n\\t// dataTypeExpression is optional and defaults to \\\"*\\\"\\n\\treturn function( dataTypeExpression, func ) {\\n\\n\\t\\tif ( typeof dataTypeExpression !== \\\"string\\\" ) {\\n\\t\\t\\tfunc = dataTypeExpression;\\n\\t\\t\\tdataTypeExpression = \\\"*\\\";\\n\\t\\t}\\n\\n\\t\\tvar dataType,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\\n\\n\\t\\tif ( jQuery.isFunction( func ) ) {\\n\\n\\t\\t\\t// For each dataType in the dataTypeExpression\\n\\t\\t\\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\\n\\n\\t\\t\\t\\t// Prepend if requested\\n\\t\\t\\t\\tif ( dataType[ 0 ] === \\\"+\\\" ) {\\n\\t\\t\\t\\t\\tdataType = dataType.slice( 1 ) || \\\"*\\\";\\n\\t\\t\\t\\t\\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\\n\\n\\t\\t\\t\\t// Otherwise append\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n}\\n\\n// Base inspection function for prefilters and transports\\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\\n\\n\\tvar inspected = {},\\n\\t\\tseekingTransport = ( structure === transports );\\n\\n\\tfunction inspect( dataType ) {\\n\\t\\tvar selected;\\n\\t\\tinspected[ dataType ] = true;\\n\\t\\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\\n\\t\\t\\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\\n\\t\\t\\tif ( typeof dataTypeOrTransport === \\\"string\\\" &&\\n\\t\\t\\t\\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\\n\\n\\t\\t\\t\\toptions.dataTypes.unshift( dataTypeOrTransport );\\n\\t\\t\\t\\tinspect( dataTypeOrTransport );\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t} else if ( seekingTransport ) {\\n\\t\\t\\t\\treturn !( selected = dataTypeOrTransport );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t\\treturn selected;\\n\\t}\\n\\n\\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \\\"*\\\" ] && inspect( \\\"*\\\" );\\n}\\n\\n// A special extend for ajax options\\n// that takes \\\"flat\\\" options (not to be deep extended)\\n// Fixes #9887\\nfunction ajaxExtend( target, src ) {\\n\\tvar key, deep,\\n\\t\\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\\n\\n\\tfor ( key in src ) {\\n\\t\\tif ( src[ key ] !== undefined ) {\\n\\t\\t\\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\\n\\t\\t}\\n\\t}\\n\\tif ( deep ) {\\n\\t\\tjQuery.extend( true, target, deep );\\n\\t}\\n\\n\\treturn target;\\n}\\n\\n/* Handles responses to an ajax request:\\n * - finds the right dataType (mediates between content-type and expected dataType)\\n * - returns the corresponding response\\n */\\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\\n\\n\\tvar ct, type, finalDataType, firstDataType,\\n\\t\\tcontents = s.contents,\\n\\t\\tdataTypes = s.dataTypes;\\n\\n\\t// Remove auto dataType and get content-type in the process\\n\\twhile ( dataTypes[ 0 ] === \\\"*\\\" ) {\\n\\t\\tdataTypes.shift();\\n\\t\\tif ( ct === undefined ) {\\n\\t\\t\\tct = s.mimeType || jqXHR.getResponseHeader( \\\"Content-Type\\\" );\\n\\t\\t}\\n\\t}\\n\\n\\t// Check if we're dealing with a known content-type\\n\\tif ( ct ) {\\n\\t\\tfor ( type in contents ) {\\n\\t\\t\\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\\n\\t\\t\\t\\tdataTypes.unshift( type );\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Check to see if we have a response for the expected dataType\\n\\tif ( dataTypes[ 0 ] in responses ) {\\n\\t\\tfinalDataType = dataTypes[ 0 ];\\n\\t} else {\\n\\n\\t\\t// Try convertible dataTypes\\n\\t\\tfor ( type in responses ) {\\n\\t\\t\\tif ( !dataTypes[ 0 ] || s.converters[ type + \\\" \\\" + dataTypes[ 0 ] ] ) {\\n\\t\\t\\t\\tfinalDataType = type;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif ( !firstDataType ) {\\n\\t\\t\\t\\tfirstDataType = type;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Or just use first one\\n\\t\\tfinalDataType = finalDataType || firstDataType;\\n\\t}\\n\\n\\t// If we found a dataType\\n\\t// We add the dataType to the list if needed\\n\\t// and return the corresponding response\\n\\tif ( finalDataType ) {\\n\\t\\tif ( finalDataType !== dataTypes[ 0 ] ) {\\n\\t\\t\\tdataTypes.unshift( finalDataType );\\n\\t\\t}\\n\\t\\treturn responses[ finalDataType ];\\n\\t}\\n}\\n\\n/* Chain conversions given the request and the original response\\n * Also sets the responseXXX fields on the jqXHR instance\\n */\\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\\n\\tvar conv2, current, conv, tmp, prev,\\n\\t\\tconverters = {},\\n\\n\\t\\t// Work with a copy of dataTypes in case we need to modify it for conversion\\n\\t\\tdataTypes = s.dataTypes.slice();\\n\\n\\t// Create converters map with lowercased keys\\n\\tif ( dataTypes[ 1 ] ) {\\n\\t\\tfor ( conv in s.converters ) {\\n\\t\\t\\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\\n\\t\\t}\\n\\t}\\n\\n\\tcurrent = dataTypes.shift();\\n\\n\\t// Convert to each sequential dataType\\n\\twhile ( current ) {\\n\\n\\t\\tif ( s.responseFields[ current ] ) {\\n\\t\\t\\tjqXHR[ s.responseFields[ current ] ] = response;\\n\\t\\t}\\n\\n\\t\\t// Apply the dataFilter if provided\\n\\t\\tif ( !prev && isSuccess && s.dataFilter ) {\\n\\t\\t\\tresponse = s.dataFilter( response, s.dataType );\\n\\t\\t}\\n\\n\\t\\tprev = current;\\n\\t\\tcurrent = dataTypes.shift();\\n\\n\\t\\tif ( current ) {\\n\\n\\t\\t\\t// There's only work to do if current dataType is non-auto\\n\\t\\t\\tif ( current === \\\"*\\\" ) {\\n\\n\\t\\t\\t\\tcurrent = prev;\\n\\n\\t\\t\\t// Convert response if prev dataType is non-auto and differs from current\\n\\t\\t\\t} else if ( prev !== \\\"*\\\" && prev !== current ) {\\n\\n\\t\\t\\t\\t// Seek a direct converter\\n\\t\\t\\t\\tconv = converters[ prev + \\\" \\\" + current ] || converters[ \\\"* \\\" + current ];\\n\\n\\t\\t\\t\\t// If none found, seek a pair\\n\\t\\t\\t\\tif ( !conv ) {\\n\\t\\t\\t\\t\\tfor ( conv2 in converters ) {\\n\\n\\t\\t\\t\\t\\t\\t// If conv2 outputs current\\n\\t\\t\\t\\t\\t\\ttmp = conv2.split( \\\" \\\" );\\n\\t\\t\\t\\t\\t\\tif ( tmp[ 1 ] === current ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// If prev can be converted to accepted input\\n\\t\\t\\t\\t\\t\\t\\tconv = converters[ prev + \\\" \\\" + tmp[ 0 ] ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\tconverters[ \\\"* \\\" + tmp[ 0 ] ];\\n\\t\\t\\t\\t\\t\\t\\tif ( conv ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Condense equivalence converters\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( conv === true ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tconv = converters[ conv2 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Otherwise, insert the intermediate dataType\\n\\t\\t\\t\\t\\t\\t\\t\\t} else if ( converters[ conv2 ] !== true ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcurrent = tmp[ 0 ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdataTypes.unshift( tmp[ 1 ] );\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Apply converter (if not an equivalence)\\n\\t\\t\\t\\tif ( conv !== true ) {\\n\\n\\t\\t\\t\\t\\t// Unless errors are allowed to bubble, catch and return them\\n\\t\\t\\t\\t\\tif ( conv && s.throws ) {\\n\\t\\t\\t\\t\\t\\tresponse = conv( response );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\tresponse = conv( response );\\n\\t\\t\\t\\t\\t\\t} catch ( e ) {\\n\\t\\t\\t\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\t\\t\\t\\tstate: \\\"parsererror\\\",\\n\\t\\t\\t\\t\\t\\t\\t\\terror: conv ? e : \\\"No conversion from \\\" + prev + \\\" to \\\" + current\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn { state: \\\"success\\\", data: response };\\n}\\n\\njQuery.extend( {\\n\\n\\t// Counter for holding the number of active queries\\n\\tactive: 0,\\n\\n\\t// Last-Modified header cache for next request\\n\\tlastModified: {},\\n\\tetag: {},\\n\\n\\tajaxSettings: {\\n\\t\\turl: location.href,\\n\\t\\ttype: \\\"GET\\\",\\n\\t\\tisLocal: rlocalProtocol.test( location.protocol ),\\n\\t\\tglobal: true,\\n\\t\\tprocessData: true,\\n\\t\\tasync: true,\\n\\t\\tcontentType: \\\"application/x-www-form-urlencoded; charset=UTF-8\\\",\\n\\n\\t\\t/*\\n\\t\\ttimeout: 0,\\n\\t\\tdata: null,\\n\\t\\tdataType: null,\\n\\t\\tusername: null,\\n\\t\\tpassword: null,\\n\\t\\tcache: null,\\n\\t\\tthrows: false,\\n\\t\\ttraditional: false,\\n\\t\\theaders: {},\\n\\t\\t*/\\n\\n\\t\\taccepts: {\\n\\t\\t\\t\\\"*\\\": allTypes,\\n\\t\\t\\ttext: \\\"text/plain\\\",\\n\\t\\t\\thtml: \\\"text/html\\\",\\n\\t\\t\\txml: \\\"application/xml, text/xml\\\",\\n\\t\\t\\tjson: \\\"application/json, text/javascript\\\"\\n\\t\\t},\\n\\n\\t\\tcontents: {\\n\\t\\t\\txml: /\\\\bxml\\\\b/,\\n\\t\\t\\thtml: /\\\\bhtml/,\\n\\t\\t\\tjson: /\\\\bjson\\\\b/\\n\\t\\t},\\n\\n\\t\\tresponseFields: {\\n\\t\\t\\txml: \\\"responseXML\\\",\\n\\t\\t\\ttext: \\\"responseText\\\",\\n\\t\\t\\tjson: \\\"responseJSON\\\"\\n\\t\\t},\\n\\n\\t\\t// Data converters\\n\\t\\t// Keys separate source (or catchall \\\"*\\\") and destination types with a single space\\n\\t\\tconverters: {\\n\\n\\t\\t\\t// Convert anything to text\\n\\t\\t\\t\\\"* text\\\": String,\\n\\n\\t\\t\\t// Text to html (true = no transformation)\\n\\t\\t\\t\\\"text html\\\": true,\\n\\n\\t\\t\\t// Evaluate text as a json expression\\n\\t\\t\\t\\\"text json\\\": JSON.parse,\\n\\n\\t\\t\\t// Parse text as xml\\n\\t\\t\\t\\\"text xml\\\": jQuery.parseXML\\n\\t\\t},\\n\\n\\t\\t// For options that shouldn't be deep extended:\\n\\t\\t// you can add your own custom options here if\\n\\t\\t// and when you create one that shouldn't be\\n\\t\\t// deep extended (see ajaxExtend)\\n\\t\\tflatOptions: {\\n\\t\\t\\turl: true,\\n\\t\\t\\tcontext: true\\n\\t\\t}\\n\\t},\\n\\n\\t// Creates a full fledged settings object into target\\n\\t// with both ajaxSettings and settings fields.\\n\\t// If target is omitted, writes into ajaxSettings.\\n\\tajaxSetup: function( target, settings ) {\\n\\t\\treturn settings ?\\n\\n\\t\\t\\t// Building a settings object\\n\\t\\t\\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\\n\\n\\t\\t\\t// Extending ajaxSettings\\n\\t\\t\\tajaxExtend( jQuery.ajaxSettings, target );\\n\\t},\\n\\n\\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\\n\\tajaxTransport: addToPrefiltersOrTransports( transports ),\\n\\n\\t// Main method\\n\\tajax: function( url, options ) {\\n\\n\\t\\t// If url is an object, simulate pre-1.5 signature\\n\\t\\tif ( typeof url === \\\"object\\\" ) {\\n\\t\\t\\toptions = url;\\n\\t\\t\\turl = undefined;\\n\\t\\t}\\n\\n\\t\\t// Force options to be an object\\n\\t\\toptions = options || {};\\n\\n\\t\\tvar transport,\\n\\n\\t\\t\\t// URL without anti-cache param\\n\\t\\t\\tcacheURL,\\n\\n\\t\\t\\t// Response headers\\n\\t\\t\\tresponseHeadersString,\\n\\t\\t\\tresponseHeaders,\\n\\n\\t\\t\\t// timeout handle\\n\\t\\t\\ttimeoutTimer,\\n\\n\\t\\t\\t// Url cleanup var\\n\\t\\t\\turlAnchor,\\n\\n\\t\\t\\t// Request state (becomes false upon send and true upon completion)\\n\\t\\t\\tcompleted,\\n\\n\\t\\t\\t// To know if global events are to be dispatched\\n\\t\\t\\tfireGlobals,\\n\\n\\t\\t\\t// Loop variable\\n\\t\\t\\ti,\\n\\n\\t\\t\\t// uncached part of the url\\n\\t\\t\\tuncached,\\n\\n\\t\\t\\t// Create the final options object\\n\\t\\t\\ts = jQuery.ajaxSetup( {}, options ),\\n\\n\\t\\t\\t// Callbacks context\\n\\t\\t\\tcallbackContext = s.context || s,\\n\\n\\t\\t\\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\\n\\t\\t\\tglobalEventContext = s.context &&\\n\\t\\t\\t\\t( callbackContext.nodeType || callbackContext.jquery ) ?\\n\\t\\t\\t\\t\\tjQuery( callbackContext ) :\\n\\t\\t\\t\\t\\tjQuery.event,\\n\\n\\t\\t\\t// Deferreds\\n\\t\\t\\tdeferred = jQuery.Deferred(),\\n\\t\\t\\tcompleteDeferred = jQuery.Callbacks( \\\"once memory\\\" ),\\n\\n\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\tstatusCode = s.statusCode || {},\\n\\n\\t\\t\\t// Headers (they are sent all at once)\\n\\t\\t\\trequestHeaders = {},\\n\\t\\t\\trequestHeadersNames = {},\\n\\n\\t\\t\\t// Default abort message\\n\\t\\t\\tstrAbort = \\\"canceled\\\",\\n\\n\\t\\t\\t// Fake xhr\\n\\t\\t\\tjqXHR = {\\n\\t\\t\\t\\treadyState: 0,\\n\\n\\t\\t\\t\\t// Builds headers hashtable if needed\\n\\t\\t\\t\\tgetResponseHeader: function( key ) {\\n\\t\\t\\t\\t\\tvar match;\\n\\t\\t\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\t\\t\\tif ( !responseHeaders ) {\\n\\t\\t\\t\\t\\t\\t\\tresponseHeaders = {};\\n\\t\\t\\t\\t\\t\\t\\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tmatch = responseHeaders[ key.toLowerCase() ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn match == null ? null : match;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Raw string\\n\\t\\t\\t\\tgetAllResponseHeaders: function() {\\n\\t\\t\\t\\t\\treturn completed ? responseHeadersString : null;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Caches the header\\n\\t\\t\\t\\tsetRequestHeader: function( name, value ) {\\n\\t\\t\\t\\t\\tif ( completed == null ) {\\n\\t\\t\\t\\t\\t\\tname = requestHeadersNames[ name.toLowerCase() ] =\\n\\t\\t\\t\\t\\t\\t\\trequestHeadersNames[ name.toLowerCase() ] || name;\\n\\t\\t\\t\\t\\t\\trequestHeaders[ name ] = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Overrides response content-type header\\n\\t\\t\\t\\toverrideMimeType: function( type ) {\\n\\t\\t\\t\\t\\tif ( completed == null ) {\\n\\t\\t\\t\\t\\t\\ts.mimeType = type;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\t\\tstatusCode: function( map ) {\\n\\t\\t\\t\\t\\tvar code;\\n\\t\\t\\t\\t\\tif ( map ) {\\n\\t\\t\\t\\t\\t\\tif ( completed ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Execute the appropriate callbacks\\n\\t\\t\\t\\t\\t\\t\\tjqXHR.always( map[ jqXHR.status ] );\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Lazy-add the new callbacks in a way that preserves old ones\\n\\t\\t\\t\\t\\t\\t\\tfor ( code in map ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Cancel the request\\n\\t\\t\\t\\tabort: function( statusText ) {\\n\\t\\t\\t\\t\\tvar finalText = statusText || strAbort;\\n\\t\\t\\t\\t\\tif ( transport ) {\\n\\t\\t\\t\\t\\t\\ttransport.abort( finalText );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdone( 0, finalText );\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t// Attach deferreds\\n\\t\\tdeferred.promise( jqXHR );\\n\\n\\t\\t// Add protocol if not provided (prefilters might expect it)\\n\\t\\t// Handle falsy url in the settings object (#10093: consistency with old signature)\\n\\t\\t// We also use the url parameter if available\\n\\t\\ts.url = ( ( url || s.url || location.href ) + \\\"\\\" )\\n\\t\\t\\t.replace( rprotocol, location.protocol + \\\"//\\\" );\\n\\n\\t\\t// Alias method option to type as per ticket #12004\\n\\t\\ts.type = options.method || options.type || s.method || s.type;\\n\\n\\t\\t// Extract dataTypes list\\n\\t\\ts.dataTypes = ( s.dataType || \\\"*\\\" ).toLowerCase().match( rnothtmlwhite ) || [ \\\"\\\" ];\\n\\n\\t\\t// A cross-domain request is in order when the origin doesn't match the current origin.\\n\\t\\tif ( s.crossDomain == null ) {\\n\\t\\t\\turlAnchor = document.createElement( \\\"a\\\" );\\n\\n\\t\\t\\t// Support: IE <=8 - 11, Edge 12 - 13\\n\\t\\t\\t// IE throws exception on accessing the href property if url is malformed,\\n\\t\\t\\t// e.g. http://example.com:80x/\\n\\t\\t\\ttry {\\n\\t\\t\\t\\turlAnchor.href = s.url;\\n\\n\\t\\t\\t\\t// Support: IE <=8 - 11 only\\n\\t\\t\\t\\t// Anchor's host property isn't correctly set when s.url is relative\\n\\t\\t\\t\\turlAnchor.href = urlAnchor.href;\\n\\t\\t\\t\\ts.crossDomain = originAnchor.protocol + \\\"//\\\" + originAnchor.host !==\\n\\t\\t\\t\\t\\turlAnchor.protocol + \\\"//\\\" + urlAnchor.host;\\n\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t// If there is an error parsing the URL, assume it is crossDomain,\\n\\t\\t\\t\\t// it can be rejected by the transport if it is invalid\\n\\t\\t\\t\\ts.crossDomain = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Convert data if not already a string\\n\\t\\tif ( s.data && s.processData && typeof s.data !== \\\"string\\\" ) {\\n\\t\\t\\ts.data = jQuery.param( s.data, s.traditional );\\n\\t\\t}\\n\\n\\t\\t// Apply prefilters\\n\\t\\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\\n\\n\\t\\t// If request was aborted inside a prefilter, stop there\\n\\t\\tif ( completed ) {\\n\\t\\t\\treturn jqXHR;\\n\\t\\t}\\n\\n\\t\\t// We can fire global events as of now if asked to\\n\\t\\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\\n\\t\\tfireGlobals = jQuery.event && s.global;\\n\\n\\t\\t// Watch for a new set of requests\\n\\t\\tif ( fireGlobals && jQuery.active++ === 0 ) {\\n\\t\\t\\tjQuery.event.trigger( \\\"ajaxStart\\\" );\\n\\t\\t}\\n\\n\\t\\t// Uppercase the type\\n\\t\\ts.type = s.type.toUpperCase();\\n\\n\\t\\t// Determine if request has content\\n\\t\\ts.hasContent = !rnoContent.test( s.type );\\n\\n\\t\\t// Save the URL in case we're toying with the If-Modified-Since\\n\\t\\t// and/or If-None-Match header later on\\n\\t\\t// Remove hash to simplify url manipulation\\n\\t\\tcacheURL = s.url.replace( rhash, \\\"\\\" );\\n\\n\\t\\t// More options handling for requests with no content\\n\\t\\tif ( !s.hasContent ) {\\n\\n\\t\\t\\t// Remember the hash so we can put it back\\n\\t\\t\\tuncached = s.url.slice( cacheURL.length );\\n\\n\\t\\t\\t// If data is available, append data to url\\n\\t\\t\\tif ( s.data ) {\\n\\t\\t\\t\\tcacheURL += ( rquery.test( cacheURL ) ? \\\"&\\\" : \\\"?\\\" ) + s.data;\\n\\n\\t\\t\\t\\t// #9682: remove data so that it's not used in an eventual retry\\n\\t\\t\\t\\tdelete s.data;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add or update anti-cache param if needed\\n\\t\\t\\tif ( s.cache === false ) {\\n\\t\\t\\t\\tcacheURL = cacheURL.replace( rantiCache, \\\"$1\\\" );\\n\\t\\t\\t\\tuncached = ( rquery.test( cacheURL ) ? \\\"&\\\" : \\\"?\\\" ) + \\\"_=\\\" + ( nonce++ ) + uncached;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\\n\\t\\t\\ts.url = cacheURL + uncached;\\n\\n\\t\\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\\n\\t\\t} else if ( s.data && s.processData &&\\n\\t\\t\\t( s.contentType || \\\"\\\" ).indexOf( \\\"application/x-www-form-urlencoded\\\" ) === 0 ) {\\n\\t\\t\\ts.data = s.data.replace( r20, \\\"+\\\" );\\n\\t\\t}\\n\\n\\t\\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\\n\\t\\tif ( s.ifModified ) {\\n\\t\\t\\tif ( jQuery.lastModified[ cacheURL ] ) {\\n\\t\\t\\t\\tjqXHR.setRequestHeader( \\\"If-Modified-Since\\\", jQuery.lastModified[ cacheURL ] );\\n\\t\\t\\t}\\n\\t\\t\\tif ( jQuery.etag[ cacheURL ] ) {\\n\\t\\t\\t\\tjqXHR.setRequestHeader( \\\"If-None-Match\\\", jQuery.etag[ cacheURL ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Set the correct header, if data is being sent\\n\\t\\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\\n\\t\\t\\tjqXHR.setRequestHeader( \\\"Content-Type\\\", s.contentType );\\n\\t\\t}\\n\\n\\t\\t// Set the Accepts header for the server, depending on the dataType\\n\\t\\tjqXHR.setRequestHeader(\\n\\t\\t\\t\\\"Accept\\\",\\n\\t\\t\\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\\n\\t\\t\\t\\ts.accepts[ s.dataTypes[ 0 ] ] +\\n\\t\\t\\t\\t\\t( s.dataTypes[ 0 ] !== \\\"*\\\" ? \\\", \\\" + allTypes + \\\"; q=0.01\\\" : \\\"\\\" ) :\\n\\t\\t\\t\\ts.accepts[ \\\"*\\\" ]\\n\\t\\t);\\n\\n\\t\\t// Check for headers option\\n\\t\\tfor ( i in s.headers ) {\\n\\t\\t\\tjqXHR.setRequestHeader( i, s.headers[ i ] );\\n\\t\\t}\\n\\n\\t\\t// Allow custom headers/mimetypes and early abort\\n\\t\\tif ( s.beforeSend &&\\n\\t\\t\\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\\n\\n\\t\\t\\t// Abort if not done already and return\\n\\t\\t\\treturn jqXHR.abort();\\n\\t\\t}\\n\\n\\t\\t// Aborting is no longer a cancellation\\n\\t\\tstrAbort = \\\"abort\\\";\\n\\n\\t\\t// Install callbacks on deferreds\\n\\t\\tcompleteDeferred.add( s.complete );\\n\\t\\tjqXHR.done( s.success );\\n\\t\\tjqXHR.fail( s.error );\\n\\n\\t\\t// Get transport\\n\\t\\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\\n\\n\\t\\t// If no transport, we auto-abort\\n\\t\\tif ( !transport ) {\\n\\t\\t\\tdone( -1, \\\"No Transport\\\" );\\n\\t\\t} else {\\n\\t\\t\\tjqXHR.readyState = 1;\\n\\n\\t\\t\\t// Send global event\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( \\\"ajaxSend\\\", [ jqXHR, s ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If request was aborted inside ajaxSend, stop there\\n\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\treturn jqXHR;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Timeout\\n\\t\\t\\tif ( s.async && s.timeout > 0 ) {\\n\\t\\t\\t\\ttimeoutTimer = window.setTimeout( function() {\\n\\t\\t\\t\\t\\tjqXHR.abort( \\\"timeout\\\" );\\n\\t\\t\\t\\t}, s.timeout );\\n\\t\\t\\t}\\n\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tcompleted = false;\\n\\t\\t\\t\\ttransport.send( requestHeaders, done );\\n\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t// Rethrow post-completion exceptions\\n\\t\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\t\\tthrow e;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Propagate others as results\\n\\t\\t\\t\\tdone( -1, e );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Callback for when everything is done\\n\\t\\tfunction done( status, nativeStatusText, responses, headers ) {\\n\\t\\t\\tvar isSuccess, success, error, response, modified,\\n\\t\\t\\t\\tstatusText = nativeStatusText;\\n\\n\\t\\t\\t// Ignore repeat invocations\\n\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcompleted = true;\\n\\n\\t\\t\\t// Clear timeout if it exists\\n\\t\\t\\tif ( timeoutTimer ) {\\n\\t\\t\\t\\twindow.clearTimeout( timeoutTimer );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Dereference transport for early garbage collection\\n\\t\\t\\t// (no matter how long the jqXHR object will be used)\\n\\t\\t\\ttransport = undefined;\\n\\n\\t\\t\\t// Cache response headers\\n\\t\\t\\tresponseHeadersString = headers || \\\"\\\";\\n\\n\\t\\t\\t// Set readyState\\n\\t\\t\\tjqXHR.readyState = status > 0 ? 4 : 0;\\n\\n\\t\\t\\t// Determine if successful\\n\\t\\t\\tisSuccess = status >= 200 && status < 300 || status === 304;\\n\\n\\t\\t\\t// Get response data\\n\\t\\t\\tif ( responses ) {\\n\\t\\t\\t\\tresponse = ajaxHandleResponses( s, jqXHR, responses );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Convert no matter what (that way responseXXX fields are always set)\\n\\t\\t\\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\\n\\n\\t\\t\\t// If successful, handle type chaining\\n\\t\\t\\tif ( isSuccess ) {\\n\\n\\t\\t\\t\\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\\n\\t\\t\\t\\tif ( s.ifModified ) {\\n\\t\\t\\t\\t\\tmodified = jqXHR.getResponseHeader( \\\"Last-Modified\\\" );\\n\\t\\t\\t\\t\\tif ( modified ) {\\n\\t\\t\\t\\t\\t\\tjQuery.lastModified[ cacheURL ] = modified;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmodified = jqXHR.getResponseHeader( \\\"etag\\\" );\\n\\t\\t\\t\\t\\tif ( modified ) {\\n\\t\\t\\t\\t\\t\\tjQuery.etag[ cacheURL ] = modified;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if no content\\n\\t\\t\\t\\tif ( status === 204 || s.type === \\\"HEAD\\\" ) {\\n\\t\\t\\t\\t\\tstatusText = \\\"nocontent\\\";\\n\\n\\t\\t\\t\\t// if not modified\\n\\t\\t\\t\\t} else if ( status === 304 ) {\\n\\t\\t\\t\\t\\tstatusText = \\\"notmodified\\\";\\n\\n\\t\\t\\t\\t// If we have data, let's convert it\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tstatusText = response.state;\\n\\t\\t\\t\\t\\tsuccess = response.data;\\n\\t\\t\\t\\t\\terror = response.error;\\n\\t\\t\\t\\t\\tisSuccess = !error;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Extract error from statusText and normalize for non-aborts\\n\\t\\t\\t\\terror = statusText;\\n\\t\\t\\t\\tif ( status || !statusText ) {\\n\\t\\t\\t\\t\\tstatusText = \\\"error\\\";\\n\\t\\t\\t\\t\\tif ( status < 0 ) {\\n\\t\\t\\t\\t\\t\\tstatus = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set data for the fake xhr object\\n\\t\\t\\tjqXHR.status = status;\\n\\t\\t\\tjqXHR.statusText = ( nativeStatusText || statusText ) + \\\"\\\";\\n\\n\\t\\t\\t// Success/Error\\n\\t\\t\\tif ( isSuccess ) {\\n\\t\\t\\t\\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\tjqXHR.statusCode( statusCode );\\n\\t\\t\\tstatusCode = undefined;\\n\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( isSuccess ? \\\"ajaxSuccess\\\" : \\\"ajaxError\\\",\\n\\t\\t\\t\\t\\t[ jqXHR, s, isSuccess ? success : error ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Complete\\n\\t\\t\\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\\n\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( \\\"ajaxComplete\\\", [ jqXHR, s ] );\\n\\n\\t\\t\\t\\t// Handle the global AJAX counter\\n\\t\\t\\t\\tif ( !( --jQuery.active ) ) {\\n\\t\\t\\t\\t\\tjQuery.event.trigger( \\\"ajaxStop\\\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn jqXHR;\\n\\t},\\n\\n\\tgetJSON: function( url, data, callback ) {\\n\\t\\treturn jQuery.get( url, data, callback, \\\"json\\\" );\\n\\t},\\n\\n\\tgetScript: function( url, callback ) {\\n\\t\\treturn jQuery.get( url, undefined, callback, \\\"script\\\" );\\n\\t}\\n} );\\n\\njQuery.each( [ \\\"get\\\", \\\"post\\\" ], function( i, method ) {\\n\\tjQuery[ method ] = function( url, data, callback, type ) {\\n\\n\\t\\t// Shift arguments if data argument was omitted\\n\\t\\tif ( jQuery.isFunction( data ) ) {\\n\\t\\t\\ttype = type || callback;\\n\\t\\t\\tcallback = data;\\n\\t\\t\\tdata = undefined;\\n\\t\\t}\\n\\n\\t\\t// The url can be an options object (which then must have .url)\\n\\t\\treturn jQuery.ajax( jQuery.extend( {\\n\\t\\t\\turl: url,\\n\\t\\t\\ttype: method,\\n\\t\\t\\tdataType: type,\\n\\t\\t\\tdata: data,\\n\\t\\t\\tsuccess: callback\\n\\t\\t}, jQuery.isPlainObject( url ) && url ) );\\n\\t};\\n} );\\n\\n\\njQuery._evalUrl = function( url ) {\\n\\treturn jQuery.ajax( {\\n\\t\\turl: url,\\n\\n\\t\\t// Make this explicit, since user can override this through ajaxSetup (#11264)\\n\\t\\ttype: \\\"GET\\\",\\n\\t\\tdataType: \\\"script\\\",\\n\\t\\tcache: true,\\n\\t\\tasync: false,\\n\\t\\tglobal: false,\\n\\t\\t\\\"throws\\\": true\\n\\t} );\\n};\\n\\n\\njQuery.fn.extend( {\\n\\twrapAll: function( html ) {\\n\\t\\tvar wrap;\\n\\n\\t\\tif ( this[ 0 ] ) {\\n\\t\\t\\tif ( jQuery.isFunction( html ) ) {\\n\\t\\t\\t\\thtml = html.call( this[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// The elements to wrap the target around\\n\\t\\t\\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\\n\\n\\t\\t\\tif ( this[ 0 ].parentNode ) {\\n\\t\\t\\t\\twrap.insertBefore( this[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\twrap.map( function() {\\n\\t\\t\\t\\tvar elem = this;\\n\\n\\t\\t\\t\\twhile ( elem.firstElementChild ) {\\n\\t\\t\\t\\t\\telem = elem.firstElementChild;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn elem;\\n\\t\\t\\t} ).append( this );\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\twrapInner: function( html ) {\\n\\t\\tif ( jQuery.isFunction( html ) ) {\\n\\t\\t\\treturn this.each( function( i ) {\\n\\t\\t\\t\\tjQuery( this ).wrapInner( html.call( this, i ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar self = jQuery( this ),\\n\\t\\t\\t\\tcontents = self.contents();\\n\\n\\t\\t\\tif ( contents.length ) {\\n\\t\\t\\t\\tcontents.wrapAll( html );\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tself.append( html );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\twrap: function( html ) {\\n\\t\\tvar isFunction = jQuery.isFunction( html );\\n\\n\\t\\treturn this.each( function( i ) {\\n\\t\\t\\tjQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\\n\\t\\t} );\\n\\t},\\n\\n\\tunwrap: function( selector ) {\\n\\t\\tthis.parent( selector ).not( \\\"body\\\" ).each( function() {\\n\\t\\t\\tjQuery( this ).replaceWith( this.childNodes );\\n\\t\\t} );\\n\\t\\treturn this;\\n\\t}\\n} );\\n\\n\\njQuery.expr.pseudos.hidden = function( elem ) {\\n\\treturn !jQuery.expr.pseudos.visible( elem );\\n};\\njQuery.expr.pseudos.visible = function( elem ) {\\n\\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\\n};\\n\\n\\n\\n\\njQuery.ajaxSettings.xhr = function() {\\n\\ttry {\\n\\t\\treturn new window.XMLHttpRequest();\\n\\t} catch ( e ) {}\\n};\\n\\nvar xhrSuccessStatus = {\\n\\n\\t\\t// File protocol always yields status code 0, assume 200\\n\\t\\t0: 200,\\n\\n\\t\\t// Support: IE <=9 only\\n\\t\\t// #1450: sometimes IE returns 1223 when it should be 204\\n\\t\\t1223: 204\\n\\t},\\n\\txhrSupported = jQuery.ajaxSettings.xhr();\\n\\nsupport.cors = !!xhrSupported && ( \\\"withCredentials\\\" in xhrSupported );\\nsupport.ajax = xhrSupported = !!xhrSupported;\\n\\njQuery.ajaxTransport( function( options ) {\\n\\tvar callback, errorCallback;\\n\\n\\t// Cross domain only allowed if supported through XMLHttpRequest\\n\\tif ( support.cors || xhrSupported && !options.crossDomain ) {\\n\\t\\treturn {\\n\\t\\t\\tsend: function( headers, complete ) {\\n\\t\\t\\t\\tvar i,\\n\\t\\t\\t\\t\\txhr = options.xhr();\\n\\n\\t\\t\\t\\txhr.open(\\n\\t\\t\\t\\t\\toptions.type,\\n\\t\\t\\t\\t\\toptions.url,\\n\\t\\t\\t\\t\\toptions.async,\\n\\t\\t\\t\\t\\toptions.username,\\n\\t\\t\\t\\t\\toptions.password\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t// Apply custom fields if provided\\n\\t\\t\\t\\tif ( options.xhrFields ) {\\n\\t\\t\\t\\t\\tfor ( i in options.xhrFields ) {\\n\\t\\t\\t\\t\\t\\txhr[ i ] = options.xhrFields[ i ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Override mime type if needed\\n\\t\\t\\t\\tif ( options.mimeType && xhr.overrideMimeType ) {\\n\\t\\t\\t\\t\\txhr.overrideMimeType( options.mimeType );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// X-Requested-With header\\n\\t\\t\\t\\t// For cross-domain requests, seeing as conditions for a preflight are\\n\\t\\t\\t\\t// akin to a jigsaw puzzle, we simply never set it to be sure.\\n\\t\\t\\t\\t// (it can always be set on a per-request basis or even using ajaxSetup)\\n\\t\\t\\t\\t// For same-domain requests, won't change header if already provided.\\n\\t\\t\\t\\tif ( !options.crossDomain && !headers[ \\\"X-Requested-With\\\" ] ) {\\n\\t\\t\\t\\t\\theaders[ \\\"X-Requested-With\\\" ] = \\\"XMLHttpRequest\\\";\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Set headers\\n\\t\\t\\t\\tfor ( i in headers ) {\\n\\t\\t\\t\\t\\txhr.setRequestHeader( i, headers[ i ] );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Callback\\n\\t\\t\\t\\tcallback = function( type ) {\\n\\t\\t\\t\\t\\treturn function() {\\n\\t\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\t\\tcallback = errorCallback = xhr.onload =\\n\\t\\t\\t\\t\\t\\t\\t\\txhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( type === \\\"abort\\\" ) {\\n\\t\\t\\t\\t\\t\\t\\t\\txhr.abort();\\n\\t\\t\\t\\t\\t\\t\\t} else if ( type === \\\"error\\\" ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t// On a manual native abort, IE9 throws\\n\\t\\t\\t\\t\\t\\t\\t\\t// errors on any property access that is not readyState\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( typeof xhr.status !== \\\"number\\\" ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcomplete( 0, \\\"error\\\" );\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcomplete(\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// File: protocol always yields status 0; see #8605, #14207\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.status,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.statusText\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tcomplete(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhrSuccessStatus[ xhr.status ] || xhr.status,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.statusText,\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// IE9 has no XHR2 but throws on binary (trac-11426)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// For XHR2 non-text, let the caller handle it (gh-2498)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t( xhr.responseType || \\\"text\\\" ) !== \\\"text\\\"  ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ttypeof xhr.responseText !== \\\"string\\\" ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{ binary: xhr.response } :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{ text: xhr.responseText },\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.getAllResponseHeaders()\\n\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t// Listen to events\\n\\t\\t\\t\\txhr.onload = callback();\\n\\t\\t\\t\\terrorCallback = xhr.onerror = callback( \\\"error\\\" );\\n\\n\\t\\t\\t\\t// Support: IE 9 only\\n\\t\\t\\t\\t// Use onreadystatechange to replace onabort\\n\\t\\t\\t\\t// to handle uncaught aborts\\n\\t\\t\\t\\tif ( xhr.onabort !== undefined ) {\\n\\t\\t\\t\\t\\txhr.onabort = errorCallback;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\txhr.onreadystatechange = function() {\\n\\n\\t\\t\\t\\t\\t\\t// Check readyState before timeout as it changes\\n\\t\\t\\t\\t\\t\\tif ( xhr.readyState === 4 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Allow onerror to be called first,\\n\\t\\t\\t\\t\\t\\t\\t// but that will not handle a native abort\\n\\t\\t\\t\\t\\t\\t\\t// Also, save errorCallback to a variable\\n\\t\\t\\t\\t\\t\\t\\t// as xhr.onerror cannot be accessed\\n\\t\\t\\t\\t\\t\\t\\twindow.setTimeout( function() {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\terrorCallback();\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Create the abort callback\\n\\t\\t\\t\\tcallback = callback( \\\"abort\\\" );\\n\\n\\t\\t\\t\\ttry {\\n\\n\\t\\t\\t\\t\\t// Do send the request (this may raise an exception)\\n\\t\\t\\t\\t\\txhr.send( options.hasContent && options.data || null );\\n\\t\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t\\t// #14683: Only rethrow if this hasn't been notified as an error yet\\n\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\tthrow e;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\tabort: function() {\\n\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\tcallback();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\\njQuery.ajaxPrefilter( function( s ) {\\n\\tif ( s.crossDomain ) {\\n\\t\\ts.contents.script = false;\\n\\t}\\n} );\\n\\n// Install script dataType\\njQuery.ajaxSetup( {\\n\\taccepts: {\\n\\t\\tscript: \\\"text/javascript, application/javascript, \\\" +\\n\\t\\t\\t\\\"application/ecmascript, application/x-ecmascript\\\"\\n\\t},\\n\\tcontents: {\\n\\t\\tscript: /\\\\b(?:java|ecma)script\\\\b/\\n\\t},\\n\\tconverters: {\\n\\t\\t\\\"text script\\\": function( text ) {\\n\\t\\t\\tjQuery.globalEval( text );\\n\\t\\t\\treturn text;\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Handle cache's special case and crossDomain\\njQuery.ajaxPrefilter( \\\"script\\\", function( s ) {\\n\\tif ( s.cache === undefined ) {\\n\\t\\ts.cache = false;\\n\\t}\\n\\tif ( s.crossDomain ) {\\n\\t\\ts.type = \\\"GET\\\";\\n\\t}\\n} );\\n\\n// Bind script tag hack transport\\njQuery.ajaxTransport( \\\"script\\\", function( s ) {\\n\\n\\t// This transport only deals with cross domain requests\\n\\tif ( s.crossDomain ) {\\n\\t\\tvar script, callback;\\n\\t\\treturn {\\n\\t\\t\\tsend: function( _, complete ) {\\n\\t\\t\\t\\tscript = jQuery( \\\"<script>\\\" ).prop( {\\n\\t\\t\\t\\t\\tcharset: s.scriptCharset,\\n\\t\\t\\t\\t\\tsrc: s.url\\n\\t\\t\\t\\t} ).on(\\n\\t\\t\\t\\t\\t\\\"load error\\\",\\n\\t\\t\\t\\t\\tcallback = function( evt ) {\\n\\t\\t\\t\\t\\t\\tscript.remove();\\n\\t\\t\\t\\t\\t\\tcallback = null;\\n\\t\\t\\t\\t\\t\\tif ( evt ) {\\n\\t\\t\\t\\t\\t\\t\\tcomplete( evt.type === \\\"error\\\" ? 404 : 200, evt.type );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t// Use native DOM manipulation to avoid our domManip AJAX trickery\\n\\t\\t\\t\\tdocument.head.appendChild( script[ 0 ] );\\n\\t\\t\\t},\\n\\t\\t\\tabort: function() {\\n\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\tcallback();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\nvar oldCallbacks = [],\\n\\trjsonp = /(=)\\\\?(?=&|$)|\\\\?\\\\?/;\\n\\n// Default jsonp settings\\njQuery.ajaxSetup( {\\n\\tjsonp: \\\"callback\\\",\\n\\tjsonpCallback: function() {\\n\\t\\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \\\"_\\\" + ( nonce++ ) );\\n\\t\\tthis[ callback ] = true;\\n\\t\\treturn callback;\\n\\t}\\n} );\\n\\n// Detect, normalize options and install callbacks for jsonp requests\\njQuery.ajaxPrefilter( \\\"json jsonp\\\", function( s, originalSettings, jqXHR ) {\\n\\n\\tvar callbackName, overwritten, responseContainer,\\n\\t\\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\\n\\t\\t\\t\\\"url\\\" :\\n\\t\\t\\ttypeof s.data === \\\"string\\\" &&\\n\\t\\t\\t\\t( s.contentType || \\\"\\\" )\\n\\t\\t\\t\\t\\t.indexOf( \\\"application/x-www-form-urlencoded\\\" ) === 0 &&\\n\\t\\t\\t\\trjsonp.test( s.data ) && \\\"data\\\"\\n\\t\\t);\\n\\n\\t// Handle iff the expected data type is \\\"jsonp\\\" or we have a parameter to set\\n\\tif ( jsonProp || s.dataTypes[ 0 ] === \\\"jsonp\\\" ) {\\n\\n\\t\\t// Get callback name, remembering preexisting value associated with it\\n\\t\\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\\n\\t\\t\\ts.jsonpCallback() :\\n\\t\\t\\ts.jsonpCallback;\\n\\n\\t\\t// Insert callback into url or form data\\n\\t\\tif ( jsonProp ) {\\n\\t\\t\\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \\\"$1\\\" + callbackName );\\n\\t\\t} else if ( s.jsonp !== false ) {\\n\\t\\t\\ts.url += ( rquery.test( s.url ) ? \\\"&\\\" : \\\"?\\\" ) + s.jsonp + \\\"=\\\" + callbackName;\\n\\t\\t}\\n\\n\\t\\t// Use data converter to retrieve json after script execution\\n\\t\\ts.converters[ \\\"script json\\\" ] = function() {\\n\\t\\t\\tif ( !responseContainer ) {\\n\\t\\t\\t\\tjQuery.error( callbackName + \\\" was not called\\\" );\\n\\t\\t\\t}\\n\\t\\t\\treturn responseContainer[ 0 ];\\n\\t\\t};\\n\\n\\t\\t// Force json dataType\\n\\t\\ts.dataTypes[ 0 ] = \\\"json\\\";\\n\\n\\t\\t// Install callback\\n\\t\\toverwritten = window[ callbackName ];\\n\\t\\twindow[ callbackName ] = function() {\\n\\t\\t\\tresponseContainer = arguments;\\n\\t\\t};\\n\\n\\t\\t// Clean-up function (fires after converters)\\n\\t\\tjqXHR.always( function() {\\n\\n\\t\\t\\t// If previous value didn't exist - remove it\\n\\t\\t\\tif ( overwritten === undefined ) {\\n\\t\\t\\t\\tjQuery( window ).removeProp( callbackName );\\n\\n\\t\\t\\t// Otherwise restore preexisting value\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twindow[ callbackName ] = overwritten;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Save back as free\\n\\t\\t\\tif ( s[ callbackName ] ) {\\n\\n\\t\\t\\t\\t// Make sure that re-using the options doesn't screw things around\\n\\t\\t\\t\\ts.jsonpCallback = originalSettings.jsonpCallback;\\n\\n\\t\\t\\t\\t// Save the callback name for future use\\n\\t\\t\\t\\toldCallbacks.push( callbackName );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Call if it was a function and we have a response\\n\\t\\t\\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\\n\\t\\t\\t\\toverwritten( responseContainer[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\tresponseContainer = overwritten = undefined;\\n\\t\\t} );\\n\\n\\t\\t// Delegate to script\\n\\t\\treturn \\\"script\\\";\\n\\t}\\n} );\\n\\n\\n\\n\\n// Support: Safari 8 only\\n// In Safari 8 documents created via document.implementation.createHTMLDocument\\n// collapse sibling forms: the second one becomes a child of the first one.\\n// Because of that, this security measure has to be disabled in Safari 8.\\n// https://bugs.webkit.org/show_bug.cgi?id=137337\\nsupport.createHTMLDocument = ( function() {\\n\\tvar body = document.implementation.createHTMLDocument( \\\"\\\" ).body;\\n\\tbody.innerHTML = \\\"<form></form><form></form>\\\";\\n\\treturn body.childNodes.length === 2;\\n} )();\\n\\n\\n// Argument \\\"data\\\" should be string of html\\n// context (optional): If specified, the fragment will be created in this context,\\n// defaults to document\\n// keepScripts (optional): If true, will include scripts passed in the html string\\njQuery.parseHTML = function( data, context, keepScripts ) {\\n\\tif ( typeof data !== \\\"string\\\" ) {\\n\\t\\treturn [];\\n\\t}\\n\\tif ( typeof context === \\\"boolean\\\" ) {\\n\\t\\tkeepScripts = context;\\n\\t\\tcontext = false;\\n\\t}\\n\\n\\tvar base, parsed, scripts;\\n\\n\\tif ( !context ) {\\n\\n\\t\\t// Stop scripts or inline event handlers from being executed immediately\\n\\t\\t// by using document.implementation\\n\\t\\tif ( support.createHTMLDocument ) {\\n\\t\\t\\tcontext = document.implementation.createHTMLDocument( \\\"\\\" );\\n\\n\\t\\t\\t// Set the base href for the created document\\n\\t\\t\\t// so any parsed elements with URLs\\n\\t\\t\\t// are based on the document's URL (gh-2965)\\n\\t\\t\\tbase = context.createElement( \\\"base\\\" );\\n\\t\\t\\tbase.href = document.location.href;\\n\\t\\t\\tcontext.head.appendChild( base );\\n\\t\\t} else {\\n\\t\\t\\tcontext = document;\\n\\t\\t}\\n\\t}\\n\\n\\tparsed = rsingleTag.exec( data );\\n\\tscripts = !keepScripts && [];\\n\\n\\t// Single tag\\n\\tif ( parsed ) {\\n\\t\\treturn [ context.createElement( parsed[ 1 ] ) ];\\n\\t}\\n\\n\\tparsed = buildFragment( [ data ], context, scripts );\\n\\n\\tif ( scripts && scripts.length ) {\\n\\t\\tjQuery( scripts ).remove();\\n\\t}\\n\\n\\treturn jQuery.merge( [], parsed.childNodes );\\n};\\n\\n\\n/**\\n * Load a url into a page\\n */\\njQuery.fn.load = function( url, params, callback ) {\\n\\tvar selector, type, response,\\n\\t\\tself = this,\\n\\t\\toff = url.indexOf( \\\" \\\" );\\n\\n\\tif ( off > -1 ) {\\n\\t\\tselector = stripAndCollapse( url.slice( off ) );\\n\\t\\turl = url.slice( 0, off );\\n\\t}\\n\\n\\t// If it's a function\\n\\tif ( jQuery.isFunction( params ) ) {\\n\\n\\t\\t// We assume that it's the callback\\n\\t\\tcallback = params;\\n\\t\\tparams = undefined;\\n\\n\\t// Otherwise, build a param string\\n\\t} else if ( params && typeof params === \\\"object\\\" ) {\\n\\t\\ttype = \\\"POST\\\";\\n\\t}\\n\\n\\t// If we have elements to modify, make the request\\n\\tif ( self.length > 0 ) {\\n\\t\\tjQuery.ajax( {\\n\\t\\t\\turl: url,\\n\\n\\t\\t\\t// If \\\"type\\\" variable is undefined, then \\\"GET\\\" method will be used.\\n\\t\\t\\t// Make value of this field explicit since\\n\\t\\t\\t// user can override it through ajaxSetup method\\n\\t\\t\\ttype: type || \\\"GET\\\",\\n\\t\\t\\tdataType: \\\"html\\\",\\n\\t\\t\\tdata: params\\n\\t\\t} ).done( function( responseText ) {\\n\\n\\t\\t\\t// Save response for use in complete callback\\n\\t\\t\\tresponse = arguments;\\n\\n\\t\\t\\tself.html( selector ?\\n\\n\\t\\t\\t\\t// If a selector was specified, locate the right elements in a dummy div\\n\\t\\t\\t\\t// Exclude scripts to avoid IE 'Permission Denied' errors\\n\\t\\t\\t\\tjQuery( \\\"<div>\\\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\\n\\n\\t\\t\\t\\t// Otherwise use the full result\\n\\t\\t\\t\\tresponseText );\\n\\n\\t\\t// If the request succeeds, this function gets \\\"data\\\", \\\"status\\\", \\\"jqXHR\\\"\\n\\t\\t// but they are ignored because response was set above.\\n\\t\\t// If it fails, this function gets \\\"jqXHR\\\", \\\"status\\\", \\\"error\\\"\\n\\t\\t} ).always( callback && function( jqXHR, status ) {\\n\\t\\t\\tself.each( function() {\\n\\t\\t\\t\\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\\n\\t\\t\\t} );\\n\\t\\t} );\\n\\t}\\n\\n\\treturn this;\\n};\\n\\n\\n\\n\\n// Attach a bunch of functions for handling common AJAX events\\njQuery.each( [\\n\\t\\\"ajaxStart\\\",\\n\\t\\\"ajaxStop\\\",\\n\\t\\\"ajaxComplete\\\",\\n\\t\\\"ajaxError\\\",\\n\\t\\\"ajaxSuccess\\\",\\n\\t\\\"ajaxSend\\\"\\n], function( i, type ) {\\n\\tjQuery.fn[ type ] = function( fn ) {\\n\\t\\treturn this.on( type, fn );\\n\\t};\\n} );\\n\\n\\n\\n\\njQuery.expr.pseudos.animated = function( elem ) {\\n\\treturn jQuery.grep( jQuery.timers, function( fn ) {\\n\\t\\treturn elem === fn.elem;\\n\\t} ).length;\\n};\\n\\n\\n\\n\\n/**\\n * Gets a window from an element\\n */\\nfunction getWindow( elem ) {\\n\\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\\n}\\n\\njQuery.offset = {\\n\\tsetOffset: function( elem, options, i ) {\\n\\t\\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\\n\\t\\t\\tposition = jQuery.css( elem, \\\"position\\\" ),\\n\\t\\t\\tcurElem = jQuery( elem ),\\n\\t\\t\\tprops = {};\\n\\n\\t\\t// Set position first, in-case top/left are set even on static elem\\n\\t\\tif ( position === \\\"static\\\" ) {\\n\\t\\t\\telem.style.position = \\\"relative\\\";\\n\\t\\t}\\n\\n\\t\\tcurOffset = curElem.offset();\\n\\t\\tcurCSSTop = jQuery.css( elem, \\\"top\\\" );\\n\\t\\tcurCSSLeft = jQuery.css( elem, \\\"left\\\" );\\n\\t\\tcalculatePosition = ( position === \\\"absolute\\\" || position === \\\"fixed\\\" ) &&\\n\\t\\t\\t( curCSSTop + curCSSLeft ).indexOf( \\\"auto\\\" ) > -1;\\n\\n\\t\\t// Need to be able to calculate position if either\\n\\t\\t// top or left is auto and position is either absolute or fixed\\n\\t\\tif ( calculatePosition ) {\\n\\t\\t\\tcurPosition = curElem.position();\\n\\t\\t\\tcurTop = curPosition.top;\\n\\t\\t\\tcurLeft = curPosition.left;\\n\\n\\t\\t} else {\\n\\t\\t\\tcurTop = parseFloat( curCSSTop ) || 0;\\n\\t\\t\\tcurLeft = parseFloat( curCSSLeft ) || 0;\\n\\t\\t}\\n\\n\\t\\tif ( jQuery.isFunction( options ) ) {\\n\\n\\t\\t\\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\\n\\t\\t\\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\\n\\t\\t}\\n\\n\\t\\tif ( options.top != null ) {\\n\\t\\t\\tprops.top = ( options.top - curOffset.top ) + curTop;\\n\\t\\t}\\n\\t\\tif ( options.left != null ) {\\n\\t\\t\\tprops.left = ( options.left - curOffset.left ) + curLeft;\\n\\t\\t}\\n\\n\\t\\tif ( \\\"using\\\" in options ) {\\n\\t\\t\\toptions.using.call( elem, props );\\n\\n\\t\\t} else {\\n\\t\\t\\tcurElem.css( props );\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.fn.extend( {\\n\\toffset: function( options ) {\\n\\n\\t\\t// Preserve chaining for setter\\n\\t\\tif ( arguments.length ) {\\n\\t\\t\\treturn options === undefined ?\\n\\t\\t\\t\\tthis :\\n\\t\\t\\t\\tthis.each( function( i ) {\\n\\t\\t\\t\\t\\tjQuery.offset.setOffset( this, options, i );\\n\\t\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tvar docElem, win, rect, doc,\\n\\t\\t\\telem = this[ 0 ];\\n\\n\\t\\tif ( !elem ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Support: IE <=11 only\\n\\t\\t// Running getBoundingClientRect on a\\n\\t\\t// disconnected node in IE throws an error\\n\\t\\tif ( !elem.getClientRects().length ) {\\n\\t\\t\\treturn { top: 0, left: 0 };\\n\\t\\t}\\n\\n\\t\\trect = elem.getBoundingClientRect();\\n\\n\\t\\t// Make sure element is not hidden (display: none)\\n\\t\\tif ( rect.width || rect.height ) {\\n\\t\\t\\tdoc = elem.ownerDocument;\\n\\t\\t\\twin = getWindow( doc );\\n\\t\\t\\tdocElem = doc.documentElement;\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\ttop: rect.top + win.pageYOffset - docElem.clientTop,\\n\\t\\t\\t\\tleft: rect.left + win.pageXOffset - docElem.clientLeft\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\t// Return zeros for disconnected and hidden elements (gh-2310)\\n\\t\\treturn rect;\\n\\t},\\n\\n\\tposition: function() {\\n\\t\\tif ( !this[ 0 ] ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvar offsetParent, offset,\\n\\t\\t\\telem = this[ 0 ],\\n\\t\\t\\tparentOffset = { top: 0, left: 0 };\\n\\n\\t\\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\\n\\t\\t// because it is its only offset parent\\n\\t\\tif ( jQuery.css( elem, \\\"position\\\" ) === \\\"fixed\\\" ) {\\n\\n\\t\\t\\t// Assume getBoundingClientRect is there when computed position is fixed\\n\\t\\t\\toffset = elem.getBoundingClientRect();\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t// Get *real* offsetParent\\n\\t\\t\\toffsetParent = this.offsetParent();\\n\\n\\t\\t\\t// Get correct offsets\\n\\t\\t\\toffset = this.offset();\\n\\t\\t\\tif ( !jQuery.nodeName( offsetParent[ 0 ], \\\"html\\\" ) ) {\\n\\t\\t\\t\\tparentOffset = offsetParent.offset();\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add offsetParent borders\\n\\t\\t\\tparentOffset = {\\n\\t\\t\\t\\ttop: parentOffset.top + jQuery.css( offsetParent[ 0 ], \\\"borderTopWidth\\\", true ),\\n\\t\\t\\t\\tleft: parentOffset.left + jQuery.css( offsetParent[ 0 ], \\\"borderLeftWidth\\\", true )\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\t// Subtract parent offsets and element margins\\n\\t\\treturn {\\n\\t\\t\\ttop: offset.top - parentOffset.top - jQuery.css( elem, \\\"marginTop\\\", true ),\\n\\t\\t\\tleft: offset.left - parentOffset.left - jQuery.css( elem, \\\"marginLeft\\\", true )\\n\\t\\t};\\n\\t},\\n\\n\\t// This method will return documentElement in the following cases:\\n\\t// 1) For the element inside the iframe without offsetParent, this method will return\\n\\t//    documentElement of the parent window\\n\\t// 2) For the hidden or detached element\\n\\t// 3) For body or html element, i.e. in case of the html node - it will return itself\\n\\t//\\n\\t// but those exceptions were never presented as a real life use-cases\\n\\t// and might be considered as more preferable results.\\n\\t//\\n\\t// This logic, however, is not guaranteed and can change at any point in the future\\n\\toffsetParent: function() {\\n\\t\\treturn this.map( function() {\\n\\t\\t\\tvar offsetParent = this.offsetParent;\\n\\n\\t\\t\\twhile ( offsetParent && jQuery.css( offsetParent, \\\"position\\\" ) === \\\"static\\\" ) {\\n\\t\\t\\t\\toffsetParent = offsetParent.offsetParent;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn offsetParent || documentElement;\\n\\t\\t} );\\n\\t}\\n} );\\n\\n// Create scrollLeft and scrollTop methods\\njQuery.each( { scrollLeft: \\\"pageXOffset\\\", scrollTop: \\\"pageYOffset\\\" }, function( method, prop ) {\\n\\tvar top = \\\"pageYOffset\\\" === prop;\\n\\n\\tjQuery.fn[ method ] = function( val ) {\\n\\t\\treturn access( this, function( elem, method, val ) {\\n\\t\\t\\tvar win = getWindow( elem );\\n\\n\\t\\t\\tif ( val === undefined ) {\\n\\t\\t\\t\\treturn win ? win[ prop ] : elem[ method ];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( win ) {\\n\\t\\t\\t\\twin.scrollTo(\\n\\t\\t\\t\\t\\t!top ? val : win.pageXOffset,\\n\\t\\t\\t\\t\\ttop ? val : win.pageYOffset\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\telem[ method ] = val;\\n\\t\\t\\t}\\n\\t\\t}, method, val, arguments.length );\\n\\t};\\n} );\\n\\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\\n// Add the top/left cssHooks using jQuery.fn.position\\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\\n// getComputedStyle returns percent when specified for top/left/bottom/right;\\n// rather than make the css module depend on the offset module, just check for it here\\njQuery.each( [ \\\"top\\\", \\\"left\\\" ], function( i, prop ) {\\n\\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\\n\\t\\tfunction( elem, computed ) {\\n\\t\\t\\tif ( computed ) {\\n\\t\\t\\t\\tcomputed = curCSS( elem, prop );\\n\\n\\t\\t\\t\\t// If curCSS returns percentage, fallback to offset\\n\\t\\t\\t\\treturn rnumnonpx.test( computed ) ?\\n\\t\\t\\t\\t\\tjQuery( elem ).position()[ prop ] + \\\"px\\\" :\\n\\t\\t\\t\\t\\tcomputed;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t);\\n} );\\n\\n\\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\\njQuery.each( { Height: \\\"height\\\", Width: \\\"width\\\" }, function( name, type ) {\\n\\tjQuery.each( { padding: \\\"inner\\\" + name, content: type, \\\"\\\": \\\"outer\\\" + name },\\n\\t\\tfunction( defaultExtra, funcName ) {\\n\\n\\t\\t// Margin is only for outerHeight, outerWidth\\n\\t\\tjQuery.fn[ funcName ] = function( margin, value ) {\\n\\t\\t\\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \\\"boolean\\\" ),\\n\\t\\t\\t\\textra = defaultExtra || ( margin === true || value === true ? \\\"margin\\\" : \\\"border\\\" );\\n\\n\\t\\t\\treturn access( this, function( elem, type, value ) {\\n\\t\\t\\t\\tvar doc;\\n\\n\\t\\t\\t\\tif ( jQuery.isWindow( elem ) ) {\\n\\n\\t\\t\\t\\t\\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\\n\\t\\t\\t\\t\\treturn funcName.indexOf( \\\"outer\\\" ) === 0 ?\\n\\t\\t\\t\\t\\t\\telem[ \\\"inner\\\" + name ] :\\n\\t\\t\\t\\t\\t\\telem.document.documentElement[ \\\"client\\\" + name ];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Get document width or height\\n\\t\\t\\t\\tif ( elem.nodeType === 9 ) {\\n\\t\\t\\t\\t\\tdoc = elem.documentElement;\\n\\n\\t\\t\\t\\t\\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\\n\\t\\t\\t\\t\\t// whichever is greatest\\n\\t\\t\\t\\t\\treturn Math.max(\\n\\t\\t\\t\\t\\t\\telem.body[ \\\"scroll\\\" + name ], doc[ \\\"scroll\\\" + name ],\\n\\t\\t\\t\\t\\t\\telem.body[ \\\"offset\\\" + name ], doc[ \\\"offset\\\" + name ],\\n\\t\\t\\t\\t\\t\\tdoc[ \\\"client\\\" + name ]\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn value === undefined ?\\n\\n\\t\\t\\t\\t\\t// Get width or height on the element, requesting but not forcing parseFloat\\n\\t\\t\\t\\t\\tjQuery.css( elem, type, extra ) :\\n\\n\\t\\t\\t\\t\\t// Set width or height on the element\\n\\t\\t\\t\\t\\tjQuery.style( elem, type, value, extra );\\n\\t\\t\\t}, type, chainable ? margin : undefined, chainable );\\n\\t\\t};\\n\\t} );\\n} );\\n\\n\\njQuery.fn.extend( {\\n\\n\\tbind: function( types, data, fn ) {\\n\\t\\treturn this.on( types, null, data, fn );\\n\\t},\\n\\tunbind: function( types, fn ) {\\n\\t\\treturn this.off( types, null, fn );\\n\\t},\\n\\n\\tdelegate: function( selector, types, data, fn ) {\\n\\t\\treturn this.on( types, selector, data, fn );\\n\\t},\\n\\tundelegate: function( selector, types, fn ) {\\n\\n\\t\\t// ( namespace ) or ( selector, types [, fn] )\\n\\t\\treturn arguments.length === 1 ?\\n\\t\\t\\tthis.off( selector, \\\"**\\\" ) :\\n\\t\\t\\tthis.off( types, selector || \\\"**\\\", fn );\\n\\t}\\n} );\\n\\njQuery.parseJSON = JSON.parse;\\n\\n\\n\\n\\n// Register as a named AMD module, since jQuery can be concatenated with other\\n// files that may use define, but not via a proper concatenation script that\\n// understands anonymous AMD modules. A named AMD is safest and most robust\\n// way to register. Lowercase jquery is used because AMD module names are\\n// derived from file names, and jQuery is normally delivered in a lowercase\\n// file name. Do this after creating the global so that if an AMD module wants\\n// to call noConflict to hide this version of jQuery, it will work.\\n\\n// Note that for maximum portability, libraries that are not jQuery should\\n// declare themselves as anonymous modules, and avoid setting a global if an\\n// AMD loader is present. jQuery is a special case. For more information, see\\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\\n\\nif ( typeof define === \\\"function\\\" && define.amd ) {\\n\\tdefine( \\\"jquery\\\", [], function() {\\n\\t\\treturn jQuery;\\n\\t} );\\n}\\n\\n\\n\\n\\nvar\\n\\n\\t// Map over jQuery in case of overwrite\\n\\t_jQuery = window.jQuery,\\n\\n\\t// Map over the $ in case of overwrite\\n\\t_$ = window.$;\\n\\njQuery.noConflict = function( deep ) {\\n\\tif ( window.$ === jQuery ) {\\n\\t\\twindow.$ = _$;\\n\\t}\\n\\n\\tif ( deep && window.jQuery === jQuery ) {\\n\\t\\twindow.jQuery = _jQuery;\\n\\t}\\n\\n\\treturn jQuery;\\n};\\n\\n// Expose jQuery and $ identifiers, even in AMD\\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\\n// and CommonJS for browser emulators (#13566)\\nif ( !noGlobal ) {\\n\\twindow.jQuery = window.$ = jQuery;\\n}\\n\\n\\n\\n\\n\\nreturn jQuery;\\n} );\\n\"\n\n/***/ },\n\n/***/ 829:\n/***/ function(module, exports) {\n\nmodule.exports = \"/**\\n * @license\\n * Video.js 5.11.6 <http://videojs.com/>\\n * Copyright Brightcove, Inc. <https://www.brightcove.com/>\\n * Available under Apache License Version 2.0\\n * <https://github.com/videojs/video.js/blob/master/LICENSE>\\n *\\n * Includes vtt.js <https://github.com/mozilla/vtt.js>\\n * Available under Apache License Version 2.0\\n * <https://github.com/mozilla/vtt.js/blob/master/LICENSE>\\n */\\n\\n(function(f){if(typeof exports===\\\"object\\\"&&typeof module!==\\\"undefined\\\"){module.exports=f()}else if(typeof define===\\\"function\\\"&&define.amd){define([],f)}else{var g;if(typeof window!==\\\"undefined\\\"){g=window}else if(typeof global!==\\\"undefined\\\"){g=global}else if(typeof self!==\\\"undefined\\\"){g=self}else{g=this}g.videojs = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\\\"function\\\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\\\"Cannot find module '\\\"+o+\\\"'\\\");throw f.code=\\\"MODULE_NOT_FOUND\\\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\\\"function\\\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\\n(function (global){\\nvar topLevel = typeof global !== 'undefined' ? global :\\n    typeof window !== 'undefined' ? window : {}\\nvar minDoc = _dereq_('min-document');\\n\\nif (typeof document !== 'undefined') {\\n    module.exports = document;\\n} else {\\n    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\\n\\n    if (!doccy) {\\n        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\\n    }\\n\\n    module.exports = doccy;\\n}\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9nbG9iYWwvZG9jdW1lbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdG9wTGV2ZWwgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB7fVxudmFyIG1pbkRvYyA9IHJlcXVpcmUoJ21pbi1kb2N1bWVudCcpO1xuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQ7XG59IGVsc2Uge1xuICAgIHZhciBkb2NjeSA9IHRvcExldmVsWydfX0dMT0JBTF9ET0NVTUVOVF9DQUNIRUA0J107XG5cbiAgICBpZiAoIWRvY2N5KSB7XG4gICAgICAgIGRvY2N5ID0gdG9wTGV2ZWxbJ19fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDQnXSA9IG1pbkRvYztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRvY2N5O1xufVxuIl19\\n},{\\\"min-document\\\":3}],2:[function(_dereq_,module,exports){\\n(function (global){\\nif (typeof window !== \\\"undefined\\\") {\\n    module.exports = window;\\n} else if (typeof global !== \\\"undefined\\\") {\\n    module.exports = global;\\n} else if (typeof self !== \\\"undefined\\\"){\\n    module.exports = self;\\n} else {\\n    module.exports = {};\\n}\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9nbG9iYWwvd2luZG93LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzZWxmO1xufSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHt9O1xufVxuIl19\\n},{}],3:[function(_dereq_,module,exports){\\n\\n},{}],4:[function(_dereq_,module,exports){\\nvar getNative = _dereq_('../internal/getNative');\\n\\n/* Native method references for those with the same name as other `lodash` methods. */\\nvar nativeNow = getNative(Date, 'now');\\n\\n/**\\n * Gets the number of milliseconds that have elapsed since the Unix epoch\\n * (1 January 1970 00:00:00 UTC).\\n *\\n * @static\\n * @memberOf _\\n * @category Date\\n * @example\\n *\\n * _.defer(function(stamp) {\\n *   console.log(_.now() - stamp);\\n * }, _.now());\\n * // => logs the number of milliseconds it took for the deferred function to be invoked\\n */\\nvar now = nativeNow || function() {\\n  return new Date().getTime();\\n};\\n\\nmodule.exports = now;\\n\\n},{\\\"../internal/getNative\\\":20}],5:[function(_dereq_,module,exports){\\nvar isObject = _dereq_('../lang/isObject'),\\n    now = _dereq_('../date/now');\\n\\n/** Used as the `TypeError` message for \\\"Functions\\\" methods. */\\nvar FUNC_ERROR_TEXT = 'Expected a function';\\n\\n/* Native method references for those with the same name as other `lodash` methods. */\\nvar nativeMax = Math.max;\\n\\n/**\\n * Creates a debounced function that delays invoking `func` until after `wait`\\n * milliseconds have elapsed since the last time the debounced function was\\n * invoked. The debounced function comes with a `cancel` method to cancel\\n * delayed invocations. Provide an options object to indicate that `func`\\n * should be invoked on the leading and/or trailing edge of the `wait` timeout.\\n * Subsequent calls to the debounced function return the result of the last\\n * `func` invocation.\\n *\\n * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\\n * on the trailing edge of the timeout only if the the debounced function is\\n * invoked more than once during the `wait` timeout.\\n *\\n * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\\n * for details over the differences between `_.debounce` and `_.throttle`.\\n *\\n * @static\\n * @memberOf _\\n * @category Function\\n * @param {Function} func The function to debounce.\\n * @param {number} [wait=0] The number of milliseconds to delay.\\n * @param {Object} [options] The options object.\\n * @param {boolean} [options.leading=false] Specify invoking on the leading\\n *  edge of the timeout.\\n * @param {number} [options.maxWait] The maximum time `func` is allowed to be\\n *  delayed before it's invoked.\\n * @param {boolean} [options.trailing=true] Specify invoking on the trailing\\n *  edge of the timeout.\\n * @returns {Function} Returns the new debounced function.\\n * @example\\n *\\n * // avoid costly calculations while the window size is in flux\\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\\n *\\n * // invoke `sendMail` when the click event is fired, debouncing subsequent calls\\n * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {\\n *   'leading': true,\\n *   'trailing': false\\n * }));\\n *\\n * // ensure `batchLog` is invoked once after 1 second of debounced calls\\n * var source = new EventSource('/stream');\\n * jQuery(source).on('message', _.debounce(batchLog, 250, {\\n *   'maxWait': 1000\\n * }));\\n *\\n * // cancel a debounced call\\n * var todoChanges = _.debounce(batchLog, 1000);\\n * Object.observe(models.todo, todoChanges);\\n *\\n * Object.observe(models, function(changes) {\\n *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {\\n *     todoChanges.cancel();\\n *   }\\n * }, ['delete']);\\n *\\n * // ...at some point `models.todo` is changed\\n * models.todo.completed = true;\\n *\\n * // ...before 1 second has passed `models.todo` is deleted\\n * // which cancels the debounced `todoChanges` call\\n * delete models.todo;\\n */\\nfunction debounce(func, wait, options) {\\n  var args,\\n      maxTimeoutId,\\n      result,\\n      stamp,\\n      thisArg,\\n      timeoutId,\\n      trailingCall,\\n      lastCalled = 0,\\n      maxWait = false,\\n      trailing = true;\\n\\n  if (typeof func != 'function') {\\n    throw new TypeError(FUNC_ERROR_TEXT);\\n  }\\n  wait = wait < 0 ? 0 : (+wait || 0);\\n  if (options === true) {\\n    var leading = true;\\n    trailing = false;\\n  } else if (isObject(options)) {\\n    leading = !!options.leading;\\n    maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);\\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\\n  }\\n\\n  function cancel() {\\n    if (timeoutId) {\\n      clearTimeout(timeoutId);\\n    }\\n    if (maxTimeoutId) {\\n      clearTimeout(maxTimeoutId);\\n    }\\n    lastCalled = 0;\\n    maxTimeoutId = timeoutId = trailingCall = undefined;\\n  }\\n\\n  function complete(isCalled, id) {\\n    if (id) {\\n      clearTimeout(id);\\n    }\\n    maxTimeoutId = timeoutId = trailingCall = undefined;\\n    if (isCalled) {\\n      lastCalled = now();\\n      result = func.apply(thisArg, args);\\n      if (!timeoutId && !maxTimeoutId) {\\n        args = thisArg = undefined;\\n      }\\n    }\\n  }\\n\\n  function delayed() {\\n    var remaining = wait - (now() - stamp);\\n    if (remaining <= 0 || remaining > wait) {\\n      complete(trailingCall, maxTimeoutId);\\n    } else {\\n      timeoutId = setTimeout(delayed, remaining);\\n    }\\n  }\\n\\n  function maxDelayed() {\\n    complete(trailing, timeoutId);\\n  }\\n\\n  function debounced() {\\n    args = arguments;\\n    stamp = now();\\n    thisArg = this;\\n    trailingCall = trailing && (timeoutId || !leading);\\n\\n    if (maxWait === false) {\\n      var leadingCall = leading && !timeoutId;\\n    } else {\\n      if (!maxTimeoutId && !leading) {\\n        lastCalled = stamp;\\n      }\\n      var remaining = maxWait - (stamp - lastCalled),\\n          isCalled = remaining <= 0 || remaining > maxWait;\\n\\n      if (isCalled) {\\n        if (maxTimeoutId) {\\n          maxTimeoutId = clearTimeout(maxTimeoutId);\\n        }\\n        lastCalled = stamp;\\n        result = func.apply(thisArg, args);\\n      }\\n      else if (!maxTimeoutId) {\\n        maxTimeoutId = setTimeout(maxDelayed, remaining);\\n      }\\n    }\\n    if (isCalled && timeoutId) {\\n      timeoutId = clearTimeout(timeoutId);\\n    }\\n    else if (!timeoutId && wait !== maxWait) {\\n      timeoutId = setTimeout(delayed, wait);\\n    }\\n    if (leadingCall) {\\n      isCalled = true;\\n      result = func.apply(thisArg, args);\\n    }\\n    if (isCalled && !timeoutId && !maxTimeoutId) {\\n      args = thisArg = undefined;\\n    }\\n    return result;\\n  }\\n  debounced.cancel = cancel;\\n  return debounced;\\n}\\n\\nmodule.exports = debounce;\\n\\n},{\\\"../date/now\\\":4,\\\"../lang/isObject\\\":33}],6:[function(_dereq_,module,exports){\\n/** Used as the `TypeError` message for \\\"Functions\\\" methods. */\\nvar FUNC_ERROR_TEXT = 'Expected a function';\\n\\n/* Native method references for those with the same name as other `lodash` methods. */\\nvar nativeMax = Math.max;\\n\\n/**\\n * Creates a function that invokes `func` with the `this` binding of the\\n * created function and arguments from `start` and beyond provided as an array.\\n *\\n * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/Web/JavaScript/Reference/Functions/rest_parameters).\\n *\\n * @static\\n * @memberOf _\\n * @category Function\\n * @param {Function} func The function to apply a rest parameter to.\\n * @param {number} [start=func.length-1] The start position of the rest parameter.\\n * @returns {Function} Returns the new function.\\n * @example\\n *\\n * var say = _.restParam(function(what, names) {\\n *   return what + ' ' + _.initial(names).join(', ') +\\n *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\\n * });\\n *\\n * say('hello', 'fred', 'barney', 'pebbles');\\n * // => 'hello fred, barney, & pebbles'\\n */\\nfunction restParam(func, start) {\\n  if (typeof func != 'function') {\\n    throw new TypeError(FUNC_ERROR_TEXT);\\n  }\\n  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);\\n  return function() {\\n    var args = arguments,\\n        index = -1,\\n        length = nativeMax(args.length - start, 0),\\n        rest = Array(length);\\n\\n    while (++index < length) {\\n      rest[index] = args[start + index];\\n    }\\n    switch (start) {\\n      case 0: return func.call(this, rest);\\n      case 1: return func.call(this, args[0], rest);\\n      case 2: return func.call(this, args[0], args[1], rest);\\n    }\\n    var otherArgs = Array(start + 1);\\n    index = -1;\\n    while (++index < start) {\\n      otherArgs[index] = args[index];\\n    }\\n    otherArgs[start] = rest;\\n    return func.apply(this, otherArgs);\\n  };\\n}\\n\\nmodule.exports = restParam;\\n\\n},{}],7:[function(_dereq_,module,exports){\\nvar debounce = _dereq_('./debounce'),\\n    isObject = _dereq_('../lang/isObject');\\n\\n/** Used as the `TypeError` message for \\\"Functions\\\" methods. */\\nvar FUNC_ERROR_TEXT = 'Expected a function';\\n\\n/**\\n * Creates a throttled function that only invokes `func` at most once per\\n * every `wait` milliseconds. The throttled function comes with a `cancel`\\n * method to cancel delayed invocations. Provide an options object to indicate\\n * that `func` should be invoked on the leading and/or trailing edge of the\\n * `wait` timeout. Subsequent calls to the throttled function return the\\n * result of the last `func` call.\\n *\\n * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\\n * on the trailing edge of the timeout only if the the throttled function is\\n * invoked more than once during the `wait` timeout.\\n *\\n * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\\n * for details over the differences between `_.throttle` and `_.debounce`.\\n *\\n * @static\\n * @memberOf _\\n * @category Function\\n * @param {Function} func The function to throttle.\\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\\n * @param {Object} [options] The options object.\\n * @param {boolean} [options.leading=true] Specify invoking on the leading\\n *  edge of the timeout.\\n * @param {boolean} [options.trailing=true] Specify invoking on the trailing\\n *  edge of the timeout.\\n * @returns {Function} Returns the new throttled function.\\n * @example\\n *\\n * // avoid excessively updating the position while scrolling\\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\\n *\\n * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes\\n * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {\\n *   'trailing': false\\n * }));\\n *\\n * // cancel a trailing throttled call\\n * jQuery(window).on('popstate', throttled.cancel);\\n */\\nfunction throttle(func, wait, options) {\\n  var leading = true,\\n      trailing = true;\\n\\n  if (typeof func != 'function') {\\n    throw new TypeError(FUNC_ERROR_TEXT);\\n  }\\n  if (options === false) {\\n    leading = false;\\n  } else if (isObject(options)) {\\n    leading = 'leading' in options ? !!options.leading : leading;\\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\\n  }\\n  return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });\\n}\\n\\nmodule.exports = throttle;\\n\\n},{\\\"../lang/isObject\\\":33,\\\"./debounce\\\":5}],8:[function(_dereq_,module,exports){\\n/**\\n * Copies the values of `source` to `array`.\\n *\\n * @private\\n * @param {Array} source The array to copy values from.\\n * @param {Array} [array=[]] The array to copy values to.\\n * @returns {Array} Returns `array`.\\n */\\nfunction arrayCopy(source, array) {\\n  var index = -1,\\n      length = source.length;\\n\\n  array || (array = Array(length));\\n  while (++index < length) {\\n    array[index] = source[index];\\n  }\\n  return array;\\n}\\n\\nmodule.exports = arrayCopy;\\n\\n},{}],9:[function(_dereq_,module,exports){\\n/**\\n * A specialized version of `_.forEach` for arrays without support for callback\\n * shorthands and `this` binding.\\n *\\n * @private\\n * @param {Array} array The array to iterate over.\\n * @param {Function} iteratee The function invoked per iteration.\\n * @returns {Array} Returns `array`.\\n */\\nfunction arrayEach(array, iteratee) {\\n  var index = -1,\\n      length = array.length;\\n\\n  while (++index < length) {\\n    if (iteratee(array[index], index, array) === false) {\\n      break;\\n    }\\n  }\\n  return array;\\n}\\n\\nmodule.exports = arrayEach;\\n\\n},{}],10:[function(_dereq_,module,exports){\\n/**\\n * Copies properties of `source` to `object`.\\n *\\n * @private\\n * @param {Object} source The object to copy properties from.\\n * @param {Array} props The property names to copy.\\n * @param {Object} [object={}] The object to copy properties to.\\n * @returns {Object} Returns `object`.\\n */\\nfunction baseCopy(source, props, object) {\\n  object || (object = {});\\n\\n  var index = -1,\\n      length = props.length;\\n\\n  while (++index < length) {\\n    var key = props[index];\\n    object[key] = source[key];\\n  }\\n  return object;\\n}\\n\\nmodule.exports = baseCopy;\\n\\n},{}],11:[function(_dereq_,module,exports){\\nvar createBaseFor = _dereq_('./createBaseFor');\\n\\n/**\\n * The base implementation of `baseForIn` and `baseForOwn` which iterates\\n * over `object` properties returned by `keysFunc` invoking `iteratee` for\\n * each property. Iteratee functions may exit iteration early by explicitly\\n * returning `false`.\\n *\\n * @private\\n * @param {Object} object The object to iterate over.\\n * @param {Function} iteratee The function invoked per iteration.\\n * @param {Function} keysFunc The function to get the keys of `object`.\\n * @returns {Object} Returns `object`.\\n */\\nvar baseFor = createBaseFor();\\n\\nmodule.exports = baseFor;\\n\\n},{\\\"./createBaseFor\\\":18}],12:[function(_dereq_,module,exports){\\nvar baseFor = _dereq_('./baseFor'),\\n    keysIn = _dereq_('../object/keysIn');\\n\\n/**\\n * The base implementation of `_.forIn` without support for callback\\n * shorthands and `this` binding.\\n *\\n * @private\\n * @param {Object} object The object to iterate over.\\n * @param {Function} iteratee The function invoked per iteration.\\n * @returns {Object} Returns `object`.\\n */\\nfunction baseForIn(object, iteratee) {\\n  return baseFor(object, iteratee, keysIn);\\n}\\n\\nmodule.exports = baseForIn;\\n\\n},{\\\"../object/keysIn\\\":39,\\\"./baseFor\\\":11}],13:[function(_dereq_,module,exports){\\nvar arrayEach = _dereq_('./arrayEach'),\\n    baseMergeDeep = _dereq_('./baseMergeDeep'),\\n    isArray = _dereq_('../lang/isArray'),\\n    isArrayLike = _dereq_('./isArrayLike'),\\n    isObject = _dereq_('../lang/isObject'),\\n    isObjectLike = _dereq_('./isObjectLike'),\\n    isTypedArray = _dereq_('../lang/isTypedArray'),\\n    keys = _dereq_('../object/keys');\\n\\n/**\\n * The base implementation of `_.merge` without support for argument juggling,\\n * multiple sources, and `this` binding `customizer` functions.\\n *\\n * @private\\n * @param {Object} object The destination object.\\n * @param {Object} source The source object.\\n * @param {Function} [customizer] The function to customize merged values.\\n * @param {Array} [stackA=[]] Tracks traversed source objects.\\n * @param {Array} [stackB=[]] Associates values with source counterparts.\\n * @returns {Object} Returns `object`.\\n */\\nfunction baseMerge(object, source, customizer, stackA, stackB) {\\n  if (!isObject(object)) {\\n    return object;\\n  }\\n  var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),\\n      props = isSrcArr ? undefined : keys(source);\\n\\n  arrayEach(props || source, function(srcValue, key) {\\n    if (props) {\\n      key = srcValue;\\n      srcValue = source[key];\\n    }\\n    if (isObjectLike(srcValue)) {\\n      stackA || (stackA = []);\\n      stackB || (stackB = []);\\n      baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);\\n    }\\n    else {\\n      var value = object[key],\\n          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\\n          isCommon = result === undefined;\\n\\n      if (isCommon) {\\n        result = srcValue;\\n      }\\n      if ((result !== undefined || (isSrcArr && !(key in object))) &&\\n          (isCommon || (result === result ? (result !== value) : (value === value)))) {\\n        object[key] = result;\\n      }\\n    }\\n  });\\n  return object;\\n}\\n\\nmodule.exports = baseMerge;\\n\\n},{\\\"../lang/isArray\\\":30,\\\"../lang/isObject\\\":33,\\\"../lang/isTypedArray\\\":36,\\\"../object/keys\\\":38,\\\"./arrayEach\\\":9,\\\"./baseMergeDeep\\\":14,\\\"./isArrayLike\\\":21,\\\"./isObjectLike\\\":26}],14:[function(_dereq_,module,exports){\\nvar arrayCopy = _dereq_('./arrayCopy'),\\n    isArguments = _dereq_('../lang/isArguments'),\\n    isArray = _dereq_('../lang/isArray'),\\n    isArrayLike = _dereq_('./isArrayLike'),\\n    isPlainObject = _dereq_('../lang/isPlainObject'),\\n    isTypedArray = _dereq_('../lang/isTypedArray'),\\n    toPlainObject = _dereq_('../lang/toPlainObject');\\n\\n/**\\n * A specialized version of `baseMerge` for arrays and objects which performs\\n * deep merges and tracks traversed objects enabling objects with circular\\n * references to be merged.\\n *\\n * @private\\n * @param {Object} object The destination object.\\n * @param {Object} source The source object.\\n * @param {string} key The key of the value to merge.\\n * @param {Function} mergeFunc The function to merge values.\\n * @param {Function} [customizer] The function to customize merged values.\\n * @param {Array} [stackA=[]] Tracks traversed source objects.\\n * @param {Array} [stackB=[]] Associates values with source counterparts.\\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\\n */\\nfunction baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {\\n  var length = stackA.length,\\n      srcValue = source[key];\\n\\n  while (length--) {\\n    if (stackA[length] == srcValue) {\\n      object[key] = stackB[length];\\n      return;\\n    }\\n  }\\n  var value = object[key],\\n      result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\\n      isCommon = result === undefined;\\n\\n  if (isCommon) {\\n    result = srcValue;\\n    if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {\\n      result = isArray(value)\\n        ? value\\n        : (isArrayLike(value) ? arrayCopy(value) : []);\\n    }\\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\\n      result = isArguments(value)\\n        ? toPlainObject(value)\\n        : (isPlainObject(value) ? value : {});\\n    }\\n    else {\\n      isCommon = false;\\n    }\\n  }\\n  // Add the source value to the stack of traversed objects and associate\\n  // it with its merged value.\\n  stackA.push(srcValue);\\n  stackB.push(result);\\n\\n  if (isCommon) {\\n    // Recursively merge objects and arrays (susceptible to call stack limits).\\n    object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);\\n  } else if (result === result ? (result !== value) : (value === value)) {\\n    object[key] = result;\\n  }\\n}\\n\\nmodule.exports = baseMergeDeep;\\n\\n},{\\\"../lang/isArguments\\\":29,\\\"../lang/isArray\\\":30,\\\"../lang/isPlainObject\\\":34,\\\"../lang/isTypedArray\\\":36,\\\"../lang/toPlainObject\\\":37,\\\"./arrayCopy\\\":8,\\\"./isArrayLike\\\":21}],15:[function(_dereq_,module,exports){\\nvar toObject = _dereq_('./toObject');\\n\\n/**\\n * The base implementation of `_.property` without support for deep paths.\\n *\\n * @private\\n * @param {string} key The key of the property to get.\\n * @returns {Function} Returns the new function.\\n */\\nfunction baseProperty(key) {\\n  return function(object) {\\n    return object == null ? undefined : toObject(object)[key];\\n  };\\n}\\n\\nmodule.exports = baseProperty;\\n\\n},{\\\"./toObject\\\":28}],16:[function(_dereq_,module,exports){\\nvar identity = _dereq_('../utility/identity');\\n\\n/**\\n * A specialized version of `baseCallback` which only supports `this` binding\\n * and specifying the number of arguments to provide to `func`.\\n *\\n * @private\\n * @param {Function} func The function to bind.\\n * @param {*} thisArg The `this` binding of `func`.\\n * @param {number} [argCount] The number of arguments to provide to `func`.\\n * @returns {Function} Returns the callback.\\n */\\nfunction bindCallback(func, thisArg, argCount) {\\n  if (typeof func != 'function') {\\n    return identity;\\n  }\\n  if (thisArg === undefined) {\\n    return func;\\n  }\\n  switch (argCount) {\\n    case 1: return function(value) {\\n      return func.call(thisArg, value);\\n    };\\n    case 3: return function(value, index, collection) {\\n      return func.call(thisArg, value, index, collection);\\n    };\\n    case 4: return function(accumulator, value, index, collection) {\\n      return func.call(thisArg, accumulator, value, index, collection);\\n    };\\n    case 5: return function(value, other, key, object, source) {\\n      return func.call(thisArg, value, other, key, object, source);\\n    };\\n  }\\n  return function() {\\n    return func.apply(thisArg, arguments);\\n  };\\n}\\n\\nmodule.exports = bindCallback;\\n\\n},{\\\"../utility/identity\\\":42}],17:[function(_dereq_,module,exports){\\nvar bindCallback = _dereq_('./bindCallback'),\\n    isIterateeCall = _dereq_('./isIterateeCall'),\\n    restParam = _dereq_('../function/restParam');\\n\\n/**\\n * Creates a `_.assign`, `_.defaults`, or `_.merge` function.\\n *\\n * @private\\n * @param {Function} assigner The function to assign values.\\n * @returns {Function} Returns the new assigner function.\\n */\\nfunction createAssigner(assigner) {\\n  return restParam(function(object, sources) {\\n    var index = -1,\\n        length = object == null ? 0 : sources.length,\\n        customizer = length > 2 ? sources[length - 2] : undefined,\\n        guard = length > 2 ? sources[2] : undefined,\\n        thisArg = length > 1 ? sources[length - 1] : undefined;\\n\\n    if (typeof customizer == 'function') {\\n      customizer = bindCallback(customizer, thisArg, 5);\\n      length -= 2;\\n    } else {\\n      customizer = typeof thisArg == 'function' ? thisArg : undefined;\\n      length -= (customizer ? 1 : 0);\\n    }\\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\\n      customizer = length < 3 ? undefined : customizer;\\n      length = 1;\\n    }\\n    while (++index < length) {\\n      var source = sources[index];\\n      if (source) {\\n        assigner(object, source, customizer);\\n      }\\n    }\\n    return object;\\n  });\\n}\\n\\nmodule.exports = createAssigner;\\n\\n},{\\\"../function/restParam\\\":6,\\\"./bindCallback\\\":16,\\\"./isIterateeCall\\\":24}],18:[function(_dereq_,module,exports){\\nvar toObject = _dereq_('./toObject');\\n\\n/**\\n * Creates a base function for `_.forIn` or `_.forInRight`.\\n *\\n * @private\\n * @param {boolean} [fromRight] Specify iterating from right to left.\\n * @returns {Function} Returns the new base function.\\n */\\nfunction createBaseFor(fromRight) {\\n  return function(object, iteratee, keysFunc) {\\n    var iterable = toObject(object),\\n        props = keysFunc(object),\\n        length = props.length,\\n        index = fromRight ? length : -1;\\n\\n    while ((fromRight ? index-- : ++index < length)) {\\n      var key = props[index];\\n      if (iteratee(iterable[key], key, iterable) === false) {\\n        break;\\n      }\\n    }\\n    return object;\\n  };\\n}\\n\\nmodule.exports = createBaseFor;\\n\\n},{\\\"./toObject\\\":28}],19:[function(_dereq_,module,exports){\\nvar baseProperty = _dereq_('./baseProperty');\\n\\n/**\\n * Gets the \\\"length\\\" property value of `object`.\\n *\\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\\n * that affects Safari on at least iOS 8.1-8.3 ARM64.\\n *\\n * @private\\n * @param {Object} object The object to query.\\n * @returns {*} Returns the \\\"length\\\" value.\\n */\\nvar getLength = baseProperty('length');\\n\\nmodule.exports = getLength;\\n\\n},{\\\"./baseProperty\\\":15}],20:[function(_dereq_,module,exports){\\nvar isNative = _dereq_('../lang/isNative');\\n\\n/**\\n * Gets the native function at `key` of `object`.\\n *\\n * @private\\n * @param {Object} object The object to query.\\n * @param {string} key The key of the method to get.\\n * @returns {*} Returns the function if it's native, else `undefined`.\\n */\\nfunction getNative(object, key) {\\n  var value = object == null ? undefined : object[key];\\n  return isNative(value) ? value : undefined;\\n}\\n\\nmodule.exports = getNative;\\n\\n},{\\\"../lang/isNative\\\":32}],21:[function(_dereq_,module,exports){\\nvar getLength = _dereq_('./getLength'),\\n    isLength = _dereq_('./isLength');\\n\\n/**\\n * Checks if `value` is array-like.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\\n */\\nfunction isArrayLike(value) {\\n  return value != null && isLength(getLength(value));\\n}\\n\\nmodule.exports = isArrayLike;\\n\\n},{\\\"./getLength\\\":19,\\\"./isLength\\\":25}],22:[function(_dereq_,module,exports){\\n/**\\n * Checks if `value` is a host object in IE < 9.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\\n */\\nvar isHostObject = (function() {\\n  try {\\n    Object({ 'toString': 0 } + '');\\n  } catch(e) {\\n    return function() { return false; };\\n  }\\n  return function(value) {\\n    // IE < 9 presents many host objects as `Object` objects that can coerce\\n    // to strings despite having improperly defined `toString` methods.\\n    return typeof value.toString != 'function' && typeof (value + '') == 'string';\\n  };\\n}());\\n\\nmodule.exports = isHostObject;\\n\\n},{}],23:[function(_dereq_,module,exports){\\n/** Used to detect unsigned integer values. */\\nvar reIsUint = /^\\\\d+$/;\\n\\n/**\\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\\n * of an array-like value.\\n */\\nvar MAX_SAFE_INTEGER = 9007199254740991;\\n\\n/**\\n * Checks if `value` is a valid array-like index.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\\n */\\nfunction isIndex(value, length) {\\n  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\\n  length = length == null ? MAX_SAFE_INTEGER : length;\\n  return value > -1 && value % 1 == 0 && value < length;\\n}\\n\\nmodule.exports = isIndex;\\n\\n},{}],24:[function(_dereq_,module,exports){\\nvar isArrayLike = _dereq_('./isArrayLike'),\\n    isIndex = _dereq_('./isIndex'),\\n    isObject = _dereq_('../lang/isObject');\\n\\n/**\\n * Checks if the provided arguments are from an iteratee call.\\n *\\n * @private\\n * @param {*} value The potential iteratee value argument.\\n * @param {*} index The potential iteratee index or key argument.\\n * @param {*} object The potential iteratee object argument.\\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\\n */\\nfunction isIterateeCall(value, index, object) {\\n  if (!isObject(object)) {\\n    return false;\\n  }\\n  var type = typeof index;\\n  if (type == 'number'\\n      ? (isArrayLike(object) && isIndex(index, object.length))\\n      : (type == 'string' && index in object)) {\\n    var other = object[index];\\n    return value === value ? (value === other) : (other !== other);\\n  }\\n  return false;\\n}\\n\\nmodule.exports = isIterateeCall;\\n\\n},{\\\"../lang/isObject\\\":33,\\\"./isArrayLike\\\":21,\\\"./isIndex\\\":23}],25:[function(_dereq_,module,exports){\\n/**\\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\\n * of an array-like value.\\n */\\nvar MAX_SAFE_INTEGER = 9007199254740991;\\n\\n/**\\n * Checks if `value` is a valid array-like length.\\n *\\n * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\\n */\\nfunction isLength(value) {\\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\\n}\\n\\nmodule.exports = isLength;\\n\\n},{}],26:[function(_dereq_,module,exports){\\n/**\\n * Checks if `value` is object-like.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\\n */\\nfunction isObjectLike(value) {\\n  return !!value && typeof value == 'object';\\n}\\n\\nmodule.exports = isObjectLike;\\n\\n},{}],27:[function(_dereq_,module,exports){\\nvar isArguments = _dereq_('../lang/isArguments'),\\n    isArray = _dereq_('../lang/isArray'),\\n    isIndex = _dereq_('./isIndex'),\\n    isLength = _dereq_('./isLength'),\\n    isString = _dereq_('../lang/isString'),\\n    keysIn = _dereq_('../object/keysIn');\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/** Used to check objects for own properties. */\\nvar hasOwnProperty = objectProto.hasOwnProperty;\\n\\n/**\\n * A fallback implementation of `Object.keys` which creates an array of the\\n * own enumerable property names of `object`.\\n *\\n * @private\\n * @param {Object} object The object to query.\\n * @returns {Array} Returns the array of property names.\\n */\\nfunction shimKeys(object) {\\n  var props = keysIn(object),\\n      propsLength = props.length,\\n      length = propsLength && object.length;\\n\\n  var allowIndexes = !!length && isLength(length) &&\\n    (isArray(object) || isArguments(object) || isString(object));\\n\\n  var index = -1,\\n      result = [];\\n\\n  while (++index < propsLength) {\\n    var key = props[index];\\n    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\\n      result.push(key);\\n    }\\n  }\\n  return result;\\n}\\n\\nmodule.exports = shimKeys;\\n\\n},{\\\"../lang/isArguments\\\":29,\\\"../lang/isArray\\\":30,\\\"../lang/isString\\\":35,\\\"../object/keysIn\\\":39,\\\"./isIndex\\\":23,\\\"./isLength\\\":25}],28:[function(_dereq_,module,exports){\\nvar isObject = _dereq_('../lang/isObject'),\\n    isString = _dereq_('../lang/isString'),\\n    support = _dereq_('../support');\\n\\n/**\\n * Converts `value` to an object if it's not one.\\n *\\n * @private\\n * @param {*} value The value to process.\\n * @returns {Object} Returns the object.\\n */\\nfunction toObject(value) {\\n  if (support.unindexedChars && isString(value)) {\\n    var index = -1,\\n        length = value.length,\\n        result = Object(value);\\n\\n    while (++index < length) {\\n      result[index] = value.charAt(index);\\n    }\\n    return result;\\n  }\\n  return isObject(value) ? value : Object(value);\\n}\\n\\nmodule.exports = toObject;\\n\\n},{\\\"../lang/isObject\\\":33,\\\"../lang/isString\\\":35,\\\"../support\\\":41}],29:[function(_dereq_,module,exports){\\nvar isArrayLike = _dereq_('../internal/isArrayLike'),\\n    isObjectLike = _dereq_('../internal/isObjectLike');\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/** Used to check objects for own properties. */\\nvar hasOwnProperty = objectProto.hasOwnProperty;\\n\\n/** Native method references. */\\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\\n\\n/**\\n * Checks if `value` is classified as an `arguments` object.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\\n * @example\\n *\\n * _.isArguments(function() { return arguments; }());\\n * // => true\\n *\\n * _.isArguments([1, 2, 3]);\\n * // => false\\n */\\nfunction isArguments(value) {\\n  return isObjectLike(value) && isArrayLike(value) &&\\n    hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\\n}\\n\\nmodule.exports = isArguments;\\n\\n},{\\\"../internal/isArrayLike\\\":21,\\\"../internal/isObjectLike\\\":26}],30:[function(_dereq_,module,exports){\\nvar getNative = _dereq_('../internal/getNative'),\\n    isLength = _dereq_('../internal/isLength'),\\n    isObjectLike = _dereq_('../internal/isObjectLike');\\n\\n/** `Object#toString` result references. */\\nvar arrayTag = '[object Array]';\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/* Native method references for those with the same name as other `lodash` methods. */\\nvar nativeIsArray = getNative(Array, 'isArray');\\n\\n/**\\n * Checks if `value` is classified as an `Array` object.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\\n * @example\\n *\\n * _.isArray([1, 2, 3]);\\n * // => true\\n *\\n * _.isArray(function() { return arguments; }());\\n * // => false\\n */\\nvar isArray = nativeIsArray || function(value) {\\n  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\\n};\\n\\nmodule.exports = isArray;\\n\\n},{\\\"../internal/getNative\\\":20,\\\"../internal/isLength\\\":25,\\\"../internal/isObjectLike\\\":26}],31:[function(_dereq_,module,exports){\\nvar isObject = _dereq_('./isObject');\\n\\n/** `Object#toString` result references. */\\nvar funcTag = '[object Function]';\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/**\\n * Checks if `value` is classified as a `Function` object.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\\n * @example\\n *\\n * _.isFunction(_);\\n * // => true\\n *\\n * _.isFunction(/abc/);\\n * // => false\\n */\\nfunction isFunction(value) {\\n  // The use of `Object#toString` avoids issues with the `typeof` operator\\n  // in older versions of Chrome and Safari which return 'function' for regexes\\n  // and Safari 8 which returns 'object' for typed array constructors.\\n  return isObject(value) && objToString.call(value) == funcTag;\\n}\\n\\nmodule.exports = isFunction;\\n\\n},{\\\"./isObject\\\":33}],32:[function(_dereq_,module,exports){\\nvar isFunction = _dereq_('./isFunction'),\\n    isHostObject = _dereq_('../internal/isHostObject'),\\n    isObjectLike = _dereq_('../internal/isObjectLike');\\n\\n/** Used to detect host constructors (Safari > 5). */\\nvar reIsHostCtor = /^\\\\[object .+?Constructor\\\\]$/;\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/** Used to resolve the decompiled source of functions. */\\nvar fnToString = Function.prototype.toString;\\n\\n/** Used to check objects for own properties. */\\nvar hasOwnProperty = objectProto.hasOwnProperty;\\n\\n/** Used to detect if a method is native. */\\nvar reIsNative = RegExp('^' +\\n  fnToString.call(hasOwnProperty).replace(/[\\\\\\\\^$.*+?()[\\\\]{}|]/g, '\\\\\\\\$&')\\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\\\\\\\()| for .+?(?=\\\\\\\\\\\\])/g, '$1.*?') + '$'\\n);\\n\\n/**\\n * Checks if `value` is a native function.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\\n * @example\\n *\\n * _.isNative(Array.prototype.push);\\n * // => true\\n *\\n * _.isNative(_);\\n * // => false\\n */\\nfunction isNative(value) {\\n  if (value == null) {\\n    return false;\\n  }\\n  if (isFunction(value)) {\\n    return reIsNative.test(fnToString.call(value));\\n  }\\n  return isObjectLike(value) && (isHostObject(value) ? reIsNative : reIsHostCtor).test(value);\\n}\\n\\nmodule.exports = isNative;\\n\\n},{\\\"../internal/isHostObject\\\":22,\\\"../internal/isObjectLike\\\":26,\\\"./isFunction\\\":31}],33:[function(_dereq_,module,exports){\\n/**\\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\\n * @example\\n *\\n * _.isObject({});\\n * // => true\\n *\\n * _.isObject([1, 2, 3]);\\n * // => true\\n *\\n * _.isObject(1);\\n * // => false\\n */\\nfunction isObject(value) {\\n  // Avoid a V8 JIT bug in Chrome 19-20.\\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\\n  var type = typeof value;\\n  return !!value && (type == 'object' || type == 'function');\\n}\\n\\nmodule.exports = isObject;\\n\\n},{}],34:[function(_dereq_,module,exports){\\nvar baseForIn = _dereq_('../internal/baseForIn'),\\n    isArguments = _dereq_('./isArguments'),\\n    isHostObject = _dereq_('../internal/isHostObject'),\\n    isObjectLike = _dereq_('../internal/isObjectLike'),\\n    support = _dereq_('../support');\\n\\n/** `Object#toString` result references. */\\nvar objectTag = '[object Object]';\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/** Used to check objects for own properties. */\\nvar hasOwnProperty = objectProto.hasOwnProperty;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/**\\n * Checks if `value` is a plain object, that is, an object created by the\\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\\n *\\n * **Note:** This method assumes objects created by the `Object` constructor\\n * have no inherited enumerable properties.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\\n * @example\\n *\\n * function Foo() {\\n *   this.a = 1;\\n * }\\n *\\n * _.isPlainObject(new Foo);\\n * // => false\\n *\\n * _.isPlainObject([1, 2, 3]);\\n * // => false\\n *\\n * _.isPlainObject({ 'x': 0, 'y': 0 });\\n * // => true\\n *\\n * _.isPlainObject(Object.create(null));\\n * // => true\\n */\\nfunction isPlainObject(value) {\\n  var Ctor;\\n\\n  // Exit early for non `Object` objects.\\n  if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isHostObject(value) && !isArguments(value)) ||\\n      (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {\\n    return false;\\n  }\\n  // IE < 9 iterates inherited properties before own properties. If the first\\n  // iterated property is an object's own property then there are no inherited\\n  // enumerable properties.\\n  var result;\\n  if (support.ownLast) {\\n    baseForIn(value, function(subValue, key, object) {\\n      result = hasOwnProperty.call(object, key);\\n      return false;\\n    });\\n    return result !== false;\\n  }\\n  // In most environments an object's own properties are iterated before\\n  // its inherited properties. If the last iterated property is an object's\\n  // own property then there are no inherited enumerable properties.\\n  baseForIn(value, function(subValue, key) {\\n    result = key;\\n  });\\n  return result === undefined || hasOwnProperty.call(value, result);\\n}\\n\\nmodule.exports = isPlainObject;\\n\\n},{\\\"../internal/baseForIn\\\":12,\\\"../internal/isHostObject\\\":22,\\\"../internal/isObjectLike\\\":26,\\\"../support\\\":41,\\\"./isArguments\\\":29}],35:[function(_dereq_,module,exports){\\nvar isObjectLike = _dereq_('../internal/isObjectLike');\\n\\n/** `Object#toString` result references. */\\nvar stringTag = '[object String]';\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/**\\n * Checks if `value` is classified as a `String` primitive or object.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\\n * @example\\n *\\n * _.isString('abc');\\n * // => true\\n *\\n * _.isString(1);\\n * // => false\\n */\\nfunction isString(value) {\\n  return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);\\n}\\n\\nmodule.exports = isString;\\n\\n},{\\\"../internal/isObjectLike\\\":26}],36:[function(_dereq_,module,exports){\\nvar isLength = _dereq_('../internal/isLength'),\\n    isObjectLike = _dereq_('../internal/isObjectLike');\\n\\n/** `Object#toString` result references. */\\nvar argsTag = '[object Arguments]',\\n    arrayTag = '[object Array]',\\n    boolTag = '[object Boolean]',\\n    dateTag = '[object Date]',\\n    errorTag = '[object Error]',\\n    funcTag = '[object Function]',\\n    mapTag = '[object Map]',\\n    numberTag = '[object Number]',\\n    objectTag = '[object Object]',\\n    regexpTag = '[object RegExp]',\\n    setTag = '[object Set]',\\n    stringTag = '[object String]',\\n    weakMapTag = '[object WeakMap]';\\n\\nvar arrayBufferTag = '[object ArrayBuffer]',\\n    float32Tag = '[object Float32Array]',\\n    float64Tag = '[object Float64Array]',\\n    int8Tag = '[object Int8Array]',\\n    int16Tag = '[object Int16Array]',\\n    int32Tag = '[object Int32Array]',\\n    uint8Tag = '[object Uint8Array]',\\n    uint8ClampedTag = '[object Uint8ClampedArray]',\\n    uint16Tag = '[object Uint16Array]',\\n    uint32Tag = '[object Uint32Array]';\\n\\n/** Used to identify `toStringTag` values of typed arrays. */\\nvar typedArrayTags = {};\\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\\ntypedArrayTags[uint32Tag] = true;\\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\\ntypedArrayTags[dateTag] = typedArrayTags[errorTag] =\\ntypedArrayTags[funcTag] = typedArrayTags[mapTag] =\\ntypedArrayTags[numberTag] = typedArrayTags[objectTag] =\\ntypedArrayTags[regexpTag] = typedArrayTags[setTag] =\\ntypedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/**\\n * Checks if `value` is classified as a typed array.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\\n * @example\\n *\\n * _.isTypedArray(new Uint8Array);\\n * // => true\\n *\\n * _.isTypedArray([]);\\n * // => false\\n */\\nfunction isTypedArray(value) {\\n  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];\\n}\\n\\nmodule.exports = isTypedArray;\\n\\n},{\\\"../internal/isLength\\\":25,\\\"../internal/isObjectLike\\\":26}],37:[function(_dereq_,module,exports){\\nvar baseCopy = _dereq_('../internal/baseCopy'),\\n    keysIn = _dereq_('../object/keysIn');\\n\\n/**\\n * Converts `value` to a plain object flattening inherited enumerable\\n * properties of `value` to own properties of the plain object.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to convert.\\n * @returns {Object} Returns the converted plain object.\\n * @example\\n *\\n * function Foo() {\\n *   this.b = 2;\\n * }\\n *\\n * Foo.prototype.c = 3;\\n *\\n * _.assign({ 'a': 1 }, new Foo);\\n * // => { 'a': 1, 'b': 2 }\\n *\\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\\n * // => { 'a': 1, 'b': 2, 'c': 3 }\\n */\\nfunction toPlainObject(value) {\\n  return baseCopy(value, keysIn(value));\\n}\\n\\nmodule.exports = toPlainObject;\\n\\n},{\\\"../internal/baseCopy\\\":10,\\\"../object/keysIn\\\":39}],38:[function(_dereq_,module,exports){\\nvar getNative = _dereq_('../internal/getNative'),\\n    isArrayLike = _dereq_('../internal/isArrayLike'),\\n    isObject = _dereq_('../lang/isObject'),\\n    shimKeys = _dereq_('../internal/shimKeys'),\\n    support = _dereq_('../support');\\n\\n/* Native method references for those with the same name as other `lodash` methods. */\\nvar nativeKeys = getNative(Object, 'keys');\\n\\n/**\\n * Creates an array of the own enumerable property names of `object`.\\n *\\n * **Note:** Non-object values are coerced to objects. See the\\n * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\\n * for more details.\\n *\\n * @static\\n * @memberOf _\\n * @category Object\\n * @param {Object} object The object to query.\\n * @returns {Array} Returns the array of property names.\\n * @example\\n *\\n * function Foo() {\\n *   this.a = 1;\\n *   this.b = 2;\\n * }\\n *\\n * Foo.prototype.c = 3;\\n *\\n * _.keys(new Foo);\\n * // => ['a', 'b'] (iteration order is not guaranteed)\\n *\\n * _.keys('hi');\\n * // => ['0', '1']\\n */\\nvar keys = !nativeKeys ? shimKeys : function(object) {\\n  var Ctor = object == null ? undefined : object.constructor;\\n  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\\n      (typeof object == 'function' ? support.enumPrototypes : isArrayLike(object))) {\\n    return shimKeys(object);\\n  }\\n  return isObject(object) ? nativeKeys(object) : [];\\n};\\n\\nmodule.exports = keys;\\n\\n},{\\\"../internal/getNative\\\":20,\\\"../internal/isArrayLike\\\":21,\\\"../internal/shimKeys\\\":27,\\\"../lang/isObject\\\":33,\\\"../support\\\":41}],39:[function(_dereq_,module,exports){\\nvar arrayEach = _dereq_('../internal/arrayEach'),\\n    isArguments = _dereq_('../lang/isArguments'),\\n    isArray = _dereq_('../lang/isArray'),\\n    isFunction = _dereq_('../lang/isFunction'),\\n    isIndex = _dereq_('../internal/isIndex'),\\n    isLength = _dereq_('../internal/isLength'),\\n    isObject = _dereq_('../lang/isObject'),\\n    isString = _dereq_('../lang/isString'),\\n    support = _dereq_('../support');\\n\\n/** `Object#toString` result references. */\\nvar arrayTag = '[object Array]',\\n    boolTag = '[object Boolean]',\\n    dateTag = '[object Date]',\\n    errorTag = '[object Error]',\\n    funcTag = '[object Function]',\\n    numberTag = '[object Number]',\\n    objectTag = '[object Object]',\\n    regexpTag = '[object RegExp]',\\n    stringTag = '[object String]';\\n\\n/** Used to fix the JScript `[[DontEnum]]` bug. */\\nvar shadowProps = [\\n  'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',\\n  'toLocaleString', 'toString', 'valueOf'\\n];\\n\\n/** Used for native method references. */\\nvar errorProto = Error.prototype,\\n    objectProto = Object.prototype,\\n    stringProto = String.prototype;\\n\\n/** Used to check objects for own properties. */\\nvar hasOwnProperty = objectProto.hasOwnProperty;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/** Used to avoid iterating over non-enumerable properties in IE < 9. */\\nvar nonEnumProps = {};\\nnonEnumProps[arrayTag] = nonEnumProps[dateTag] = nonEnumProps[numberTag] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };\\nnonEnumProps[boolTag] = nonEnumProps[stringTag] = { 'constructor': true, 'toString': true, 'valueOf': true };\\nnonEnumProps[errorTag] = nonEnumProps[funcTag] = nonEnumProps[regexpTag] = { 'constructor': true, 'toString': true };\\nnonEnumProps[objectTag] = { 'constructor': true };\\n\\narrayEach(shadowProps, function(key) {\\n  for (var tag in nonEnumProps) {\\n    if (hasOwnProperty.call(nonEnumProps, tag)) {\\n      var props = nonEnumProps[tag];\\n      props[key] = hasOwnProperty.call(props, key);\\n    }\\n  }\\n});\\n\\n/**\\n * Creates an array of the own and inherited enumerable property names of `object`.\\n *\\n * **Note:** Non-object values are coerced to objects.\\n *\\n * @static\\n * @memberOf _\\n * @category Object\\n * @param {Object} object The object to query.\\n * @returns {Array} Returns the array of property names.\\n * @example\\n *\\n * function Foo() {\\n *   this.a = 1;\\n *   this.b = 2;\\n * }\\n *\\n * Foo.prototype.c = 3;\\n *\\n * _.keysIn(new Foo);\\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\\n */\\nfunction keysIn(object) {\\n  if (object == null) {\\n    return [];\\n  }\\n  if (!isObject(object)) {\\n    object = Object(object);\\n  }\\n  var length = object.length;\\n\\n  length = (length && isLength(length) &&\\n    (isArray(object) || isArguments(object) || isString(object)) && length) || 0;\\n\\n  var Ctor = object.constructor,\\n      index = -1,\\n      proto = (isFunction(Ctor) && Ctor.prototype) || objectProto,\\n      isProto = proto === object,\\n      result = Array(length),\\n      skipIndexes = length > 0,\\n      skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error),\\n      skipProto = support.enumPrototypes && isFunction(object);\\n\\n  while (++index < length) {\\n    result[index] = (index + '');\\n  }\\n  // lodash skips the `constructor` property when it infers it's iterating\\n  // over a `prototype` object because IE < 9 can't set the `[[Enumerable]]`\\n  // attribute of an existing property and the `constructor` property of a\\n  // prototype defaults to non-enumerable.\\n  for (var key in object) {\\n    if (!(skipProto && key == 'prototype') &&\\n        !(skipErrorProps && (key == 'message' || key == 'name')) &&\\n        !(skipIndexes && isIndex(key, length)) &&\\n        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\\n      result.push(key);\\n    }\\n  }\\n  if (support.nonEnumShadows && object !== objectProto) {\\n    var tag = object === stringProto ? stringTag : (object === errorProto ? errorTag : objToString.call(object)),\\n        nonEnums = nonEnumProps[tag] || nonEnumProps[objectTag];\\n\\n    if (tag == objectTag) {\\n      proto = objectProto;\\n    }\\n    length = shadowProps.length;\\n    while (length--) {\\n      key = shadowProps[length];\\n      var nonEnum = nonEnums[key];\\n      if (!(isProto && nonEnum) &&\\n          (nonEnum ? hasOwnProperty.call(object, key) : object[key] !== proto[key])) {\\n        result.push(key);\\n      }\\n    }\\n  }\\n  return result;\\n}\\n\\nmodule.exports = keysIn;\\n\\n},{\\\"../internal/arrayEach\\\":9,\\\"../internal/isIndex\\\":23,\\\"../internal/isLength\\\":25,\\\"../lang/isArguments\\\":29,\\\"../lang/isArray\\\":30,\\\"../lang/isFunction\\\":31,\\\"../lang/isObject\\\":33,\\\"../lang/isString\\\":35,\\\"../support\\\":41}],40:[function(_dereq_,module,exports){\\nvar baseMerge = _dereq_('../internal/baseMerge'),\\n    createAssigner = _dereq_('../internal/createAssigner');\\n\\n/**\\n * Recursively merges own enumerable properties of the source object(s), that\\n * don't resolve to `undefined` into the destination object. Subsequent sources\\n * overwrite property assignments of previous sources. If `customizer` is\\n * provided it's invoked to produce the merged values of the destination and\\n * source properties. If `customizer` returns `undefined` merging is handled\\n * by the method instead. The `customizer` is bound to `thisArg` and invoked\\n * with five arguments: (objectValue, sourceValue, key, object, source).\\n *\\n * @static\\n * @memberOf _\\n * @category Object\\n * @param {Object} object The destination object.\\n * @param {...Object} [sources] The source objects.\\n * @param {Function} [customizer] The function to customize assigned values.\\n * @param {*} [thisArg] The `this` binding of `customizer`.\\n * @returns {Object} Returns `object`.\\n * @example\\n *\\n * var users = {\\n *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]\\n * };\\n *\\n * var ages = {\\n *   'data': [{ 'age': 36 }, { 'age': 40 }]\\n * };\\n *\\n * _.merge(users, ages);\\n * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }\\n *\\n * // using a customizer callback\\n * var object = {\\n *   'fruits': ['apple'],\\n *   'vegetables': ['beet']\\n * };\\n *\\n * var other = {\\n *   'fruits': ['banana'],\\n *   'vegetables': ['carrot']\\n * };\\n *\\n * _.merge(object, other, function(a, b) {\\n *   if (_.isArray(a)) {\\n *     return a.concat(b);\\n *   }\\n * });\\n * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }\\n */\\nvar merge = createAssigner(baseMerge);\\n\\nmodule.exports = merge;\\n\\n},{\\\"../internal/baseMerge\\\":13,\\\"../internal/createAssigner\\\":17}],41:[function(_dereq_,module,exports){\\n/** Used for native method references. */\\nvar arrayProto = Array.prototype,\\n    errorProto = Error.prototype,\\n    objectProto = Object.prototype;\\n\\n/** Native method references. */\\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable,\\n    splice = arrayProto.splice;\\n\\n/**\\n * An object environment feature flags.\\n *\\n * @static\\n * @memberOf _\\n * @type Object\\n */\\nvar support = {};\\n\\n(function(x) {\\n  var Ctor = function() { this.x = x; },\\n      object = { '0': x, 'length': x },\\n      props = [];\\n\\n  Ctor.prototype = { 'valueOf': x, 'y': x };\\n  for (var key in new Ctor) { props.push(key); }\\n\\n  /**\\n   * Detect if `name` or `message` properties of `Error.prototype` are\\n   * enumerable by default (IE < 9, Safari < 5.1).\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') ||\\n    propertyIsEnumerable.call(errorProto, 'name');\\n\\n  /**\\n   * Detect if `prototype` properties are enumerable by default.\\n   *\\n   * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1\\n   * (if the prototype or a property on the prototype has been set)\\n   * incorrectly set the `[[Enumerable]]` value of a function's `prototype`\\n   * property to `true`.\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.enumPrototypes = propertyIsEnumerable.call(Ctor, 'prototype');\\n\\n  /**\\n   * Detect if properties shadowing those on `Object.prototype` are non-enumerable.\\n   *\\n   * In IE < 9 an object's own properties, shadowing non-enumerable ones,\\n   * are made non-enumerable as well (a.k.a the JScript `[[DontEnum]]` bug).\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.nonEnumShadows = !/valueOf/.test(props);\\n\\n  /**\\n   * Detect if own properties are iterated after inherited properties (IE < 9).\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.ownLast = props[0] != 'x';\\n\\n  /**\\n   * Detect if `Array#shift` and `Array#splice` augment array-like objects\\n   * correctly.\\n   *\\n   * Firefox < 10, compatibility modes of IE 8, and IE < 9 have buggy Array\\n   * `shift()` and `splice()` functions that fail to remove the last element,\\n   * `value[0]`, of array-like objects even though the \\\"length\\\" property is\\n   * set to `0`. The `shift()` method is buggy in compatibility modes of IE 8,\\n   * while `splice()` is buggy regardless of mode in IE < 9.\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.spliceObjects = (splice.call(object, 0, 1), !object[0]);\\n\\n  /**\\n   * Detect lack of support for accessing string characters by index.\\n   *\\n   * IE < 8 can't access characters by index. IE 8 can only access characters\\n   * by index on string literals, not string objects.\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.unindexedChars = ('x'[0] + Object('x')[0]) != 'xx';\\n}(1, 0));\\n\\nmodule.exports = support;\\n\\n},{}],42:[function(_dereq_,module,exports){\\n/**\\n * This method returns the first argument provided to it.\\n *\\n * @static\\n * @memberOf _\\n * @category Utility\\n * @param {*} value Any value.\\n * @returns {*} Returns `value`.\\n * @example\\n *\\n * var object = { 'user': 'fred' };\\n *\\n * _.identity(object) === object;\\n * // => true\\n */\\nfunction identity(value) {\\n  return value;\\n}\\n\\nmodule.exports = identity;\\n\\n},{}],43:[function(_dereq_,module,exports){\\n'use strict';\\n\\nvar keys = _dereq_('object-keys');\\n\\nmodule.exports = function hasSymbols() {\\n\\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\\n\\tif (typeof Symbol.iterator === 'symbol') { return true; }\\n\\n\\tvar obj = {};\\n\\tvar sym = Symbol('test');\\n\\tif (typeof sym === 'string') { return false; }\\n\\n\\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\\n\\t// if (sym instanceof Symbol) { return false; }\\n\\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\\n\\t// if (!(Object(sym) instanceof Symbol)) { return false; }\\n\\n\\tvar symVal = 42;\\n\\tobj[sym] = symVal;\\n\\tfor (sym in obj) { return false; }\\n\\tif (keys(obj).length !== 0) { return false; }\\n\\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\\n\\n\\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\\n\\n\\tvar syms = Object.getOwnPropertySymbols(obj);\\n\\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\\n\\n\\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\\n\\n\\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\\n\\t\\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\\n\\t\\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\\n\\t}\\n\\n\\treturn true;\\n};\\n\\n},{\\\"object-keys\\\":50}],44:[function(_dereq_,module,exports){\\n'use strict';\\n\\n// modified from https://github.com/es-shims/es6-shim\\nvar keys = _dereq_('object-keys');\\nvar bind = _dereq_('function-bind');\\nvar canBeObject = function (obj) {\\n\\treturn typeof obj !== 'undefined' && obj !== null;\\n};\\nvar hasSymbols = _dereq_('./hasSymbols')();\\nvar toObject = Object;\\nvar push = bind.call(Function.call, Array.prototype.push);\\nvar propIsEnumerable = bind.call(Function.call, Object.prototype.propertyIsEnumerable);\\n\\nmodule.exports = function assign(target, source1) {\\n\\tif (!canBeObject(target)) { throw new TypeError('target must be an object'); }\\n\\tvar objTarget = toObject(target);\\n\\tvar s, source, i, props, syms, value, key;\\n\\tfor (s = 1; s < arguments.length; ++s) {\\n\\t\\tsource = toObject(arguments[s]);\\n\\t\\tprops = keys(source);\\n\\t\\tif (hasSymbols && Object.getOwnPropertySymbols) {\\n\\t\\t\\tsyms = Object.getOwnPropertySymbols(source);\\n\\t\\t\\tfor (i = 0; i < syms.length; ++i) {\\n\\t\\t\\t\\tkey = syms[i];\\n\\t\\t\\t\\tif (propIsEnumerable(source, key)) {\\n\\t\\t\\t\\t\\tpush(props, key);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (i = 0; i < props.length; ++i) {\\n\\t\\t\\tkey = props[i];\\n\\t\\t\\tvalue = source[key];\\n\\t\\t\\tif (propIsEnumerable(source, key)) {\\n\\t\\t\\t\\tobjTarget[key] = value;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn objTarget;\\n};\\n\\n},{\\\"./hasSymbols\\\":43,\\\"function-bind\\\":49,\\\"object-keys\\\":50}],45:[function(_dereq_,module,exports){\\n'use strict';\\n\\nvar defineProperties = _dereq_('define-properties');\\n\\nvar implementation = _dereq_('./implementation');\\nvar getPolyfill = _dereq_('./polyfill');\\nvar shim = _dereq_('./shim');\\n\\ndefineProperties(implementation, {\\n\\timplementation: implementation,\\n\\tgetPolyfill: getPolyfill,\\n\\tshim: shim\\n});\\n\\nmodule.exports = implementation;\\n\\n},{\\\"./implementation\\\":44,\\\"./polyfill\\\":52,\\\"./shim\\\":53,\\\"define-properties\\\":46}],46:[function(_dereq_,module,exports){\\n'use strict';\\n\\nvar keys = _dereq_('object-keys');\\nvar foreach = _dereq_('foreach');\\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';\\n\\nvar toStr = Object.prototype.toString;\\n\\nvar isFunction = function (fn) {\\n\\treturn typeof fn === 'function' && toStr.call(fn) === '[object Function]';\\n};\\n\\nvar arePropertyDescriptorsSupported = function () {\\n\\tvar obj = {};\\n\\ttry {\\n\\t\\tObject.defineProperty(obj, 'x', { enumerable: false, value: obj });\\n        /* eslint-disable no-unused-vars, no-restricted-syntax */\\n        for (var _ in obj) { return false; }\\n        /* eslint-enable no-unused-vars, no-restricted-syntax */\\n\\t\\treturn obj.x === obj;\\n\\t} catch (e) { /* this is IE 8. */\\n\\t\\treturn false;\\n\\t}\\n};\\nvar supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();\\n\\nvar defineProperty = function (object, name, value, predicate) {\\n\\tif (name in object && (!isFunction(predicate) || !predicate())) {\\n\\t\\treturn;\\n\\t}\\n\\tif (supportsDescriptors) {\\n\\t\\tObject.defineProperty(object, name, {\\n\\t\\t\\tconfigurable: true,\\n\\t\\t\\tenumerable: false,\\n\\t\\t\\tvalue: value,\\n\\t\\t\\twritable: true\\n\\t\\t});\\n\\t} else {\\n\\t\\tobject[name] = value;\\n\\t}\\n};\\n\\nvar defineProperties = function (object, map) {\\n\\tvar predicates = arguments.length > 2 ? arguments[2] : {};\\n\\tvar props = keys(map);\\n\\tif (hasSymbols) {\\n\\t\\tprops = props.concat(Object.getOwnPropertySymbols(map));\\n\\t}\\n\\tforeach(props, function (name) {\\n\\t\\tdefineProperty(object, name, map[name], predicates[name]);\\n\\t});\\n};\\n\\ndefineProperties.supportsDescriptors = !!supportsDescriptors;\\n\\nmodule.exports = defineProperties;\\n\\n},{\\\"foreach\\\":47,\\\"object-keys\\\":50}],47:[function(_dereq_,module,exports){\\n\\nvar hasOwn = Object.prototype.hasOwnProperty;\\nvar toString = Object.prototype.toString;\\n\\nmodule.exports = function forEach (obj, fn, ctx) {\\n    if (toString.call(fn) !== '[object Function]') {\\n        throw new TypeError('iterator must be a function');\\n    }\\n    var l = obj.length;\\n    if (l === +l) {\\n        for (var i = 0; i < l; i++) {\\n            fn.call(ctx, obj[i], i, obj);\\n        }\\n    } else {\\n        for (var k in obj) {\\n            if (hasOwn.call(obj, k)) {\\n                fn.call(ctx, obj[k], k, obj);\\n            }\\n        }\\n    }\\n};\\n\\n\\n},{}],48:[function(_dereq_,module,exports){\\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\\nvar slice = Array.prototype.slice;\\nvar toStr = Object.prototype.toString;\\nvar funcType = '[object Function]';\\n\\nmodule.exports = function bind(that) {\\n    var target = this;\\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\\n        throw new TypeError(ERROR_MESSAGE + target);\\n    }\\n    var args = slice.call(arguments, 1);\\n\\n    var bound;\\n    var binder = function () {\\n        if (this instanceof bound) {\\n            var result = target.apply(\\n                this,\\n                args.concat(slice.call(arguments))\\n            );\\n            if (Object(result) === result) {\\n                return result;\\n            }\\n            return this;\\n        } else {\\n            return target.apply(\\n                that,\\n                args.concat(slice.call(arguments))\\n            );\\n        }\\n    };\\n\\n    var boundLength = Math.max(0, target.length - args.length);\\n    var boundArgs = [];\\n    for (var i = 0; i < boundLength; i++) {\\n        boundArgs.push('$' + i);\\n    }\\n\\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\\n\\n    if (target.prototype) {\\n        var Empty = function Empty() {};\\n        Empty.prototype = target.prototype;\\n        bound.prototype = new Empty();\\n        Empty.prototype = null;\\n    }\\n\\n    return bound;\\n};\\n\\n},{}],49:[function(_dereq_,module,exports){\\nvar implementation = _dereq_('./implementation');\\n\\nmodule.exports = Function.prototype.bind || implementation;\\n\\n},{\\\"./implementation\\\":48}],50:[function(_dereq_,module,exports){\\n'use strict';\\n\\n// modified from https://github.com/es-shims/es5-shim\\nvar has = Object.prototype.hasOwnProperty;\\nvar toStr = Object.prototype.toString;\\nvar slice = Array.prototype.slice;\\nvar isArgs = _dereq_('./isArguments');\\nvar isEnumerable = Object.prototype.propertyIsEnumerable;\\nvar hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');\\nvar hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');\\nvar dontEnums = [\\n\\t'toString',\\n\\t'toLocaleString',\\n\\t'valueOf',\\n\\t'hasOwnProperty',\\n\\t'isPrototypeOf',\\n\\t'propertyIsEnumerable',\\n\\t'constructor'\\n];\\nvar equalsConstructorPrototype = function (o) {\\n\\tvar ctor = o.constructor;\\n\\treturn ctor && ctor.prototype === o;\\n};\\nvar excludedKeys = {\\n\\t$console: true,\\n\\t$external: true,\\n\\t$frame: true,\\n\\t$frameElement: true,\\n\\t$frames: true,\\n\\t$innerHeight: true,\\n\\t$innerWidth: true,\\n\\t$outerHeight: true,\\n\\t$outerWidth: true,\\n\\t$pageXOffset: true,\\n\\t$pageYOffset: true,\\n\\t$parent: true,\\n\\t$scrollLeft: true,\\n\\t$scrollTop: true,\\n\\t$scrollX: true,\\n\\t$scrollY: true,\\n\\t$self: true,\\n\\t$webkitIndexedDB: true,\\n\\t$webkitStorageInfo: true,\\n\\t$window: true\\n};\\nvar hasAutomationEqualityBug = (function () {\\n\\t/* global window */\\n\\tif (typeof window === 'undefined') { return false; }\\n\\tfor (var k in window) {\\n\\t\\ttry {\\n\\t\\t\\tif (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tequalsConstructorPrototype(window[k]);\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}());\\nvar equalsConstructorPrototypeIfNotBuggy = function (o) {\\n\\t/* global window */\\n\\tif (typeof window === 'undefined' || !hasAutomationEqualityBug) {\\n\\t\\treturn equalsConstructorPrototype(o);\\n\\t}\\n\\ttry {\\n\\t\\treturn equalsConstructorPrototype(o);\\n\\t} catch (e) {\\n\\t\\treturn false;\\n\\t}\\n};\\n\\nvar keysShim = function keys(object) {\\n\\tvar isObject = object !== null && typeof object === 'object';\\n\\tvar isFunction = toStr.call(object) === '[object Function]';\\n\\tvar isArguments = isArgs(object);\\n\\tvar isString = isObject && toStr.call(object) === '[object String]';\\n\\tvar theKeys = [];\\n\\n\\tif (!isObject && !isFunction && !isArguments) {\\n\\t\\tthrow new TypeError('Object.keys called on a non-object');\\n\\t}\\n\\n\\tvar skipProto = hasProtoEnumBug && isFunction;\\n\\tif (isString && object.length > 0 && !has.call(object, 0)) {\\n\\t\\tfor (var i = 0; i < object.length; ++i) {\\n\\t\\t\\ttheKeys.push(String(i));\\n\\t\\t}\\n\\t}\\n\\n\\tif (isArguments && object.length > 0) {\\n\\t\\tfor (var j = 0; j < object.length; ++j) {\\n\\t\\t\\ttheKeys.push(String(j));\\n\\t\\t}\\n\\t} else {\\n\\t\\tfor (var name in object) {\\n\\t\\t\\tif (!(skipProto && name === 'prototype') && has.call(object, name)) {\\n\\t\\t\\t\\ttheKeys.push(String(name));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif (hasDontEnumBug) {\\n\\t\\tvar skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\\n\\n\\t\\tfor (var k = 0; k < dontEnums.length; ++k) {\\n\\t\\t\\tif (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {\\n\\t\\t\\t\\ttheKeys.push(dontEnums[k]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn theKeys;\\n};\\n\\nkeysShim.shim = function shimObjectKeys() {\\n\\tif (Object.keys) {\\n\\t\\tvar keysWorksWithArguments = (function () {\\n\\t\\t\\t// Safari 5.0 bug\\n\\t\\t\\treturn (Object.keys(arguments) || '').length === 2;\\n\\t\\t}(1, 2));\\n\\t\\tif (!keysWorksWithArguments) {\\n\\t\\t\\tvar originalKeys = Object.keys;\\n\\t\\t\\tObject.keys = function keys(object) {\\n\\t\\t\\t\\tif (isArgs(object)) {\\n\\t\\t\\t\\t\\treturn originalKeys(slice.call(object));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn originalKeys(object);\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t}\\n\\t} else {\\n\\t\\tObject.keys = keysShim;\\n\\t}\\n\\treturn Object.keys || keysShim;\\n};\\n\\nmodule.exports = keysShim;\\n\\n},{\\\"./isArguments\\\":51}],51:[function(_dereq_,module,exports){\\n'use strict';\\n\\nvar toStr = Object.prototype.toString;\\n\\nmodule.exports = function isArguments(value) {\\n\\tvar str = toStr.call(value);\\n\\tvar isArgs = str === '[object Arguments]';\\n\\tif (!isArgs) {\\n\\t\\tisArgs = str !== '[object Array]' &&\\n\\t\\t\\tvalue !== null &&\\n\\t\\t\\ttypeof value === 'object' &&\\n\\t\\t\\ttypeof value.length === 'number' &&\\n\\t\\t\\tvalue.length >= 0 &&\\n\\t\\t\\ttoStr.call(value.callee) === '[object Function]';\\n\\t}\\n\\treturn isArgs;\\n};\\n\\n},{}],52:[function(_dereq_,module,exports){\\n'use strict';\\n\\nvar implementation = _dereq_('./implementation');\\n\\nvar lacksProperEnumerationOrder = function () {\\n\\tif (!Object.assign) {\\n\\t\\treturn false;\\n\\t}\\n\\t// v8, specifically in node 4.x, has a bug with incorrect property enumeration order\\n\\t// note: this does not detect the bug unless there's 20 characters\\n\\tvar str = 'abcdefghijklmnopqrst';\\n\\tvar letters = str.split('');\\n\\tvar map = {};\\n\\tfor (var i = 0; i < letters.length; ++i) {\\n\\t\\tmap[letters[i]] = letters[i];\\n\\t}\\n\\tvar obj = Object.assign({}, map);\\n\\tvar actual = '';\\n\\tfor (var k in obj) {\\n\\t\\tactual += k;\\n\\t}\\n\\treturn str !== actual;\\n};\\n\\nvar assignHasPendingExceptions = function () {\\n\\tif (!Object.assign || !Object.preventExtensions) {\\n\\t\\treturn false;\\n\\t}\\n\\t// Firefox 37 still has \\\"pending exception\\\" logic in its Object.assign implementation,\\n\\t// which is 72% slower than our shim, and Firefox 40's native implementation.\\n\\tvar thrower = Object.preventExtensions({ 1: 2 });\\n\\ttry {\\n\\t\\tObject.assign(thrower, 'xy');\\n\\t} catch (e) {\\n\\t\\treturn thrower[1] === 'y';\\n\\t}\\n};\\n\\nmodule.exports = function getPolyfill() {\\n\\tif (!Object.assign) {\\n\\t\\treturn implementation;\\n\\t}\\n\\tif (lacksProperEnumerationOrder()) {\\n\\t\\treturn implementation;\\n\\t}\\n\\tif (assignHasPendingExceptions()) {\\n\\t\\treturn implementation;\\n\\t}\\n\\treturn Object.assign;\\n};\\n\\n},{\\\"./implementation\\\":44}],53:[function(_dereq_,module,exports){\\n'use strict';\\n\\nvar define = _dereq_('define-properties');\\nvar getPolyfill = _dereq_('./polyfill');\\n\\nmodule.exports = function shimAssign() {\\n\\tvar polyfill = getPolyfill();\\n\\tdefine(\\n\\t\\tObject,\\n\\t\\t{ assign: polyfill },\\n\\t\\t{ assign: function () { return Object.assign !== polyfill; } }\\n\\t);\\n\\treturn polyfill;\\n};\\n\\n},{\\\"./polyfill\\\":52,\\\"define-properties\\\":46}],54:[function(_dereq_,module,exports){\\nmodule.exports = SafeParseTuple\\n\\nfunction SafeParseTuple(obj, reviver) {\\n    var json\\n    var error = null\\n\\n    try {\\n        json = JSON.parse(obj, reviver)\\n    } catch (err) {\\n        error = err\\n    }\\n\\n    return [error, json]\\n}\\n\\n},{}],55:[function(_dereq_,module,exports){\\nfunction clean (s) {\\n  return s.replace(/\\\\n\\\\r?\\\\s*/g, '')\\n}\\n\\n\\nmodule.exports = function tsml (sa) {\\n  var s = ''\\n    , i = 0\\n\\n  for (; i < arguments.length; i++)\\n    s += clean(sa[i]) + (arguments[i + 1] || '')\\n\\n  return s\\n}\\n},{}],56:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nvar window = _dereq_(\\\"global/window\\\")\\nvar once = _dereq_(\\\"once\\\")\\nvar isFunction = _dereq_(\\\"is-function\\\")\\nvar parseHeaders = _dereq_(\\\"parse-headers\\\")\\nvar xtend = _dereq_(\\\"xtend\\\")\\n\\nmodule.exports = createXHR\\ncreateXHR.XMLHttpRequest = window.XMLHttpRequest || noop\\ncreateXHR.XDomainRequest = \\\"withCredentials\\\" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest\\n\\nforEachArray([\\\"get\\\", \\\"put\\\", \\\"post\\\", \\\"patch\\\", \\\"head\\\", \\\"delete\\\"], function(method) {\\n    createXHR[method === \\\"delete\\\" ? \\\"del\\\" : method] = function(uri, options, callback) {\\n        options = initParams(uri, options, callback)\\n        options.method = method.toUpperCase()\\n        return _createXHR(options)\\n    }\\n})\\n\\nfunction forEachArray(array, iterator) {\\n    for (var i = 0; i < array.length; i++) {\\n        iterator(array[i])\\n    }\\n}\\n\\nfunction isEmpty(obj){\\n    for(var i in obj){\\n        if(obj.hasOwnProperty(i)) return false\\n    }\\n    return true\\n}\\n\\nfunction initParams(uri, options, callback) {\\n    var params = uri\\n\\n    if (isFunction(options)) {\\n        callback = options\\n        if (typeof uri === \\\"string\\\") {\\n            params = {uri:uri}\\n        }\\n    } else {\\n        params = xtend(options, {uri: uri})\\n    }\\n\\n    params.callback = callback\\n    return params\\n}\\n\\nfunction createXHR(uri, options, callback) {\\n    options = initParams(uri, options, callback)\\n    return _createXHR(options)\\n}\\n\\nfunction _createXHR(options) {\\n    var callback = options.callback\\n    if(typeof callback === \\\"undefined\\\"){\\n        throw new Error(\\\"callback argument missing\\\")\\n    }\\n    callback = once(callback)\\n\\n    function readystatechange() {\\n        if (xhr.readyState === 4) {\\n            loadFunc()\\n        }\\n    }\\n\\n    function getBody() {\\n        // Chrome with requestType=blob throws errors arround when even testing access to responseText\\n        var body = undefined\\n\\n        if (xhr.response) {\\n            body = xhr.response\\n        } else if (xhr.responseType === \\\"text\\\" || !xhr.responseType) {\\n            body = xhr.responseText || xhr.responseXML\\n        }\\n\\n        if (isJson) {\\n            try {\\n                body = JSON.parse(body)\\n            } catch (e) {}\\n        }\\n\\n        return body\\n    }\\n\\n    var failureResponse = {\\n                body: undefined,\\n                headers: {},\\n                statusCode: 0,\\n                method: method,\\n                url: uri,\\n                rawRequest: xhr\\n            }\\n\\n    function errorFunc(evt) {\\n        clearTimeout(timeoutTimer)\\n        if(!(evt instanceof Error)){\\n            evt = new Error(\\\"\\\" + (evt || \\\"Unknown XMLHttpRequest Error\\\") )\\n        }\\n        evt.statusCode = 0\\n        callback(evt, failureResponse)\\n    }\\n\\n    // will load the data & process the response in a special response object\\n    function loadFunc() {\\n        if (aborted) return\\n        var status\\n        clearTimeout(timeoutTimer)\\n        if(options.useXDR && xhr.status===undefined) {\\n            //IE8 CORS GET successful response doesn't have a status field, but body is fine\\n            status = 200\\n        } else {\\n            status = (xhr.status === 1223 ? 204 : xhr.status)\\n        }\\n        var response = failureResponse\\n        var err = null\\n\\n        if (status !== 0){\\n            response = {\\n                body: getBody(),\\n                statusCode: status,\\n                method: method,\\n                headers: {},\\n                url: uri,\\n                rawRequest: xhr\\n            }\\n            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE\\n                response.headers = parseHeaders(xhr.getAllResponseHeaders())\\n            }\\n        } else {\\n            err = new Error(\\\"Internal XMLHttpRequest Error\\\")\\n        }\\n        callback(err, response, response.body)\\n\\n    }\\n\\n    var xhr = options.xhr || null\\n\\n    if (!xhr) {\\n        if (options.cors || options.useXDR) {\\n            xhr = new createXHR.XDomainRequest()\\n        }else{\\n            xhr = new createXHR.XMLHttpRequest()\\n        }\\n    }\\n\\n    var key\\n    var aborted\\n    var uri = xhr.url = options.uri || options.url\\n    var method = xhr.method = options.method || \\\"GET\\\"\\n    var body = options.body || options.data || null\\n    var headers = xhr.headers = options.headers || {}\\n    var sync = !!options.sync\\n    var isJson = false\\n    var timeoutTimer\\n\\n    if (\\\"json\\\" in options) {\\n        isJson = true\\n        headers[\\\"accept\\\"] || headers[\\\"Accept\\\"] || (headers[\\\"Accept\\\"] = \\\"application/json\\\") //Don't override existing accept header declared by user\\n        if (method !== \\\"GET\\\" && method !== \\\"HEAD\\\") {\\n            headers[\\\"content-type\\\"] || headers[\\\"Content-Type\\\"] || (headers[\\\"Content-Type\\\"] = \\\"application/json\\\") //Don't override existing accept header declared by user\\n            body = JSON.stringify(options.json)\\n        }\\n    }\\n\\n    xhr.onreadystatechange = readystatechange\\n    xhr.onload = loadFunc\\n    xhr.onerror = errorFunc\\n    // IE9 must have onprogress be set to a unique function.\\n    xhr.onprogress = function () {\\n        // IE must die\\n    }\\n    xhr.ontimeout = errorFunc\\n    xhr.open(method, uri, !sync, options.username, options.password)\\n    //has to be after open\\n    if(!sync) {\\n        xhr.withCredentials = !!options.withCredentials\\n    }\\n    // Cannot set timeout with sync request\\n    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\\n    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent\\n    if (!sync && options.timeout > 0 ) {\\n        timeoutTimer = setTimeout(function(){\\n            aborted=true//IE9 may still call readystatechange\\n            xhr.abort(\\\"timeout\\\")\\n            var e = new Error(\\\"XMLHttpRequest timeout\\\")\\n            e.code = \\\"ETIMEDOUT\\\"\\n            errorFunc(e)\\n        }, options.timeout )\\n    }\\n\\n    if (xhr.setRequestHeader) {\\n        for(key in headers){\\n            if(headers.hasOwnProperty(key)){\\n                xhr.setRequestHeader(key, headers[key])\\n            }\\n        }\\n    } else if (options.headers && !isEmpty(options.headers)) {\\n        throw new Error(\\\"Headers cannot be set on an XDomainRequest object\\\")\\n    }\\n\\n    if (\\\"responseType\\\" in options) {\\n        xhr.responseType = options.responseType\\n    }\\n\\n    if (\\\"beforeSend\\\" in options &&\\n        typeof options.beforeSend === \\\"function\\\"\\n    ) {\\n        options.beforeSend(xhr)\\n    }\\n\\n    xhr.send(body)\\n\\n    return xhr\\n\\n\\n}\\n\\nfunction noop() {}\\n\\n},{\\\"global/window\\\":2,\\\"is-function\\\":57,\\\"once\\\":58,\\\"parse-headers\\\":61,\\\"xtend\\\":62}],57:[function(_dereq_,module,exports){\\nmodule.exports = isFunction\\n\\nvar toString = Object.prototype.toString\\n\\nfunction isFunction (fn) {\\n  var string = toString.call(fn)\\n  return string === '[object Function]' ||\\n    (typeof fn === 'function' && string !== '[object RegExp]') ||\\n    (typeof window !== 'undefined' &&\\n     // IE8 and below\\n     (fn === window.setTimeout ||\\n      fn === window.alert ||\\n      fn === window.confirm ||\\n      fn === window.prompt))\\n};\\n\\n},{}],58:[function(_dereq_,module,exports){\\nmodule.exports = once\\n\\nonce.proto = once(function () {\\n  Object.defineProperty(Function.prototype, 'once', {\\n    value: function () {\\n      return once(this)\\n    },\\n    configurable: true\\n  })\\n})\\n\\nfunction once (fn) {\\n  var called = false\\n  return function () {\\n    if (called) return\\n    called = true\\n    return fn.apply(this, arguments)\\n  }\\n}\\n\\n},{}],59:[function(_dereq_,module,exports){\\nvar isFunction = _dereq_('is-function')\\n\\nmodule.exports = forEach\\n\\nvar toString = Object.prototype.toString\\nvar hasOwnProperty = Object.prototype.hasOwnProperty\\n\\nfunction forEach(list, iterator, context) {\\n    if (!isFunction(iterator)) {\\n        throw new TypeError('iterator must be a function')\\n    }\\n\\n    if (arguments.length < 3) {\\n        context = this\\n    }\\n    \\n    if (toString.call(list) === '[object Array]')\\n        forEachArray(list, iterator, context)\\n    else if (typeof list === 'string')\\n        forEachString(list, iterator, context)\\n    else\\n        forEachObject(list, iterator, context)\\n}\\n\\nfunction forEachArray(array, iterator, context) {\\n    for (var i = 0, len = array.length; i < len; i++) {\\n        if (hasOwnProperty.call(array, i)) {\\n            iterator.call(context, array[i], i, array)\\n        }\\n    }\\n}\\n\\nfunction forEachString(string, iterator, context) {\\n    for (var i = 0, len = string.length; i < len; i++) {\\n        // no such thing as a sparse string.\\n        iterator.call(context, string.charAt(i), i, string)\\n    }\\n}\\n\\nfunction forEachObject(object, iterator, context) {\\n    for (var k in object) {\\n        if (hasOwnProperty.call(object, k)) {\\n            iterator.call(context, object[k], k, object)\\n        }\\n    }\\n}\\n\\n},{\\\"is-function\\\":57}],60:[function(_dereq_,module,exports){\\n\\nexports = module.exports = trim;\\n\\nfunction trim(str){\\n  return str.replace(/^\\\\s*|\\\\s*$/g, '');\\n}\\n\\nexports.left = function(str){\\n  return str.replace(/^\\\\s*/, '');\\n};\\n\\nexports.right = function(str){\\n  return str.replace(/\\\\s*$/, '');\\n};\\n\\n},{}],61:[function(_dereq_,module,exports){\\nvar trim = _dereq_('trim')\\n  , forEach = _dereq_('for-each')\\n  , isArray = function(arg) {\\n      return Object.prototype.toString.call(arg) === '[object Array]';\\n    }\\n\\nmodule.exports = function (headers) {\\n  if (!headers)\\n    return {}\\n\\n  var result = {}\\n\\n  forEach(\\n      trim(headers).split('\\\\n')\\n    , function (row) {\\n        var index = row.indexOf(':')\\n          , key = trim(row.slice(0, index)).toLowerCase()\\n          , value = trim(row.slice(index + 1))\\n\\n        if (typeof(result[key]) === 'undefined') {\\n          result[key] = value\\n        } else if (isArray(result[key])) {\\n          result[key].push(value)\\n        } else {\\n          result[key] = [ result[key], value ]\\n        }\\n      }\\n  )\\n\\n  return result\\n}\\n},{\\\"for-each\\\":59,\\\"trim\\\":60}],62:[function(_dereq_,module,exports){\\nmodule.exports = extend\\n\\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\\n\\nfunction extend() {\\n    var target = {}\\n\\n    for (var i = 0; i < arguments.length; i++) {\\n        var source = arguments[i]\\n\\n        for (var key in source) {\\n            if (hasOwnProperty.call(source, key)) {\\n                target[key] = source[key]\\n            }\\n        }\\n    }\\n\\n    return target\\n}\\n\\n},{}],63:[function(_dereq_,module,exports){\\n/**\\n * @file big-play-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _buttonJs = _dereq_('./button.js');\\n\\nvar _buttonJs2 = _interopRequireDefault(_buttonJs);\\n\\nvar _componentJs = _dereq_('./component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n/**\\n * Initial play button. Shows before the video has played. The hiding of the\\n * big play button is done via CSS and player states.\\n *\\n * @param {Object} player  Main Player\\n * @param {Object=} options Object of option names and values\\n * @extends Button\\n * @class BigPlayButton\\n */\\n\\nvar BigPlayButton = (function (_Button) {\\n  _inherits(BigPlayButton, _Button);\\n\\n  function BigPlayButton(player, options) {\\n    _classCallCheck(this, BigPlayButton);\\n\\n    _Button.call(this, player, options);\\n  }\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  BigPlayButton.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-big-play-button';\\n  };\\n\\n  /**\\n   * Handles click for play\\n   *\\n   * @method handleClick\\n   */\\n\\n  BigPlayButton.prototype.handleClick = function handleClick() {\\n    this.player_.play();\\n  };\\n\\n  return BigPlayButton;\\n})(_buttonJs2['default']);\\n\\nBigPlayButton.prototype.controlText_ = 'Play Video';\\n\\n_componentJs2['default'].registerComponent('BigPlayButton', BigPlayButton);\\nexports['default'] = BigPlayButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./button.js\\\":64,\\\"./component.js\\\":67}],64:[function(_dereq_,module,exports){\\n/**\\n * @file button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _clickableComponentJs = _dereq_('./clickable-component.js');\\n\\nvar _clickableComponentJs2 = _interopRequireDefault(_clickableComponentJs);\\n\\nvar _component = _dereq_('./component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _utilsEventsJs = _dereq_('./utils/events.js');\\n\\nvar Events = _interopRequireWildcard(_utilsEventsJs);\\n\\nvar _utilsFnJs = _dereq_('./utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsLogJs = _dereq_('./utils/log.js');\\n\\nvar _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _objectAssign = _dereq_('object.assign');\\n\\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\\n\\n/**\\n * Base class for all buttons\\n *\\n * @param {Object} player  Main Player\\n * @param {Object=} options Object of option names and values\\n * @extends ClickableComponent\\n * @class Button\\n */\\n\\nvar Button = (function (_ClickableComponent) {\\n  _inherits(Button, _ClickableComponent);\\n\\n  function Button(player, options) {\\n    _classCallCheck(this, Button);\\n\\n    _ClickableComponent.call(this, player, options);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @param {String=} type Element's node type. e.g. 'div'\\n   * @param {Object=} props An object of properties that should be set on the element\\n   * @param {Object=} attributes An object of attributes that should be set on the element\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  Button.prototype.createEl = function createEl() {\\n    var tag = arguments.length <= 0 || arguments[0] === undefined ? 'button' : arguments[0];\\n    var props = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n    var attributes = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\\n\\n    props = _objectAssign2['default']({\\n      className: this.buildCSSClass()\\n    }, props);\\n\\n    if (tag !== 'button') {\\n      _utilsLogJs2['default'].warn('Creating a Button with an HTML element of ' + tag + ' is deprecated; use ClickableComponent instead.');\\n\\n      // Add properties for clickable element which is not a native HTML button\\n      props = _objectAssign2['default']({\\n        tabIndex: 0\\n      }, props);\\n\\n      // Add ARIA attributes for clickable element which is not a native HTML button\\n      attributes = _objectAssign2['default']({\\n        role: 'button'\\n      }, attributes);\\n    }\\n\\n    // Add attributes for button element\\n    attributes = _objectAssign2['default']({\\n      type: 'button', // Necessary since the default button type is \\\"submit\\\"\\n      'aria-live': 'polite' // let the screen reader user know that the text of the button may change\\n    }, attributes);\\n\\n    var el = _component2['default'].prototype.createEl.call(this, tag, props, attributes);\\n\\n    this.createControlTextEl(el);\\n\\n    return el;\\n  };\\n\\n  /**\\n   * Adds a child component inside this button\\n   *\\n   * @param {String|Component} child The class name or instance of a child to add\\n   * @param {Object=} options Options, including options to be passed to children of the child.\\n   * @return {Component} The child component (created by this process if a string was used)\\n   * @deprecated\\n   * @method addChild\\n   */\\n\\n  Button.prototype.addChild = function addChild(child) {\\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n\\n    var className = this.constructor.name;\\n    _utilsLogJs2['default'].warn('Adding an actionable (user controllable) child to a Button (' + className + ') is not supported; use a ClickableComponent instead.');\\n\\n    // Avoid the error message generated by ClickableComponent's addChild method\\n    return _component2['default'].prototype.addChild.call(this, child, options);\\n  };\\n\\n  /**\\n   * Handle KeyPress (document level) - Extend with specific functionality for button\\n   *\\n   * @method handleKeyPress\\n   */\\n\\n  Button.prototype.handleKeyPress = function handleKeyPress(event) {\\n    // Ignore Space (32) or Enter (13) key operation, which is handled by the browser for a button.\\n    if (event.which === 32 || event.which === 13) {} else {\\n      _ClickableComponent.prototype.handleKeyPress.call(this, event); // Pass keypress handling up for unsupported keys\\n    }\\n  };\\n\\n  return Button;\\n})(_clickableComponentJs2['default']);\\n\\n_component2['default'].registerComponent('Button', Button);\\nexports['default'] = Button;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./clickable-component.js\\\":65,\\\"./component\\\":67,\\\"./utils/events.js\\\":143,\\\"./utils/fn.js\\\":144,\\\"./utils/log.js\\\":147,\\\"global/document\\\":1,\\\"object.assign\\\":45}],65:[function(_dereq_,module,exports){\\n/**\\n * @file button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _component = _dereq_('./component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _utilsDomJs = _dereq_('./utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsEventsJs = _dereq_('./utils/events.js');\\n\\nvar Events = _interopRequireWildcard(_utilsEventsJs);\\n\\nvar _utilsFnJs = _dereq_('./utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsLogJs = _dereq_('./utils/log.js');\\n\\nvar _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _objectAssign = _dereq_('object.assign');\\n\\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\\n\\n/**\\n * Clickable Component which is clickable or keyboard actionable, but is not a native HTML button\\n *\\n * @param {Object} player  Main Player\\n * @param {Object=} options Object of option names and values\\n * @extends Component\\n * @class ClickableComponent\\n */\\n\\nvar ClickableComponent = (function (_Component) {\\n  _inherits(ClickableComponent, _Component);\\n\\n  function ClickableComponent(player, options) {\\n    _classCallCheck(this, ClickableComponent);\\n\\n    _Component.call(this, player, options);\\n\\n    this.emitTapEvents();\\n\\n    this.on('tap', this.handleClick);\\n    this.on('click', this.handleClick);\\n    this.on('focus', this.handleFocus);\\n    this.on('blur', this.handleBlur);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @param {String=} type Element's node type. e.g. 'div'\\n   * @param {Object=} props An object of properties that should be set on the element\\n   * @param {Object=} attributes An object of attributes that should be set on the element\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  ClickableComponent.prototype.createEl = function createEl() {\\n    var tag = arguments.length <= 0 || arguments[0] === undefined ? 'div' : arguments[0];\\n    var props = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n    var attributes = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\\n\\n    props = _objectAssign2['default']({\\n      className: this.buildCSSClass(),\\n      tabIndex: 0\\n    }, props);\\n\\n    if (tag === 'button') {\\n      _utilsLogJs2['default'].error('Creating a ClickableComponent with an HTML element of ' + tag + ' is not supported; use a Button instead.');\\n    }\\n\\n    // Add ARIA attributes for clickable element which is not a native HTML button\\n    attributes = _objectAssign2['default']({\\n      role: 'button',\\n      'aria-live': 'polite' // let the screen reader user know that the text of the element may change\\n    }, attributes);\\n\\n    var el = _Component.prototype.createEl.call(this, tag, props, attributes);\\n\\n    this.createControlTextEl(el);\\n\\n    return el;\\n  };\\n\\n  /**\\n   * create control text\\n   *\\n   * @param {Element} el Parent element for the control text\\n   * @return {Element}\\n   * @method controlText\\n   */\\n\\n  ClickableComponent.prototype.createControlTextEl = function createControlTextEl(el) {\\n    this.controlTextEl_ = Dom.createEl('span', {\\n      className: 'vjs-control-text'\\n    });\\n\\n    if (el) {\\n      el.appendChild(this.controlTextEl_);\\n    }\\n\\n    this.controlText(this.controlText_, el);\\n\\n    return this.controlTextEl_;\\n  };\\n\\n  /**\\n   * Controls text - both request and localize\\n   *\\n   * @param {String}  text Text for element\\n   * @param {Element=} el Element to set the title on\\n   * @return {String}\\n   * @method controlText\\n   */\\n\\n  ClickableComponent.prototype.controlText = function controlText(text) {\\n    var el = arguments.length <= 1 || arguments[1] === undefined ? this.el() : arguments[1];\\n\\n    if (!text) return this.controlText_ || 'Need Text';\\n\\n    var localizedText = this.localize(text);\\n\\n    this.controlText_ = text;\\n    this.controlTextEl_.innerHTML = localizedText;\\n    el.setAttribute('title', localizedText);\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Allows sub components to stack CSS class names\\n   *\\n   * @return {String}\\n   * @method buildCSSClass\\n   */\\n\\n  ClickableComponent.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-control vjs-button ' + _Component.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Adds a child component inside this clickable-component\\n   *\\n   * @param {String|Component} child The class name or instance of a child to add\\n   * @param {Object=} options Options, including options to be passed to children of the child.\\n   * @return {Component} The child component (created by this process if a string was used)\\n   * @method addChild\\n   */\\n\\n  ClickableComponent.prototype.addChild = function addChild(child) {\\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n\\n    // TODO: Fix adding an actionable child to a ClickableComponent; currently\\n    // it will cause issues with assistive technology (e.g. screen readers)\\n    // which support ARIA, since an element with role=\\\"button\\\" cannot have\\n    // actionable child elements.\\n\\n    //let className = this.constructor.name;\\n    //log.warn(`Adding a child to a ClickableComponent (${className}) can cause issues with assistive technology which supports ARIA, since an element with role=\\\"button\\\" cannot have actionable child elements.`);\\n\\n    return _Component.prototype.addChild.call(this, child, options);\\n  };\\n\\n  /**\\n   * Enable the component element\\n   *\\n   * @return {Component}\\n   * @method enable\\n   */\\n\\n  ClickableComponent.prototype.enable = function enable() {\\n    this.removeClass('vjs-disabled');\\n    this.el_.setAttribute('aria-disabled', 'false');\\n    return this;\\n  };\\n\\n  /**\\n   * Disable the component element\\n   *\\n   * @return {Component}\\n   * @method disable\\n   */\\n\\n  ClickableComponent.prototype.disable = function disable() {\\n    this.addClass('vjs-disabled');\\n    this.el_.setAttribute('aria-disabled', 'true');\\n    return this;\\n  };\\n\\n  /**\\n   * Handle Click - Override with specific functionality for component\\n   *\\n   * @method handleClick\\n   */\\n\\n  ClickableComponent.prototype.handleClick = function handleClick() {};\\n\\n  /**\\n   * Handle Focus - Add keyboard functionality to element\\n   *\\n   * @method handleFocus\\n   */\\n\\n  ClickableComponent.prototype.handleFocus = function handleFocus() {\\n    Events.on(_globalDocument2['default'], 'keydown', Fn.bind(this, this.handleKeyPress));\\n  };\\n\\n  /**\\n   * Handle KeyPress (document level) - Trigger click when Space or Enter key is pressed\\n   *\\n   * @method handleKeyPress\\n   */\\n\\n  ClickableComponent.prototype.handleKeyPress = function handleKeyPress(event) {\\n    // Support Space (32) or Enter (13) key operation to fire a click event\\n    if (event.which === 32 || event.which === 13) {\\n      event.preventDefault();\\n      this.handleClick(event);\\n    } else if (_Component.prototype.handleKeyPress) {\\n      _Component.prototype.handleKeyPress.call(this, event); // Pass keypress handling up for unsupported keys\\n    }\\n  };\\n\\n  /**\\n   * Handle Blur - Remove keyboard triggers\\n   *\\n   * @method handleBlur\\n   */\\n\\n  ClickableComponent.prototype.handleBlur = function handleBlur() {\\n    Events.off(_globalDocument2['default'], 'keydown', Fn.bind(this, this.handleKeyPress));\\n  };\\n\\n  return ClickableComponent;\\n})(_component2['default']);\\n\\n_component2['default'].registerComponent('ClickableComponent', ClickableComponent);\\nexports['default'] = ClickableComponent;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./component\\\":67,\\\"./utils/dom.js\\\":142,\\\"./utils/events.js\\\":143,\\\"./utils/fn.js\\\":144,\\\"./utils/log.js\\\":147,\\\"global/document\\\":1,\\\"object.assign\\\":45}],66:[function(_dereq_,module,exports){\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _button = _dereq_('./button');\\n\\nvar _button2 = _interopRequireDefault(_button);\\n\\nvar _component = _dereq_('./component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\n/**\\n * The `CloseButton` component is a button which fires a \\\"close\\\" event\\n * when it is activated.\\n *\\n * @extends Button\\n * @class CloseButton\\n */\\n\\nvar CloseButton = (function (_Button) {\\n  _inherits(CloseButton, _Button);\\n\\n  function CloseButton(player, options) {\\n    _classCallCheck(this, CloseButton);\\n\\n    _Button.call(this, player, options);\\n    this.controlText(options && options.controlText || this.localize('Close'));\\n  }\\n\\n  CloseButton.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-close-button ' + _Button.prototype.buildCSSClass.call(this);\\n  };\\n\\n  CloseButton.prototype.handleClick = function handleClick() {\\n    this.trigger({ type: 'close', bubbles: false });\\n  };\\n\\n  return CloseButton;\\n})(_button2['default']);\\n\\n_component2['default'].registerComponent('CloseButton', CloseButton);\\nexports['default'] = CloseButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./button\\\":64,\\\"./component\\\":67}],67:[function(_dereq_,module,exports){\\n/**\\n * @file component.js\\n *\\n * Player Component - Base class for all UI objects\\n */\\n\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _utilsDomJs = _dereq_('./utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFnJs = _dereq_('./utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsGuidJs = _dereq_('./utils/guid.js');\\n\\nvar Guid = _interopRequireWildcard(_utilsGuidJs);\\n\\nvar _utilsEventsJs = _dereq_('./utils/events.js');\\n\\nvar Events = _interopRequireWildcard(_utilsEventsJs);\\n\\nvar _utilsLogJs = _dereq_('./utils/log.js');\\n\\nvar _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);\\n\\nvar _utilsToTitleCaseJs = _dereq_('./utils/to-title-case.js');\\n\\nvar _utilsToTitleCaseJs2 = _interopRequireDefault(_utilsToTitleCaseJs);\\n\\nvar _utilsMergeOptionsJs = _dereq_('./utils/merge-options.js');\\n\\nvar _utilsMergeOptionsJs2 = _interopRequireDefault(_utilsMergeOptionsJs);\\n\\n/**\\n * Base UI Component class\\n * Components are embeddable UI objects that are represented by both a\\n * javascript object and an element in the DOM. They can be children of other\\n * components, and can have many children themselves.\\n * ```js\\n *     // adding a button to the player\\n *     var button = player.addChild('button');\\n *     button.el(); // -> button element\\n * ```\\n * ```html\\n *     <div class=\\\"video-js\\\">\\n *       <div class=\\\"vjs-button\\\">Button</div>\\n *     </div>\\n * ```\\n * Components are also event targets.\\n * ```js\\n *     button.on('click', function(){\\n *       console.log('Button Clicked!');\\n *     });\\n *     button.trigger('customevent');\\n * ```\\n *\\n * @param {Object} player  Main Player\\n * @param {Object=} options Object of option names and values\\n * @param {Function=} ready    Ready callback function\\n * @class Component\\n */\\n\\nvar Component = (function () {\\n  function Component(player, options, ready) {\\n    _classCallCheck(this, Component);\\n\\n    // The component might be the player itself and we can't pass `this` to super\\n    if (!player && this.play) {\\n      this.player_ = player = this; // eslint-disable-line\\n    } else {\\n        this.player_ = player;\\n      }\\n\\n    // Make a copy of prototype.options_ to protect against overriding defaults\\n    this.options_ = _utilsMergeOptionsJs2['default']({}, this.options_);\\n\\n    // Updated options with supplied options\\n    options = this.options_ = _utilsMergeOptionsJs2['default'](this.options_, options);\\n\\n    // Get ID from options or options element if one is supplied\\n    this.id_ = options.id || options.el && options.el.id;\\n\\n    // If there was no ID from the options, generate one\\n    if (!this.id_) {\\n      // Don't require the player ID function in the case of mock players\\n      var id = player && player.id && player.id() || 'no_player';\\n\\n      this.id_ = id + '_component_' + Guid.newGUID();\\n    }\\n\\n    this.name_ = options.name || null;\\n\\n    // Create element if one wasn't provided in options\\n    if (options.el) {\\n      this.el_ = options.el;\\n    } else if (options.createEl !== false) {\\n      this.el_ = this.createEl();\\n    }\\n\\n    this.children_ = [];\\n    this.childIndex_ = {};\\n    this.childNameIndex_ = {};\\n\\n    // Add any child components in options\\n    if (options.initChildren !== false) {\\n      this.initChildren();\\n    }\\n\\n    this.ready(ready);\\n    // Don't want to trigger ready here or it will before init is actually\\n    // finished for all children that run this constructor\\n\\n    if (options.reportTouchActivity !== false) {\\n      this.enableTouchActivity();\\n    }\\n  }\\n\\n  /**\\n   * Dispose of the component and all child components\\n   *\\n   * @method dispose\\n   */\\n\\n  Component.prototype.dispose = function dispose() {\\n    this.trigger({ type: 'dispose', bubbles: false });\\n\\n    // Dispose all children.\\n    if (this.children_) {\\n      for (var i = this.children_.length - 1; i >= 0; i--) {\\n        if (this.children_[i].dispose) {\\n          this.children_[i].dispose();\\n        }\\n      }\\n    }\\n\\n    // Delete child references\\n    this.children_ = null;\\n    this.childIndex_ = null;\\n    this.childNameIndex_ = null;\\n\\n    // Remove all event listeners.\\n    this.off();\\n\\n    // Remove element from DOM\\n    if (this.el_.parentNode) {\\n      this.el_.parentNode.removeChild(this.el_);\\n    }\\n\\n    Dom.removeElData(this.el_);\\n    this.el_ = null;\\n  };\\n\\n  /**\\n   * Return the component's player\\n   *\\n   * @return {Player}\\n   * @method player\\n   */\\n\\n  Component.prototype.player = function player() {\\n    return this.player_;\\n  };\\n\\n  /**\\n   * Deep merge of options objects\\n   * Whenever a property is an object on both options objects\\n   * the two properties will be merged using mergeOptions.\\n   *\\n   * ```js\\n   *     Parent.prototype.options_ = {\\n   *       optionSet: {\\n   *         'childOne': { 'foo': 'bar', 'asdf': 'fdsa' },\\n   *         'childTwo': {},\\n   *         'childThree': {}\\n   *       }\\n   *     }\\n   *     newOptions = {\\n   *       optionSet: {\\n   *         'childOne': { 'foo': 'baz', 'abc': '123' }\\n   *         'childTwo': null,\\n   *         'childFour': {}\\n   *       }\\n   *     }\\n   *\\n   *     this.options(newOptions);\\n   * ```\\n   * RESULT\\n   * ```js\\n   *     {\\n   *       optionSet: {\\n   *         'childOne': { 'foo': 'baz', 'asdf': 'fdsa', 'abc': '123' },\\n   *         'childTwo': null, // Disabled. Won't be initialized.\\n   *         'childThree': {},\\n   *         'childFour': {}\\n   *       }\\n   *     }\\n   * ```\\n   *\\n   * @param  {Object} obj Object of new option values\\n   * @return {Object}     A NEW object of this.options_ and obj merged\\n   * @method options\\n   */\\n\\n  Component.prototype.options = function options(obj) {\\n    _utilsLogJs2['default'].warn('this.options() has been deprecated and will be moved to the constructor in 6.0');\\n\\n    if (!obj) {\\n      return this.options_;\\n    }\\n\\n    this.options_ = _utilsMergeOptionsJs2['default'](this.options_, obj);\\n    return this.options_;\\n  };\\n\\n  /**\\n   * Get the component's DOM element\\n   * ```js\\n   *     var domEl = myComponent.el();\\n   * ```\\n   *\\n   * @return {Element}\\n   * @method el\\n   */\\n\\n  Component.prototype.el = function el() {\\n    return this.el_;\\n  };\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @param  {String=} tagName  Element's node type. e.g. 'div'\\n   * @param  {Object=} properties An object of properties that should be set\\n   * @param  {Object=} attributes An object of attributes that should be set\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  Component.prototype.createEl = function createEl(tagName, properties, attributes) {\\n    return Dom.createEl(tagName, properties, attributes);\\n  };\\n\\n  Component.prototype.localize = function localize(string) {\\n    var code = this.player_.language && this.player_.language();\\n    var languages = this.player_.languages && this.player_.languages();\\n\\n    if (!code || !languages) {\\n      return string;\\n    }\\n\\n    var language = languages[code];\\n\\n    if (language && language[string]) {\\n      return language[string];\\n    }\\n\\n    var primaryCode = code.split('-')[0];\\n    var primaryLang = languages[primaryCode];\\n\\n    if (primaryLang && primaryLang[string]) {\\n      return primaryLang[string];\\n    }\\n\\n    return string;\\n  };\\n\\n  /**\\n   * Return the component's DOM element where children are inserted.\\n   * Will either be the same as el() or a new element defined in createEl().\\n   *\\n   * @return {Element}\\n   * @method contentEl\\n   */\\n\\n  Component.prototype.contentEl = function contentEl() {\\n    return this.contentEl_ || this.el_;\\n  };\\n\\n  /**\\n   * Get the component's ID\\n   * ```js\\n   *     var id = myComponent.id();\\n   * ```\\n   *\\n   * @return {String}\\n   * @method id\\n   */\\n\\n  Component.prototype.id = function id() {\\n    return this.id_;\\n  };\\n\\n  /**\\n   * Get the component's name. The name is often used to reference the component.\\n   * ```js\\n   *     var name = myComponent.name();\\n   * ```\\n   *\\n   * @return {String}\\n   * @method name\\n   */\\n\\n  Component.prototype.name = function name() {\\n    return this.name_;\\n  };\\n\\n  /**\\n   * Get an array of all child components\\n   * ```js\\n   *     var kids = myComponent.children();\\n   * ```\\n   *\\n   * @return {Array} The children\\n   * @method children\\n   */\\n\\n  Component.prototype.children = function children() {\\n    return this.children_;\\n  };\\n\\n  /**\\n   * Returns a child component with the provided ID\\n   *\\n   * @return {Component}\\n   * @method getChildById\\n   */\\n\\n  Component.prototype.getChildById = function getChildById(id) {\\n    return this.childIndex_[id];\\n  };\\n\\n  /**\\n   * Returns a child component with the provided name\\n   *\\n   * @return {Component}\\n   * @method getChild\\n   */\\n\\n  Component.prototype.getChild = function getChild(name) {\\n    return this.childNameIndex_[name];\\n  };\\n\\n  /**\\n   * Adds a child component inside this component\\n   * ```js\\n   *     myComponent.el();\\n   *     // -> <div class='my-component'></div>\\n   *     myComponent.children();\\n   *     // [empty array]\\n   *\\n   *     var myButton = myComponent.addChild('MyButton');\\n   *     // -> <div class='my-component'><div class=\\\"my-button\\\">myButton<div></div>\\n   *     // -> myButton === myComponent.children()[0];\\n   * ```\\n   * Pass in options for child constructors and options for children of the child\\n   * ```js\\n   *     var myButton = myComponent.addChild('MyButton', {\\n   *       text: 'Press Me',\\n   *       buttonChildExample: {\\n   *         buttonChildOption: true\\n   *       }\\n   *     });\\n   * ```\\n   *\\n   * @param {String|Component} child The class name or instance of a child to add\\n   * @param {Object=} options Options, including options to be passed to children of the child.\\n   * @param {Number} index into our children array to attempt to add the child\\n   * @return {Component} The child component (created by this process if a string was used)\\n   * @method addChild\\n   */\\n\\n  Component.prototype.addChild = function addChild(child) {\\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n    var index = arguments.length <= 2 || arguments[2] === undefined ? this.children_.length : arguments[2];\\n\\n    var component = undefined;\\n    var componentName = undefined;\\n\\n    // If child is a string, create nt with options\\n    if (typeof child === 'string') {\\n      componentName = child;\\n\\n      // Options can also be specified as a boolean, so convert to an empty object if false.\\n      if (!options) {\\n        options = {};\\n      }\\n\\n      // Same as above, but true is deprecated so show a warning.\\n      if (options === true) {\\n        _utilsLogJs2['default'].warn('Initializing a child component with `true` is deprecated. Children should be defined in an array when possible, but if necessary use an object instead of `true`.');\\n        options = {};\\n      }\\n\\n      // If no componentClass in options, assume componentClass is the name lowercased\\n      // (e.g. playButton)\\n      var componentClassName = options.componentClass || _utilsToTitleCaseJs2['default'](componentName);\\n\\n      // Set name through options\\n      options.name = componentName;\\n\\n      // Create a new object & element for this controls set\\n      // If there's no .player_, this is a player\\n      var ComponentClass = Component.getComponent(componentClassName);\\n\\n      if (!ComponentClass) {\\n        throw new Error('Component ' + componentClassName + ' does not exist');\\n      }\\n\\n      // data stored directly on the videojs object may be\\n      // misidentified as a component to retain\\n      // backwards-compatibility with 4.x. check to make sure the\\n      // component class can be instantiated.\\n      if (typeof ComponentClass !== 'function') {\\n        return null;\\n      }\\n\\n      component = new ComponentClass(this.player_ || this, options);\\n\\n      // child is a component instance\\n    } else {\\n        component = child;\\n      }\\n\\n    this.children_.splice(index, 0, component);\\n\\n    if (typeof component.id === 'function') {\\n      this.childIndex_[component.id()] = component;\\n    }\\n\\n    // If a name wasn't used to create the component, check if we can use the\\n    // name function of the component\\n    componentName = componentName || component.name && component.name();\\n\\n    if (componentName) {\\n      this.childNameIndex_[componentName] = component;\\n    }\\n\\n    // Add the UI object's element to the container div (box)\\n    // Having an element is not required\\n    if (typeof component.el === 'function' && component.el()) {\\n      var childNodes = this.contentEl().children;\\n      var refNode = childNodes[index] || null;\\n      this.contentEl().insertBefore(component.el(), refNode);\\n    }\\n\\n    // Return so it can stored on parent object if desired.\\n    return component;\\n  };\\n\\n  /**\\n   * Remove a child component from this component's list of children, and the\\n   * child component's element from this component's element\\n   *\\n   * @param  {Component} component Component to remove\\n   * @method removeChild\\n   */\\n\\n  Component.prototype.removeChild = function removeChild(component) {\\n    if (typeof component === 'string') {\\n      component = this.getChild(component);\\n    }\\n\\n    if (!component || !this.children_) {\\n      return;\\n    }\\n\\n    var childFound = false;\\n\\n    for (var i = this.children_.length - 1; i >= 0; i--) {\\n      if (this.children_[i] === component) {\\n        childFound = true;\\n        this.children_.splice(i, 1);\\n        break;\\n      }\\n    }\\n\\n    if (!childFound) {\\n      return;\\n    }\\n\\n    this.childIndex_[component.id()] = null;\\n    this.childNameIndex_[component.name()] = null;\\n\\n    var compEl = component.el();\\n\\n    if (compEl && compEl.parentNode === this.contentEl()) {\\n      this.contentEl().removeChild(component.el());\\n    }\\n  };\\n\\n  /**\\n   * Add and initialize default child components from options\\n   * ```js\\n   *     // when an instance of MyComponent is created, all children in options\\n   *     // will be added to the instance by their name strings and options\\n   *     MyComponent.prototype.options_ = {\\n   *       children: [\\n   *         'myChildComponent'\\n   *       ],\\n   *       myChildComponent: {\\n   *         myChildOption: true\\n   *       }\\n   *     };\\n   *\\n   *     // Or when creating the component\\n   *     var myComp = new MyComponent(player, {\\n   *       children: [\\n   *         'myChildComponent'\\n   *       ],\\n   *       myChildComponent: {\\n   *         myChildOption: true\\n   *       }\\n   *     });\\n   * ```\\n   * The children option can also be an array of\\n   * child options objects (that also include a 'name' key).\\n   * This can be used if you have two child components of the\\n   * same type that need different options.\\n   * ```js\\n   *     var myComp = new MyComponent(player, {\\n   *       children: [\\n   *         'button',\\n   *         {\\n   *           name: 'button',\\n   *           someOtherOption: true\\n   *         },\\n   *         {\\n   *           name: 'button',\\n   *           someOtherOption: false\\n   *         }\\n   *       ]\\n   *     });\\n   * ```\\n   *\\n   * @method initChildren\\n   */\\n\\n  Component.prototype.initChildren = function initChildren() {\\n    var _this = this;\\n\\n    var children = this.options_.children;\\n\\n    if (children) {\\n      (function () {\\n        // `this` is `parent`\\n        var parentOptions = _this.options_;\\n\\n        var handleAdd = function handleAdd(child) {\\n          var name = child.name;\\n          var opts = child.opts;\\n\\n          // Allow options for children to be set at the parent options\\n          // e.g. videojs(id, { controlBar: false });\\n          // instead of videojs(id, { children: { controlBar: false });\\n          if (parentOptions[name] !== undefined) {\\n            opts = parentOptions[name];\\n          }\\n\\n          // Allow for disabling default components\\n          // e.g. options['children']['posterImage'] = false\\n          if (opts === false) {\\n            return;\\n          }\\n\\n          // Allow options to be passed as a simple boolean if no configuration\\n          // is necessary.\\n          if (opts === true) {\\n            opts = {};\\n          }\\n\\n          // We also want to pass the original player options to each component as well so they don't need to\\n          // reach back into the player for options later.\\n          opts.playerOptions = _this.options_.playerOptions;\\n\\n          // Create and add the child component.\\n          // Add a direct reference to the child by name on the parent instance.\\n          // If two of the same component are used, different names should be supplied\\n          // for each\\n          var newChild = _this.addChild(name, opts);\\n          if (newChild) {\\n            _this[name] = newChild;\\n          }\\n        };\\n\\n        // Allow for an array of children details to passed in the options\\n        var workingChildren = undefined;\\n        var Tech = Component.getComponent('Tech');\\n\\n        if (Array.isArray(children)) {\\n          workingChildren = children;\\n        } else {\\n          workingChildren = Object.keys(children);\\n        }\\n\\n        workingChildren\\n        // children that are in this.options_ but also in workingChildren  would\\n        // give us extra children we do not want. So, we want to filter them out.\\n        .concat(Object.keys(_this.options_).filter(function (child) {\\n          return !workingChildren.some(function (wchild) {\\n            if (typeof wchild === 'string') {\\n              return child === wchild;\\n            } else {\\n              return child === wchild.name;\\n            }\\n          });\\n        })).map(function (child) {\\n          var name = undefined,\\n              opts = undefined;\\n\\n          if (typeof child === 'string') {\\n            name = child;\\n            opts = children[name] || _this.options_[name] || {};\\n          } else {\\n            name = child.name;\\n            opts = child;\\n          }\\n\\n          return { name: name, opts: opts };\\n        }).filter(function (child) {\\n          // we have to make sure that child.name isn't in the techOrder since\\n          // techs are registerd as Components but can't aren't compatible\\n          // See https://github.com/videojs/video.js/issues/2772\\n          var c = Component.getComponent(child.opts.componentClass || _utilsToTitleCaseJs2['default'](child.name));\\n          return c && !Tech.isTech(c);\\n        }).forEach(handleAdd);\\n      })();\\n    }\\n  };\\n\\n  /**\\n   * Allows sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  Component.prototype.buildCSSClass = function buildCSSClass() {\\n    // Child classes can include a function that does:\\n    // return 'CLASS NAME' + this._super();\\n    return '';\\n  };\\n\\n  /**\\n   * Add an event listener to this component's element\\n   * ```js\\n   *     var myFunc = function(){\\n   *       var myComponent = this;\\n   *       // Do something when the event is fired\\n   *     };\\n   *\\n   *     myComponent.on('eventType', myFunc);\\n   * ```\\n   * The context of myFunc will be myComponent unless previously bound.\\n   * Alternatively, you can add a listener to another element or component.\\n   * ```js\\n   *     myComponent.on(otherElement, 'eventName', myFunc);\\n   *     myComponent.on(otherComponent, 'eventName', myFunc);\\n   * ```\\n   * The benefit of using this over `VjsEvents.on(otherElement, 'eventName', myFunc)`\\n   * and `otherComponent.on('eventName', myFunc)` is that this way the listeners\\n   * will be automatically cleaned up when either component is disposed.\\n   * It will also bind myComponent as the context of myFunc.\\n   * **NOTE**: When using this on elements in the page other than window\\n   * and document (both permanent), if you remove the element from the DOM\\n   * you need to call `myComponent.trigger(el, 'dispose')` on it to clean up\\n   * references to it and allow the browser to garbage collect it.\\n   *\\n   * @param  {String|Component} first   The event type or other component\\n   * @param  {Function|String}      second  The event handler or event type\\n   * @param  {Function}             third   The event handler\\n   * @return {Component}\\n   * @method on\\n   */\\n\\n  Component.prototype.on = function on(first, second, third) {\\n    var _this2 = this;\\n\\n    if (typeof first === 'string' || Array.isArray(first)) {\\n      Events.on(this.el_, first, Fn.bind(this, second));\\n\\n      // Targeting another component or element\\n    } else {\\n        (function () {\\n          var target = first;\\n          var type = second;\\n          var fn = Fn.bind(_this2, third);\\n\\n          // When this component is disposed, remove the listener from the other component\\n          var removeOnDispose = function removeOnDispose() {\\n            return _this2.off(target, type, fn);\\n          };\\n\\n          // Use the same function ID so we can remove it later it using the ID\\n          // of the original listener\\n          removeOnDispose.guid = fn.guid;\\n          _this2.on('dispose', removeOnDispose);\\n\\n          // If the other component is disposed first we need to clean the reference\\n          // to the other component in this component's removeOnDispose listener\\n          // Otherwise we create a memory leak.\\n          var cleanRemover = function cleanRemover() {\\n            return _this2.off('dispose', removeOnDispose);\\n          };\\n\\n          // Add the same function ID so we can easily remove it later\\n          cleanRemover.guid = fn.guid;\\n\\n          // Check if this is a DOM node\\n          if (first.nodeName) {\\n            // Add the listener to the other element\\n            Events.on(target, type, fn);\\n            Events.on(target, 'dispose', cleanRemover);\\n\\n            // Should be a component\\n            // Not using `instanceof Component` because it makes mock players difficult\\n          } else if (typeof first.on === 'function') {\\n              // Add the listener to the other component\\n              target.on(type, fn);\\n              target.on('dispose', cleanRemover);\\n            }\\n        })();\\n      }\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Remove an event listener from this component's element\\n   * ```js\\n   *     myComponent.off('eventType', myFunc);\\n   * ```\\n   * If myFunc is excluded, ALL listeners for the event type will be removed.\\n   * If eventType is excluded, ALL listeners will be removed from the component.\\n   * Alternatively you can use `off` to remove listeners that were added to other\\n   * elements or components using `myComponent.on(otherComponent...`.\\n   * In this case both the event type and listener function are REQUIRED.\\n   * ```js\\n   *     myComponent.off(otherElement, 'eventType', myFunc);\\n   *     myComponent.off(otherComponent, 'eventType', myFunc);\\n   * ```\\n   *\\n   * @param  {String=|Component}  first  The event type or other component\\n   * @param  {Function=|String}       second The listener function or event type\\n   * @param  {Function=}              third  The listener for other component\\n   * @return {Component}\\n   * @method off\\n   */\\n\\n  Component.prototype.off = function off(first, second, third) {\\n    if (!first || typeof first === 'string' || Array.isArray(first)) {\\n      Events.off(this.el_, first, second);\\n    } else {\\n      var target = first;\\n      var type = second;\\n      // Ensure there's at least a guid, even if the function hasn't been used\\n      var fn = Fn.bind(this, third);\\n\\n      // Remove the dispose listener on this component,\\n      // which was given the same guid as the event listener\\n      this.off('dispose', fn);\\n\\n      if (first.nodeName) {\\n        // Remove the listener\\n        Events.off(target, type, fn);\\n        // Remove the listener for cleaning the dispose listener\\n        Events.off(target, 'dispose', fn);\\n      } else {\\n        target.off(type, fn);\\n        target.off('dispose', fn);\\n      }\\n    }\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Add an event listener to be triggered only once and then removed\\n   * ```js\\n   *     myComponent.one('eventName', myFunc);\\n   * ```\\n   * Alternatively you can add a listener to another element or component\\n   * that will be triggered only once.\\n   * ```js\\n   *     myComponent.one(otherElement, 'eventName', myFunc);\\n   *     myComponent.one(otherComponent, 'eventName', myFunc);\\n   * ```\\n   *\\n   * @param  {String|Component}  first   The event type or other component\\n   * @param  {Function|String}       second  The listener function or event type\\n   * @param  {Function=}             third   The listener function for other component\\n   * @return {Component}\\n   * @method one\\n   */\\n\\n  Component.prototype.one = function one(first, second, third) {\\n    var _this3 = this,\\n        _arguments = arguments;\\n\\n    if (typeof first === 'string' || Array.isArray(first)) {\\n      Events.one(this.el_, first, Fn.bind(this, second));\\n    } else {\\n      (function () {\\n        var target = first;\\n        var type = second;\\n        var fn = Fn.bind(_this3, third);\\n\\n        var newFunc = function newFunc() {\\n          _this3.off(target, type, newFunc);\\n          fn.apply(null, _arguments);\\n        };\\n\\n        // Keep the same function ID so we can remove it later\\n        newFunc.guid = fn.guid;\\n\\n        _this3.on(target, type, newFunc);\\n      })();\\n    }\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Trigger an event on an element\\n   * ```js\\n   *     myComponent.trigger('eventName');\\n   *     myComponent.trigger({'type':'eventName'});\\n   *     myComponent.trigger('eventName', {data: 'some data'});\\n   *     myComponent.trigger({'type':'eventName'}, {data: 'some data'});\\n   * ```\\n   *\\n   * @param  {Event|Object|String} event  A string (the type) or an event object with a type attribute\\n   * @param  {Object} [hash] data hash to pass along with the event\\n   * @return {Component}       self\\n   * @method trigger\\n   */\\n\\n  Component.prototype.trigger = function trigger(event, hash) {\\n    Events.trigger(this.el_, event, hash);\\n    return this;\\n  };\\n\\n  /**\\n   * Bind a listener to the component's ready state.\\n   * Different from event listeners in that if the ready event has already happened\\n   * it will trigger the function immediately.\\n   *\\n   * @param  {Function} fn Ready listener\\n   * @param  {Boolean} sync Exec the listener synchronously if component is ready\\n   * @return {Component}\\n   * @method ready\\n   */\\n\\n  Component.prototype.ready = function ready(fn) {\\n    var sync = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\\n\\n    if (fn) {\\n      if (this.isReady_) {\\n        if (sync) {\\n          fn.call(this);\\n        } else {\\n          // Call the function asynchronously by default for consistency\\n          this.setTimeout(fn, 1);\\n        }\\n      } else {\\n        this.readyQueue_ = this.readyQueue_ || [];\\n        this.readyQueue_.push(fn);\\n      }\\n    }\\n    return this;\\n  };\\n\\n  /**\\n   * Trigger the ready listeners\\n   *\\n   * @return {Component}\\n   * @method triggerReady\\n   */\\n\\n  Component.prototype.triggerReady = function triggerReady() {\\n    this.isReady_ = true;\\n\\n    // Ensure ready is triggerd asynchronously\\n    this.setTimeout(function () {\\n      var readyQueue = this.readyQueue_;\\n\\n      // Reset Ready Queue\\n      this.readyQueue_ = [];\\n\\n      if (readyQueue && readyQueue.length > 0) {\\n        readyQueue.forEach(function (fn) {\\n          fn.call(this);\\n        }, this);\\n      }\\n\\n      // Allow for using event listeners also\\n      this.trigger('ready');\\n    }, 1);\\n  };\\n\\n  /**\\n   * Finds a single DOM element matching `selector` within the component's\\n   * `contentEl` or another custom context.\\n   *\\n   * @method $\\n   * @param  {String} selector\\n   *         A valid CSS selector, which will be passed to `querySelector`.\\n   *\\n   * @param  {Element|String} [context=document]\\n   *         A DOM element within which to query. Can also be a selector\\n   *         string in which case the first matching element will be used\\n   *         as context. If missing (or no element matches selector), falls\\n   *         back to `document`.\\n   *\\n   * @return {Element|null}\\n   */\\n\\n  Component.prototype.$ = function $(selector, context) {\\n    return Dom.$(selector, context || this.contentEl());\\n  };\\n\\n  /**\\n   * Finds a all DOM elements matching `selector` within the component's\\n   * `contentEl` or another custom context.\\n   *\\n   * @method $$\\n   * @param  {String} selector\\n   *         A valid CSS selector, which will be passed to `querySelectorAll`.\\n   *\\n   * @param  {Element|String} [context=document]\\n   *         A DOM element within which to query. Can also be a selector\\n   *         string in which case the first matching element will be used\\n   *         as context. If missing (or no element matches selector), falls\\n   *         back to `document`.\\n   *\\n   * @return {NodeList}\\n   */\\n\\n  Component.prototype.$$ = function $$(selector, context) {\\n    return Dom.$$(selector, context || this.contentEl());\\n  };\\n\\n  /**\\n   * Check if a component's element has a CSS class name\\n   *\\n   * @param {String} classToCheck Classname to check\\n   * @return {Component}\\n   * @method hasClass\\n   */\\n\\n  Component.prototype.hasClass = function hasClass(classToCheck) {\\n    return Dom.hasElClass(this.el_, classToCheck);\\n  };\\n\\n  /**\\n   * Add a CSS class name to the component's element\\n   *\\n   * @param {String} classToAdd Classname to add\\n   * @return {Component}\\n   * @method addClass\\n   */\\n\\n  Component.prototype.addClass = function addClass(classToAdd) {\\n    Dom.addElClass(this.el_, classToAdd);\\n    return this;\\n  };\\n\\n  /**\\n   * Remove a CSS class name from the component's element\\n   *\\n   * @param {String} classToRemove Classname to remove\\n   * @return {Component}\\n   * @method removeClass\\n   */\\n\\n  Component.prototype.removeClass = function removeClass(classToRemove) {\\n    Dom.removeElClass(this.el_, classToRemove);\\n    return this;\\n  };\\n\\n  /**\\n   * Add or remove a CSS class name from the component's element\\n   *\\n   * @param  {String} classToToggle\\n   * @param  {Boolean|Function} [predicate]\\n   *         Can be a function that returns a Boolean. If `true`, the class\\n   *         will be added; if `false`, the class will be removed. If not\\n   *         given, the class will be added if not present and vice versa.\\n   *\\n   * @return {Component}\\n   * @method toggleClass\\n   */\\n\\n  Component.prototype.toggleClass = function toggleClass(classToToggle, predicate) {\\n    Dom.toggleElClass(this.el_, classToToggle, predicate);\\n    return this;\\n  };\\n\\n  /**\\n   * Show the component element if hidden\\n   *\\n   * @return {Component}\\n   * @method show\\n   */\\n\\n  Component.prototype.show = function show() {\\n    this.removeClass('vjs-hidden');\\n    return this;\\n  };\\n\\n  /**\\n   * Hide the component element if currently showing\\n   *\\n   * @return {Component}\\n   * @method hide\\n   */\\n\\n  Component.prototype.hide = function hide() {\\n    this.addClass('vjs-hidden');\\n    return this;\\n  };\\n\\n  /**\\n   * Lock an item in its visible state\\n   * To be used with fadeIn/fadeOut.\\n   *\\n   * @return {Component}\\n   * @private\\n   * @method lockShowing\\n   */\\n\\n  Component.prototype.lockShowing = function lockShowing() {\\n    this.addClass('vjs-lock-showing');\\n    return this;\\n  };\\n\\n  /**\\n   * Unlock an item to be hidden\\n   * To be used with fadeIn/fadeOut.\\n   *\\n   * @return {Component}\\n   * @private\\n   * @method unlockShowing\\n   */\\n\\n  Component.prototype.unlockShowing = function unlockShowing() {\\n    this.removeClass('vjs-lock-showing');\\n    return this;\\n  };\\n\\n  /**\\n   * Set or get the width of the component (CSS values)\\n   * Setting the video tag dimension values only works with values in pixels.\\n   * Percent values will not work.\\n   * Some percents can be used, but width()/height() will return the number + %,\\n   * not the actual computed width/height.\\n   *\\n   * @param  {Number|String=} num   Optional width number\\n   * @param  {Boolean} skipListeners Skip the 'resize' event trigger\\n   * @return {Component} This component, when setting the width\\n   * @return {Number|String} The width, when getting\\n   * @method width\\n   */\\n\\n  Component.prototype.width = function width(num, skipListeners) {\\n    return this.dimension('width', num, skipListeners);\\n  };\\n\\n  /**\\n   * Get or set the height of the component (CSS values)\\n   * Setting the video tag dimension values only works with values in pixels.\\n   * Percent values will not work.\\n   * Some percents can be used, but width()/height() will return the number + %,\\n   * not the actual computed width/height.\\n   *\\n   * @param  {Number|String=} num     New component height\\n   * @param  {Boolean=} skipListeners Skip the resize event trigger\\n   * @return {Component} This component, when setting the height\\n   * @return {Number|String} The height, when getting\\n   * @method height\\n   */\\n\\n  Component.prototype.height = function height(num, skipListeners) {\\n    return this.dimension('height', num, skipListeners);\\n  };\\n\\n  /**\\n   * Set both width and height at the same time\\n   *\\n   * @param  {Number|String} width Width of player\\n   * @param  {Number|String} height Height of player\\n   * @return {Component} The component\\n   * @method dimensions\\n   */\\n\\n  Component.prototype.dimensions = function dimensions(width, height) {\\n    // Skip resize listeners on width for optimization\\n    return this.width(width, true).height(height);\\n  };\\n\\n  /**\\n   * Get or set width or height\\n   * This is the shared code for the width() and height() methods.\\n   * All for an integer, integer + 'px' or integer + '%';\\n   * Known issue: Hidden elements officially have a width of 0. We're defaulting\\n   * to the style.width value and falling back to computedStyle which has the\\n   * hidden element issue. Info, but probably not an efficient fix:\\n   * http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/\\n   *\\n   * @param  {String} widthOrHeight  'width' or 'height'\\n   * @param  {Number|String=} num     New dimension\\n   * @param  {Boolean=} skipListeners Skip resize event trigger\\n   * @return {Component} The component if a dimension was set\\n   * @return {Number|String} The dimension if nothing was set\\n   * @private\\n   * @method dimension\\n   */\\n\\n  Component.prototype.dimension = function dimension(widthOrHeight, num, skipListeners) {\\n    if (num !== undefined) {\\n      // Set to zero if null or literally NaN (NaN !== NaN)\\n      if (num === null || num !== num) {\\n        num = 0;\\n      }\\n\\n      // Check if using css width/height (% or px) and adjust\\n      if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {\\n        this.el_.style[widthOrHeight] = num;\\n      } else if (num === 'auto') {\\n        this.el_.style[widthOrHeight] = '';\\n      } else {\\n        this.el_.style[widthOrHeight] = num + 'px';\\n      }\\n\\n      // skipListeners allows us to avoid triggering the resize event when setting both width and height\\n      if (!skipListeners) {\\n        this.trigger('resize');\\n      }\\n\\n      // Return component\\n      return this;\\n    }\\n\\n    // Not setting a value, so getting it\\n    // Make sure element exists\\n    if (!this.el_) {\\n      return 0;\\n    }\\n\\n    // Get dimension value from style\\n    var val = this.el_.style[widthOrHeight];\\n    var pxIndex = val.indexOf('px');\\n\\n    if (pxIndex !== -1) {\\n      // Return the pixel value with no 'px'\\n      return parseInt(val.slice(0, pxIndex), 10);\\n    }\\n\\n    // No px so using % or no style was set, so falling back to offsetWidth/height\\n    // If component has display:none, offset will return 0\\n    // TODO: handle display:none and no dimension style using px\\n    return parseInt(this.el_['offset' + _utilsToTitleCaseJs2['default'](widthOrHeight)], 10);\\n  };\\n\\n  /**\\n   * Get width or height of computed style\\n   * @param  {String} widthOrHeight  'width' or 'height'\\n   * @return {Number|Boolean} The bolean false if nothing was set\\n   * @method currentDimension\\n   */\\n\\n  Component.prototype.currentDimension = function currentDimension(widthOrHeight) {\\n    var computedWidthOrHeight = 0;\\n\\n    if (widthOrHeight !== 'width' && widthOrHeight !== 'height') {\\n      throw new Error('currentDimension only accepts width or height value');\\n    }\\n\\n    if (typeof _globalWindow2['default'].getComputedStyle === 'function') {\\n      var computedStyle = _globalWindow2['default'].getComputedStyle(this.el_);\\n      computedWidthOrHeight = computedStyle.getPropertyValue(widthOrHeight) || computedStyle[widthOrHeight];\\n    } else if (this.el_.currentStyle) {\\n      // ie 8 doesn't support computed style, shim it\\n      // return clientWidth or clientHeight instead for better accuracy\\n      var rule = 'offset' + _utilsToTitleCaseJs2['default'](widthOrHeight);\\n      computedWidthOrHeight = this.el_[rule];\\n    }\\n\\n    // remove 'px' from variable and parse as integer\\n    computedWidthOrHeight = parseFloat(computedWidthOrHeight);\\n    return computedWidthOrHeight;\\n  };\\n\\n  /**\\n   * Get an object which contains width and height values of computed style\\n   * @return {Object} The dimensions of element\\n   * @method currentDimensions\\n   */\\n\\n  Component.prototype.currentDimensions = function currentDimensions() {\\n    return {\\n      width: this.currentDimension('width'),\\n      height: this.currentDimension('height')\\n    };\\n  };\\n\\n  /**\\n   * Get width of computed style\\n   * @return {Integer}\\n   * @method currentWidth\\n   */\\n\\n  Component.prototype.currentWidth = function currentWidth() {\\n    return this.currentDimension('width');\\n  };\\n\\n  /**\\n   * Get height of computed style\\n   * @return {Integer}\\n   * @method currentHeight\\n   */\\n\\n  Component.prototype.currentHeight = function currentHeight() {\\n    return this.currentDimension('height');\\n  };\\n\\n  /**\\n   * Emit 'tap' events when touch events are supported\\n   * This is used to support toggling the controls through a tap on the video.\\n   * We're requiring them to be enabled because otherwise every component would\\n   * have this extra overhead unnecessarily, on mobile devices where extra\\n   * overhead is especially bad.\\n   *\\n   * @private\\n   * @method emitTapEvents\\n   */\\n\\n  Component.prototype.emitTapEvents = function emitTapEvents() {\\n    // Track the start time so we can determine how long the touch lasted\\n    var touchStart = 0;\\n    var firstTouch = null;\\n\\n    // Maximum movement allowed during a touch event to still be considered a tap\\n    // Other popular libs use anywhere from 2 (hammer.js) to 15, so 10 seems like a nice, round number.\\n    var tapMovementThreshold = 10;\\n\\n    // The maximum length a touch can be while still being considered a tap\\n    var touchTimeThreshold = 200;\\n\\n    var couldBeTap = undefined;\\n\\n    this.on('touchstart', function (event) {\\n      // If more than one finger, don't consider treating this as a click\\n      if (event.touches.length === 1) {\\n        // Copy pageX/pageY from the object\\n        firstTouch = {\\n          pageX: event.touches[0].pageX,\\n          pageY: event.touches[0].pageY\\n        };\\n        // Record start time so we can detect a tap vs. \\\"touch and hold\\\"\\n        touchStart = new Date().getTime();\\n        // Reset couldBeTap tracking\\n        couldBeTap = true;\\n      }\\n    });\\n\\n    this.on('touchmove', function (event) {\\n      // If more than one finger, don't consider treating this as a click\\n      if (event.touches.length > 1) {\\n        couldBeTap = false;\\n      } else if (firstTouch) {\\n        // Some devices will throw touchmoves for all but the slightest of taps.\\n        // So, if we moved only a small distance, this could still be a tap\\n        var xdiff = event.touches[0].pageX - firstTouch.pageX;\\n        var ydiff = event.touches[0].pageY - firstTouch.pageY;\\n        var touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);\\n\\n        if (touchDistance > tapMovementThreshold) {\\n          couldBeTap = false;\\n        }\\n      }\\n    });\\n\\n    var noTap = function noTap() {\\n      couldBeTap = false;\\n    };\\n\\n    // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s\\n    this.on('touchleave', noTap);\\n    this.on('touchcancel', noTap);\\n\\n    // When the touch ends, measure how long it took and trigger the appropriate\\n    // event\\n    this.on('touchend', function (event) {\\n      firstTouch = null;\\n      // Proceed only if the touchmove/leave/cancel event didn't happen\\n      if (couldBeTap === true) {\\n        // Measure how long the touch lasted\\n        var touchTime = new Date().getTime() - touchStart;\\n\\n        // Make sure the touch was less than the threshold to be considered a tap\\n        if (touchTime < touchTimeThreshold) {\\n          // Don't let browser turn this into a click\\n          event.preventDefault();\\n          this.trigger('tap');\\n          // It may be good to copy the touchend event object and change the\\n          // type to tap, if the other event properties aren't exact after\\n          // Events.fixEvent runs (e.g. event.target)\\n        }\\n      }\\n    });\\n  };\\n\\n  /**\\n   * Report user touch activity when touch events occur\\n   * User activity is used to determine when controls should show/hide. It's\\n   * relatively simple when it comes to mouse events, because any mouse event\\n   * should show the controls. So we capture mouse events that bubble up to the\\n   * player and report activity when that happens.\\n   * With touch events it isn't as easy. We can't rely on touch events at the\\n   * player level, because a tap (touchstart + touchend) on the video itself on\\n   * mobile devices is meant to turn controls off (and on). User activity is\\n   * checked asynchronously, so what could happen is a tap event on the video\\n   * turns the controls off, then the touchend event bubbles up to the player,\\n   * which if it reported user activity, would turn the controls right back on.\\n   * (We also don't want to completely block touch events from bubbling up)\\n   * Also a touchmove, touch+hold, and anything other than a tap is not supposed\\n   * to turn the controls back on on a mobile device.\\n   * Here we're setting the default component behavior to report user activity\\n   * whenever touch events happen, and this can be turned off by components that\\n   * want touch events to act differently.\\n   *\\n   * @method enableTouchActivity\\n   */\\n\\n  Component.prototype.enableTouchActivity = function enableTouchActivity() {\\n    // Don't continue if the root player doesn't support reporting user activity\\n    if (!this.player() || !this.player().reportUserActivity) {\\n      return;\\n    }\\n\\n    // listener for reporting that the user is active\\n    var report = Fn.bind(this.player(), this.player().reportUserActivity);\\n\\n    var touchHolding = undefined;\\n\\n    this.on('touchstart', function () {\\n      report();\\n      // For as long as the they are touching the device or have their mouse down,\\n      // we consider them active even if they're not moving their finger or mouse.\\n      // So we want to continue to update that they are active\\n      this.clearInterval(touchHolding);\\n      // report at the same interval as activityCheck\\n      touchHolding = this.setInterval(report, 250);\\n    });\\n\\n    var touchEnd = function touchEnd(event) {\\n      report();\\n      // stop the interval that maintains activity if the touch is holding\\n      this.clearInterval(touchHolding);\\n    };\\n\\n    this.on('touchmove', report);\\n    this.on('touchend', touchEnd);\\n    this.on('touchcancel', touchEnd);\\n  };\\n\\n  /**\\n   * Creates timeout and sets up disposal automatically.\\n   *\\n   * @param {Function} fn The function to run after the timeout.\\n   * @param {Number} timeout Number of ms to delay before executing specified function.\\n   * @return {Number} Returns the timeout ID\\n   * @method setTimeout\\n   */\\n\\n  Component.prototype.setTimeout = function setTimeout(fn, timeout) {\\n    fn = Fn.bind(this, fn);\\n\\n    // window.setTimeout would be preferable here, but due to some bizarre issue with Sinon and/or Phantomjs, we can't.\\n    var timeoutId = _globalWindow2['default'].setTimeout(fn, timeout);\\n\\n    var disposeFn = function disposeFn() {\\n      this.clearTimeout(timeoutId);\\n    };\\n\\n    disposeFn.guid = 'vjs-timeout-' + timeoutId;\\n\\n    this.on('dispose', disposeFn);\\n\\n    return timeoutId;\\n  };\\n\\n  /**\\n   * Clears a timeout and removes the associated dispose listener\\n   *\\n   * @param {Number} timeoutId The id of the timeout to clear\\n   * @return {Number} Returns the timeout ID\\n   * @method clearTimeout\\n   */\\n\\n  Component.prototype.clearTimeout = function clearTimeout(timeoutId) {\\n    _globalWindow2['default'].clearTimeout(timeoutId);\\n\\n    var disposeFn = function disposeFn() {};\\n\\n    disposeFn.guid = 'vjs-timeout-' + timeoutId;\\n\\n    this.off('dispose', disposeFn);\\n\\n    return timeoutId;\\n  };\\n\\n  /**\\n   * Creates an interval and sets up disposal automatically.\\n   *\\n   * @param {Function} fn The function to run every N seconds.\\n   * @param {Number} interval Number of ms to delay before executing specified function.\\n   * @return {Number} Returns the interval ID\\n   * @method setInterval\\n   */\\n\\n  Component.prototype.setInterval = function setInterval(fn, interval) {\\n    fn = Fn.bind(this, fn);\\n\\n    var intervalId = _globalWindow2['default'].setInterval(fn, interval);\\n\\n    var disposeFn = function disposeFn() {\\n      this.clearInterval(intervalId);\\n    };\\n\\n    disposeFn.guid = 'vjs-interval-' + intervalId;\\n\\n    this.on('dispose', disposeFn);\\n\\n    return intervalId;\\n  };\\n\\n  /**\\n   * Clears an interval and removes the associated dispose listener\\n   *\\n   * @param {Number} intervalId The id of the interval to clear\\n   * @return {Number} Returns the interval ID\\n   * @method clearInterval\\n   */\\n\\n  Component.prototype.clearInterval = function clearInterval(intervalId) {\\n    _globalWindow2['default'].clearInterval(intervalId);\\n\\n    var disposeFn = function disposeFn() {};\\n\\n    disposeFn.guid = 'vjs-interval-' + intervalId;\\n\\n    this.off('dispose', disposeFn);\\n\\n    return intervalId;\\n  };\\n\\n  /**\\n   * Registers a component\\n   *\\n   * @param {String} name Name of the component to register\\n   * @param {Object} comp The component to register\\n   * @static\\n   * @method registerComponent\\n   */\\n\\n  Component.registerComponent = function registerComponent(name, comp) {\\n    if (!Component.components_) {\\n      Component.components_ = {};\\n    }\\n\\n    Component.components_[name] = comp;\\n    return comp;\\n  };\\n\\n  /**\\n   * Gets a component by name\\n   *\\n   * @param {String} name Name of the component to get\\n   * @return {Component}\\n   * @static\\n   * @method getComponent\\n   */\\n\\n  Component.getComponent = function getComponent(name) {\\n    if (Component.components_ && Component.components_[name]) {\\n      return Component.components_[name];\\n    }\\n\\n    if (_globalWindow2['default'] && _globalWindow2['default'].videojs && _globalWindow2['default'].videojs[name]) {\\n      _utilsLogJs2['default'].warn('The ' + name + ' component was added to the videojs object when it should be registered using videojs.registerComponent(name, component)');\\n      return _globalWindow2['default'].videojs[name];\\n    }\\n  };\\n\\n  /**\\n   * Sets up the constructor using the supplied init method\\n   * or uses the init of the parent object\\n   *\\n   * @param {Object} props An object of properties\\n   * @static\\n   * @deprecated\\n   * @method extend\\n   */\\n\\n  Component.extend = function extend(props) {\\n    props = props || {};\\n\\n    _utilsLogJs2['default'].warn('Component.extend({}) has been deprecated, use videojs.extend(Component, {}) instead');\\n\\n    // Set up the constructor using the supplied init method\\n    // or using the init of the parent object\\n    // Make sure to check the unobfuscated version for external libs\\n    var init = props.init || props.init || this.prototype.init || this.prototype.init || function () {};\\n    // In Resig's simple class inheritance (previously used) the constructor\\n    //  is a function that calls `this.init.apply(arguments)`\\n    // However that would prevent us from using `ParentObject.call(this);`\\n    //  in a Child constructor because the `this` in `this.init`\\n    //  would still refer to the Child and cause an infinite loop.\\n    // We would instead have to do\\n    //    `ParentObject.prototype.init.apply(this, arguments);`\\n    //  Bleh. We're not creating a _super() function, so it's good to keep\\n    //  the parent constructor reference simple.\\n    var subObj = function subObj() {\\n      init.apply(this, arguments);\\n    };\\n\\n    // Inherit from this object's prototype\\n    subObj.prototype = Object.create(this.prototype);\\n    // Reset the constructor property for subObj otherwise\\n    // instances of subObj would have the constructor of the parent Object\\n    subObj.prototype.constructor = subObj;\\n\\n    // Make the class extendable\\n    subObj.extend = Component.extend;\\n\\n    // Extend subObj's prototype with functions and other properties from props\\n    for (var _name in props) {\\n      if (props.hasOwnProperty(_name)) {\\n        subObj.prototype[_name] = props[_name];\\n      }\\n    }\\n\\n    return subObj;\\n  };\\n\\n  return Component;\\n})();\\n\\nComponent.registerComponent('Component', Component);\\nexports['default'] = Component;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./utils/dom.js\\\":142,\\\"./utils/events.js\\\":143,\\\"./utils/fn.js\\\":144,\\\"./utils/guid.js\\\":146,\\\"./utils/log.js\\\":147,\\\"./utils/merge-options.js\\\":148,\\\"./utils/to-title-case.js\\\":151,\\\"global/window\\\":2}],68:[function(_dereq_,module,exports){\\n/**\\n * @file audio-track-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _trackButtonJs = _dereq_('../track-button.js');\\n\\nvar _trackButtonJs2 = _interopRequireDefault(_trackButtonJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _audioTrackMenuItemJs = _dereq_('./audio-track-menu-item.js');\\n\\nvar _audioTrackMenuItemJs2 = _interopRequireDefault(_audioTrackMenuItemJs);\\n\\n/**\\n * The base class for buttons that toggle specific text track types (e.g. subtitles)\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends TrackButton\\n * @class AudioTrackButton\\n */\\n\\nvar AudioTrackButton = (function (_TrackButton) {\\n  _inherits(AudioTrackButton, _TrackButton);\\n\\n  function AudioTrackButton(player) {\\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n\\n    _classCallCheck(this, AudioTrackButton);\\n\\n    options.tracks = player.audioTracks && player.audioTracks();\\n\\n    _TrackButton.call(this, player, options);\\n\\n    this.el_.setAttribute('aria-label', 'Audio Menu');\\n  }\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  AudioTrackButton.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-audio-button ' + _TrackButton.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Create a menu item for each audio track\\n   *\\n   * @return {Array} Array of menu items\\n   * @method createItems\\n   */\\n\\n  AudioTrackButton.prototype.createItems = function createItems() {\\n    var items = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\\n\\n    var tracks = this.player_.audioTracks && this.player_.audioTracks();\\n\\n    if (!tracks) {\\n      return items;\\n    }\\n\\n    for (var i = 0; i < tracks.length; i++) {\\n      var track = tracks[i];\\n\\n      items.push(new _audioTrackMenuItemJs2['default'](this.player_, {\\n        // MenuItem is selectable\\n        'selectable': true,\\n        'track': track\\n      }));\\n    }\\n\\n    return items;\\n  };\\n\\n  return AudioTrackButton;\\n})(_trackButtonJs2['default']);\\n\\nAudioTrackButton.prototype.controlText_ = 'Audio Track';\\n_componentJs2['default'].registerComponent('AudioTrackButton', AudioTrackButton);\\nexports['default'] = AudioTrackButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../utils/fn.js\\\":144,\\\"../track-button.js\\\":98,\\\"./audio-track-menu-item.js\\\":69}],69:[function(_dereq_,module,exports){\\n/**\\n * @file audio-track-menu-item.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _menuMenuItemJs = _dereq_('../../menu/menu-item.js');\\n\\nvar _menuMenuItemJs2 = _interopRequireDefault(_menuMenuItemJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\n/**\\n * The audio track menu item\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends MenuItem\\n * @class AudioTrackMenuItem\\n */\\n\\nvar AudioTrackMenuItem = (function (_MenuItem) {\\n  _inherits(AudioTrackMenuItem, _MenuItem);\\n\\n  function AudioTrackMenuItem(player, options) {\\n    var _this = this;\\n\\n    _classCallCheck(this, AudioTrackMenuItem);\\n\\n    var track = options.track;\\n    var tracks = player.audioTracks();\\n\\n    // Modify options for parent MenuItem class's init.\\n    options.label = track.label || track.language || 'Unknown';\\n    options.selected = track.enabled;\\n\\n    _MenuItem.call(this, player, options);\\n\\n    this.track = track;\\n\\n    if (tracks) {\\n      (function () {\\n        var changeHandler = Fn.bind(_this, _this.handleTracksChange);\\n\\n        tracks.addEventListener('change', changeHandler);\\n        _this.on('dispose', function () {\\n          tracks.removeEventListener('change', changeHandler);\\n        });\\n      })();\\n    }\\n  }\\n\\n  /**\\n   * Handle click on audio track\\n   *\\n   * @method handleClick\\n   */\\n\\n  AudioTrackMenuItem.prototype.handleClick = function handleClick(event) {\\n    var tracks = this.player_.audioTracks();\\n\\n    _MenuItem.prototype.handleClick.call(this, event);\\n\\n    if (!tracks) return;\\n\\n    for (var i = 0; i < tracks.length; i++) {\\n      var track = tracks[i];\\n\\n      track.enabled = track === this.track;\\n    }\\n  };\\n\\n  /**\\n   * Handle audio track change\\n   *\\n   * @method handleTracksChange\\n   */\\n\\n  AudioTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {\\n    this.selected(this.track.enabled);\\n  };\\n\\n  return AudioTrackMenuItem;\\n})(_menuMenuItemJs2['default']);\\n\\n_componentJs2['default'].registerComponent('AudioTrackMenuItem', AudioTrackMenuItem);\\nexports['default'] = AudioTrackMenuItem;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../menu/menu-item.js\\\":110,\\\"../../utils/fn.js\\\":144}],70:[function(_dereq_,module,exports){\\n/**\\n * @file control-bar.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n// Required children\\n\\nvar _playToggleJs = _dereq_('./play-toggle.js');\\n\\nvar _playToggleJs2 = _interopRequireDefault(_playToggleJs);\\n\\nvar _timeControlsCurrentTimeDisplayJs = _dereq_('./time-controls/current-time-display.js');\\n\\nvar _timeControlsCurrentTimeDisplayJs2 = _interopRequireDefault(_timeControlsCurrentTimeDisplayJs);\\n\\nvar _timeControlsDurationDisplayJs = _dereq_('./time-controls/duration-display.js');\\n\\nvar _timeControlsDurationDisplayJs2 = _interopRequireDefault(_timeControlsDurationDisplayJs);\\n\\nvar _timeControlsTimeDividerJs = _dereq_('./time-controls/time-divider.js');\\n\\nvar _timeControlsTimeDividerJs2 = _interopRequireDefault(_timeControlsTimeDividerJs);\\n\\nvar _timeControlsRemainingTimeDisplayJs = _dereq_('./time-controls/remaining-time-display.js');\\n\\nvar _timeControlsRemainingTimeDisplayJs2 = _interopRequireDefault(_timeControlsRemainingTimeDisplayJs);\\n\\nvar _liveDisplayJs = _dereq_('./live-display.js');\\n\\nvar _liveDisplayJs2 = _interopRequireDefault(_liveDisplayJs);\\n\\nvar _progressControlProgressControlJs = _dereq_('./progress-control/progress-control.js');\\n\\nvar _progressControlProgressControlJs2 = _interopRequireDefault(_progressControlProgressControlJs);\\n\\nvar _fullscreenToggleJs = _dereq_('./fullscreen-toggle.js');\\n\\nvar _fullscreenToggleJs2 = _interopRequireDefault(_fullscreenToggleJs);\\n\\nvar _volumeControlVolumeControlJs = _dereq_('./volume-control/volume-control.js');\\n\\nvar _volumeControlVolumeControlJs2 = _interopRequireDefault(_volumeControlVolumeControlJs);\\n\\nvar _volumeMenuButtonJs = _dereq_('./volume-menu-button.js');\\n\\nvar _volumeMenuButtonJs2 = _interopRequireDefault(_volumeMenuButtonJs);\\n\\nvar _muteToggleJs = _dereq_('./mute-toggle.js');\\n\\nvar _muteToggleJs2 = _interopRequireDefault(_muteToggleJs);\\n\\nvar _textTrackControlsChaptersButtonJs = _dereq_('./text-track-controls/chapters-button.js');\\n\\nvar _textTrackControlsChaptersButtonJs2 = _interopRequireDefault(_textTrackControlsChaptersButtonJs);\\n\\nvar _textTrackControlsDescriptionsButtonJs = _dereq_('./text-track-controls/descriptions-button.js');\\n\\nvar _textTrackControlsDescriptionsButtonJs2 = _interopRequireDefault(_textTrackControlsDescriptionsButtonJs);\\n\\nvar _textTrackControlsSubtitlesButtonJs = _dereq_('./text-track-controls/subtitles-button.js');\\n\\nvar _textTrackControlsSubtitlesButtonJs2 = _interopRequireDefault(_textTrackControlsSubtitlesButtonJs);\\n\\nvar _textTrackControlsCaptionsButtonJs = _dereq_('./text-track-controls/captions-button.js');\\n\\nvar _textTrackControlsCaptionsButtonJs2 = _interopRequireDefault(_textTrackControlsCaptionsButtonJs);\\n\\nvar _audioTrackControlsAudioTrackButtonJs = _dereq_('./audio-track-controls/audio-track-button.js');\\n\\nvar _audioTrackControlsAudioTrackButtonJs2 = _interopRequireDefault(_audioTrackControlsAudioTrackButtonJs);\\n\\nvar _playbackRateMenuPlaybackRateMenuButtonJs = _dereq_('./playback-rate-menu/playback-rate-menu-button.js');\\n\\nvar _playbackRateMenuPlaybackRateMenuButtonJs2 = _interopRequireDefault(_playbackRateMenuPlaybackRateMenuButtonJs);\\n\\nvar _spacerControlsCustomControlSpacerJs = _dereq_('./spacer-controls/custom-control-spacer.js');\\n\\nvar _spacerControlsCustomControlSpacerJs2 = _interopRequireDefault(_spacerControlsCustomControlSpacerJs);\\n\\n/**\\n * Container of main controls\\n *\\n * @extends Component\\n * @class ControlBar\\n */\\n\\nvar ControlBar = (function (_Component) {\\n  _inherits(ControlBar, _Component);\\n\\n  function ControlBar() {\\n    _classCallCheck(this, ControlBar);\\n\\n    _Component.apply(this, arguments);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  ControlBar.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-control-bar',\\n      dir: 'ltr'\\n    }, {\\n      'role': 'group' // The control bar is a group, so it can contain menuitems\\n    });\\n  };\\n\\n  return ControlBar;\\n})(_componentJs2['default']);\\n\\nControlBar.prototype.options_ = {\\n  children: ['playToggle', 'volumeMenuButton', 'currentTimeDisplay', 'timeDivider', 'durationDisplay', 'progressControl', 'liveDisplay', 'remainingTimeDisplay', 'customControlSpacer', 'playbackRateMenuButton', 'chaptersButton', 'descriptionsButton', 'subtitlesButton', 'captionsButton', 'audioTrackButton', 'fullscreenToggle']\\n};\\n\\n_componentJs2['default'].registerComponent('ControlBar', ControlBar);\\nexports['default'] = ControlBar;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component.js\\\":67,\\\"./audio-track-controls/audio-track-button.js\\\":68,\\\"./fullscreen-toggle.js\\\":71,\\\"./live-display.js\\\":72,\\\"./mute-toggle.js\\\":73,\\\"./play-toggle.js\\\":74,\\\"./playback-rate-menu/playback-rate-menu-button.js\\\":75,\\\"./progress-control/progress-control.js\\\":80,\\\"./spacer-controls/custom-control-spacer.js\\\":83,\\\"./text-track-controls/captions-button.js\\\":86,\\\"./text-track-controls/chapters-button.js\\\":87,\\\"./text-track-controls/descriptions-button.js\\\":89,\\\"./text-track-controls/subtitles-button.js\\\":91,\\\"./time-controls/current-time-display.js\\\":94,\\\"./time-controls/duration-display.js\\\":95,\\\"./time-controls/remaining-time-display.js\\\":96,\\\"./time-controls/time-divider.js\\\":97,\\\"./volume-control/volume-control.js\\\":100,\\\"./volume-menu-button.js\\\":102}],71:[function(_dereq_,module,exports){\\n/**\\n * @file fullscreen-toggle.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _buttonJs = _dereq_('../button.js');\\n\\nvar _buttonJs2 = _interopRequireDefault(_buttonJs);\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n/**\\n * Toggle fullscreen video\\n *\\n * @extends Button\\n * @class FullscreenToggle\\n */\\n\\nvar FullscreenToggle = (function (_Button) {\\n  _inherits(FullscreenToggle, _Button);\\n\\n  function FullscreenToggle(player, options) {\\n    _classCallCheck(this, FullscreenToggle);\\n\\n    _Button.call(this, player, options);\\n    this.on(player, 'fullscreenchange', this.handleFullscreenChange);\\n  }\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  FullscreenToggle.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-fullscreen-control ' + _Button.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Handles Fullscreenchange on the component and change control text accordingly\\n   *\\n   * @method handleFullscreenChange\\n   */\\n\\n  FullscreenToggle.prototype.handleFullscreenChange = function handleFullscreenChange() {\\n    if (this.player_.isFullscreen()) {\\n      this.controlText('Non-Fullscreen');\\n    } else {\\n      this.controlText('Fullscreen');\\n    }\\n  };\\n\\n  /**\\n   * Handles click for full screen\\n   *\\n   * @method handleClick\\n   */\\n\\n  FullscreenToggle.prototype.handleClick = function handleClick() {\\n    if (!this.player_.isFullscreen()) {\\n      this.player_.requestFullscreen();\\n    } else {\\n      this.player_.exitFullscreen();\\n    }\\n  };\\n\\n  return FullscreenToggle;\\n})(_buttonJs2['default']);\\n\\nFullscreenToggle.prototype.controlText_ = 'Fullscreen';\\n\\n_componentJs2['default'].registerComponent('FullscreenToggle', FullscreenToggle);\\nexports['default'] = FullscreenToggle;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../button.js\\\":64,\\\"../component.js\\\":67}],72:[function(_dereq_,module,exports){\\n/**\\n * @file live-display.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _component = _dereq_('../component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _utilsDomJs = _dereq_('../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\n/**\\n * Displays the live indicator\\n * TODO - Future make it click to snap to live\\n *\\n * @extends Component\\n * @class LiveDisplay\\n */\\n\\nvar LiveDisplay = (function (_Component) {\\n  _inherits(LiveDisplay, _Component);\\n\\n  function LiveDisplay(player, options) {\\n    _classCallCheck(this, LiveDisplay);\\n\\n    _Component.call(this, player, options);\\n\\n    this.updateShowing();\\n    this.on(this.player(), 'durationchange', this.updateShowing);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  LiveDisplay.prototype.createEl = function createEl() {\\n    var el = _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-live-control vjs-control'\\n    });\\n\\n    this.contentEl_ = Dom.createEl('div', {\\n      className: 'vjs-live-display',\\n      innerHTML: '<span class=\\\"vjs-control-text\\\">' + this.localize('Stream Type') + '</span>' + this.localize('LIVE')\\n    }, {\\n      'aria-live': 'off'\\n    });\\n\\n    el.appendChild(this.contentEl_);\\n    return el;\\n  };\\n\\n  LiveDisplay.prototype.updateShowing = function updateShowing() {\\n    if (this.player().duration() === Infinity) {\\n      this.show();\\n    } else {\\n      this.hide();\\n    }\\n  };\\n\\n  return LiveDisplay;\\n})(_component2['default']);\\n\\n_component2['default'].registerComponent('LiveDisplay', LiveDisplay);\\nexports['default'] = LiveDisplay;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component\\\":67,\\\"../utils/dom.js\\\":142}],73:[function(_dereq_,module,exports){\\n/**\\n * @file mute-toggle.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _button = _dereq_('../button');\\n\\nvar _button2 = _interopRequireDefault(_button);\\n\\nvar _component = _dereq_('../component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _utilsDomJs = _dereq_('../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\n/**\\n * A button component for muting the audio\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Button\\n * @class MuteToggle\\n */\\n\\nvar MuteToggle = (function (_Button) {\\n  _inherits(MuteToggle, _Button);\\n\\n  function MuteToggle(player, options) {\\n    _classCallCheck(this, MuteToggle);\\n\\n    _Button.call(this, player, options);\\n\\n    this.on(player, 'volumechange', this.update);\\n\\n    // hide mute toggle if the current tech doesn't support volume control\\n    if (player.tech_ && player.tech_['featuresVolumeControl'] === false) {\\n      this.addClass('vjs-hidden');\\n    }\\n\\n    this.on(player, 'loadstart', function () {\\n      this.update(); // We need to update the button to account for a default muted state.\\n\\n      if (player.tech_['featuresVolumeControl'] === false) {\\n        this.addClass('vjs-hidden');\\n      } else {\\n        this.removeClass('vjs-hidden');\\n      }\\n    });\\n  }\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  MuteToggle.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-mute-control ' + _Button.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Handle click on mute\\n   *\\n   * @method handleClick\\n   */\\n\\n  MuteToggle.prototype.handleClick = function handleClick() {\\n    this.player_.muted(this.player_.muted() ? false : true);\\n  };\\n\\n  /**\\n   * Update volume\\n   *\\n   * @method update\\n   */\\n\\n  MuteToggle.prototype.update = function update() {\\n    var vol = this.player_.volume(),\\n        level = 3;\\n\\n    if (vol === 0 || this.player_.muted()) {\\n      level = 0;\\n    } else if (vol < 0.33) {\\n      level = 1;\\n    } else if (vol < 0.67) {\\n      level = 2;\\n    }\\n\\n    // Don't rewrite the button text if the actual text doesn't change.\\n    // This causes unnecessary and confusing information for screen reader users.\\n    // This check is needed because this function gets called every time the volume level is changed.\\n    var toMute = this.player_.muted() ? 'Unmute' : 'Mute';\\n    if (this.controlText() !== toMute) {\\n      this.controlText(toMute);\\n    }\\n\\n    /* TODO improve muted icon classes */\\n    for (var i = 0; i < 4; i++) {\\n      Dom.removeElClass(this.el_, 'vjs-vol-' + i);\\n    }\\n    Dom.addElClass(this.el_, 'vjs-vol-' + level);\\n  };\\n\\n  return MuteToggle;\\n})(_button2['default']);\\n\\nMuteToggle.prototype.controlText_ = 'Mute';\\n\\n_component2['default'].registerComponent('MuteToggle', MuteToggle);\\nexports['default'] = MuteToggle;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../button\\\":64,\\\"../component\\\":67,\\\"../utils/dom.js\\\":142}],74:[function(_dereq_,module,exports){\\n/**\\n * @file play-toggle.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _buttonJs = _dereq_('../button.js');\\n\\nvar _buttonJs2 = _interopRequireDefault(_buttonJs);\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n/**\\n * Button to toggle between play and pause\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Button\\n * @class PlayToggle\\n */\\n\\nvar PlayToggle = (function (_Button) {\\n  _inherits(PlayToggle, _Button);\\n\\n  function PlayToggle(player, options) {\\n    _classCallCheck(this, PlayToggle);\\n\\n    _Button.call(this, player, options);\\n\\n    this.on(player, 'play', this.handlePlay);\\n    this.on(player, 'pause', this.handlePause);\\n  }\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  PlayToggle.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-play-control ' + _Button.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Handle click to toggle between play and pause\\n   *\\n   * @method handleClick\\n   */\\n\\n  PlayToggle.prototype.handleClick = function handleClick() {\\n    if (this.player_.paused()) {\\n      this.player_.play();\\n    } else {\\n      this.player_.pause();\\n    }\\n  };\\n\\n  /**\\n   * Add the vjs-playing class to the element so it can change appearance\\n   *\\n   * @method handlePlay\\n   */\\n\\n  PlayToggle.prototype.handlePlay = function handlePlay() {\\n    this.removeClass('vjs-paused');\\n    this.addClass('vjs-playing');\\n    this.controlText('Pause'); // change the button text to \\\"Pause\\\"\\n  };\\n\\n  /**\\n   * Add the vjs-paused class to the element so it can change appearance\\n   *\\n   * @method handlePause\\n   */\\n\\n  PlayToggle.prototype.handlePause = function handlePause() {\\n    this.removeClass('vjs-playing');\\n    this.addClass('vjs-paused');\\n    this.controlText('Play'); // change the button text to \\\"Play\\\"\\n  };\\n\\n  return PlayToggle;\\n})(_buttonJs2['default']);\\n\\nPlayToggle.prototype.controlText_ = 'Play';\\n\\n_componentJs2['default'].registerComponent('PlayToggle', PlayToggle);\\nexports['default'] = PlayToggle;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../button.js\\\":64,\\\"../component.js\\\":67}],75:[function(_dereq_,module,exports){\\n/**\\n * @file playback-rate-menu-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _menuMenuButtonJs = _dereq_('../../menu/menu-button.js');\\n\\nvar _menuMenuButtonJs2 = _interopRequireDefault(_menuMenuButtonJs);\\n\\nvar _menuMenuJs = _dereq_('../../menu/menu.js');\\n\\nvar _menuMenuJs2 = _interopRequireDefault(_menuMenuJs);\\n\\nvar _playbackRateMenuItemJs = _dereq_('./playback-rate-menu-item.js');\\n\\nvar _playbackRateMenuItemJs2 = _interopRequireDefault(_playbackRateMenuItemJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsDomJs = _dereq_('../../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\n/**\\n * The component for controlling the playback rate\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends MenuButton\\n * @class PlaybackRateMenuButton\\n */\\n\\nvar PlaybackRateMenuButton = (function (_MenuButton) {\\n  _inherits(PlaybackRateMenuButton, _MenuButton);\\n\\n  function PlaybackRateMenuButton(player, options) {\\n    _classCallCheck(this, PlaybackRateMenuButton);\\n\\n    _MenuButton.call(this, player, options);\\n\\n    this.updateVisibility();\\n    this.updateLabel();\\n\\n    this.on(player, 'loadstart', this.updateVisibility);\\n    this.on(player, 'ratechange', this.updateLabel);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  PlaybackRateMenuButton.prototype.createEl = function createEl() {\\n    var el = _MenuButton.prototype.createEl.call(this);\\n\\n    this.labelEl_ = Dom.createEl('div', {\\n      className: 'vjs-playback-rate-value',\\n      innerHTML: 1.0\\n    });\\n\\n    el.appendChild(this.labelEl_);\\n\\n    return el;\\n  };\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  PlaybackRateMenuButton.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-playback-rate ' + _MenuButton.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Create the playback rate menu\\n   *\\n   * @return {Menu} Menu object populated with items\\n   * @method createMenu\\n   */\\n\\n  PlaybackRateMenuButton.prototype.createMenu = function createMenu() {\\n    var menu = new _menuMenuJs2['default'](this.player());\\n    var rates = this.playbackRates();\\n\\n    if (rates) {\\n      for (var i = rates.length - 1; i >= 0; i--) {\\n        menu.addChild(new _playbackRateMenuItemJs2['default'](this.player(), { 'rate': rates[i] + 'x' }));\\n      }\\n    }\\n\\n    return menu;\\n  };\\n\\n  /**\\n   * Updates ARIA accessibility attributes\\n   *\\n   * @method updateARIAAttributes\\n   */\\n\\n  PlaybackRateMenuButton.prototype.updateARIAAttributes = function updateARIAAttributes() {\\n    // Current playback rate\\n    this.el().setAttribute('aria-valuenow', this.player().playbackRate());\\n  };\\n\\n  /**\\n   * Handle menu item click\\n   *\\n   * @method handleClick\\n   */\\n\\n  PlaybackRateMenuButton.prototype.handleClick = function handleClick() {\\n    // select next rate option\\n    var currentRate = this.player().playbackRate();\\n    var rates = this.playbackRates();\\n\\n    // this will select first one if the last one currently selected\\n    var newRate = rates[0];\\n    for (var i = 0; i < rates.length; i++) {\\n      if (rates[i] > currentRate) {\\n        newRate = rates[i];\\n        break;\\n      }\\n    }\\n    this.player().playbackRate(newRate);\\n  };\\n\\n  /**\\n   * Get possible playback rates\\n   *\\n   * @return {Array} Possible playback rates\\n   * @method playbackRates\\n   */\\n\\n  PlaybackRateMenuButton.prototype.playbackRates = function playbackRates() {\\n    return this.options_['playbackRates'] || this.options_.playerOptions && this.options_.playerOptions['playbackRates'];\\n  };\\n\\n  /**\\n   * Get whether playback rates is supported by the tech\\n   * and an array of playback rates exists\\n   *\\n   * @return {Boolean} Whether changing playback rate is supported\\n   * @method playbackRateSupported\\n   */\\n\\n  PlaybackRateMenuButton.prototype.playbackRateSupported = function playbackRateSupported() {\\n    return this.player().tech_ && this.player().tech_['featuresPlaybackRate'] && this.playbackRates() && this.playbackRates().length > 0;\\n  };\\n\\n  /**\\n   * Hide playback rate controls when they're no playback rate options to select\\n   *\\n   * @method updateVisibility\\n   */\\n\\n  PlaybackRateMenuButton.prototype.updateVisibility = function updateVisibility() {\\n    if (this.playbackRateSupported()) {\\n      this.removeClass('vjs-hidden');\\n    } else {\\n      this.addClass('vjs-hidden');\\n    }\\n  };\\n\\n  /**\\n   * Update button label when rate changed\\n   *\\n   * @method updateLabel\\n   */\\n\\n  PlaybackRateMenuButton.prototype.updateLabel = function updateLabel() {\\n    if (this.playbackRateSupported()) {\\n      this.labelEl_.innerHTML = this.player().playbackRate() + 'x';\\n    }\\n  };\\n\\n  return PlaybackRateMenuButton;\\n})(_menuMenuButtonJs2['default']);\\n\\nPlaybackRateMenuButton.prototype.controlText_ = 'Playback Rate';\\n\\n_componentJs2['default'].registerComponent('PlaybackRateMenuButton', PlaybackRateMenuButton);\\nexports['default'] = PlaybackRateMenuButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../menu/menu-button.js\\\":109,\\\"../../menu/menu.js\\\":111,\\\"../../utils/dom.js\\\":142,\\\"./playback-rate-menu-item.js\\\":76}],76:[function(_dereq_,module,exports){\\n/**\\n * @file playback-rate-menu-item.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _menuMenuItemJs = _dereq_('../../menu/menu-item.js');\\n\\nvar _menuMenuItemJs2 = _interopRequireDefault(_menuMenuItemJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n/**\\n * The specific menu item type for selecting a playback rate\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends MenuItem\\n * @class PlaybackRateMenuItem\\n */\\n\\nvar PlaybackRateMenuItem = (function (_MenuItem) {\\n  _inherits(PlaybackRateMenuItem, _MenuItem);\\n\\n  function PlaybackRateMenuItem(player, options) {\\n    _classCallCheck(this, PlaybackRateMenuItem);\\n\\n    var label = options['rate'];\\n    var rate = parseFloat(label, 10);\\n\\n    // Modify options for parent MenuItem class's init.\\n    options['label'] = label;\\n    options['selected'] = rate === 1;\\n    _MenuItem.call(this, player, options);\\n\\n    this.label = label;\\n    this.rate = rate;\\n\\n    this.on(player, 'ratechange', this.update);\\n  }\\n\\n  /**\\n   * Handle click on menu item\\n   *\\n   * @method handleClick\\n   */\\n\\n  PlaybackRateMenuItem.prototype.handleClick = function handleClick() {\\n    _MenuItem.prototype.handleClick.call(this);\\n    this.player().playbackRate(this.rate);\\n  };\\n\\n  /**\\n   * Update playback rate with selected rate\\n   *\\n   * @method update\\n   */\\n\\n  PlaybackRateMenuItem.prototype.update = function update() {\\n    this.selected(this.player().playbackRate() === this.rate);\\n  };\\n\\n  return PlaybackRateMenuItem;\\n})(_menuMenuItemJs2['default']);\\n\\nPlaybackRateMenuItem.prototype.contentElType = 'button';\\n\\n_componentJs2['default'].registerComponent('PlaybackRateMenuItem', PlaybackRateMenuItem);\\nexports['default'] = PlaybackRateMenuItem;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../menu/menu-item.js\\\":110}],77:[function(_dereq_,module,exports){\\n/**\\n * @file load-progress-bar.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsDomJs = _dereq_('../../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\n/**\\n * Shows load progress\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class LoadProgressBar\\n */\\n\\nvar LoadProgressBar = (function (_Component) {\\n  _inherits(LoadProgressBar, _Component);\\n\\n  function LoadProgressBar(player, options) {\\n    _classCallCheck(this, LoadProgressBar);\\n\\n    _Component.call(this, player, options);\\n    this.on(player, 'progress', this.update);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  LoadProgressBar.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-load-progress',\\n      innerHTML: '<span class=\\\"vjs-control-text\\\"><span>' + this.localize('Loaded') + '</span>: 0%</span>'\\n    });\\n  };\\n\\n  /**\\n   * Update progress bar\\n   *\\n   * @method update\\n   */\\n\\n  LoadProgressBar.prototype.update = function update() {\\n    var buffered = this.player_.buffered();\\n    var duration = this.player_.duration();\\n    var bufferedEnd = this.player_.bufferedEnd();\\n    var children = this.el_.children;\\n\\n    // get the percent width of a time compared to the total end\\n    var percentify = function percentify(time, end) {\\n      var percent = time / end || 0; // no NaN\\n      return (percent >= 1 ? 1 : percent) * 100 + '%';\\n    };\\n\\n    // update the width of the progress bar\\n    this.el_.style.width = percentify(bufferedEnd, duration);\\n\\n    // add child elements to represent the individual buffered time ranges\\n    for (var i = 0; i < buffered.length; i++) {\\n      var start = buffered.start(i);\\n      var end = buffered.end(i);\\n      var part = children[i];\\n\\n      if (!part) {\\n        part = this.el_.appendChild(Dom.createEl());\\n      }\\n\\n      // set the percent based on the width of the progress bar (bufferedEnd)\\n      part.style.left = percentify(start, bufferedEnd);\\n      part.style.width = percentify(end - start, bufferedEnd);\\n    }\\n\\n    // remove unused buffered range elements\\n    for (var i = children.length; i > buffered.length; i--) {\\n      this.el_.removeChild(children[i - 1]);\\n    }\\n  };\\n\\n  return LoadProgressBar;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('LoadProgressBar', LoadProgressBar);\\nexports['default'] = LoadProgressBar;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../utils/dom.js\\\":142}],78:[function(_dereq_,module,exports){\\n/**\\n * @file mouse-time-display.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsDomJs = _dereq_('../../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsFormatTimeJs = _dereq_('../../utils/format-time.js');\\n\\nvar _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);\\n\\nvar _lodashCompatFunctionThrottle = _dereq_('lodash-compat/function/throttle');\\n\\nvar _lodashCompatFunctionThrottle2 = _interopRequireDefault(_lodashCompatFunctionThrottle);\\n\\n/**\\n * The Mouse Time Display component shows the time you will seek to\\n * when hovering over the progress bar\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class MouseTimeDisplay\\n */\\n\\nvar MouseTimeDisplay = (function (_Component) {\\n  _inherits(MouseTimeDisplay, _Component);\\n\\n  function MouseTimeDisplay(player, options) {\\n    var _this = this;\\n\\n    _classCallCheck(this, MouseTimeDisplay);\\n\\n    _Component.call(this, player, options);\\n\\n    if (options.playerOptions && options.playerOptions.controlBar && options.playerOptions.controlBar.progressControl && options.playerOptions.controlBar.progressControl.keepTooltipsInside) {\\n      this.keepTooltipsInside = options.playerOptions.controlBar.progressControl.keepTooltipsInside;\\n    }\\n\\n    if (this.keepTooltipsInside) {\\n      this.tooltip = Dom.createEl('div', { className: 'vjs-time-tooltip' });\\n      this.el().appendChild(this.tooltip);\\n      this.addClass('vjs-keep-tooltips-inside');\\n    }\\n\\n    this.update(0, 0);\\n\\n    player.on('ready', function () {\\n      _this.on(player.controlBar.progressControl.el(), 'mousemove', _lodashCompatFunctionThrottle2['default'](Fn.bind(_this, _this.handleMouseMove), 25));\\n    });\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  MouseTimeDisplay.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-mouse-display'\\n    });\\n  };\\n\\n  MouseTimeDisplay.prototype.handleMouseMove = function handleMouseMove(event) {\\n    var duration = this.player_.duration();\\n    var newTime = this.calculateDistance(event) * duration;\\n    var position = event.pageX - Dom.findElPosition(this.el().parentNode).left;\\n\\n    this.update(newTime, position);\\n  };\\n\\n  MouseTimeDisplay.prototype.update = function update(newTime, position) {\\n    var time = _utilsFormatTimeJs2['default'](newTime, this.player_.duration());\\n\\n    this.el().style.left = position + 'px';\\n    this.el().setAttribute('data-current-time', time);\\n\\n    if (this.keepTooltipsInside) {\\n      var clampedPosition = this.clampPosition_(position);\\n      var difference = position - clampedPosition + 1;\\n      var tooltipWidth = parseFloat(_globalWindow2['default'].getComputedStyle(this.tooltip).width);\\n      var tooltipWidthHalf = tooltipWidth / 2;\\n\\n      this.tooltip.innerHTML = time;\\n      this.tooltip.style.right = '-' + (tooltipWidthHalf - difference) + 'px';\\n    }\\n  };\\n\\n  MouseTimeDisplay.prototype.calculateDistance = function calculateDistance(event) {\\n    return Dom.getPointerPosition(this.el().parentNode, event).x;\\n  };\\n\\n  /**\\n   * This takes in a horizontal position for the bar and returns a clamped position.\\n   * Clamped position means that it will keep the position greater than half the width\\n   * of the tooltip and smaller than the player width minus half the width o the tooltip.\\n   * It will only clamp the position if `keepTooltipsInside` option is set.\\n   *\\n   * @param {Number} position the position the bar wants to be\\n   * @return {Number} newPosition the (potentially) clamped position\\n   * @method clampPosition_\\n   */\\n\\n  MouseTimeDisplay.prototype.clampPosition_ = function clampPosition_(position) {\\n    if (!this.keepTooltipsInside) {\\n      return position;\\n    }\\n\\n    var playerWidth = parseFloat(_globalWindow2['default'].getComputedStyle(this.player().el()).width);\\n    var tooltipWidth = parseFloat(_globalWindow2['default'].getComputedStyle(this.tooltip).width);\\n    var tooltipWidthHalf = tooltipWidth / 2;\\n    var actualPosition = position;\\n\\n    if (position < tooltipWidthHalf) {\\n      actualPosition = Math.ceil(tooltipWidthHalf);\\n    } else if (position > playerWidth - tooltipWidthHalf) {\\n      actualPosition = Math.floor(playerWidth - tooltipWidthHalf);\\n    }\\n\\n    return actualPosition;\\n  };\\n\\n  return MouseTimeDisplay;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('MouseTimeDisplay', MouseTimeDisplay);\\nexports['default'] = MouseTimeDisplay;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../utils/dom.js\\\":142,\\\"../../utils/fn.js\\\":144,\\\"../../utils/format-time.js\\\":145,\\\"global/window\\\":2,\\\"lodash-compat/function/throttle\\\":7}],79:[function(_dereq_,module,exports){\\n/**\\n * @file play-progress-bar.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsDomJs = _dereq_('../../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFormatTimeJs = _dereq_('../../utils/format-time.js');\\n\\nvar _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);\\n\\n/**\\n * Shows play progress\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class PlayProgressBar\\n */\\n\\nvar PlayProgressBar = (function (_Component) {\\n  _inherits(PlayProgressBar, _Component);\\n\\n  function PlayProgressBar(player, options) {\\n    _classCallCheck(this, PlayProgressBar);\\n\\n    _Component.call(this, player, options);\\n    this.updateDataAttr();\\n    this.on(player, 'timeupdate', this.updateDataAttr);\\n    player.ready(Fn.bind(this, this.updateDataAttr));\\n\\n    if (options.playerOptions && options.playerOptions.controlBar && options.playerOptions.controlBar.progressControl && options.playerOptions.controlBar.progressControl.keepTooltipsInside) {\\n      this.keepTooltipsInside = options.playerOptions.controlBar.progressControl.keepTooltipsInside;\\n    }\\n\\n    if (this.keepTooltipsInside) {\\n      this.addClass('vjs-keep-tooltips-inside');\\n    }\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  PlayProgressBar.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-play-progress vjs-slider-bar',\\n      innerHTML: '<span class=\\\"vjs-control-text\\\"><span>' + this.localize('Progress') + '</span>: 0%</span>'\\n    });\\n  };\\n\\n  PlayProgressBar.prototype.updateDataAttr = function updateDataAttr() {\\n    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\\n    this.el_.setAttribute('data-current-time', _utilsFormatTimeJs2['default'](time, this.player_.duration()));\\n  };\\n\\n  return PlayProgressBar;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('PlayProgressBar', PlayProgressBar);\\nexports['default'] = PlayProgressBar;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../utils/dom.js\\\":142,\\\"../../utils/fn.js\\\":144,\\\"../../utils/format-time.js\\\":145}],80:[function(_dereq_,module,exports){\\n/**\\n * @file progress-control.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _seekBarJs = _dereq_('./seek-bar.js');\\n\\nvar _seekBarJs2 = _interopRequireDefault(_seekBarJs);\\n\\nvar _mouseTimeDisplayJs = _dereq_('./mouse-time-display.js');\\n\\nvar _mouseTimeDisplayJs2 = _interopRequireDefault(_mouseTimeDisplayJs);\\n\\n/**\\n * The Progress Control component contains the seek bar, load progress,\\n * and play progress\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class ProgressControl\\n */\\n\\nvar ProgressControl = (function (_Component) {\\n  _inherits(ProgressControl, _Component);\\n\\n  function ProgressControl() {\\n    _classCallCheck(this, ProgressControl);\\n\\n    _Component.apply(this, arguments);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  ProgressControl.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-progress-control vjs-control'\\n    });\\n  };\\n\\n  return ProgressControl;\\n})(_componentJs2['default']);\\n\\nProgressControl.prototype.options_ = {\\n  children: ['seekBar']\\n};\\n\\n_componentJs2['default'].registerComponent('ProgressControl', ProgressControl);\\nexports['default'] = ProgressControl;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"./mouse-time-display.js\\\":78,\\\"./seek-bar.js\\\":81}],81:[function(_dereq_,module,exports){\\n/**\\n * @file seek-bar.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _sliderSliderJs = _dereq_('../../slider/slider.js');\\n\\nvar _sliderSliderJs2 = _interopRequireDefault(_sliderSliderJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _loadProgressBarJs = _dereq_('./load-progress-bar.js');\\n\\nvar _loadProgressBarJs2 = _interopRequireDefault(_loadProgressBarJs);\\n\\nvar _playProgressBarJs = _dereq_('./play-progress-bar.js');\\n\\nvar _playProgressBarJs2 = _interopRequireDefault(_playProgressBarJs);\\n\\nvar _tooltipProgressBarJs = _dereq_('./tooltip-progress-bar.js');\\n\\nvar _tooltipProgressBarJs2 = _interopRequireDefault(_tooltipProgressBarJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsFormatTimeJs = _dereq_('../../utils/format-time.js');\\n\\nvar _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);\\n\\nvar _objectAssign = _dereq_('object.assign');\\n\\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\\n\\n/**\\n * Seek Bar and holder for the progress bars\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Slider\\n * @class SeekBar\\n */\\n\\nvar SeekBar = (function (_Slider) {\\n  _inherits(SeekBar, _Slider);\\n\\n  function SeekBar(player, options) {\\n    _classCallCheck(this, SeekBar);\\n\\n    _Slider.call(this, player, options);\\n    this.on(player, 'timeupdate', this.updateProgress);\\n    this.on(player, 'ended', this.updateProgress);\\n    player.ready(Fn.bind(this, this.updateProgress));\\n\\n    if (options.playerOptions && options.playerOptions.controlBar && options.playerOptions.controlBar.progressControl && options.playerOptions.controlBar.progressControl.keepTooltipsInside) {\\n      this.keepTooltipsInside = options.playerOptions.controlBar.progressControl.keepTooltipsInside;\\n    }\\n\\n    if (this.keepTooltipsInside) {\\n      this.tooltipProgressBar = this.addChild('TooltipProgressBar');\\n    }\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  SeekBar.prototype.createEl = function createEl() {\\n    return _Slider.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-progress-holder'\\n    }, {\\n      'aria-label': 'progress bar'\\n    });\\n  };\\n\\n  /**\\n   * Update ARIA accessibility attributes\\n   *\\n   * @method updateARIAAttributes\\n   */\\n\\n  SeekBar.prototype.updateProgress = function updateProgress() {\\n    this.updateAriaAttributes(this.el_);\\n\\n    if (this.keepTooltipsInside) {\\n      this.updateAriaAttributes(this.tooltipProgressBar.el_);\\n      this.tooltipProgressBar.el_.style.width = this.bar.el_.style.width;\\n\\n      var playerWidth = parseFloat(_globalWindow2['default'].getComputedStyle(this.player().el()).width);\\n      var tooltipWidth = parseFloat(_globalWindow2['default'].getComputedStyle(this.tooltipProgressBar.tooltip).width);\\n      var tooltipStyle = this.tooltipProgressBar.el().style;\\n      tooltipStyle.maxWidth = Math.floor(playerWidth - tooltipWidth / 2) + 'px';\\n      tooltipStyle.minWidth = Math.ceil(tooltipWidth / 2) + 'px';\\n      tooltipStyle.right = '-' + tooltipWidth / 2 + 'px';\\n    }\\n  };\\n\\n  SeekBar.prototype.updateAriaAttributes = function updateAriaAttributes(el) {\\n    // Allows for smooth scrubbing, when player can't keep up.\\n    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\\n    el.setAttribute('aria-valuenow', (this.getPercent() * 100).toFixed(2)); // machine readable value of progress bar (percentage complete)\\n    el.setAttribute('aria-valuetext', _utilsFormatTimeJs2['default'](time, this.player_.duration())); // human readable value of progress bar (time complete)\\n  };\\n\\n  /**\\n   * Get percentage of video played\\n   *\\n   * @return {Number} Percentage played\\n   * @method getPercent\\n   */\\n\\n  SeekBar.prototype.getPercent = function getPercent() {\\n    var percent = this.player_.currentTime() / this.player_.duration();\\n    return percent >= 1 ? 1 : percent;\\n  };\\n\\n  /**\\n   * Handle mouse down on seek bar\\n   *\\n   * @method handleMouseDown\\n   */\\n\\n  SeekBar.prototype.handleMouseDown = function handleMouseDown(event) {\\n    _Slider.prototype.handleMouseDown.call(this, event);\\n\\n    this.player_.scrubbing(true);\\n\\n    this.videoWasPlaying = !this.player_.paused();\\n    this.player_.pause();\\n  };\\n\\n  /**\\n   * Handle mouse move on seek bar\\n   *\\n   * @method handleMouseMove\\n   */\\n\\n  SeekBar.prototype.handleMouseMove = function handleMouseMove(event) {\\n    var newTime = this.calculateDistance(event) * this.player_.duration();\\n\\n    // Don't let video end while scrubbing.\\n    if (newTime === this.player_.duration()) {\\n      newTime = newTime - 0.1;\\n    }\\n\\n    // Set new time (tell player to seek to new time)\\n    this.player_.currentTime(newTime);\\n  };\\n\\n  /**\\n   * Handle mouse up on seek bar\\n   *\\n   * @method handleMouseUp\\n   */\\n\\n  SeekBar.prototype.handleMouseUp = function handleMouseUp(event) {\\n    _Slider.prototype.handleMouseUp.call(this, event);\\n\\n    this.player_.scrubbing(false);\\n    if (this.videoWasPlaying) {\\n      this.player_.play();\\n    }\\n  };\\n\\n  /**\\n   * Move more quickly fast forward for keyboard-only users\\n   *\\n   * @method stepForward\\n   */\\n\\n  SeekBar.prototype.stepForward = function stepForward() {\\n    this.player_.currentTime(this.player_.currentTime() + 5); // more quickly fast forward for keyboard-only users\\n  };\\n\\n  /**\\n   * Move more quickly rewind for keyboard-only users\\n   *\\n   * @method stepBack\\n   */\\n\\n  SeekBar.prototype.stepBack = function stepBack() {\\n    this.player_.currentTime(this.player_.currentTime() - 5); // more quickly rewind for keyboard-only users\\n  };\\n\\n  return SeekBar;\\n})(_sliderSliderJs2['default']);\\n\\nSeekBar.prototype.options_ = {\\n  children: ['loadProgressBar', 'mouseTimeDisplay', 'playProgressBar'],\\n  'barName': 'playProgressBar'\\n};\\n\\nSeekBar.prototype.playerEvent = 'timeupdate';\\n\\n_componentJs2['default'].registerComponent('SeekBar', SeekBar);\\nexports['default'] = SeekBar;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../slider/slider.js\\\":119,\\\"../../utils/fn.js\\\":144,\\\"../../utils/format-time.js\\\":145,\\\"./load-progress-bar.js\\\":77,\\\"./play-progress-bar.js\\\":79,\\\"./tooltip-progress-bar.js\\\":82,\\\"global/window\\\":2,\\\"object.assign\\\":45}],82:[function(_dereq_,module,exports){\\n/**\\n * @file play-progress-bar.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsDomJs = _dereq_('../../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFormatTimeJs = _dereq_('../../utils/format-time.js');\\n\\nvar _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);\\n\\n/**\\n * Shows play progress\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class PlayProgressBar\\n */\\n\\nvar TooltipProgressBar = (function (_Component) {\\n  _inherits(TooltipProgressBar, _Component);\\n\\n  function TooltipProgressBar(player, options) {\\n    _classCallCheck(this, TooltipProgressBar);\\n\\n    _Component.call(this, player, options);\\n    this.updateDataAttr();\\n    this.on(player, 'timeupdate', this.updateDataAttr);\\n    player.ready(Fn.bind(this, this.updateDataAttr));\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  TooltipProgressBar.prototype.createEl = function createEl() {\\n    var el = _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-tooltip-progress-bar vjs-slider-bar',\\n      innerHTML: '<div class=\\\"vjs-time-tooltip\\\"></div>\\\\n        <span class=\\\"vjs-control-text\\\"><span>' + this.localize('Progress') + '</span>: 0%</span>'\\n    });\\n\\n    this.tooltip = el.querySelector('.vjs-time-tooltip');\\n\\n    return el;\\n  };\\n\\n  TooltipProgressBar.prototype.updateDataAttr = function updateDataAttr() {\\n    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\\n    var formattedTime = _utilsFormatTimeJs2['default'](time, this.player_.duration());\\n    this.el_.setAttribute('data-current-time', formattedTime);\\n    this.tooltip.innerHTML = formattedTime;\\n  };\\n\\n  return TooltipProgressBar;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('TooltipProgressBar', TooltipProgressBar);\\nexports['default'] = TooltipProgressBar;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../utils/dom.js\\\":142,\\\"../../utils/fn.js\\\":144,\\\"../../utils/format-time.js\\\":145}],83:[function(_dereq_,module,exports){\\n/**\\n * @file custom-control-spacer.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _spacerJs = _dereq_('./spacer.js');\\n\\nvar _spacerJs2 = _interopRequireDefault(_spacerJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n/**\\n * Spacer specifically meant to be used as an insertion point for new plugins, etc.\\n *\\n * @extends Spacer\\n * @class CustomControlSpacer\\n */\\n\\nvar CustomControlSpacer = (function (_Spacer) {\\n  _inherits(CustomControlSpacer, _Spacer);\\n\\n  function CustomControlSpacer() {\\n    _classCallCheck(this, CustomControlSpacer);\\n\\n    _Spacer.apply(this, arguments);\\n  }\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  CustomControlSpacer.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-custom-control-spacer ' + _Spacer.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  CustomControlSpacer.prototype.createEl = function createEl() {\\n    var el = _Spacer.prototype.createEl.call(this, {\\n      className: this.buildCSSClass()\\n    });\\n\\n    // No-flex/table-cell mode requires there be some content\\n    // in the cell to fill the remaining space of the table.\\n    el.innerHTML = '&nbsp;';\\n    return el;\\n  };\\n\\n  return CustomControlSpacer;\\n})(_spacerJs2['default']);\\n\\n_componentJs2['default'].registerComponent('CustomControlSpacer', CustomControlSpacer);\\nexports['default'] = CustomControlSpacer;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"./spacer.js\\\":84}],84:[function(_dereq_,module,exports){\\n/**\\n * @file spacer.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n/**\\n * Just an empty spacer element that can be used as an append point for plugins, etc.\\n * Also can be used to create space between elements when necessary.\\n *\\n * @extends Component\\n * @class Spacer\\n */\\n\\nvar Spacer = (function (_Component) {\\n  _inherits(Spacer, _Component);\\n\\n  function Spacer() {\\n    _classCallCheck(this, Spacer);\\n\\n    _Component.apply(this, arguments);\\n  }\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  Spacer.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-spacer ' + _Component.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  Spacer.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: this.buildCSSClass()\\n    });\\n  };\\n\\n  return Spacer;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('Spacer', Spacer);\\n\\nexports['default'] = Spacer;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67}],85:[function(_dereq_,module,exports){\\n/**\\n * @file caption-settings-menu-item.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _textTrackMenuItemJs = _dereq_('./text-track-menu-item.js');\\n\\nvar _textTrackMenuItemJs2 = _interopRequireDefault(_textTrackMenuItemJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n/**\\n * The menu item for caption track settings menu\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends TextTrackMenuItem\\n * @class CaptionSettingsMenuItem\\n */\\n\\nvar CaptionSettingsMenuItem = (function (_TextTrackMenuItem) {\\n  _inherits(CaptionSettingsMenuItem, _TextTrackMenuItem);\\n\\n  function CaptionSettingsMenuItem(player, options) {\\n    _classCallCheck(this, CaptionSettingsMenuItem);\\n\\n    options['track'] = {\\n      'kind': options['kind'],\\n      'player': player,\\n      'label': options['kind'] + ' settings',\\n      'selectable': false,\\n      'default': false,\\n      mode: 'disabled'\\n    };\\n\\n    // CaptionSettingsMenuItem has no concept of 'selected'\\n    options['selectable'] = false;\\n\\n    _TextTrackMenuItem.call(this, player, options);\\n    this.addClass('vjs-texttrack-settings');\\n    this.controlText(', opens ' + options['kind'] + ' settings dialog');\\n  }\\n\\n  /**\\n   * Handle click on menu item\\n   *\\n   * @method handleClick\\n   */\\n\\n  CaptionSettingsMenuItem.prototype.handleClick = function handleClick() {\\n    this.player().getChild('textTrackSettings').show();\\n    this.player().getChild('textTrackSettings').el_.focus();\\n  };\\n\\n  return CaptionSettingsMenuItem;\\n})(_textTrackMenuItemJs2['default']);\\n\\n_componentJs2['default'].registerComponent('CaptionSettingsMenuItem', CaptionSettingsMenuItem);\\nexports['default'] = CaptionSettingsMenuItem;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"./text-track-menu-item.js\\\":93}],86:[function(_dereq_,module,exports){\\n/**\\n * @file captions-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _textTrackButtonJs = _dereq_('./text-track-button.js');\\n\\nvar _textTrackButtonJs2 = _interopRequireDefault(_textTrackButtonJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _captionSettingsMenuItemJs = _dereq_('./caption-settings-menu-item.js');\\n\\nvar _captionSettingsMenuItemJs2 = _interopRequireDefault(_captionSettingsMenuItemJs);\\n\\n/**\\n * The button component for toggling and selecting captions\\n *\\n * @param {Object} player  Player object\\n * @param {Object=} options Object of option names and values\\n * @param {Function=} ready    Ready callback function\\n * @extends TextTrackButton\\n * @class CaptionsButton\\n */\\n\\nvar CaptionsButton = (function (_TextTrackButton) {\\n  _inherits(CaptionsButton, _TextTrackButton);\\n\\n  function CaptionsButton(player, options, ready) {\\n    _classCallCheck(this, CaptionsButton);\\n\\n    _TextTrackButton.call(this, player, options, ready);\\n    this.el_.setAttribute('aria-label', 'Captions Menu');\\n  }\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  CaptionsButton.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-captions-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Update caption menu items\\n   *\\n   * @method update\\n   */\\n\\n  CaptionsButton.prototype.update = function update() {\\n    var threshold = 2;\\n    _TextTrackButton.prototype.update.call(this);\\n\\n    // if native, then threshold is 1 because no settings button\\n    if (this.player().tech_ && this.player().tech_['featuresNativeTextTracks']) {\\n      threshold = 1;\\n    }\\n\\n    if (this.items && this.items.length > threshold) {\\n      this.show();\\n    } else {\\n      this.hide();\\n    }\\n  };\\n\\n  /**\\n   * Create caption menu items\\n   *\\n   * @return {Array} Array of menu items\\n   * @method createItems\\n   */\\n\\n  CaptionsButton.prototype.createItems = function createItems() {\\n    var items = [];\\n\\n    if (!(this.player().tech_ && this.player().tech_['featuresNativeTextTracks'])) {\\n      items.push(new _captionSettingsMenuItemJs2['default'](this.player_, { 'kind': this.kind_ }));\\n    }\\n\\n    return _TextTrackButton.prototype.createItems.call(this, items);\\n  };\\n\\n  return CaptionsButton;\\n})(_textTrackButtonJs2['default']);\\n\\nCaptionsButton.prototype.kind_ = 'captions';\\nCaptionsButton.prototype.controlText_ = 'Captions';\\n\\n_componentJs2['default'].registerComponent('CaptionsButton', CaptionsButton);\\nexports['default'] = CaptionsButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"./caption-settings-menu-item.js\\\":85,\\\"./text-track-button.js\\\":92}],87:[function(_dereq_,module,exports){\\n/**\\n * @file chapters-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _textTrackButtonJs = _dereq_('./text-track-button.js');\\n\\nvar _textTrackButtonJs2 = _interopRequireDefault(_textTrackButtonJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _textTrackMenuItemJs = _dereq_('./text-track-menu-item.js');\\n\\nvar _textTrackMenuItemJs2 = _interopRequireDefault(_textTrackMenuItemJs);\\n\\nvar _chaptersTrackMenuItemJs = _dereq_('./chapters-track-menu-item.js');\\n\\nvar _chaptersTrackMenuItemJs2 = _interopRequireDefault(_chaptersTrackMenuItemJs);\\n\\nvar _menuMenuJs = _dereq_('../../menu/menu.js');\\n\\nvar _menuMenuJs2 = _interopRequireDefault(_menuMenuJs);\\n\\nvar _utilsDomJs = _dereq_('../../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsToTitleCaseJs = _dereq_('../../utils/to-title-case.js');\\n\\nvar _utilsToTitleCaseJs2 = _interopRequireDefault(_utilsToTitleCaseJs);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\n/**\\n * The button component for toggling and selecting chapters\\n * Chapters act much differently than other text tracks\\n * Cues are navigation vs. other tracks of alternative languages\\n *\\n * @param {Object} player  Player object\\n * @param {Object=} options Object of option names and values\\n * @param {Function=} ready    Ready callback function\\n * @extends TextTrackButton\\n * @class ChaptersButton\\n */\\n\\nvar ChaptersButton = (function (_TextTrackButton) {\\n  _inherits(ChaptersButton, _TextTrackButton);\\n\\n  function ChaptersButton(player, options, ready) {\\n    _classCallCheck(this, ChaptersButton);\\n\\n    _TextTrackButton.call(this, player, options, ready);\\n    this.el_.setAttribute('aria-label', 'Chapters Menu');\\n  }\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  ChaptersButton.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-chapters-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Create a menu item for each text track\\n   *\\n   * @return {Array} Array of menu items\\n   * @method createItems\\n   */\\n\\n  ChaptersButton.prototype.createItems = function createItems() {\\n    var items = [];\\n\\n    var tracks = this.player_.textTracks();\\n\\n    if (!tracks) {\\n      return items;\\n    }\\n\\n    for (var i = 0; i < tracks.length; i++) {\\n      var track = tracks[i];\\n      if (track['kind'] === this.kind_) {\\n        items.push(new _textTrackMenuItemJs2['default'](this.player_, {\\n          'track': track\\n        }));\\n      }\\n    }\\n\\n    return items;\\n  };\\n\\n  /**\\n   * Create menu from chapter buttons\\n   *\\n   * @return {Menu} Menu of chapter buttons\\n   * @method createMenu\\n   */\\n\\n  ChaptersButton.prototype.createMenu = function createMenu() {\\n    var _this = this;\\n\\n    var tracks = this.player_.textTracks() || [];\\n    var chaptersTrack = undefined;\\n    var items = this.items || [];\\n\\n    for (var i = tracks.length - 1; i >= 0; i--) {\\n\\n      // We will always choose the last track as our chaptersTrack\\n      var track = tracks[i];\\n\\n      if (track['kind'] === this.kind_) {\\n        chaptersTrack = track;\\n\\n        break;\\n      }\\n    }\\n\\n    var menu = this.menu;\\n    if (menu === undefined) {\\n      menu = new _menuMenuJs2['default'](this.player_);\\n      var title = Dom.createEl('li', {\\n        className: 'vjs-menu-title',\\n        innerHTML: _utilsToTitleCaseJs2['default'](this.kind_),\\n        tabIndex: -1\\n      });\\n      menu.children_.unshift(title);\\n      Dom.insertElFirst(title, menu.contentEl());\\n    } else {\\n      // We will empty out the menu children each time because we want a\\n      // fresh new menu child list each time\\n      items.forEach(function (item) {\\n        return menu.removeChild(item);\\n      });\\n      // Empty out the ChaptersButton menu items because we no longer need them\\n      items = [];\\n    }\\n\\n    if (chaptersTrack && chaptersTrack.cues == null) {\\n      chaptersTrack['mode'] = 'hidden';\\n\\n      var remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(chaptersTrack);\\n\\n      if (remoteTextTrackEl) {\\n        remoteTextTrackEl.addEventListener('load', function (event) {\\n          return _this.update();\\n        });\\n      }\\n    }\\n\\n    if (chaptersTrack && chaptersTrack.cues && chaptersTrack.cues.length > 0) {\\n      var cues = chaptersTrack['cues'],\\n          cue = undefined;\\n\\n      for (var i = 0, l = cues.length; i < l; i++) {\\n        cue = cues[i];\\n\\n        var mi = new _chaptersTrackMenuItemJs2['default'](this.player_, {\\n          'track': chaptersTrack,\\n          'cue': cue\\n        });\\n\\n        items.push(mi);\\n\\n        menu.addChild(mi);\\n      }\\n    }\\n\\n    if (items.length > 0) {\\n      this.show();\\n    }\\n    // Assigning the value of items back to this.items for next iteration\\n    this.items = items;\\n    return menu;\\n  };\\n\\n  return ChaptersButton;\\n})(_textTrackButtonJs2['default']);\\n\\nChaptersButton.prototype.kind_ = 'chapters';\\nChaptersButton.prototype.controlText_ = 'Chapters';\\n\\n_componentJs2['default'].registerComponent('ChaptersButton', ChaptersButton);\\nexports['default'] = ChaptersButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../menu/menu.js\\\":111,\\\"../../utils/dom.js\\\":142,\\\"../../utils/fn.js\\\":144,\\\"../../utils/to-title-case.js\\\":151,\\\"./chapters-track-menu-item.js\\\":88,\\\"./text-track-button.js\\\":92,\\\"./text-track-menu-item.js\\\":93,\\\"global/window\\\":2}],88:[function(_dereq_,module,exports){\\n/**\\n * @file chapters-track-menu-item.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _menuMenuItemJs = _dereq_('../../menu/menu-item.js');\\n\\nvar _menuMenuItemJs2 = _interopRequireDefault(_menuMenuItemJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\n/**\\n * The chapter track menu item\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends MenuItem\\n * @class ChaptersTrackMenuItem\\n */\\n\\nvar ChaptersTrackMenuItem = (function (_MenuItem) {\\n  _inherits(ChaptersTrackMenuItem, _MenuItem);\\n\\n  function ChaptersTrackMenuItem(player, options) {\\n    _classCallCheck(this, ChaptersTrackMenuItem);\\n\\n    var track = options['track'];\\n    var cue = options['cue'];\\n    var currentTime = player.currentTime();\\n\\n    // Modify options for parent MenuItem class's init.\\n    options['label'] = cue.text;\\n    options['selected'] = cue['startTime'] <= currentTime && currentTime < cue['endTime'];\\n    _MenuItem.call(this, player, options);\\n\\n    this.track = track;\\n    this.cue = cue;\\n    track.addEventListener('cuechange', Fn.bind(this, this.update));\\n  }\\n\\n  /**\\n   * Handle click on menu item\\n   *\\n   * @method handleClick\\n   */\\n\\n  ChaptersTrackMenuItem.prototype.handleClick = function handleClick() {\\n    _MenuItem.prototype.handleClick.call(this);\\n    this.player_.currentTime(this.cue.startTime);\\n    this.update(this.cue.startTime);\\n  };\\n\\n  /**\\n   * Update chapter menu item\\n   *\\n   * @method update\\n   */\\n\\n  ChaptersTrackMenuItem.prototype.update = function update() {\\n    var cue = this.cue;\\n    var currentTime = this.player_.currentTime();\\n\\n    // vjs.log(currentTime, cue.startTime);\\n    this.selected(cue['startTime'] <= currentTime && currentTime < cue['endTime']);\\n  };\\n\\n  return ChaptersTrackMenuItem;\\n})(_menuMenuItemJs2['default']);\\n\\n_componentJs2['default'].registerComponent('ChaptersTrackMenuItem', ChaptersTrackMenuItem);\\nexports['default'] = ChaptersTrackMenuItem;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../menu/menu-item.js\\\":110,\\\"../../utils/fn.js\\\":144}],89:[function(_dereq_,module,exports){\\n/**\\n * @file descriptions-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _textTrackButtonJs = _dereq_('./text-track-button.js');\\n\\nvar _textTrackButtonJs2 = _interopRequireDefault(_textTrackButtonJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\n/**\\n * The button component for toggling and selecting descriptions\\n *\\n * @param {Object} player  Player object\\n * @param {Object=} options Object of option names and values\\n * @param {Function=} ready    Ready callback function\\n * @extends TextTrackButton\\n * @class DescriptionsButton\\n */\\n\\nvar DescriptionsButton = (function (_TextTrackButton) {\\n  _inherits(DescriptionsButton, _TextTrackButton);\\n\\n  function DescriptionsButton(player, options, ready) {\\n    var _this = this;\\n\\n    _classCallCheck(this, DescriptionsButton);\\n\\n    _TextTrackButton.call(this, player, options, ready);\\n    this.el_.setAttribute('aria-label', 'Descriptions Menu');\\n\\n    var tracks = player.textTracks();\\n\\n    if (tracks) {\\n      (function () {\\n        var changeHandler = Fn.bind(_this, _this.handleTracksChange);\\n\\n        tracks.addEventListener('change', changeHandler);\\n        _this.on('dispose', function () {\\n          tracks.removeEventListener('change', changeHandler);\\n        });\\n      })();\\n    }\\n  }\\n\\n  /**\\n   * Handle text track change\\n   *\\n   * @method handleTracksChange\\n   */\\n\\n  DescriptionsButton.prototype.handleTracksChange = function handleTracksChange(event) {\\n    var tracks = this.player().textTracks();\\n    var disabled = false;\\n\\n    // Check whether a track of a different kind is showing\\n    for (var i = 0, l = tracks.length; i < l; i++) {\\n      var track = tracks[i];\\n      if (track['kind'] !== this.kind_ && track['mode'] === 'showing') {\\n        disabled = true;\\n        break;\\n      }\\n    }\\n\\n    // If another track is showing, disable this menu button\\n    if (disabled) {\\n      this.disable();\\n    } else {\\n      this.enable();\\n    }\\n  };\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  DescriptionsButton.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-descriptions-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\\n  };\\n\\n  return DescriptionsButton;\\n})(_textTrackButtonJs2['default']);\\n\\nDescriptionsButton.prototype.kind_ = 'descriptions';\\nDescriptionsButton.prototype.controlText_ = 'Descriptions';\\n\\n_componentJs2['default'].registerComponent('DescriptionsButton', DescriptionsButton);\\nexports['default'] = DescriptionsButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../utils/fn.js\\\":144,\\\"./text-track-button.js\\\":92}],90:[function(_dereq_,module,exports){\\n/**\\n * @file off-text-track-menu-item.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _textTrackMenuItemJs = _dereq_('./text-track-menu-item.js');\\n\\nvar _textTrackMenuItemJs2 = _interopRequireDefault(_textTrackMenuItemJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n/**\\n * A special menu item for turning of a specific type of text track\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends TextTrackMenuItem\\n * @class OffTextTrackMenuItem\\n */\\n\\nvar OffTextTrackMenuItem = (function (_TextTrackMenuItem) {\\n  _inherits(OffTextTrackMenuItem, _TextTrackMenuItem);\\n\\n  function OffTextTrackMenuItem(player, options) {\\n    _classCallCheck(this, OffTextTrackMenuItem);\\n\\n    // Create pseudo track info\\n    // Requires options['kind']\\n    options['track'] = {\\n      'kind': options['kind'],\\n      'player': player,\\n      'label': options['kind'] + ' off',\\n      'default': false,\\n      'mode': 'disabled'\\n    };\\n\\n    // MenuItem is selectable\\n    options['selectable'] = true;\\n\\n    _TextTrackMenuItem.call(this, player, options);\\n    this.selected(true);\\n  }\\n\\n  /**\\n   * Handle text track change\\n   *\\n   * @param {Object} event Event object\\n   * @method handleTracksChange\\n   */\\n\\n  OffTextTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {\\n    var tracks = this.player().textTracks();\\n    var selected = true;\\n\\n    for (var i = 0, l = tracks.length; i < l; i++) {\\n      var track = tracks[i];\\n      if (track['kind'] === this.track['kind'] && track['mode'] === 'showing') {\\n        selected = false;\\n        break;\\n      }\\n    }\\n\\n    this.selected(selected);\\n  };\\n\\n  return OffTextTrackMenuItem;\\n})(_textTrackMenuItemJs2['default']);\\n\\n_componentJs2['default'].registerComponent('OffTextTrackMenuItem', OffTextTrackMenuItem);\\nexports['default'] = OffTextTrackMenuItem;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"./text-track-menu-item.js\\\":93}],91:[function(_dereq_,module,exports){\\n/**\\n * @file subtitles-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _textTrackButtonJs = _dereq_('./text-track-button.js');\\n\\nvar _textTrackButtonJs2 = _interopRequireDefault(_textTrackButtonJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n/**\\n * The button component for toggling and selecting subtitles\\n *\\n * @param {Object} player  Player object\\n * @param {Object=} options Object of option names and values\\n * @param {Function=} ready    Ready callback function\\n * @extends TextTrackButton\\n * @class SubtitlesButton\\n */\\n\\nvar SubtitlesButton = (function (_TextTrackButton) {\\n  _inherits(SubtitlesButton, _TextTrackButton);\\n\\n  function SubtitlesButton(player, options, ready) {\\n    _classCallCheck(this, SubtitlesButton);\\n\\n    _TextTrackButton.call(this, player, options, ready);\\n    this.el_.setAttribute('aria-label', 'Subtitles Menu');\\n  }\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  SubtitlesButton.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-subtitles-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\\n  };\\n\\n  return SubtitlesButton;\\n})(_textTrackButtonJs2['default']);\\n\\nSubtitlesButton.prototype.kind_ = 'subtitles';\\nSubtitlesButton.prototype.controlText_ = 'Subtitles';\\n\\n_componentJs2['default'].registerComponent('SubtitlesButton', SubtitlesButton);\\nexports['default'] = SubtitlesButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"./text-track-button.js\\\":92}],92:[function(_dereq_,module,exports){\\n/**\\n * @file text-track-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _trackButtonJs = _dereq_('../track-button.js');\\n\\nvar _trackButtonJs2 = _interopRequireDefault(_trackButtonJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _textTrackMenuItemJs = _dereq_('./text-track-menu-item.js');\\n\\nvar _textTrackMenuItemJs2 = _interopRequireDefault(_textTrackMenuItemJs);\\n\\nvar _offTextTrackMenuItemJs = _dereq_('./off-text-track-menu-item.js');\\n\\nvar _offTextTrackMenuItemJs2 = _interopRequireDefault(_offTextTrackMenuItemJs);\\n\\n/**\\n * The base class for buttons that toggle specific text track types (e.g. subtitles)\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends MenuButton\\n * @class TextTrackButton\\n */\\n\\nvar TextTrackButton = (function (_TrackButton) {\\n  _inherits(TextTrackButton, _TrackButton);\\n\\n  function TextTrackButton(player) {\\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n\\n    _classCallCheck(this, TextTrackButton);\\n\\n    options.tracks = player.textTracks();\\n\\n    _TrackButton.call(this, player, options);\\n  }\\n\\n  /**\\n   * Create a menu item for each text track\\n   *\\n   * @return {Array} Array of menu items\\n   * @method createItems\\n   */\\n\\n  TextTrackButton.prototype.createItems = function createItems() {\\n    var items = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\\n\\n    // Add an OFF menu item to turn all tracks off\\n    items.push(new _offTextTrackMenuItemJs2['default'](this.player_, { 'kind': this.kind_ }));\\n\\n    var tracks = this.player_.textTracks();\\n\\n    if (!tracks) {\\n      return items;\\n    }\\n\\n    for (var i = 0; i < tracks.length; i++) {\\n      var track = tracks[i];\\n\\n      // only add tracks that are of the appropriate kind and have a label\\n      if (track['kind'] === this.kind_) {\\n        items.push(new _textTrackMenuItemJs2['default'](this.player_, {\\n          // MenuItem is selectable\\n          'selectable': true,\\n          'track': track\\n        }));\\n      }\\n    }\\n\\n    return items;\\n  };\\n\\n  return TextTrackButton;\\n})(_trackButtonJs2['default']);\\n\\n_componentJs2['default'].registerComponent('TextTrackButton', TextTrackButton);\\nexports['default'] = TextTrackButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../utils/fn.js\\\":144,\\\"../track-button.js\\\":98,\\\"./off-text-track-menu-item.js\\\":90,\\\"./text-track-menu-item.js\\\":93}],93:[function(_dereq_,module,exports){\\n/**\\n * @file text-track-menu-item.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _menuMenuItemJs = _dereq_('../../menu/menu-item.js');\\n\\nvar _menuMenuItemJs2 = _interopRequireDefault(_menuMenuItemJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\n/**\\n * The specific menu item type for selecting a language within a text track kind\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends MenuItem\\n * @class TextTrackMenuItem\\n */\\n\\nvar TextTrackMenuItem = (function (_MenuItem) {\\n  _inherits(TextTrackMenuItem, _MenuItem);\\n\\n  function TextTrackMenuItem(player, options) {\\n    var _this = this;\\n\\n    _classCallCheck(this, TextTrackMenuItem);\\n\\n    var track = options['track'];\\n    var tracks = player.textTracks();\\n\\n    // Modify options for parent MenuItem class's init.\\n    options['label'] = track['label'] || track['language'] || 'Unknown';\\n    options['selected'] = track['default'] || track['mode'] === 'showing';\\n\\n    _MenuItem.call(this, player, options);\\n\\n    this.track = track;\\n\\n    if (tracks) {\\n      (function () {\\n        var changeHandler = Fn.bind(_this, _this.handleTracksChange);\\n\\n        tracks.addEventListener('change', changeHandler);\\n        _this.on('dispose', function () {\\n          tracks.removeEventListener('change', changeHandler);\\n        });\\n      })();\\n    }\\n\\n    // iOS7 doesn't dispatch change events to TextTrackLists when an\\n    // associated track's mode changes. Without something like\\n    // Object.observe() (also not present on iOS7), it's not\\n    // possible to detect changes to the mode attribute and polyfill\\n    // the change event. As a poor substitute, we manually dispatch\\n    // change events whenever the controls modify the mode.\\n    if (tracks && tracks.onchange === undefined) {\\n      (function () {\\n        var event = undefined;\\n\\n        _this.on(['tap', 'click'], function () {\\n          if (typeof _globalWindow2['default'].Event !== 'object') {\\n            // Android 2.3 throws an Illegal Constructor error for window.Event\\n            try {\\n              event = new _globalWindow2['default'].Event('change');\\n            } catch (err) {}\\n          }\\n\\n          if (!event) {\\n            event = _globalDocument2['default'].createEvent('Event');\\n            event.initEvent('change', true, true);\\n          }\\n\\n          tracks.dispatchEvent(event);\\n        });\\n      })();\\n    }\\n  }\\n\\n  /**\\n   * Handle click on text track\\n   *\\n   * @method handleClick\\n   */\\n\\n  TextTrackMenuItem.prototype.handleClick = function handleClick(event) {\\n    var kind = this.track['kind'];\\n    var tracks = this.player_.textTracks();\\n\\n    _MenuItem.prototype.handleClick.call(this, event);\\n\\n    if (!tracks) return;\\n\\n    for (var i = 0; i < tracks.length; i++) {\\n      var track = tracks[i];\\n\\n      if (track['kind'] !== kind) {\\n        continue;\\n      }\\n\\n      if (track === this.track) {\\n        track['mode'] = 'showing';\\n      } else {\\n        track['mode'] = 'disabled';\\n      }\\n    }\\n  };\\n\\n  /**\\n   * Handle text track change\\n   *\\n   * @method handleTracksChange\\n   */\\n\\n  TextTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {\\n    this.selected(this.track['mode'] === 'showing');\\n  };\\n\\n  return TextTrackMenuItem;\\n})(_menuMenuItemJs2['default']);\\n\\n_componentJs2['default'].registerComponent('TextTrackMenuItem', TextTrackMenuItem);\\nexports['default'] = TextTrackMenuItem;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../menu/menu-item.js\\\":110,\\\"../../utils/fn.js\\\":144,\\\"global/document\\\":1,\\\"global/window\\\":2}],94:[function(_dereq_,module,exports){\\n/**\\n * @file current-time-display.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsDomJs = _dereq_('../../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFormatTimeJs = _dereq_('../../utils/format-time.js');\\n\\nvar _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);\\n\\n/**\\n * Displays the current time\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class CurrentTimeDisplay\\n */\\n\\nvar CurrentTimeDisplay = (function (_Component) {\\n  _inherits(CurrentTimeDisplay, _Component);\\n\\n  function CurrentTimeDisplay(player, options) {\\n    _classCallCheck(this, CurrentTimeDisplay);\\n\\n    _Component.call(this, player, options);\\n\\n    this.on(player, 'timeupdate', this.updateContent);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  CurrentTimeDisplay.prototype.createEl = function createEl() {\\n    var el = _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-current-time vjs-time-control vjs-control'\\n    });\\n\\n    this.contentEl_ = Dom.createEl('div', {\\n      className: 'vjs-current-time-display',\\n      // label the current time for screen reader users\\n      innerHTML: '<span class=\\\"vjs-control-text\\\">Current Time </span>' + '0:00'\\n    }, {\\n      // tell screen readers not to automatically read the time as it changes\\n      'aria-live': 'off'\\n    });\\n\\n    el.appendChild(this.contentEl_);\\n    return el;\\n  };\\n\\n  /**\\n   * Update current time display\\n   *\\n   * @method updateContent\\n   */\\n\\n  CurrentTimeDisplay.prototype.updateContent = function updateContent() {\\n    // Allows for smooth scrubbing, when player can't keep up.\\n    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\\n    var localizedText = this.localize('Current Time');\\n    var formattedTime = _utilsFormatTimeJs2['default'](time, this.player_.duration());\\n    if (formattedTime !== this.formattedTime_) {\\n      this.formattedTime_ = formattedTime;\\n      this.contentEl_.innerHTML = '<span class=\\\"vjs-control-text\\\">' + localizedText + '</span> ' + formattedTime;\\n    }\\n  };\\n\\n  return CurrentTimeDisplay;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('CurrentTimeDisplay', CurrentTimeDisplay);\\nexports['default'] = CurrentTimeDisplay;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../utils/dom.js\\\":142,\\\"../../utils/format-time.js\\\":145}],95:[function(_dereq_,module,exports){\\n/**\\n * @file duration-display.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsDomJs = _dereq_('../../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFormatTimeJs = _dereq_('../../utils/format-time.js');\\n\\nvar _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);\\n\\n/**\\n * Displays the duration\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class DurationDisplay\\n */\\n\\nvar DurationDisplay = (function (_Component) {\\n  _inherits(DurationDisplay, _Component);\\n\\n  function DurationDisplay(player, options) {\\n    _classCallCheck(this, DurationDisplay);\\n\\n    _Component.call(this, player, options);\\n\\n    this.on(player, 'durationchange', this.updateContent);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  DurationDisplay.prototype.createEl = function createEl() {\\n    var el = _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-duration vjs-time-control vjs-control'\\n    });\\n\\n    this.contentEl_ = Dom.createEl('div', {\\n      className: 'vjs-duration-display',\\n      // label the duration time for screen reader users\\n      innerHTML: '<span class=\\\"vjs-control-text\\\">' + this.localize('Duration Time') + '</span> 0:00'\\n    }, {\\n      // tell screen readers not to automatically read the time as it changes\\n      'aria-live': 'off'\\n    });\\n\\n    el.appendChild(this.contentEl_);\\n    return el;\\n  };\\n\\n  /**\\n   * Update duration time display\\n   *\\n   * @method updateContent\\n   */\\n\\n  DurationDisplay.prototype.updateContent = function updateContent() {\\n    var duration = this.player_.duration();\\n    if (duration && this.duration_ !== duration) {\\n      this.duration_ = duration;\\n      var localizedText = this.localize('Duration Time');\\n      var formattedTime = _utilsFormatTimeJs2['default'](duration);\\n      this.contentEl_.innerHTML = '<span class=\\\"vjs-control-text\\\">' + localizedText + '</span> ' + formattedTime; // label the duration time for screen reader users\\n    }\\n  };\\n\\n  return DurationDisplay;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('DurationDisplay', DurationDisplay);\\nexports['default'] = DurationDisplay;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../utils/dom.js\\\":142,\\\"../../utils/format-time.js\\\":145}],96:[function(_dereq_,module,exports){\\n/**\\n * @file remaining-time-display.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsDomJs = _dereq_('../../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFormatTimeJs = _dereq_('../../utils/format-time.js');\\n\\nvar _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);\\n\\n/**\\n * Displays the time left in the video\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class RemainingTimeDisplay\\n */\\n\\nvar RemainingTimeDisplay = (function (_Component) {\\n  _inherits(RemainingTimeDisplay, _Component);\\n\\n  function RemainingTimeDisplay(player, options) {\\n    _classCallCheck(this, RemainingTimeDisplay);\\n\\n    _Component.call(this, player, options);\\n\\n    this.on(player, 'timeupdate', this.updateContent);\\n    this.on(player, 'durationchange', this.updateContent);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  RemainingTimeDisplay.prototype.createEl = function createEl() {\\n    var el = _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-remaining-time vjs-time-control vjs-control'\\n    });\\n\\n    this.contentEl_ = Dom.createEl('div', {\\n      className: 'vjs-remaining-time-display',\\n      // label the remaining time for screen reader users\\n      innerHTML: '<span class=\\\"vjs-control-text\\\">' + this.localize('Remaining Time') + '</span> -0:00'\\n    }, {\\n      // tell screen readers not to automatically read the time as it changes\\n      'aria-live': 'off'\\n    });\\n\\n    el.appendChild(this.contentEl_);\\n    return el;\\n  };\\n\\n  /**\\n   * Update remaining time display\\n   *\\n   * @method updateContent\\n   */\\n\\n  RemainingTimeDisplay.prototype.updateContent = function updateContent() {\\n    if (this.player_.duration()) {\\n      var localizedText = this.localize('Remaining Time');\\n      var formattedTime = _utilsFormatTimeJs2['default'](this.player_.remainingTime());\\n      if (formattedTime !== this.formattedTime_) {\\n        this.formattedTime_ = formattedTime;\\n        this.contentEl_.innerHTML = '<span class=\\\"vjs-control-text\\\">' + localizedText + '</span> -' + formattedTime;\\n      }\\n    }\\n\\n    // Allows for smooth scrubbing, when player can't keep up.\\n    // var time = (this.player_.scrubbing()) ? this.player_.getCache().currentTime : this.player_.currentTime();\\n    // this.contentEl_.innerHTML = vjs.formatTime(time, this.player_.duration());\\n  };\\n\\n  return RemainingTimeDisplay;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('RemainingTimeDisplay', RemainingTimeDisplay);\\nexports['default'] = RemainingTimeDisplay;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../utils/dom.js\\\":142,\\\"../../utils/format-time.js\\\":145}],97:[function(_dereq_,module,exports){\\n/**\\n * @file time-divider.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n/**\\n * The separator between the current time and duration.\\n * Can be hidden if it's not needed in the design.\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class TimeDivider\\n */\\n\\nvar TimeDivider = (function (_Component) {\\n  _inherits(TimeDivider, _Component);\\n\\n  function TimeDivider() {\\n    _classCallCheck(this, TimeDivider);\\n\\n    _Component.apply(this, arguments);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  TimeDivider.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-time-control vjs-time-divider',\\n      innerHTML: '<div><span>/</span></div>'\\n    });\\n  };\\n\\n  return TimeDivider;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('TimeDivider', TimeDivider);\\nexports['default'] = TimeDivider;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67}],98:[function(_dereq_,module,exports){\\n/**\\n * @file track-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _menuMenuButtonJs = _dereq_('../menu/menu-button.js');\\n\\nvar _menuMenuButtonJs2 = _interopRequireDefault(_menuMenuButtonJs);\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\n/**\\n * The base class for buttons that toggle specific text track types (e.g. subtitles)\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends MenuButton\\n * @class TrackButton\\n */\\n\\nvar TrackButton = (function (_MenuButton) {\\n  _inherits(TrackButton, _MenuButton);\\n\\n  function TrackButton(player, options) {\\n    _classCallCheck(this, TrackButton);\\n\\n    var tracks = options.tracks;\\n\\n    _MenuButton.call(this, player, options);\\n\\n    if (this.items.length <= 1) {\\n      this.hide();\\n    }\\n\\n    if (!tracks) {\\n      return;\\n    }\\n\\n    var updateHandler = Fn.bind(this, this.update);\\n    tracks.addEventListener('removetrack', updateHandler);\\n    tracks.addEventListener('addtrack', updateHandler);\\n\\n    this.player_.on('dispose', function () {\\n      tracks.removeEventListener('removetrack', updateHandler);\\n      tracks.removeEventListener('addtrack', updateHandler);\\n    });\\n  }\\n\\n  return TrackButton;\\n})(_menuMenuButtonJs2['default']);\\n\\n_componentJs2['default'].registerComponent('TrackButton', TrackButton);\\nexports['default'] = TrackButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component.js\\\":67,\\\"../menu/menu-button.js\\\":109,\\\"../utils/fn.js\\\":144}],99:[function(_dereq_,module,exports){\\n/**\\n * @file volume-bar.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _sliderSliderJs = _dereq_('../../slider/slider.js');\\n\\nvar _sliderSliderJs2 = _interopRequireDefault(_sliderSliderJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\n// Required children\\n\\nvar _volumeLevelJs = _dereq_('./volume-level.js');\\n\\nvar _volumeLevelJs2 = _interopRequireDefault(_volumeLevelJs);\\n\\n/**\\n * The bar that contains the volume level and can be clicked on to adjust the level\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Slider\\n * @class VolumeBar\\n */\\n\\nvar VolumeBar = (function (_Slider) {\\n  _inherits(VolumeBar, _Slider);\\n\\n  function VolumeBar(player, options) {\\n    _classCallCheck(this, VolumeBar);\\n\\n    _Slider.call(this, player, options);\\n    this.on(player, 'volumechange', this.updateARIAAttributes);\\n    player.ready(Fn.bind(this, this.updateARIAAttributes));\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  VolumeBar.prototype.createEl = function createEl() {\\n    return _Slider.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-volume-bar vjs-slider-bar'\\n    }, {\\n      'aria-label': 'volume level'\\n    });\\n  };\\n\\n  /**\\n   * Handle mouse move on volume bar\\n   *\\n   * @method handleMouseMove\\n   */\\n\\n  VolumeBar.prototype.handleMouseMove = function handleMouseMove(event) {\\n    this.checkMuted();\\n    this.player_.volume(this.calculateDistance(event));\\n  };\\n\\n  VolumeBar.prototype.checkMuted = function checkMuted() {\\n    if (this.player_.muted()) {\\n      this.player_.muted(false);\\n    }\\n  };\\n\\n  /**\\n   * Get percent of volume level\\n   *\\n   * @retun {Number} Volume level percent\\n   * @method getPercent\\n   */\\n\\n  VolumeBar.prototype.getPercent = function getPercent() {\\n    if (this.player_.muted()) {\\n      return 0;\\n    } else {\\n      return this.player_.volume();\\n    }\\n  };\\n\\n  /**\\n   * Increase volume level for keyboard users\\n   *\\n   * @method stepForward\\n   */\\n\\n  VolumeBar.prototype.stepForward = function stepForward() {\\n    this.checkMuted();\\n    this.player_.volume(this.player_.volume() + 0.1);\\n  };\\n\\n  /**\\n   * Decrease volume level for keyboard users\\n   *\\n   * @method stepBack\\n   */\\n\\n  VolumeBar.prototype.stepBack = function stepBack() {\\n    this.checkMuted();\\n    this.player_.volume(this.player_.volume() - 0.1);\\n  };\\n\\n  /**\\n   * Update ARIA accessibility attributes\\n   *\\n   * @method updateARIAAttributes\\n   */\\n\\n  VolumeBar.prototype.updateARIAAttributes = function updateARIAAttributes() {\\n    // Current value of volume bar as a percentage\\n    var volume = (this.player_.volume() * 100).toFixed(2);\\n    this.el_.setAttribute('aria-valuenow', volume);\\n    this.el_.setAttribute('aria-valuetext', volume + '%');\\n  };\\n\\n  return VolumeBar;\\n})(_sliderSliderJs2['default']);\\n\\nVolumeBar.prototype.options_ = {\\n  children: ['volumeLevel'],\\n  'barName': 'volumeLevel'\\n};\\n\\nVolumeBar.prototype.playerEvent = 'volumechange';\\n\\n_componentJs2['default'].registerComponent('VolumeBar', VolumeBar);\\nexports['default'] = VolumeBar;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../slider/slider.js\\\":119,\\\"../../utils/fn.js\\\":144,\\\"./volume-level.js\\\":101}],100:[function(_dereq_,module,exports){\\n/**\\n * @file volume-control.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n// Required children\\n\\nvar _volumeBarJs = _dereq_('./volume-bar.js');\\n\\nvar _volumeBarJs2 = _interopRequireDefault(_volumeBarJs);\\n\\n/**\\n * The component for controlling the volume level\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class VolumeControl\\n */\\n\\nvar VolumeControl = (function (_Component) {\\n  _inherits(VolumeControl, _Component);\\n\\n  function VolumeControl(player, options) {\\n    _classCallCheck(this, VolumeControl);\\n\\n    _Component.call(this, player, options);\\n\\n    // hide volume controls when they're not supported by the current tech\\n    if (player.tech_ && player.tech_['featuresVolumeControl'] === false) {\\n      this.addClass('vjs-hidden');\\n    }\\n    this.on(player, 'loadstart', function () {\\n      if (player.tech_['featuresVolumeControl'] === false) {\\n        this.addClass('vjs-hidden');\\n      } else {\\n        this.removeClass('vjs-hidden');\\n      }\\n    });\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  VolumeControl.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-volume-control vjs-control'\\n    });\\n  };\\n\\n  return VolumeControl;\\n})(_componentJs2['default']);\\n\\nVolumeControl.prototype.options_ = {\\n  children: ['volumeBar']\\n};\\n\\n_componentJs2['default'].registerComponent('VolumeControl', VolumeControl);\\nexports['default'] = VolumeControl;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"./volume-bar.js\\\":99}],101:[function(_dereq_,module,exports){\\n/**\\n * @file volume-level.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n/**\\n * Shows volume level\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class VolumeLevel\\n */\\n\\nvar VolumeLevel = (function (_Component) {\\n  _inherits(VolumeLevel, _Component);\\n\\n  function VolumeLevel() {\\n    _classCallCheck(this, VolumeLevel);\\n\\n    _Component.apply(this, arguments);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  VolumeLevel.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-volume-level',\\n      innerHTML: '<span class=\\\"vjs-control-text\\\"></span>'\\n    });\\n  };\\n\\n  return VolumeLevel;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('VolumeLevel', VolumeLevel);\\nexports['default'] = VolumeLevel;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67}],102:[function(_dereq_,module,exports){\\n/**\\n * @file volume-menu-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _popupPopupJs = _dereq_('../popup/popup.js');\\n\\nvar _popupPopupJs2 = _interopRequireDefault(_popupPopupJs);\\n\\nvar _popupPopupButtonJs = _dereq_('../popup/popup-button.js');\\n\\nvar _popupPopupButtonJs2 = _interopRequireDefault(_popupPopupButtonJs);\\n\\nvar _muteToggleJs = _dereq_('./mute-toggle.js');\\n\\nvar _muteToggleJs2 = _interopRequireDefault(_muteToggleJs);\\n\\nvar _volumeControlVolumeBarJs = _dereq_('./volume-control/volume-bar.js');\\n\\nvar _volumeControlVolumeBarJs2 = _interopRequireDefault(_volumeControlVolumeBarJs);\\n\\n/**\\n * Button for volume popup\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends PopupButton\\n * @class VolumeMenuButton\\n */\\n\\nvar VolumeMenuButton = (function (_PopupButton) {\\n  _inherits(VolumeMenuButton, _PopupButton);\\n\\n  function VolumeMenuButton(player) {\\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n\\n    _classCallCheck(this, VolumeMenuButton);\\n\\n    // Default to inline\\n    if (options.inline === undefined) {\\n      options.inline = true;\\n    }\\n\\n    // If the vertical option isn't passed at all, default to true.\\n    if (options.vertical === undefined) {\\n      // If an inline volumeMenuButton is used, we should default to using\\n      // a horizontal slider for obvious reasons.\\n      if (options.inline) {\\n        options.vertical = false;\\n      } else {\\n        options.vertical = true;\\n      }\\n    }\\n\\n    // The vertical option needs to be set on the volumeBar as well,\\n    // since that will need to be passed along to the VolumeBar constructor\\n    options.volumeBar = options.volumeBar || {};\\n    options.volumeBar.vertical = !!options.vertical;\\n\\n    _PopupButton.call(this, player, options);\\n\\n    // Same listeners as MuteToggle\\n    this.on(player, 'volumechange', this.volumeUpdate);\\n    this.on(player, 'loadstart', this.volumeUpdate);\\n\\n    // hide mute toggle if the current tech doesn't support volume control\\n    function updateVisibility() {\\n      if (player.tech_ && player.tech_['featuresVolumeControl'] === false) {\\n        this.addClass('vjs-hidden');\\n      } else {\\n        this.removeClass('vjs-hidden');\\n      }\\n    }\\n\\n    updateVisibility.call(this);\\n    this.on(player, 'loadstart', updateVisibility);\\n\\n    this.on(this.volumeBar, ['slideractive', 'focus'], function () {\\n      this.addClass('vjs-slider-active');\\n    });\\n\\n    this.on(this.volumeBar, ['sliderinactive', 'blur'], function () {\\n      this.removeClass('vjs-slider-active');\\n    });\\n\\n    this.on(this.volumeBar, ['focus'], function () {\\n      this.addClass('vjs-lock-showing');\\n    });\\n\\n    this.on(this.volumeBar, ['blur'], function () {\\n      this.removeClass('vjs-lock-showing');\\n    });\\n  }\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  VolumeMenuButton.prototype.buildCSSClass = function buildCSSClass() {\\n    var orientationClass = '';\\n    if (!!this.options_.vertical) {\\n      orientationClass = 'vjs-volume-menu-button-vertical';\\n    } else {\\n      orientationClass = 'vjs-volume-menu-button-horizontal';\\n    }\\n\\n    return 'vjs-volume-menu-button ' + _PopupButton.prototype.buildCSSClass.call(this) + ' ' + orientationClass;\\n  };\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {Popup} The volume popup button\\n   * @method createPopup\\n   */\\n\\n  VolumeMenuButton.prototype.createPopup = function createPopup() {\\n    var popup = new _popupPopupJs2['default'](this.player_, {\\n      contentElType: 'div'\\n    });\\n\\n    var vb = new _volumeControlVolumeBarJs2['default'](this.player_, this.options_.volumeBar);\\n\\n    popup.addChild(vb);\\n\\n    this.menuContent = popup;\\n    this.volumeBar = vb;\\n\\n    this.attachVolumeBarEvents();\\n\\n    return popup;\\n  };\\n\\n  /**\\n   * Handle click on volume popup and calls super\\n   *\\n   * @method handleClick\\n   */\\n\\n  VolumeMenuButton.prototype.handleClick = function handleClick() {\\n    _muteToggleJs2['default'].prototype.handleClick.call(this);\\n    _PopupButton.prototype.handleClick.call(this);\\n  };\\n\\n  VolumeMenuButton.prototype.attachVolumeBarEvents = function attachVolumeBarEvents() {\\n    this.menuContent.on(['mousedown', 'touchdown'], Fn.bind(this, this.handleMouseDown));\\n  };\\n\\n  VolumeMenuButton.prototype.handleMouseDown = function handleMouseDown(event) {\\n    this.on(['mousemove', 'touchmove'], Fn.bind(this.volumeBar, this.volumeBar.handleMouseMove));\\n    this.on(this.el_.ownerDocument, ['mouseup', 'touchend'], this.handleMouseUp);\\n  };\\n\\n  VolumeMenuButton.prototype.handleMouseUp = function handleMouseUp(event) {\\n    this.off(['mousemove', 'touchmove'], Fn.bind(this.volumeBar, this.volumeBar.handleMouseMove));\\n  };\\n\\n  return VolumeMenuButton;\\n})(_popupPopupButtonJs2['default']);\\n\\nVolumeMenuButton.prototype.volumeUpdate = _muteToggleJs2['default'].prototype.update;\\nVolumeMenuButton.prototype.controlText_ = 'Mute';\\n\\n_componentJs2['default'].registerComponent('VolumeMenuButton', VolumeMenuButton);\\nexports['default'] = VolumeMenuButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component.js\\\":67,\\\"../popup/popup-button.js\\\":115,\\\"../popup/popup.js\\\":116,\\\"../utils/fn.js\\\":144,\\\"./mute-toggle.js\\\":73,\\\"./volume-control/volume-bar.js\\\":99}],103:[function(_dereq_,module,exports){\\n/**\\n * @file error-display.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _component = _dereq_('./component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _modalDialog = _dereq_('./modal-dialog');\\n\\nvar _modalDialog2 = _interopRequireDefault(_modalDialog);\\n\\nvar _utilsDom = _dereq_('./utils/dom');\\n\\nvar Dom = _interopRequireWildcard(_utilsDom);\\n\\nvar _utilsMergeOptions = _dereq_('./utils/merge-options');\\n\\nvar _utilsMergeOptions2 = _interopRequireDefault(_utilsMergeOptions);\\n\\n/**\\n * Display that an error has occurred making the video unplayable.\\n *\\n * @extends ModalDialog\\n * @class ErrorDisplay\\n */\\n\\nvar ErrorDisplay = (function (_ModalDialog) {\\n  _inherits(ErrorDisplay, _ModalDialog);\\n\\n  /**\\n   * Constructor for error display modal.\\n   *\\n   * @param  {Player} player\\n   * @param  {Object} [options]\\n   */\\n\\n  function ErrorDisplay(player, options) {\\n    _classCallCheck(this, ErrorDisplay);\\n\\n    _ModalDialog.call(this, player, options);\\n    this.on(player, 'error', this.open);\\n  }\\n\\n  /**\\n   * Include the old class for backward-compatibility.\\n   *\\n   * This can be removed in 6.0.\\n   *\\n   * @method buildCSSClass\\n   * @deprecated\\n   * @return {String}\\n   */\\n\\n  ErrorDisplay.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-error-display ' + _ModalDialog.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Generates the modal content based on the player error.\\n   *\\n   * @return {String|Null}\\n   */\\n\\n  ErrorDisplay.prototype.content = function content() {\\n    var error = this.player().error();\\n    return error ? this.localize(error.message) : '';\\n  };\\n\\n  return ErrorDisplay;\\n})(_modalDialog2['default']);\\n\\nErrorDisplay.prototype.options_ = _utilsMergeOptions2['default'](_modalDialog2['default'].prototype.options_, {\\n  fillAlways: true,\\n  temporary: false,\\n  uncloseable: true\\n});\\n\\n_component2['default'].registerComponent('ErrorDisplay', ErrorDisplay);\\nexports['default'] = ErrorDisplay;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./component\\\":67,\\\"./modal-dialog\\\":112,\\\"./utils/dom\\\":142,\\\"./utils/merge-options\\\":148}],104:[function(_dereq_,module,exports){\\n/**\\n * @file event-target.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nvar _utilsEventsJs = _dereq_('./utils/events.js');\\n\\nvar Events = _interopRequireWildcard(_utilsEventsJs);\\n\\nvar EventTarget = function EventTarget() {};\\n\\nEventTarget.prototype.allowedEvents_ = {};\\n\\nEventTarget.prototype.on = function (type, fn) {\\n  // Remove the addEventListener alias before calling Events.on\\n  // so we don't get into an infinite type loop\\n  var ael = this.addEventListener;\\n  this.addEventListener = function () {};\\n  Events.on(this, type, fn);\\n  this.addEventListener = ael;\\n};\\nEventTarget.prototype.addEventListener = EventTarget.prototype.on;\\n\\nEventTarget.prototype.off = function (type, fn) {\\n  Events.off(this, type, fn);\\n};\\nEventTarget.prototype.removeEventListener = EventTarget.prototype.off;\\n\\nEventTarget.prototype.one = function (type, fn) {\\n  // Remove the addEventListener alias before calling Events.on\\n  // so we don't get into an infinite type loop\\n  var ael = this.addEventListener;\\n  this.addEventListener = function () {};\\n  Events.one(this, type, fn);\\n  this.addEventListener = ael;\\n};\\n\\nEventTarget.prototype.trigger = function (event) {\\n  var type = event.type || event;\\n\\n  if (typeof event === 'string') {\\n    event = {\\n      type: type\\n    };\\n  }\\n  event = Events.fixEvent(event);\\n\\n  if (this.allowedEvents_[type] && this['on' + type]) {\\n    this['on' + type](event);\\n  }\\n\\n  Events.trigger(this, event);\\n};\\n// The standard DOM EventTarget.dispatchEvent() is aliased to trigger()\\nEventTarget.prototype.dispatchEvent = EventTarget.prototype.trigger;\\n\\nexports['default'] = EventTarget;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./utils/events.js\\\":143}],105:[function(_dereq_,module,exports){\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _utilsLog = _dereq_('./utils/log');\\n\\nvar _utilsLog2 = _interopRequireDefault(_utilsLog);\\n\\n/*\\n * @file extend.js\\n *\\n * A combination of node inherits and babel's inherits (after transpile).\\n * Both work the same but node adds `super_` to the subClass\\n * and Bable adds the superClass as __proto__. Both seem useful.\\n */\\nvar _inherits = function _inherits(subClass, superClass) {\\n  if (typeof superClass !== 'function' && superClass !== null) {\\n    throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);\\n  }\\n\\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\\n    constructor: {\\n      value: subClass,\\n      enumerable: false,\\n      writable: true,\\n      configurable: true\\n    }\\n  });\\n\\n  if (superClass) {\\n    // node\\n    subClass.super_ = superClass;\\n  }\\n};\\n\\n/*\\n * Function for subclassing using the same inheritance that\\n * videojs uses internally\\n * ```js\\n * var Button = videojs.getComponent('Button');\\n * ```\\n * ```js\\n * var MyButton = videojs.extend(Button, {\\n *   constructor: function(player, options) {\\n *     Button.call(this, player, options);\\n *   },\\n *   onClick: function() {\\n *     // doSomething\\n *   }\\n * });\\n * ```\\n */\\nvar extendFn = function extendFn(superClass) {\\n  var subClassMethods = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n\\n  var subClass = function subClass() {\\n    superClass.apply(this, arguments);\\n  };\\n  var methods = {};\\n\\n  if (typeof subClassMethods === 'object') {\\n    if (typeof subClassMethods.init === 'function') {\\n      _utilsLog2['default'].warn('Constructor logic via init() is deprecated; please use constructor() instead.');\\n      subClassMethods.constructor = subClassMethods.init;\\n    }\\n    if (subClassMethods.constructor !== Object.prototype.constructor) {\\n      subClass = subClassMethods.constructor;\\n    }\\n    methods = subClassMethods;\\n  } else if (typeof subClassMethods === 'function') {\\n    subClass = subClassMethods;\\n  }\\n\\n  _inherits(subClass, superClass);\\n\\n  // Extend subObj's prototype with functions and other properties from props\\n  for (var name in methods) {\\n    if (methods.hasOwnProperty(name)) {\\n      subClass.prototype[name] = methods[name];\\n    }\\n  }\\n\\n  return subClass;\\n};\\n\\nexports['default'] = extendFn;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./utils/log\\\":147}],106:[function(_dereq_,module,exports){\\n/**\\n * @file fullscreen-api.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\n/*\\n * Store the browser-specific methods for the fullscreen API\\n * @type {Object|undefined}\\n * @private\\n */\\nvar FullscreenApi = {};\\n\\n// browser API methods\\n// map approach from Screenful.js - https://github.com/sindresorhus/screenfull.js\\nvar apiMap = [\\n// Spec: https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html\\n['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror'],\\n// WebKit\\n['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror'],\\n// Old WebKit (Safari 5.1)\\n['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitCurrentFullScreenElement', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitfullscreenerror'],\\n// Mozilla\\n['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror'],\\n// Microsoft\\n['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError']];\\n\\nvar specApi = apiMap[0];\\nvar browserApi = undefined;\\n\\n// determine the supported set of functions\\nfor (var i = 0; i < apiMap.length; i++) {\\n  // check for exitFullscreen function\\n  if (apiMap[i][1] in _globalDocument2['default']) {\\n    browserApi = apiMap[i];\\n    break;\\n  }\\n}\\n\\n// map the browser API names to the spec API names\\nif (browserApi) {\\n  for (var i = 0; i < browserApi.length; i++) {\\n    FullscreenApi[specApi[i]] = browserApi[i];\\n  }\\n}\\n\\nexports['default'] = FullscreenApi;\\nmodule.exports = exports['default'];\\n\\n},{\\\"global/document\\\":1}],107:[function(_dereq_,module,exports){\\n/**\\n * @file loading-spinner.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _component = _dereq_('./component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\n/* Loading Spinner\\n================================================================================ */\\n/**\\n * Loading spinner for waiting events\\n *\\n * @extends Component\\n * @class LoadingSpinner\\n */\\n\\nvar LoadingSpinner = (function (_Component) {\\n  _inherits(LoadingSpinner, _Component);\\n\\n  function LoadingSpinner() {\\n    _classCallCheck(this, LoadingSpinner);\\n\\n    _Component.apply(this, arguments);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @method createEl\\n   */\\n\\n  LoadingSpinner.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-loading-spinner',\\n      dir: 'ltr'\\n    });\\n  };\\n\\n  return LoadingSpinner;\\n})(_component2['default']);\\n\\n_component2['default'].registerComponent('LoadingSpinner', LoadingSpinner);\\nexports['default'] = LoadingSpinner;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./component\\\":67}],108:[function(_dereq_,module,exports){\\n/**\\n * @file media-error.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _objectAssign = _dereq_('object.assign');\\n\\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\\n\\n/*\\n * Custom MediaError class which mimics the standard HTML5 MediaError class.\\n *\\n * @param {Number|String|Object|MediaError} value\\n *        This can be of multiple types:\\n *        - Number: should be a standard error code\\n *        - String: an error message (the code will be 0)\\n *        - Object: arbitrary properties\\n *        - MediaError (native): used to populate a video.js MediaError object\\n *        - MediaError (video.js): will return itself if it's already a\\n *          video.js MediaError object.\\n */\\nfunction MediaError(value) {\\n\\n  // Allow redundant calls to this constructor to avoid having `instanceof`\\n  // checks peppered around the code.\\n  if (value instanceof MediaError) {\\n    return value;\\n  }\\n\\n  if (typeof value === 'number') {\\n    this.code = value;\\n  } else if (typeof value === 'string') {\\n    // default code is zero, so this is a custom error\\n    this.message = value;\\n  } else if (typeof value === 'object') {\\n\\n    // We assign the `code` property manually because native MediaError objects\\n    // do not expose it as an own/enumerable property of the object.\\n    if (typeof value.code === 'number') {\\n      this.code = value.code;\\n    }\\n\\n    _objectAssign2['default'](this, value);\\n  }\\n\\n  if (!this.message) {\\n    this.message = MediaError.defaultMessages[this.code] || '';\\n  }\\n}\\n\\n/*\\n * The error code that refers two one of the defined\\n * MediaError types\\n *\\n * @type {Number}\\n */\\nMediaError.prototype.code = 0;\\n\\n/*\\n * An optional message to be shown with the error.\\n * Message is not part of the HTML5 video spec\\n * but allows for more informative custom errors.\\n *\\n * @type {String}\\n */\\nMediaError.prototype.message = '';\\n\\n/*\\n * An optional status code that can be set by plugins\\n * to allow even more detail about the error.\\n * For example the HLS plugin might provide the specific\\n * HTTP status code that was returned when the error\\n * occurred, then allowing a custom error overlay\\n * to display more information.\\n *\\n * @type {Array}\\n */\\nMediaError.prototype.status = null;\\n\\nMediaError.errorTypes = ['MEDIA_ERR_CUSTOM', // = 0\\n'MEDIA_ERR_ABORTED', // = 1\\n'MEDIA_ERR_NETWORK', // = 2\\n'MEDIA_ERR_DECODE', // = 3\\n'MEDIA_ERR_SRC_NOT_SUPPORTED', // = 4\\n'MEDIA_ERR_ENCRYPTED' // = 5\\n];\\n\\nMediaError.defaultMessages = {\\n  1: 'You aborted the media playback',\\n  2: 'A network error caused the media download to fail part-way.',\\n  3: 'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.',\\n  4: 'The media could not be loaded, either because the server or network failed or because the format is not supported.',\\n  5: 'The media is encrypted and we do not have the keys to decrypt it.'\\n};\\n\\n// Add types as properties on MediaError\\n// e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;\\nfor (var errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {\\n  MediaError[MediaError.errorTypes[errNum]] = errNum;\\n  // values should be accessible on both the class and instance\\n  MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;\\n}\\n\\nexports['default'] = MediaError;\\nmodule.exports = exports['default'];\\n\\n},{\\\"object.assign\\\":45}],109:[function(_dereq_,module,exports){\\n/**\\n * @file menu-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _clickableComponentJs = _dereq_('../clickable-component.js');\\n\\nvar _clickableComponentJs2 = _interopRequireDefault(_clickableComponentJs);\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _menuJs = _dereq_('./menu.js');\\n\\nvar _menuJs2 = _interopRequireDefault(_menuJs);\\n\\nvar _utilsDomJs = _dereq_('../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsToTitleCaseJs = _dereq_('../utils/to-title-case.js');\\n\\nvar _utilsToTitleCaseJs2 = _interopRequireDefault(_utilsToTitleCaseJs);\\n\\n/**\\n * A button class with a popup menu\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Button\\n * @class MenuButton\\n */\\n\\nvar MenuButton = (function (_ClickableComponent) {\\n  _inherits(MenuButton, _ClickableComponent);\\n\\n  function MenuButton(player) {\\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n\\n    _classCallCheck(this, MenuButton);\\n\\n    _ClickableComponent.call(this, player, options);\\n\\n    this.update();\\n\\n    this.enabled_ = true;\\n\\n    this.el_.setAttribute('aria-haspopup', 'true');\\n    this.el_.setAttribute('role', 'menuitem');\\n    this.on('keydown', this.handleSubmenuKeyPress);\\n  }\\n\\n  /**\\n   * Update menu\\n   *\\n   * @method update\\n   */\\n\\n  MenuButton.prototype.update = function update() {\\n    var menu = this.createMenu();\\n\\n    if (this.menu) {\\n      this.removeChild(this.menu);\\n    }\\n\\n    this.menu = menu;\\n    this.addChild(menu);\\n\\n    /**\\n     * Track the state of the menu button\\n     *\\n     * @type {Boolean}\\n     * @private\\n     */\\n    this.buttonPressed_ = false;\\n    this.el_.setAttribute('aria-expanded', 'false');\\n\\n    if (this.items && this.items.length === 0) {\\n      this.hide();\\n    } else if (this.items && this.items.length > 1) {\\n      this.show();\\n    }\\n  };\\n\\n  /**\\n   * Create menu\\n   *\\n   * @return {Menu} The constructed menu\\n   * @method createMenu\\n   */\\n\\n  MenuButton.prototype.createMenu = function createMenu() {\\n    var menu = new _menuJs2['default'](this.player_);\\n\\n    // Add a title list item to the top\\n    if (this.options_.title) {\\n      var title = Dom.createEl('li', {\\n        className: 'vjs-menu-title',\\n        innerHTML: _utilsToTitleCaseJs2['default'](this.options_.title),\\n        tabIndex: -1\\n      });\\n      menu.children_.unshift(title);\\n      Dom.insertElFirst(title, menu.contentEl());\\n    }\\n\\n    this.items = this['createItems']();\\n\\n    if (this.items) {\\n      // Add menu items to the menu\\n      for (var i = 0; i < this.items.length; i++) {\\n        menu.addItem(this.items[i]);\\n      }\\n    }\\n\\n    return menu;\\n  };\\n\\n  /**\\n   * Create the list of menu items. Specific to each subclass.\\n   *\\n   * @method createItems\\n   */\\n\\n  MenuButton.prototype.createItems = function createItems() {};\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  MenuButton.prototype.createEl = function createEl() {\\n    return _ClickableComponent.prototype.createEl.call(this, 'div', {\\n      className: this.buildCSSClass()\\n    });\\n  };\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  MenuButton.prototype.buildCSSClass = function buildCSSClass() {\\n    var menuButtonClass = 'vjs-menu-button';\\n\\n    // If the inline option is passed, we want to use different styles altogether.\\n    if (this.options_.inline === true) {\\n      menuButtonClass += '-inline';\\n    } else {\\n      menuButtonClass += '-popup';\\n    }\\n\\n    return 'vjs-menu-button ' + menuButtonClass + ' ' + _ClickableComponent.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * When you click the button it adds focus, which\\n   * will show the menu indefinitely.\\n   * So we'll remove focus when the mouse leaves the button.\\n   * Focus is needed for tab navigation.\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @method handleClick\\n   */\\n\\n  MenuButton.prototype.handleClick = function handleClick() {\\n    this.one(this.menu.contentEl(), 'mouseleave', Fn.bind(this, function (e) {\\n      this.unpressButton();\\n      this.el_.blur();\\n    }));\\n    if (this.buttonPressed_) {\\n      this.unpressButton();\\n    } else {\\n      this.pressButton();\\n    }\\n  };\\n\\n  /**\\n   * Handle key press on menu\\n   *\\n   * @param {Object} event Key press event\\n   * @method handleKeyPress\\n   */\\n\\n  MenuButton.prototype.handleKeyPress = function handleKeyPress(event) {\\n\\n    // Escape (27) key or Tab (9) key unpress the 'button'\\n    if (event.which === 27 || event.which === 9) {\\n      if (this.buttonPressed_) {\\n        this.unpressButton();\\n      }\\n      // Don't preventDefault for Tab key - we still want to lose focus\\n      if (event.which !== 9) {\\n        event.preventDefault();\\n      }\\n      // Up (38) key or Down (40) key press the 'button'\\n    } else if (event.which === 38 || event.which === 40) {\\n        if (!this.buttonPressed_) {\\n          this.pressButton();\\n          event.preventDefault();\\n        }\\n      } else {\\n        _ClickableComponent.prototype.handleKeyPress.call(this, event);\\n      }\\n  };\\n\\n  /**\\n   * Handle key press on submenu\\n   *\\n   * @param {Object} event Key press event\\n   * @method handleSubmenuKeyPress\\n   */\\n\\n  MenuButton.prototype.handleSubmenuKeyPress = function handleSubmenuKeyPress(event) {\\n\\n    // Escape (27) key or Tab (9) key unpress the 'button'\\n    if (event.which === 27 || event.which === 9) {\\n      if (this.buttonPressed_) {\\n        this.unpressButton();\\n      }\\n      // Don't preventDefault for Tab key - we still want to lose focus\\n      if (event.which !== 9) {\\n        event.preventDefault();\\n      }\\n    }\\n  };\\n\\n  /**\\n   * Makes changes based on button pressed\\n   *\\n   * @method pressButton\\n   */\\n\\n  MenuButton.prototype.pressButton = function pressButton() {\\n    if (this.enabled_) {\\n      this.buttonPressed_ = true;\\n      this.menu.lockShowing();\\n      this.el_.setAttribute('aria-expanded', 'true');\\n      this.menu.focus(); // set the focus into the submenu\\n    }\\n  };\\n\\n  /**\\n   * Makes changes based on button unpressed\\n   *\\n   * @method unpressButton\\n   */\\n\\n  MenuButton.prototype.unpressButton = function unpressButton() {\\n    if (this.enabled_) {\\n      this.buttonPressed_ = false;\\n      this.menu.unlockShowing();\\n      this.el_.setAttribute('aria-expanded', 'false');\\n      this.el_.focus(); // Set focus back to this menu button\\n    }\\n  };\\n\\n  /**\\n   * Disable the menu button\\n   *\\n   * @return {Component}\\n   * @method disable\\n   */\\n\\n  MenuButton.prototype.disable = function disable() {\\n    // Unpress, but don't force focus on this button\\n    this.buttonPressed_ = false;\\n    this.menu.unlockShowing();\\n    this.el_.setAttribute('aria-expanded', 'false');\\n\\n    this.enabled_ = false;\\n\\n    return _ClickableComponent.prototype.disable.call(this);\\n  };\\n\\n  /**\\n   * Enable the menu button\\n   *\\n   * @return {Component}\\n   * @method disable\\n   */\\n\\n  MenuButton.prototype.enable = function enable() {\\n    this.enabled_ = true;\\n\\n    return _ClickableComponent.prototype.enable.call(this);\\n  };\\n\\n  return MenuButton;\\n})(_clickableComponentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('MenuButton', MenuButton);\\nexports['default'] = MenuButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../clickable-component.js\\\":65,\\\"../component.js\\\":67,\\\"../utils/dom.js\\\":142,\\\"../utils/fn.js\\\":144,\\\"../utils/to-title-case.js\\\":151,\\\"./menu.js\\\":111}],110:[function(_dereq_,module,exports){\\n/**\\n * @file menu-item.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _clickableComponentJs = _dereq_('../clickable-component.js');\\n\\nvar _clickableComponentJs2 = _interopRequireDefault(_clickableComponentJs);\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _objectAssign = _dereq_('object.assign');\\n\\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\\n\\n/**\\n * The component for a menu item. `<li>`\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Button\\n * @class MenuItem\\n */\\n\\nvar MenuItem = (function (_ClickableComponent) {\\n  _inherits(MenuItem, _ClickableComponent);\\n\\n  function MenuItem(player, options) {\\n    _classCallCheck(this, MenuItem);\\n\\n    _ClickableComponent.call(this, player, options);\\n\\n    this.selectable = options['selectable'];\\n\\n    this.selected(options['selected']);\\n\\n    if (this.selectable) {\\n      // TODO: May need to be either menuitemcheckbox or menuitemradio,\\n      //       and may need logical grouping of menu items.\\n      this.el_.setAttribute('role', 'menuitemcheckbox');\\n    } else {\\n      this.el_.setAttribute('role', 'menuitem');\\n    }\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @param {String=} type Desc\\n   * @param {Object=} props Desc\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  MenuItem.prototype.createEl = function createEl(type, props, attrs) {\\n    return _ClickableComponent.prototype.createEl.call(this, 'li', _objectAssign2['default']({\\n      className: 'vjs-menu-item',\\n      innerHTML: this.localize(this.options_['label']),\\n      tabIndex: -1\\n    }, props), attrs);\\n  };\\n\\n  /**\\n   * Handle a click on the menu item, and set it to selected\\n   *\\n   * @method handleClick\\n   */\\n\\n  MenuItem.prototype.handleClick = function handleClick() {\\n    this.selected(true);\\n  };\\n\\n  /**\\n   * Set this menu item as selected or not\\n   *\\n   * @param  {Boolean} selected\\n   * @method selected\\n   */\\n\\n  MenuItem.prototype.selected = function selected(_selected) {\\n    if (this.selectable) {\\n      if (_selected) {\\n        this.addClass('vjs-selected');\\n        this.el_.setAttribute('aria-checked', 'true');\\n        // aria-checked isn't fully supported by browsers/screen readers,\\n        // so indicate selected state to screen reader in the control text.\\n        this.controlText(', selected');\\n      } else {\\n        this.removeClass('vjs-selected');\\n        this.el_.setAttribute('aria-checked', 'false');\\n        // Indicate un-selected state to screen reader\\n        // Note that a space clears out the selected state text\\n        this.controlText(' ');\\n      }\\n    }\\n  };\\n\\n  return MenuItem;\\n})(_clickableComponentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('MenuItem', MenuItem);\\nexports['default'] = MenuItem;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../clickable-component.js\\\":65,\\\"../component.js\\\":67,\\\"object.assign\\\":45}],111:[function(_dereq_,module,exports){\\n/**\\n * @file menu.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsDomJs = _dereq_('../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsEventsJs = _dereq_('../utils/events.js');\\n\\nvar Events = _interopRequireWildcard(_utilsEventsJs);\\n\\n/**\\n * The Menu component is used to build pop up menus, including subtitle and\\n * captions selection menus.\\n *\\n * @extends Component\\n * @class Menu\\n */\\n\\nvar Menu = (function (_Component) {\\n  _inherits(Menu, _Component);\\n\\n  function Menu(player, options) {\\n    _classCallCheck(this, Menu);\\n\\n    _Component.call(this, player, options);\\n\\n    this.focusedChild_ = -1;\\n\\n    this.on('keydown', this.handleKeyPress);\\n  }\\n\\n  /**\\n   * Add a menu item to the menu\\n   *\\n   * @param {Object|String} component Component or component type to add\\n   * @method addItem\\n   */\\n\\n  Menu.prototype.addItem = function addItem(component) {\\n    this.addChild(component);\\n    component.on('click', Fn.bind(this, function () {\\n      this.unlockShowing();\\n      //TODO: Need to set keyboard focus back to the menuButton\\n    }));\\n  };\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  Menu.prototype.createEl = function createEl() {\\n    var contentElType = this.options_.contentElType || 'ul';\\n    this.contentEl_ = Dom.createEl(contentElType, {\\n      className: 'vjs-menu-content'\\n    });\\n    this.contentEl_.setAttribute('role', 'menu');\\n    var el = _Component.prototype.createEl.call(this, 'div', {\\n      append: this.contentEl_,\\n      className: 'vjs-menu'\\n    });\\n    el.setAttribute('role', 'presentation');\\n    el.appendChild(this.contentEl_);\\n\\n    // Prevent clicks from bubbling up. Needed for Menu Buttons,\\n    // where a click on the parent is significant\\n    Events.on(el, 'click', function (event) {\\n      event.preventDefault();\\n      event.stopImmediatePropagation();\\n    });\\n\\n    return el;\\n  };\\n\\n  /**\\n   * Handle key press for menu\\n   *\\n   * @param {Object} event Event object\\n   * @method handleKeyPress\\n   */\\n\\n  Menu.prototype.handleKeyPress = function handleKeyPress(event) {\\n    if (event.which === 37 || event.which === 40) {\\n      // Left and Down Arrows\\n      event.preventDefault();\\n      this.stepForward();\\n    } else if (event.which === 38 || event.which === 39) {\\n      // Up and Right Arrows\\n      event.preventDefault();\\n      this.stepBack();\\n    }\\n  };\\n\\n  /**\\n   * Move to next (lower) menu item for keyboard users\\n   *\\n   * @method stepForward\\n   */\\n\\n  Menu.prototype.stepForward = function stepForward() {\\n    var stepChild = 0;\\n\\n    if (this.focusedChild_ !== undefined) {\\n      stepChild = this.focusedChild_ + 1;\\n    }\\n    this.focus(stepChild);\\n  };\\n\\n  /**\\n   * Move to previous (higher) menu item for keyboard users\\n   *\\n   * @method stepBack\\n   */\\n\\n  Menu.prototype.stepBack = function stepBack() {\\n    var stepChild = 0;\\n\\n    if (this.focusedChild_ !== undefined) {\\n      stepChild = this.focusedChild_ - 1;\\n    }\\n    this.focus(stepChild);\\n  };\\n\\n  /**\\n   * Set focus on a menu item in the menu\\n   *\\n   * @param {Object|String} item Index of child item set focus on\\n   * @method focus\\n   */\\n\\n  Menu.prototype.focus = function focus() {\\n    var item = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\\n\\n    var children = this.children().slice();\\n    var haveTitle = children.length && children[0].className && /vjs-menu-title/.test(children[0].className);\\n\\n    if (haveTitle) {\\n      children.shift();\\n    }\\n\\n    if (children.length > 0) {\\n      if (item < 0) {\\n        item = 0;\\n      } else if (item >= children.length) {\\n        item = children.length - 1;\\n      }\\n\\n      this.focusedChild_ = item;\\n\\n      children[item].el_.focus();\\n    }\\n  };\\n\\n  return Menu;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('Menu', Menu);\\nexports['default'] = Menu;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component.js\\\":67,\\\"../utils/dom.js\\\":142,\\\"../utils/events.js\\\":143,\\\"../utils/fn.js\\\":144}],112:[function(_dereq_,module,exports){\\n/**\\n * @file modal-dialog.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _utilsDom = _dereq_('./utils/dom');\\n\\nvar Dom = _interopRequireWildcard(_utilsDom);\\n\\nvar _utilsFn = _dereq_('./utils/fn');\\n\\nvar Fn = _interopRequireWildcard(_utilsFn);\\n\\nvar _utilsLog = _dereq_('./utils/log');\\n\\nvar _utilsLog2 = _interopRequireDefault(_utilsLog);\\n\\nvar _component = _dereq_('./component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _closeButton = _dereq_('./close-button');\\n\\nvar _closeButton2 = _interopRequireDefault(_closeButton);\\n\\nvar MODAL_CLASS_NAME = 'vjs-modal-dialog';\\nvar ESC = 27;\\n\\n/**\\n * The `ModalDialog` displays over the video and its controls, which blocks\\n * interaction with the player until it is closed.\\n *\\n * Modal dialogs include a \\\"Close\\\" button and will close when that button\\n * is activated - or when ESC is pressed anywhere.\\n *\\n * @extends Component\\n * @class ModalDialog\\n */\\n\\nvar ModalDialog = (function (_Component) {\\n  _inherits(ModalDialog, _Component);\\n\\n  /**\\n   * Constructor for modals.\\n   *\\n   * @param  {Player} player\\n   * @param  {Object} [options]\\n   * @param  {Mixed} [options.content=undefined]\\n   *         Provide customized content for this modal.\\n   *\\n   * @param  {String} [options.description]\\n   *         A text description for the modal, primarily for accessibility.\\n   *\\n   * @param  {Boolean} [options.fillAlways=false]\\n   *         Normally, modals are automatically filled only the first time\\n   *         they open. This tells the modal to refresh its content\\n   *         every time it opens.\\n   *\\n   * @param  {String} [options.label]\\n   *         A text label for the modal, primarily for accessibility.\\n   *\\n   * @param  {Boolean} [options.temporary=true]\\n   *         If `true`, the modal can only be opened once; it will be\\n   *         disposed as soon as it's closed.\\n   *\\n   * @param  {Boolean} [options.uncloseable=false]\\n   *         If `true`, the user will not be able to close the modal\\n   *         through the UI in the normal ways. Programmatic closing is\\n   *         still possible.\\n   *\\n   */\\n\\n  function ModalDialog(player, options) {\\n    _classCallCheck(this, ModalDialog);\\n\\n    _Component.call(this, player, options);\\n    this.opened_ = this.hasBeenOpened_ = this.hasBeenFilled_ = false;\\n\\n    this.closeable(!this.options_.uncloseable);\\n    this.content(this.options_.content);\\n\\n    // Make sure the contentEl is defined AFTER any children are initialized\\n    // because we only want the contents of the modal in the contentEl\\n    // (not the UI elements like the close button).\\n    this.contentEl_ = Dom.createEl('div', {\\n      className: MODAL_CLASS_NAME + '-content'\\n    }, {\\n      role: 'document'\\n    });\\n\\n    this.descEl_ = Dom.createEl('p', {\\n      className: MODAL_CLASS_NAME + '-description vjs-offscreen',\\n      id: this.el().getAttribute('aria-describedby')\\n    });\\n\\n    Dom.textContent(this.descEl_, this.description());\\n    this.el_.appendChild(this.descEl_);\\n    this.el_.appendChild(this.contentEl_);\\n  }\\n\\n  /*\\n   * Modal dialog default options.\\n   *\\n   * @type {Object}\\n   * @private\\n   */\\n\\n  /**\\n   * Create the modal's DOM element\\n   *\\n   * @method createEl\\n   * @return {Element}\\n   */\\n\\n  ModalDialog.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: this.buildCSSClass(),\\n      tabIndex: -1\\n    }, {\\n      'aria-describedby': this.id() + '_description',\\n      'aria-hidden': 'true',\\n      'aria-label': this.label(),\\n      role: 'dialog'\\n    });\\n  };\\n\\n  /**\\n   * Build the modal's CSS class.\\n   *\\n   * @method buildCSSClass\\n   * @return {String}\\n   */\\n\\n  ModalDialog.prototype.buildCSSClass = function buildCSSClass() {\\n    return MODAL_CLASS_NAME + ' vjs-hidden ' + _Component.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Handles key presses on the document, looking for ESC, which closes\\n   * the modal.\\n   *\\n   * @method handleKeyPress\\n   * @param  {Event} e\\n   */\\n\\n  ModalDialog.prototype.handleKeyPress = function handleKeyPress(e) {\\n    if (e.which === ESC && this.closeable()) {\\n      this.close();\\n    }\\n  };\\n\\n  /**\\n   * Returns the label string for this modal. Primarily used for accessibility.\\n   *\\n   * @return {String}\\n   */\\n\\n  ModalDialog.prototype.label = function label() {\\n    return this.options_.label || this.localize('Modal Window');\\n  };\\n\\n  /**\\n   * Returns the description string for this modal. Primarily used for\\n   * accessibility.\\n   *\\n   * @return {String}\\n   */\\n\\n  ModalDialog.prototype.description = function description() {\\n    var desc = this.options_.description || this.localize('This is a modal window.');\\n\\n    // Append a universal closeability message if the modal is closeable.\\n    if (this.closeable()) {\\n      desc += ' ' + this.localize('This modal can be closed by pressing the Escape key or activating the close button.');\\n    }\\n\\n    return desc;\\n  };\\n\\n  /**\\n   * Opens the modal.\\n   *\\n   * @method open\\n   * @return {ModalDialog}\\n   */\\n\\n  ModalDialog.prototype.open = function open() {\\n    if (!this.opened_) {\\n      var player = this.player();\\n\\n      this.trigger('beforemodalopen');\\n      this.opened_ = true;\\n\\n      // Fill content if the modal has never opened before and\\n      // never been filled.\\n      if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {\\n        this.fill();\\n      }\\n\\n      // If the player was playing, pause it and take note of its previously\\n      // playing state.\\n      this.wasPlaying_ = !player.paused();\\n\\n      if (this.wasPlaying_) {\\n        player.pause();\\n      }\\n\\n      if (this.closeable()) {\\n        this.on(this.el_.ownerDocument, 'keydown', Fn.bind(this, this.handleKeyPress));\\n      }\\n\\n      player.controls(false);\\n      this.show();\\n      this.el().setAttribute('aria-hidden', 'false');\\n      this.trigger('modalopen');\\n      this.hasBeenOpened_ = true;\\n    }\\n    return this;\\n  };\\n\\n  /**\\n   * Whether or not the modal is opened currently.\\n   *\\n   * @method opened\\n   * @param  {Boolean} [value]\\n   *         If given, it will open (`true`) or close (`false`) the modal.\\n   *\\n   * @return {Boolean}\\n   */\\n\\n  ModalDialog.prototype.opened = function opened(value) {\\n    if (typeof value === 'boolean') {\\n      this[value ? 'open' : 'close']();\\n    }\\n    return this.opened_;\\n  };\\n\\n  /**\\n   * Closes the modal.\\n   *\\n   * @method close\\n   * @return {ModalDialog}\\n   */\\n\\n  ModalDialog.prototype.close = function close() {\\n    if (this.opened_) {\\n      var player = this.player();\\n\\n      this.trigger('beforemodalclose');\\n      this.opened_ = false;\\n\\n      if (this.wasPlaying_) {\\n        player.play();\\n      }\\n\\n      if (this.closeable()) {\\n        this.off(this.el_.ownerDocument, 'keydown', Fn.bind(this, this.handleKeyPress));\\n      }\\n\\n      player.controls(true);\\n      this.hide();\\n      this.el().setAttribute('aria-hidden', 'true');\\n      this.trigger('modalclose');\\n\\n      if (this.options_.temporary) {\\n        this.dispose();\\n      }\\n    }\\n    return this;\\n  };\\n\\n  /**\\n   * Whether or not the modal is closeable via the UI.\\n   *\\n   * @method closeable\\n   * @param  {Boolean} [value]\\n   *         If given as a Boolean, it will set the `closeable` option.\\n   *\\n   * @return {Boolean}\\n   */\\n\\n  ModalDialog.prototype.closeable = function closeable(value) {\\n    if (typeof value === 'boolean') {\\n      var closeable = this.closeable_ = !!value;\\n      var _close = this.getChild('closeButton');\\n\\n      // If this is being made closeable and has no close button, add one.\\n      if (closeable && !_close) {\\n\\n        // The close button should be a child of the modal - not its\\n        // content element, so temporarily change the content element.\\n        var temp = this.contentEl_;\\n        this.contentEl_ = this.el_;\\n        _close = this.addChild('closeButton', { controlText: 'Close Modal Dialog' });\\n        this.contentEl_ = temp;\\n        this.on(_close, 'close', this.close);\\n      }\\n\\n      // If this is being made uncloseable and has a close button, remove it.\\n      if (!closeable && _close) {\\n        this.off(_close, 'close', this.close);\\n        this.removeChild(_close);\\n        _close.dispose();\\n      }\\n    }\\n    return this.closeable_;\\n  };\\n\\n  /**\\n   * Fill the modal's content element with the modal's \\\"content\\\" option.\\n   *\\n   * The content element will be emptied before this change takes place.\\n   *\\n   * @method fill\\n   * @return {ModalDialog}\\n   */\\n\\n  ModalDialog.prototype.fill = function fill() {\\n    return this.fillWith(this.content());\\n  };\\n\\n  /**\\n   * Fill the modal's content element with arbitrary content.\\n   *\\n   * The content element will be emptied before this change takes place.\\n   *\\n   * @method fillWith\\n   * @param  {Mixed} [content]\\n   *         The same rules apply to this as apply to the `content` option.\\n   *\\n   * @return {ModalDialog}\\n   */\\n\\n  ModalDialog.prototype.fillWith = function fillWith(content) {\\n    var contentEl = this.contentEl();\\n    var parentEl = contentEl.parentNode;\\n    var nextSiblingEl = contentEl.nextSibling;\\n\\n    this.trigger('beforemodalfill');\\n    this.hasBeenFilled_ = true;\\n\\n    // Detach the content element from the DOM before performing\\n    // manipulation to avoid modifying the live DOM multiple times.\\n    parentEl.removeChild(contentEl);\\n    this.empty();\\n    Dom.insertContent(contentEl, content);\\n    this.trigger('modalfill');\\n\\n    // Re-inject the re-filled content element.\\n    if (nextSiblingEl) {\\n      parentEl.insertBefore(contentEl, nextSiblingEl);\\n    } else {\\n      parentEl.appendChild(contentEl);\\n    }\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Empties the content element.\\n   *\\n   * This happens automatically anytime the modal is filled.\\n   *\\n   * @method empty\\n   * @return {ModalDialog}\\n   */\\n\\n  ModalDialog.prototype.empty = function empty() {\\n    this.trigger('beforemodalempty');\\n    Dom.emptyEl(this.contentEl());\\n    this.trigger('modalempty');\\n    return this;\\n  };\\n\\n  /**\\n   * Gets or sets the modal content, which gets normalized before being\\n   * rendered into the DOM.\\n   *\\n   * This does not update the DOM or fill the modal, but it is called during\\n   * that process.\\n   *\\n   * @method content\\n   * @param  {Mixed} [value]\\n   *         If defined, sets the internal content value to be used on the\\n   *         next call(s) to `fill`. This value is normalized before being\\n   *         inserted. To \\\"clear\\\" the internal content value, pass `null`.\\n   *\\n   * @return {Mixed}\\n   */\\n\\n  ModalDialog.prototype.content = function content(value) {\\n    if (typeof value !== 'undefined') {\\n      this.content_ = value;\\n    }\\n    return this.content_;\\n  };\\n\\n  return ModalDialog;\\n})(_component2['default']);\\n\\nModalDialog.prototype.options_ = {\\n  temporary: true\\n};\\n\\n_component2['default'].registerComponent('ModalDialog', ModalDialog);\\nexports['default'] = ModalDialog;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./close-button\\\":66,\\\"./component\\\":67,\\\"./utils/dom\\\":142,\\\"./utils/fn\\\":144,\\\"./utils/log\\\":147}],113:[function(_dereq_,module,exports){\\n/**\\n * @file player.js\\n */\\n// Subclasses Component\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('./component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _utilsEventsJs = _dereq_('./utils/events.js');\\n\\nvar Events = _interopRequireWildcard(_utilsEventsJs);\\n\\nvar _utilsDomJs = _dereq_('./utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFnJs = _dereq_('./utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsGuidJs = _dereq_('./utils/guid.js');\\n\\nvar Guid = _interopRequireWildcard(_utilsGuidJs);\\n\\nvar _utilsBrowserJs = _dereq_('./utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\nvar _utilsLogJs = _dereq_('./utils/log.js');\\n\\nvar _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);\\n\\nvar _utilsToTitleCaseJs = _dereq_('./utils/to-title-case.js');\\n\\nvar _utilsToTitleCaseJs2 = _interopRequireDefault(_utilsToTitleCaseJs);\\n\\nvar _utilsTimeRangesJs = _dereq_('./utils/time-ranges.js');\\n\\nvar _utilsBufferJs = _dereq_('./utils/buffer.js');\\n\\nvar _utilsStylesheetJs = _dereq_('./utils/stylesheet.js');\\n\\nvar stylesheet = _interopRequireWildcard(_utilsStylesheetJs);\\n\\nvar _fullscreenApiJs = _dereq_('./fullscreen-api.js');\\n\\nvar _fullscreenApiJs2 = _interopRequireDefault(_fullscreenApiJs);\\n\\nvar _mediaErrorJs = _dereq_('./media-error.js');\\n\\nvar _mediaErrorJs2 = _interopRequireDefault(_mediaErrorJs);\\n\\nvar _safeJsonParseTuple = _dereq_('safe-json-parse/tuple');\\n\\nvar _safeJsonParseTuple2 = _interopRequireDefault(_safeJsonParseTuple);\\n\\nvar _objectAssign = _dereq_('object.assign');\\n\\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\\n\\nvar _utilsMergeOptionsJs = _dereq_('./utils/merge-options.js');\\n\\nvar _utilsMergeOptionsJs2 = _interopRequireDefault(_utilsMergeOptionsJs);\\n\\nvar _tracksTextTrackListConverterJs = _dereq_('./tracks/text-track-list-converter.js');\\n\\nvar _tracksTextTrackListConverterJs2 = _interopRequireDefault(_tracksTextTrackListConverterJs);\\n\\nvar _tracksAudioTrackListJs = _dereq_('./tracks/audio-track-list.js');\\n\\nvar _tracksAudioTrackListJs2 = _interopRequireDefault(_tracksAudioTrackListJs);\\n\\nvar _tracksVideoTrackListJs = _dereq_('./tracks/video-track-list.js');\\n\\nvar _tracksVideoTrackListJs2 = _interopRequireDefault(_tracksVideoTrackListJs);\\n\\n// Include required child components (importing also registers them)\\n\\nvar _techLoaderJs = _dereq_('./tech/loader.js');\\n\\nvar _techLoaderJs2 = _interopRequireDefault(_techLoaderJs);\\n\\nvar _posterImageJs = _dereq_('./poster-image.js');\\n\\nvar _posterImageJs2 = _interopRequireDefault(_posterImageJs);\\n\\nvar _tracksTextTrackDisplayJs = _dereq_('./tracks/text-track-display.js');\\n\\nvar _tracksTextTrackDisplayJs2 = _interopRequireDefault(_tracksTextTrackDisplayJs);\\n\\nvar _loadingSpinnerJs = _dereq_('./loading-spinner.js');\\n\\nvar _loadingSpinnerJs2 = _interopRequireDefault(_loadingSpinnerJs);\\n\\nvar _bigPlayButtonJs = _dereq_('./big-play-button.js');\\n\\nvar _bigPlayButtonJs2 = _interopRequireDefault(_bigPlayButtonJs);\\n\\nvar _controlBarControlBarJs = _dereq_('./control-bar/control-bar.js');\\n\\nvar _controlBarControlBarJs2 = _interopRequireDefault(_controlBarControlBarJs);\\n\\nvar _errorDisplayJs = _dereq_('./error-display.js');\\n\\nvar _errorDisplayJs2 = _interopRequireDefault(_errorDisplayJs);\\n\\nvar _tracksTextTrackSettingsJs = _dereq_('./tracks/text-track-settings.js');\\n\\nvar _tracksTextTrackSettingsJs2 = _interopRequireDefault(_tracksTextTrackSettingsJs);\\n\\nvar _modalDialog = _dereq_('./modal-dialog');\\n\\nvar _modalDialog2 = _interopRequireDefault(_modalDialog);\\n\\n// Require html5 tech, at least for disposing the original video tag\\n\\nvar _techTechJs = _dereq_('./tech/tech.js');\\n\\nvar _techTechJs2 = _interopRequireDefault(_techTechJs);\\n\\nvar _techHtml5Js = _dereq_('./tech/html5.js');\\n\\nvar _techHtml5Js2 = _interopRequireDefault(_techHtml5Js);\\n\\n/**\\n * An instance of the `Player` class is created when any of the Video.js setup methods are used to initialize a video.\\n * ```js\\n * var myPlayer = videojs('example_video_1');\\n * ```\\n * In the following example, the `data-setup` attribute tells the Video.js library to create a player instance when the library is ready.\\n * ```html\\n * <video id=\\\"example_video_1\\\" data-setup='{}' controls>\\n *   <source src=\\\"my-source.mp4\\\" type=\\\"video/mp4\\\">\\n * </video>\\n * ```\\n * After an instance has been created it can be accessed globally using `Video('example_video_1')`.\\n *\\n * @param {Element} tag        The original video tag used for configuring options\\n * @param {Object=} options    Object of option names and values\\n * @param {Function=} ready    Ready callback function\\n * @extends Component\\n * @class Player\\n */\\n\\nvar Player = (function (_Component) {\\n  _inherits(Player, _Component);\\n\\n  /**\\n   * player's constructor function\\n   *\\n   * @constructs\\n   * @method init\\n   * @param {Element} tag        The original video tag used for configuring options\\n   * @param {Object=} options    Player options\\n   * @param {Function=} ready    Ready callback function\\n   */\\n\\n  function Player(tag, options, ready) {\\n    var _this = this;\\n\\n    _classCallCheck(this, Player);\\n\\n    // Make sure tag ID exists\\n    tag.id = tag.id || 'vjs_video_' + Guid.newGUID();\\n\\n    // Set Options\\n    // The options argument overrides options set in the video tag\\n    // which overrides globally set options.\\n    // This latter part coincides with the load order\\n    // (tag must exist before Player)\\n    options = _objectAssign2['default'](Player.getTagSettings(tag), options);\\n\\n    // Delay the initialization of children because we need to set up\\n    // player properties first, and can't use `this` before `super()`\\n    options.initChildren = false;\\n\\n    // Same with creating the element\\n    options.createEl = false;\\n\\n    // we don't want the player to report touch activity on itself\\n    // see enableTouchActivity in Component\\n    options.reportTouchActivity = false;\\n\\n    // If language is not set, get the closest lang attribute\\n    if (!options.language) {\\n      if (typeof tag.closest === 'function') {\\n        var closest = tag.closest('[lang]');\\n        if (closest) {\\n          options.language = closest.getAttribute('lang');\\n        }\\n      } else {\\n        var element = tag;\\n        while (element && element.nodeType === 1) {\\n          if (Dom.getElAttributes(element).hasOwnProperty('lang')) {\\n            options.language = element.getAttribute('lang');\\n            break;\\n          }\\n          element = element.parentNode;\\n        }\\n      }\\n    }\\n\\n    // Run base component initializing with new options\\n    _Component.call(this, null, options, ready);\\n\\n    // if the global option object was accidentally blown away by\\n    // someone, bail early with an informative error\\n    if (!this.options_ || !this.options_.techOrder || !this.options_.techOrder.length) {\\n      throw new Error('No techOrder specified. Did you overwrite ' + 'videojs.options instead of just changing the ' + 'properties you want to override?');\\n    }\\n\\n    this.tag = tag; // Store the original tag used to set options\\n\\n    // Store the tag attributes used to restore html5 element\\n    this.tagAttributes = tag && Dom.getElAttributes(tag);\\n\\n    // Update current language\\n    this.language(this.options_.language);\\n\\n    // Update Supported Languages\\n    if (options.languages) {\\n      (function () {\\n        // Normalise player option languages to lowercase\\n        var languagesToLower = {};\\n\\n        Object.getOwnPropertyNames(options.languages).forEach(function (name) {\\n          languagesToLower[name.toLowerCase()] = options.languages[name];\\n        });\\n        _this.languages_ = languagesToLower;\\n      })();\\n    } else {\\n      this.languages_ = Player.prototype.options_.languages;\\n    }\\n\\n    // Cache for video property values.\\n    this.cache_ = {};\\n\\n    // Set poster\\n    this.poster_ = options.poster || '';\\n\\n    // Set controls\\n    this.controls_ = !!options.controls;\\n\\n    // Original tag settings stored in options\\n    // now remove immediately so native controls don't flash.\\n    // May be turned back on by HTML5 tech if nativeControlsForTouch is true\\n    tag.controls = false;\\n\\n    /*\\n     * Store the internal state of scrubbing\\n     *\\n     * @private\\n     * @return {Boolean} True if the user is scrubbing\\n     */\\n    this.scrubbing_ = false;\\n\\n    this.el_ = this.createEl();\\n\\n    // We also want to pass the original player options to each component and plugin\\n    // as well so they don't need to reach back into the player for options later.\\n    // We also need to do another copy of this.options_ so we don't end up with\\n    // an infinite loop.\\n    var playerOptionsCopy = _utilsMergeOptionsJs2['default'](this.options_);\\n\\n    // Load plugins\\n    if (options.plugins) {\\n      (function () {\\n        var plugins = options.plugins;\\n\\n        Object.getOwnPropertyNames(plugins).forEach(function (name) {\\n          if (typeof this[name] === 'function') {\\n            this[name](plugins[name]);\\n          } else {\\n            _utilsLogJs2['default'].error('Unable to find plugin:', name);\\n          }\\n        }, _this);\\n      })();\\n    }\\n\\n    this.options_.playerOptions = playerOptionsCopy;\\n\\n    this.initChildren();\\n\\n    // Set isAudio based on whether or not an audio tag was used\\n    this.isAudio(tag.nodeName.toLowerCase() === 'audio');\\n\\n    // Update controls className. Can't do this when the controls are initially\\n    // set because the element doesn't exist yet.\\n    if (this.controls()) {\\n      this.addClass('vjs-controls-enabled');\\n    } else {\\n      this.addClass('vjs-controls-disabled');\\n    }\\n\\n    // Set ARIA label and region role depending on player type\\n    this.el_.setAttribute('role', 'region');\\n    if (this.isAudio()) {\\n      this.el_.setAttribute('aria-label', 'audio player');\\n    } else {\\n      this.el_.setAttribute('aria-label', 'video player');\\n    }\\n\\n    if (this.isAudio()) {\\n      this.addClass('vjs-audio');\\n    }\\n\\n    if (this.flexNotSupported_()) {\\n      this.addClass('vjs-no-flex');\\n    }\\n\\n    // TODO: Make this smarter. Toggle user state between touching/mousing\\n    // using events, since devices can have both touch and mouse events.\\n    // if (browser.TOUCH_ENABLED) {\\n    //   this.addClass('vjs-touch-enabled');\\n    // }\\n\\n    // iOS Safari has broken hover handling\\n    if (!browser.IS_IOS) {\\n      this.addClass('vjs-workinghover');\\n    }\\n\\n    // Make player easily findable by ID\\n    Player.players[this.id_] = this;\\n\\n    // When the player is first initialized, trigger activity so components\\n    // like the control bar show themselves if needed\\n    this.userActive(true);\\n    this.reportUserActivity();\\n    this.listenForUserActivity_();\\n\\n    this.on('fullscreenchange', this.handleFullscreenChange_);\\n    this.on('stageclick', this.handleStageClick_);\\n  }\\n\\n  /*\\n   * Global player list\\n   *\\n   * @type {Object}\\n   */\\n\\n  /**\\n   * Destroys the video player and does any necessary cleanup\\n   * ```js\\n   *     myPlayer.dispose();\\n   * ```\\n   * This is especially helpful if you are dynamically adding and removing videos\\n   * to/from the DOM.\\n   *\\n   * @method dispose\\n   */\\n\\n  Player.prototype.dispose = function dispose() {\\n    this.trigger('dispose');\\n    // prevent dispose from being called twice\\n    this.off('dispose');\\n\\n    if (this.styleEl_ && this.styleEl_.parentNode) {\\n      this.styleEl_.parentNode.removeChild(this.styleEl_);\\n    }\\n\\n    // Kill reference to this player\\n    Player.players[this.id_] = null;\\n    if (this.tag && this.tag.player) {\\n      this.tag.player = null;\\n    }\\n    if (this.el_ && this.el_.player) {\\n      this.el_.player = null;\\n    }\\n\\n    if (this.tech_) {\\n      this.tech_.dispose();\\n    }\\n\\n    _Component.prototype.dispose.call(this);\\n  };\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  Player.prototype.createEl = function createEl() {\\n    var el = this.el_ = _Component.prototype.createEl.call(this, 'div');\\n    var tag = this.tag;\\n\\n    // Remove width/height attrs from tag so CSS can make it 100% width/height\\n    tag.removeAttribute('width');\\n    tag.removeAttribute('height');\\n\\n    // Copy over all the attributes from the tag, including ID and class\\n    // ID will now reference player box, not the video tag\\n    var attrs = Dom.getElAttributes(tag);\\n\\n    Object.getOwnPropertyNames(attrs).forEach(function (attr) {\\n      // workaround so we don't totally break IE7\\n      // http://stackoverflow.com/questions/3653444/css-styles-not-applied-on-dynamic-elements-in-internet-explorer-7\\n      if (attr === 'class') {\\n        el.className = attrs[attr];\\n      } else {\\n        el.setAttribute(attr, attrs[attr]);\\n      }\\n    });\\n\\n    // Update tag id/class for use as HTML5 playback tech\\n    // Might think we should do this after embedding in container so .vjs-tech class\\n    // doesn't flash 100% width/height, but class only applies with .video-js parent\\n    tag.playerId = tag.id;\\n    tag.id += '_html5_api';\\n    tag.className = 'vjs-tech';\\n\\n    // Make player findable on elements\\n    tag.player = el.player = this;\\n    // Default state of video is paused\\n    this.addClass('vjs-paused');\\n\\n    // Add a style element in the player that we'll use to set the width/height\\n    // of the player in a way that's still overrideable by CSS, just like the\\n    // video element\\n    if (_globalWindow2['default'].VIDEOJS_NO_DYNAMIC_STYLE !== true) {\\n      this.styleEl_ = stylesheet.createStyleElement('vjs-styles-dimensions');\\n      var defaultsStyleEl = Dom.$('.vjs-styles-defaults');\\n      var head = Dom.$('head');\\n      head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);\\n    }\\n\\n    // Pass in the width/height/aspectRatio options which will update the style el\\n    this.width(this.options_.width);\\n    this.height(this.options_.height);\\n    this.fluid(this.options_.fluid);\\n    this.aspectRatio(this.options_.aspectRatio);\\n\\n    // Hide any links within the video/audio tag, because IE doesn't hide them completely.\\n    var links = tag.getElementsByTagName('a');\\n    for (var i = 0; i < links.length; i++) {\\n      var linkEl = links.item(i);\\n      Dom.addElClass(linkEl, 'vjs-hidden');\\n      linkEl.setAttribute('hidden', 'hidden');\\n    }\\n\\n    // insertElFirst seems to cause the networkState to flicker from 3 to 2, so\\n    // keep track of the original for later so we can know if the source originally failed\\n    tag.initNetworkState_ = tag.networkState;\\n\\n    // Wrap video tag in div (el/box) container\\n    if (tag.parentNode) {\\n      tag.parentNode.insertBefore(el, tag);\\n    }\\n\\n    // insert the tag as the first child of the player element\\n    // then manually add it to the children array so that this.addChild\\n    // will work properly for other components\\n    Dom.insertElFirst(tag, el); // Breaks iPhone, fixed in HTML5 setup.\\n    this.children_.unshift(tag);\\n\\n    this.el_ = el;\\n\\n    return el;\\n  };\\n\\n  /**\\n   * Get/set player width\\n   *\\n   * @param {Number=} value Value for width\\n   * @return {Number} Width when getting\\n   * @method width\\n   */\\n\\n  Player.prototype.width = function width(value) {\\n    return this.dimension('width', value);\\n  };\\n\\n  /**\\n   * Get/set player height\\n   *\\n   * @param {Number=} value Value for height\\n   * @return {Number} Height when getting\\n   * @method height\\n   */\\n\\n  Player.prototype.height = function height(value) {\\n    return this.dimension('height', value);\\n  };\\n\\n  /**\\n   * Get/set dimension for player\\n   *\\n   * @param {String} dimension Either width or height\\n   * @param {Number=} value Value for dimension\\n   * @return {Component}\\n   * @method dimension\\n   */\\n\\n  Player.prototype.dimension = function dimension(_dimension, value) {\\n    var privDimension = _dimension + '_';\\n\\n    if (value === undefined) {\\n      return this[privDimension] || 0;\\n    }\\n\\n    if (value === '') {\\n      // If an empty string is given, reset the dimension to be automatic\\n      this[privDimension] = undefined;\\n    } else {\\n      var parsedVal = parseFloat(value);\\n\\n      if (isNaN(parsedVal)) {\\n        _utilsLogJs2['default'].error('Improper value \\\"' + value + '\\\" supplied for for ' + _dimension);\\n        return this;\\n      }\\n\\n      this[privDimension] = parsedVal;\\n    }\\n\\n    this.updateStyleEl_();\\n    return this;\\n  };\\n\\n  /**\\n   * Add/remove the vjs-fluid class\\n   *\\n   * @param {Boolean} bool Value of true adds the class, value of false removes the class\\n   * @method fluid\\n   */\\n\\n  Player.prototype.fluid = function fluid(bool) {\\n    if (bool === undefined) {\\n      return !!this.fluid_;\\n    }\\n\\n    this.fluid_ = !!bool;\\n\\n    if (bool) {\\n      this.addClass('vjs-fluid');\\n    } else {\\n      this.removeClass('vjs-fluid');\\n    }\\n  };\\n\\n  /**\\n   * Get/Set the aspect ratio\\n   *\\n   * @param {String=} ratio Aspect ratio for player\\n   * @return aspectRatio\\n   * @method aspectRatio\\n   */\\n\\n  Player.prototype.aspectRatio = function aspectRatio(ratio) {\\n    if (ratio === undefined) {\\n      return this.aspectRatio_;\\n    }\\n\\n    // Check for width:height format\\n    if (!/^\\\\d+\\\\:\\\\d+$/.test(ratio)) {\\n      throw new Error('Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.');\\n    }\\n    this.aspectRatio_ = ratio;\\n\\n    // We're assuming if you set an aspect ratio you want fluid mode,\\n    // because in fixed mode you could calculate width and height yourself.\\n    this.fluid(true);\\n\\n    this.updateStyleEl_();\\n  };\\n\\n  /**\\n   * Update styles of the player element (height, width and aspect ratio)\\n   *\\n   * @method updateStyleEl_\\n   */\\n\\n  Player.prototype.updateStyleEl_ = function updateStyleEl_() {\\n    if (_globalWindow2['default'].VIDEOJS_NO_DYNAMIC_STYLE === true) {\\n      var _width = typeof this.width_ === 'number' ? this.width_ : this.options_.width;\\n      var _height = typeof this.height_ === 'number' ? this.height_ : this.options_.height;\\n      var techEl = this.tech_ && this.tech_.el();\\n\\n      if (techEl) {\\n        if (_width >= 0) {\\n          techEl.width = _width;\\n        }\\n        if (_height >= 0) {\\n          techEl.height = _height;\\n        }\\n      }\\n\\n      return;\\n    }\\n\\n    var width = undefined;\\n    var height = undefined;\\n    var aspectRatio = undefined;\\n    var idClass = undefined;\\n\\n    // The aspect ratio is either used directly or to calculate width and height.\\n    if (this.aspectRatio_ !== undefined && this.aspectRatio_ !== 'auto') {\\n      // Use any aspectRatio that's been specifically set\\n      aspectRatio = this.aspectRatio_;\\n    } else if (this.videoWidth()) {\\n      // Otherwise try to get the aspect ratio from the video metadata\\n      aspectRatio = this.videoWidth() + ':' + this.videoHeight();\\n    } else {\\n      // Or use a default. The video element's is 2:1, but 16:9 is more common.\\n      aspectRatio = '16:9';\\n    }\\n\\n    // Get the ratio as a decimal we can use to calculate dimensions\\n    var ratioParts = aspectRatio.split(':');\\n    var ratioMultiplier = ratioParts[1] / ratioParts[0];\\n\\n    if (this.width_ !== undefined) {\\n      // Use any width that's been specifically set\\n      width = this.width_;\\n    } else if (this.height_ !== undefined) {\\n      // Or calulate the width from the aspect ratio if a height has been set\\n      width = this.height_ / ratioMultiplier;\\n    } else {\\n      // Or use the video's metadata, or use the video el's default of 300\\n      width = this.videoWidth() || 300;\\n    }\\n\\n    if (this.height_ !== undefined) {\\n      // Use any height that's been specifically set\\n      height = this.height_;\\n    } else {\\n      // Otherwise calculate the height from the ratio and the width\\n      height = width * ratioMultiplier;\\n    }\\n\\n    // Ensure the CSS class is valid by starting with an alpha character\\n    if (/^[^a-zA-Z]/.test(this.id())) {\\n      idClass = 'dimensions-' + this.id();\\n    } else {\\n      idClass = this.id() + '-dimensions';\\n    }\\n\\n    // Ensure the right class is still on the player for the style element\\n    this.addClass(idClass);\\n\\n    stylesheet.setTextContent(this.styleEl_, '\\\\n      .' + idClass + ' {\\\\n        width: ' + width + 'px;\\\\n        height: ' + height + 'px;\\\\n      }\\\\n\\\\n      .' + idClass + '.vjs-fluid {\\\\n        padding-top: ' + ratioMultiplier * 100 + '%;\\\\n      }\\\\n    ');\\n  };\\n\\n  /**\\n   * Load the Media Playback Technology (tech)\\n   * Load/Create an instance of playback technology including element and API methods\\n   * And append playback element in player div.\\n   *\\n   * @param {String} techName Name of the playback technology\\n   * @param {String} source Video source\\n   * @method loadTech_\\n   * @private\\n   */\\n\\n  Player.prototype.loadTech_ = function loadTech_(techName, source) {\\n\\n    // Pause and remove current playback technology\\n    if (this.tech_) {\\n      this.unloadTech_();\\n    }\\n\\n    // get rid of the HTML5 video tag as soon as we are using another tech\\n    if (techName !== 'Html5' && this.tag) {\\n      _techTechJs2['default'].getTech('Html5').disposeMediaElement(this.tag);\\n      this.tag.player = null;\\n      this.tag = null;\\n    }\\n\\n    this.techName_ = techName;\\n\\n    // Turn off API access because we're loading a new tech that might load asynchronously\\n    this.isReady_ = false;\\n\\n    // Grab tech-specific options from player options and add source and parent element to use.\\n    var techOptions = _objectAssign2['default']({\\n      'nativeControlsForTouch': this.options_.nativeControlsForTouch,\\n      'source': source,\\n      'playerId': this.id(),\\n      'techId': this.id() + '_' + techName + '_api',\\n      'videoTracks': this.videoTracks_,\\n      'textTracks': this.textTracks_,\\n      'audioTracks': this.audioTracks_,\\n      'autoplay': this.options_.autoplay,\\n      'preload': this.options_.preload,\\n      'loop': this.options_.loop,\\n      'muted': this.options_.muted,\\n      'poster': this.poster(),\\n      'language': this.language(),\\n      'vtt.js': this.options_['vtt.js']\\n    }, this.options_[techName.toLowerCase()]);\\n\\n    if (this.tag) {\\n      techOptions.tag = this.tag;\\n    }\\n\\n    if (source) {\\n      this.currentType_ = source.type;\\n      if (source.src === this.cache_.src && this.cache_.currentTime > 0) {\\n        techOptions.startTime = this.cache_.currentTime;\\n      }\\n\\n      this.cache_.src = source.src;\\n    }\\n\\n    // Initialize tech instance\\n    var techComponent = _techTechJs2['default'].getTech(techName);\\n    // Support old behavior of techs being registered as components.\\n    // Remove once that deprecated behavior is removed.\\n    if (!techComponent) {\\n      techComponent = _componentJs2['default'].getComponent(techName);\\n    }\\n    this.tech_ = new techComponent(techOptions);\\n\\n    // player.triggerReady is always async, so don't need this to be async\\n    this.tech_.ready(Fn.bind(this, this.handleTechReady_), true);\\n\\n    _tracksTextTrackListConverterJs2['default'].jsonToTextTracks(this.textTracksJson_ || [], this.tech_);\\n\\n    // Listen to all HTML5-defined events and trigger them on the player\\n    this.on(this.tech_, 'loadstart', this.handleTechLoadStart_);\\n    this.on(this.tech_, 'waiting', this.handleTechWaiting_);\\n    this.on(this.tech_, 'canplay', this.handleTechCanPlay_);\\n    this.on(this.tech_, 'canplaythrough', this.handleTechCanPlayThrough_);\\n    this.on(this.tech_, 'playing', this.handleTechPlaying_);\\n    this.on(this.tech_, 'ended', this.handleTechEnded_);\\n    this.on(this.tech_, 'seeking', this.handleTechSeeking_);\\n    this.on(this.tech_, 'seeked', this.handleTechSeeked_);\\n    this.on(this.tech_, 'play', this.handleTechPlay_);\\n    this.on(this.tech_, 'firstplay', this.handleTechFirstPlay_);\\n    this.on(this.tech_, 'pause', this.handleTechPause_);\\n    this.on(this.tech_, 'progress', this.handleTechProgress_);\\n    this.on(this.tech_, 'durationchange', this.handleTechDurationChange_);\\n    this.on(this.tech_, 'fullscreenchange', this.handleTechFullscreenChange_);\\n    this.on(this.tech_, 'error', this.handleTechError_);\\n    this.on(this.tech_, 'suspend', this.handleTechSuspend_);\\n    this.on(this.tech_, 'abort', this.handleTechAbort_);\\n    this.on(this.tech_, 'emptied', this.handleTechEmptied_);\\n    this.on(this.tech_, 'stalled', this.handleTechStalled_);\\n    this.on(this.tech_, 'loadedmetadata', this.handleTechLoadedMetaData_);\\n    this.on(this.tech_, 'loadeddata', this.handleTechLoadedData_);\\n    this.on(this.tech_, 'timeupdate', this.handleTechTimeUpdate_);\\n    this.on(this.tech_, 'ratechange', this.handleTechRateChange_);\\n    this.on(this.tech_, 'volumechange', this.handleTechVolumeChange_);\\n    this.on(this.tech_, 'texttrackchange', this.handleTechTextTrackChange_);\\n    this.on(this.tech_, 'loadedmetadata', this.updateStyleEl_);\\n    this.on(this.tech_, 'posterchange', this.handleTechPosterChange_);\\n    this.on(this.tech_, 'textdata', this.handleTechTextData_);\\n\\n    this.usingNativeControls(this.techGet_('controls'));\\n\\n    if (this.controls() && !this.usingNativeControls()) {\\n      this.addTechControlsListeners_();\\n    }\\n\\n    // Add the tech element in the DOM if it was not already there\\n    // Make sure to not insert the original video element if using Html5\\n    if (this.tech_.el().parentNode !== this.el() && (techName !== 'Html5' || !this.tag)) {\\n      Dom.insertElFirst(this.tech_.el(), this.el());\\n    }\\n\\n    // Get rid of the original video tag reference after the first tech is loaded\\n    if (this.tag) {\\n      this.tag.player = null;\\n      this.tag = null;\\n    }\\n  };\\n\\n  /**\\n   * Unload playback technology\\n   *\\n   * @method unloadTech_\\n   * @private\\n   */\\n\\n  Player.prototype.unloadTech_ = function unloadTech_() {\\n    // Save the current text tracks so that we can reuse the same text tracks with the next tech\\n    this.videoTracks_ = this.videoTracks();\\n    this.textTracks_ = this.textTracks();\\n    this.audioTracks_ = this.audioTracks();\\n    this.textTracksJson_ = _tracksTextTrackListConverterJs2['default'].textTracksToJson(this.tech_);\\n\\n    this.isReady_ = false;\\n\\n    this.tech_.dispose();\\n\\n    this.tech_ = false;\\n  };\\n\\n  /**\\n   * Return a reference to the current tech.\\n   * It will only return a reference to the tech if given an object with the\\n   * `IWillNotUseThisInPlugins` property on it. This is try and prevent misuse\\n   * of techs by plugins.\\n   *\\n   * @param {Object}\\n   * @return {Object} The Tech\\n   * @method tech\\n   */\\n\\n  Player.prototype.tech = function tech(safety) {\\n    if (safety && safety.IWillNotUseThisInPlugins) {\\n      return this.tech_;\\n    }\\n    var errorText = '\\\\n      Please make sure that you are not using this inside of a plugin.\\\\n      To disable this alert and error, please pass in an object with\\\\n      `IWillNotUseThisInPlugins` to the `tech` method. See\\\\n      https://github.com/videojs/video.js/issues/2617 for more info.\\\\n    ';\\n    _globalWindow2['default'].alert(errorText);\\n    throw new Error(errorText);\\n  };\\n\\n  /**\\n   * Set up click and touch listeners for the playback element\\n   *\\n   * On desktops, a click on the video itself will toggle playback,\\n   * on a mobile device a click on the video toggles controls.\\n   * (toggling controls is done by toggling the user state between active and\\n   * inactive)\\n   * A tap can signal that a user has become active, or has become inactive\\n   * e.g. a quick tap on an iPhone movie should reveal the controls. Another\\n   * quick tap should hide them again (signaling the user is in an inactive\\n   * viewing state)\\n   * In addition to this, we still want the user to be considered inactive after\\n   * a few seconds of inactivity.\\n   * Note: the only part of iOS interaction we can't mimic with this setup\\n   * is a touch and hold on the video element counting as activity in order to\\n   * keep the controls showing, but that shouldn't be an issue. A touch and hold\\n   * on any controls will still keep the user active\\n   *\\n   * @private\\n   * @method addTechControlsListeners_\\n   */\\n\\n  Player.prototype.addTechControlsListeners_ = function addTechControlsListeners_() {\\n    // Make sure to remove all the previous listeners in case we are called multiple times.\\n    this.removeTechControlsListeners_();\\n\\n    // Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do\\n    // trigger mousedown/up.\\n    // http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object\\n    // Any touch events are set to block the mousedown event from happening\\n    this.on(this.tech_, 'mousedown', this.handleTechClick_);\\n\\n    // If the controls were hidden we don't want that to change without a tap event\\n    // so we'll check if the controls were already showing before reporting user\\n    // activity\\n    this.on(this.tech_, 'touchstart', this.handleTechTouchStart_);\\n    this.on(this.tech_, 'touchmove', this.handleTechTouchMove_);\\n    this.on(this.tech_, 'touchend', this.handleTechTouchEnd_);\\n\\n    // The tap listener needs to come after the touchend listener because the tap\\n    // listener cancels out any reportedUserActivity when setting userActive(false)\\n    this.on(this.tech_, 'tap', this.handleTechTap_);\\n  };\\n\\n  /**\\n   * Remove the listeners used for click and tap controls. This is needed for\\n   * toggling to controls disabled, where a tap/touch should do nothing.\\n   *\\n   * @method removeTechControlsListeners_\\n   * @private\\n   */\\n\\n  Player.prototype.removeTechControlsListeners_ = function removeTechControlsListeners_() {\\n    // We don't want to just use `this.off()` because there might be other needed\\n    // listeners added by techs that extend this.\\n    this.off(this.tech_, 'tap', this.handleTechTap_);\\n    this.off(this.tech_, 'touchstart', this.handleTechTouchStart_);\\n    this.off(this.tech_, 'touchmove', this.handleTechTouchMove_);\\n    this.off(this.tech_, 'touchend', this.handleTechTouchEnd_);\\n    this.off(this.tech_, 'mousedown', this.handleTechClick_);\\n  };\\n\\n  /**\\n   * Player waits for the tech to be ready\\n   *\\n   * @method handleTechReady_\\n   * @private\\n   */\\n\\n  Player.prototype.handleTechReady_ = function handleTechReady_() {\\n    this.triggerReady();\\n\\n    // Keep the same volume as before\\n    if (this.cache_.volume) {\\n      this.techCall_('setVolume', this.cache_.volume);\\n    }\\n\\n    // Look if the tech found a higher resolution poster while loading\\n    this.handleTechPosterChange_();\\n\\n    // Update the duration if available\\n    this.handleTechDurationChange_();\\n\\n    // Chrome and Safari both have issues with autoplay.\\n    // In Safari (5.1.1), when we move the video element into the container div, autoplay doesn't work.\\n    // In Chrome (15), if you have autoplay + a poster + no controls, the video gets hidden (but audio plays)\\n    // This fixes both issues. Need to wait for API, so it updates displays correctly\\n    if ((this.src() || this.currentSrc()) && this.tag && this.options_.autoplay && this.paused()) {\\n      try {\\n        delete this.tag.poster; // Chrome Fix. Fixed in Chrome v16.\\n      } catch (e) {\\n        _utilsLogJs2['default']('deleting tag.poster throws in some browsers', e);\\n      }\\n      this.play();\\n    }\\n  };\\n\\n  /**\\n   * Fired when the user agent begins looking for media data\\n   *\\n   * @private\\n   * @method handleTechLoadStart_\\n   */\\n\\n  Player.prototype.handleTechLoadStart_ = function handleTechLoadStart_() {\\n    // TODO: Update to use `emptied` event instead. See #1277.\\n\\n    this.removeClass('vjs-ended');\\n\\n    // reset the error state\\n    this.error(null);\\n\\n    // If it's already playing we want to trigger a firstplay event now.\\n    // The firstplay event relies on both the play and loadstart events\\n    // which can happen in any order for a new source\\n    if (!this.paused()) {\\n      this.trigger('loadstart');\\n      this.trigger('firstplay');\\n    } else {\\n      // reset the hasStarted state\\n      this.hasStarted(false);\\n      this.trigger('loadstart');\\n    }\\n  };\\n\\n  /**\\n   * Add/remove the vjs-has-started class\\n   *\\n   * @param {Boolean} hasStarted The value of true adds the class the value of false remove the class\\n   * @return {Boolean} Boolean value if has started\\n   * @private\\n   * @method hasStarted\\n   */\\n\\n  Player.prototype.hasStarted = function hasStarted(_hasStarted) {\\n    if (_hasStarted !== undefined) {\\n      // only update if this is a new value\\n      if (this.hasStarted_ !== _hasStarted) {\\n        this.hasStarted_ = _hasStarted;\\n        if (_hasStarted) {\\n          this.addClass('vjs-has-started');\\n          // trigger the firstplay event if this newly has played\\n          this.trigger('firstplay');\\n        } else {\\n          this.removeClass('vjs-has-started');\\n        }\\n      }\\n      return this;\\n    }\\n    return !!this.hasStarted_;\\n  };\\n\\n  /**\\n   * Fired whenever the media begins or resumes playback\\n   *\\n   * @private\\n   * @method handleTechPlay_\\n   */\\n\\n  Player.prototype.handleTechPlay_ = function handleTechPlay_() {\\n    this.removeClass('vjs-ended');\\n    this.removeClass('vjs-paused');\\n    this.addClass('vjs-playing');\\n\\n    // hide the poster when the user hits play\\n    // https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play\\n    this.hasStarted(true);\\n\\n    this.trigger('play');\\n  };\\n\\n  /**\\n   * Fired whenever the media begins waiting\\n   *\\n   * @private\\n   * @method handleTechWaiting_\\n   */\\n\\n  Player.prototype.handleTechWaiting_ = function handleTechWaiting_() {\\n    var _this2 = this;\\n\\n    this.addClass('vjs-waiting');\\n    this.trigger('waiting');\\n    this.one('timeupdate', function () {\\n      return _this2.removeClass('vjs-waiting');\\n    });\\n  };\\n\\n  /**\\n   * A handler for events that signal that waiting has ended\\n   * which is not consistent between browsers. See #1351\\n   *\\n   * @private\\n   * @method handleTechCanPlay_\\n   */\\n\\n  Player.prototype.handleTechCanPlay_ = function handleTechCanPlay_() {\\n    this.removeClass('vjs-waiting');\\n    this.trigger('canplay');\\n  };\\n\\n  /**\\n   * A handler for events that signal that waiting has ended\\n   * which is not consistent between browsers. See #1351\\n   *\\n   * @private\\n   * @method handleTechCanPlayThrough_\\n   */\\n\\n  Player.prototype.handleTechCanPlayThrough_ = function handleTechCanPlayThrough_() {\\n    this.removeClass('vjs-waiting');\\n    this.trigger('canplaythrough');\\n  };\\n\\n  /**\\n   * A handler for events that signal that waiting has ended\\n   * which is not consistent between browsers. See #1351\\n   *\\n   * @private\\n   * @method handleTechPlaying_\\n   */\\n\\n  Player.prototype.handleTechPlaying_ = function handleTechPlaying_() {\\n    this.removeClass('vjs-waiting');\\n    this.trigger('playing');\\n  };\\n\\n  /**\\n   * Fired whenever the player is jumping to a new time\\n   *\\n   * @private\\n   * @method handleTechSeeking_\\n   */\\n\\n  Player.prototype.handleTechSeeking_ = function handleTechSeeking_() {\\n    this.addClass('vjs-seeking');\\n    this.trigger('seeking');\\n  };\\n\\n  /**\\n   * Fired when the player has finished jumping to a new time\\n   *\\n   * @private\\n   * @method handleTechSeeked_\\n   */\\n\\n  Player.prototype.handleTechSeeked_ = function handleTechSeeked_() {\\n    this.removeClass('vjs-seeking');\\n    this.trigger('seeked');\\n  };\\n\\n  /**\\n   * Fired the first time a video is played\\n   * Not part of the HLS spec, and we're not sure if this is the best\\n   * implementation yet, so use sparingly. If you don't have a reason to\\n   * prevent playback, use `myPlayer.one('play');` instead.\\n   *\\n   * @private\\n   * @method handleTechFirstPlay_\\n   */\\n\\n  Player.prototype.handleTechFirstPlay_ = function handleTechFirstPlay_() {\\n    //If the first starttime attribute is specified\\n    //then we will start at the given offset in seconds\\n    if (this.options_.starttime) {\\n      this.currentTime(this.options_.starttime);\\n    }\\n\\n    this.addClass('vjs-has-started');\\n    this.trigger('firstplay');\\n  };\\n\\n  /**\\n   * Fired whenever the media has been paused\\n   *\\n   * @private\\n   * @method handleTechPause_\\n   */\\n\\n  Player.prototype.handleTechPause_ = function handleTechPause_() {\\n    this.removeClass('vjs-playing');\\n    this.addClass('vjs-paused');\\n    this.trigger('pause');\\n  };\\n\\n  /**\\n   * Fired while the user agent is downloading media data\\n   *\\n   * @private\\n   * @method handleTechProgress_\\n   */\\n\\n  Player.prototype.handleTechProgress_ = function handleTechProgress_() {\\n    this.trigger('progress');\\n  };\\n\\n  /**\\n   * Fired when the end of the media resource is reached (currentTime == duration)\\n   *\\n   * @private\\n   * @method handleTechEnded_\\n   */\\n\\n  Player.prototype.handleTechEnded_ = function handleTechEnded_() {\\n    this.addClass('vjs-ended');\\n    if (this.options_.loop) {\\n      this.currentTime(0);\\n      this.play();\\n    } else if (!this.paused()) {\\n      this.pause();\\n    }\\n\\n    this.trigger('ended');\\n  };\\n\\n  /**\\n   * Fired when the duration of the media resource is first known or changed\\n   *\\n   * @private\\n   * @method handleTechDurationChange_\\n   */\\n\\n  Player.prototype.handleTechDurationChange_ = function handleTechDurationChange_() {\\n    this.duration(this.techGet_('duration'));\\n  };\\n\\n  /**\\n   * Handle a click on the media element to play/pause\\n   *\\n   * @param {Object=} event Event object\\n   * @private\\n   * @method handleTechClick_\\n   */\\n\\n  Player.prototype.handleTechClick_ = function handleTechClick_(event) {\\n    // We're using mousedown to detect clicks thanks to Flash, but mousedown\\n    // will also be triggered with right-clicks, so we need to prevent that\\n    if (event.button !== 0) return;\\n\\n    // When controls are disabled a click should not toggle playback because\\n    // the click is considered a control\\n    if (this.controls()) {\\n      if (this.paused()) {\\n        this.play();\\n      } else {\\n        this.pause();\\n      }\\n    }\\n  };\\n\\n  /**\\n   * Handle a tap on the media element. It will toggle the user\\n   * activity state, which hides and shows the controls.\\n   *\\n   * @private\\n   * @method handleTechTap_\\n   */\\n\\n  Player.prototype.handleTechTap_ = function handleTechTap_() {\\n    this.userActive(!this.userActive());\\n  };\\n\\n  /**\\n   * Handle touch to start\\n   *\\n   * @private\\n   * @method handleTechTouchStart_\\n   */\\n\\n  Player.prototype.handleTechTouchStart_ = function handleTechTouchStart_() {\\n    this.userWasActive = this.userActive();\\n  };\\n\\n  /**\\n   * Handle touch to move\\n   *\\n   * @private\\n   * @method handleTechTouchMove_\\n   */\\n\\n  Player.prototype.handleTechTouchMove_ = function handleTechTouchMove_() {\\n    if (this.userWasActive) {\\n      this.reportUserActivity();\\n    }\\n  };\\n\\n  /**\\n   * Handle touch to end\\n   *\\n   * @private\\n   * @method handleTechTouchEnd_\\n   */\\n\\n  Player.prototype.handleTechTouchEnd_ = function handleTechTouchEnd_(event) {\\n    // Stop the mouse events from also happening\\n    event.preventDefault();\\n  };\\n\\n  /**\\n   * Fired when the player switches in or out of fullscreen mode\\n   *\\n   * @private\\n   * @method handleFullscreenChange_\\n   */\\n\\n  Player.prototype.handleFullscreenChange_ = function handleFullscreenChange_() {\\n    if (this.isFullscreen()) {\\n      this.addClass('vjs-fullscreen');\\n    } else {\\n      this.removeClass('vjs-fullscreen');\\n    }\\n  };\\n\\n  /**\\n   * native click events on the SWF aren't triggered on IE11, Win8.1RT\\n   * use stageclick events triggered from inside the SWF instead\\n   *\\n   * @private\\n   * @method handleStageClick_\\n   */\\n\\n  Player.prototype.handleStageClick_ = function handleStageClick_() {\\n    this.reportUserActivity();\\n  };\\n\\n  /**\\n   * Handle Tech Fullscreen Change\\n   *\\n   * @private\\n   * @method handleTechFullscreenChange_\\n   */\\n\\n  Player.prototype.handleTechFullscreenChange_ = function handleTechFullscreenChange_(event, data) {\\n    if (data) {\\n      this.isFullscreen(data.isFullscreen);\\n    }\\n    this.trigger('fullscreenchange');\\n  };\\n\\n  /**\\n   * Fires when an error occurred during the loading of an audio/video\\n   *\\n   * @private\\n   * @method handleTechError_\\n   */\\n\\n  Player.prototype.handleTechError_ = function handleTechError_() {\\n    var error = this.tech_.error();\\n    this.error(error);\\n  };\\n\\n  /**\\n   * Fires when the browser is intentionally not getting media data\\n   *\\n   * @private\\n   * @method handleTechSuspend_\\n   */\\n\\n  Player.prototype.handleTechSuspend_ = function handleTechSuspend_() {\\n    this.trigger('suspend');\\n  };\\n\\n  /**\\n   * Fires when the loading of an audio/video is aborted\\n   *\\n   * @private\\n   * @method handleTechAbort_\\n   */\\n\\n  Player.prototype.handleTechAbort_ = function handleTechAbort_() {\\n    this.trigger('abort');\\n  };\\n\\n  /**\\n   * Fires when the current playlist is empty\\n   *\\n   * @private\\n   * @method handleTechEmptied_\\n   */\\n\\n  Player.prototype.handleTechEmptied_ = function handleTechEmptied_() {\\n    this.trigger('emptied');\\n  };\\n\\n  /**\\n   * Fires when the browser is trying to get media data, but data is not available\\n   *\\n   * @private\\n   * @method handleTechStalled_\\n   */\\n\\n  Player.prototype.handleTechStalled_ = function handleTechStalled_() {\\n    this.trigger('stalled');\\n  };\\n\\n  /**\\n   * Fires when the browser has loaded meta data for the audio/video\\n   *\\n   * @private\\n   * @method handleTechLoadedMetaData_\\n   */\\n\\n  Player.prototype.handleTechLoadedMetaData_ = function handleTechLoadedMetaData_() {\\n    this.trigger('loadedmetadata');\\n  };\\n\\n  Player.prototype.handleTechTextData_ = function handleTechTextData_() {\\n    var data = null;\\n    if (arguments.length > 1) {\\n      data = arguments[1];\\n    }\\n    this.trigger('textdata', data);\\n  };\\n\\n  /**\\n   * Fires when the browser has loaded the current frame of the audio/video\\n   *\\n   * @private\\n   * @method handleTechLoadedData_\\n   */\\n\\n  Player.prototype.handleTechLoadedData_ = function handleTechLoadedData_() {\\n    this.trigger('loadeddata');\\n  };\\n\\n  /**\\n   * Fires when the current playback position has changed\\n   *\\n   * @private\\n   * @method handleTechTimeUpdate_\\n   */\\n\\n  Player.prototype.handleTechTimeUpdate_ = function handleTechTimeUpdate_() {\\n    this.trigger('timeupdate');\\n  };\\n\\n  /**\\n   * Fires when the playing speed of the audio/video is changed\\n   *\\n   * @private\\n   * @method handleTechRateChange_\\n   */\\n\\n  Player.prototype.handleTechRateChange_ = function handleTechRateChange_() {\\n    this.trigger('ratechange');\\n  };\\n\\n  /**\\n   * Fires when the volume has been changed\\n   *\\n   * @private\\n   * @method handleTechVolumeChange_\\n   */\\n\\n  Player.prototype.handleTechVolumeChange_ = function handleTechVolumeChange_() {\\n    this.trigger('volumechange');\\n  };\\n\\n  /**\\n   * Fires when the text track has been changed\\n   *\\n   * @private\\n   * @method handleTechTextTrackChange_\\n   */\\n\\n  Player.prototype.handleTechTextTrackChange_ = function handleTechTextTrackChange_() {\\n    this.trigger('texttrackchange');\\n  };\\n\\n  /**\\n   * Get object for cached values.\\n   *\\n   * @return {Object}\\n   * @method getCache\\n   */\\n\\n  Player.prototype.getCache = function getCache() {\\n    return this.cache_;\\n  };\\n\\n  /**\\n   * Pass values to the playback tech\\n   *\\n   * @param {String=} method Method\\n   * @param {Object=} arg Argument\\n   * @private\\n   * @method techCall_\\n   */\\n\\n  Player.prototype.techCall_ = function techCall_(method, arg) {\\n    // If it's not ready yet, call method when it is\\n    if (this.tech_ && !this.tech_.isReady_) {\\n      this.tech_.ready(function () {\\n        this[method](arg);\\n      }, true);\\n\\n      // Otherwise call method now\\n    } else {\\n        try {\\n          this.tech_ && this.tech_[method](arg);\\n        } catch (e) {\\n          _utilsLogJs2['default'](e);\\n          throw e;\\n        }\\n      }\\n  };\\n\\n  /**\\n   * Get calls can't wait for the tech, and sometimes don't need to.\\n   *\\n   * @param {String} method Tech method\\n   * @return {Method}\\n   * @private\\n   * @method techGet_\\n   */\\n\\n  Player.prototype.techGet_ = function techGet_(method) {\\n    if (this.tech_ && this.tech_.isReady_) {\\n\\n      // Flash likes to die and reload when you hide or reposition it.\\n      // In these cases the object methods go away and we get errors.\\n      // When that happens we'll catch the errors and inform tech that it's not ready any more.\\n      try {\\n        return this.tech_[method]();\\n      } catch (e) {\\n        // When building additional tech libs, an expected method may not be defined yet\\n        if (this.tech_[method] === undefined) {\\n          _utilsLogJs2['default']('Video.js: ' + method + ' method not defined for ' + this.techName_ + ' playback technology.', e);\\n        } else {\\n          // When a method isn't available on the object it throws a TypeError\\n          if (e.name === 'TypeError') {\\n            _utilsLogJs2['default']('Video.js: ' + method + ' unavailable on ' + this.techName_ + ' playback technology element.', e);\\n            this.tech_.isReady_ = false;\\n          } else {\\n            _utilsLogJs2['default'](e);\\n          }\\n        }\\n        throw e;\\n      }\\n    }\\n\\n    return;\\n  };\\n\\n  /**\\n   * start media playback\\n   * ```js\\n   *     myPlayer.play();\\n   * ```\\n   *\\n   * @return {Player} self\\n   * @method play\\n   */\\n\\n  Player.prototype.play = function play() {\\n    // Only calls the tech's play if we already have a src loaded\\n    if (this.src() || this.currentSrc()) {\\n      this.techCall_('play');\\n    } else {\\n      this.tech_.one('loadstart', function () {\\n        this.play();\\n      });\\n    }\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Pause the video playback\\n   * ```js\\n   *     myPlayer.pause();\\n   * ```\\n   *\\n   * @return {Player} self\\n   * @method pause\\n   */\\n\\n  Player.prototype.pause = function pause() {\\n    this.techCall_('pause');\\n    return this;\\n  };\\n\\n  /**\\n   * Check if the player is paused\\n   * ```js\\n   *     var isPaused = myPlayer.paused();\\n   *     var isPlaying = !myPlayer.paused();\\n   * ```\\n   *\\n   * @return {Boolean} false if the media is currently playing, or true otherwise\\n   * @method paused\\n   */\\n\\n  Player.prototype.paused = function paused() {\\n    // The initial state of paused should be true (in Safari it's actually false)\\n    return this.techGet_('paused') === false ? false : true;\\n  };\\n\\n  /**\\n   * Returns whether or not the user is \\\"scrubbing\\\". Scrubbing is when the user\\n   * has clicked the progress bar handle and is dragging it along the progress bar.\\n   *\\n   * @param  {Boolean} isScrubbing   True/false the user is scrubbing\\n   * @return {Boolean}               The scrubbing status when getting\\n   * @return {Object}                The player when setting\\n   * @method scrubbing\\n   */\\n\\n  Player.prototype.scrubbing = function scrubbing(isScrubbing) {\\n    if (isScrubbing !== undefined) {\\n      this.scrubbing_ = !!isScrubbing;\\n\\n      if (isScrubbing) {\\n        this.addClass('vjs-scrubbing');\\n      } else {\\n        this.removeClass('vjs-scrubbing');\\n      }\\n\\n      return this;\\n    }\\n\\n    return this.scrubbing_;\\n  };\\n\\n  /**\\n   * Get or set the current time (in seconds)\\n   * ```js\\n   *     // get\\n   *     var whereYouAt = myPlayer.currentTime();\\n   *     // set\\n   *     myPlayer.currentTime(120); // 2 minutes into the video\\n   * ```\\n   *\\n   * @param  {Number|String=} seconds The time to seek to\\n   * @return {Number}        The time in seconds, when not setting\\n   * @return {Player}    self, when the current time is set\\n   * @method currentTime\\n   */\\n\\n  Player.prototype.currentTime = function currentTime(seconds) {\\n    if (seconds !== undefined) {\\n\\n      this.techCall_('setCurrentTime', seconds);\\n\\n      return this;\\n    }\\n\\n    // cache last currentTime and return. default to 0 seconds\\n    //\\n    // Caching the currentTime is meant to prevent a massive amount of reads on the tech's\\n    // currentTime when scrubbing, but may not provide much performance benefit afterall.\\n    // Should be tested. Also something has to read the actual current time or the cache will\\n    // never get updated.\\n    return this.cache_.currentTime = this.techGet_('currentTime') || 0;\\n  };\\n\\n  /**\\n   * Normally gets the length in time of the video in seconds;\\n   * in all but the rarest use cases an argument will NOT be passed to the method\\n   * ```js\\n   *     var lengthOfVideo = myPlayer.duration();\\n   * ```\\n   * **NOTE**: The video must have started loading before the duration can be\\n   * known, and in the case of Flash, may not be known until the video starts\\n   * playing.\\n   *\\n   * @param {Number} seconds Duration when setting\\n   * @return {Number} The duration of the video in seconds when getting\\n   * @method duration\\n   */\\n\\n  Player.prototype.duration = function duration(seconds) {\\n    if (seconds === undefined) {\\n      return this.cache_.duration || 0;\\n    }\\n\\n    seconds = parseFloat(seconds) || 0;\\n\\n    // Standardize on Inifity for signaling video is live\\n    if (seconds < 0) {\\n      seconds = Infinity;\\n    }\\n\\n    if (seconds !== this.cache_.duration) {\\n      // Cache the last set value for optimized scrubbing (esp. Flash)\\n      this.cache_.duration = seconds;\\n\\n      if (seconds === Infinity) {\\n        this.addClass('vjs-live');\\n      } else {\\n        this.removeClass('vjs-live');\\n      }\\n\\n      this.trigger('durationchange');\\n    }\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Calculates how much time is left.\\n   * ```js\\n   *     var timeLeft = myPlayer.remainingTime();\\n   * ```\\n   * Not a native video element function, but useful\\n   *\\n   * @return {Number} The time remaining in seconds\\n   * @method remainingTime\\n   */\\n\\n  Player.prototype.remainingTime = function remainingTime() {\\n    return this.duration() - this.currentTime();\\n  };\\n\\n  // http://dev.w3.org/html5/spec/video.html#dom-media-buffered\\n  // Buffered returns a timerange object.\\n  // Kind of like an array of portions of the video that have been downloaded.\\n\\n  /**\\n   * Get a TimeRange object with the times of the video that have been downloaded\\n   * If you just want the percent of the video that's been downloaded,\\n   * use bufferedPercent.\\n   * ```js\\n   *     // Number of different ranges of time have been buffered. Usually 1.\\n   *     numberOfRanges = bufferedTimeRange.length,\\n   *     // Time in seconds when the first range starts. Usually 0.\\n   *     firstRangeStart = bufferedTimeRange.start(0),\\n   *     // Time in seconds when the first range ends\\n   *     firstRangeEnd = bufferedTimeRange.end(0),\\n   *     // Length in seconds of the first time range\\n   *     firstRangeLength = firstRangeEnd - firstRangeStart;\\n   * ```\\n   *\\n   * @return {Object} A mock TimeRange object (following HTML spec)\\n   * @method buffered\\n   */\\n\\n  Player.prototype.buffered = function buffered() {\\n    var buffered = this.techGet_('buffered');\\n\\n    if (!buffered || !buffered.length) {\\n      buffered = _utilsTimeRangesJs.createTimeRange(0, 0);\\n    }\\n\\n    return buffered;\\n  };\\n\\n  /**\\n   * Get the percent (as a decimal) of the video that's been downloaded\\n   * ```js\\n   *     var howMuchIsDownloaded = myPlayer.bufferedPercent();\\n   * ```\\n   * 0 means none, 1 means all.\\n   * (This method isn't in the HTML5 spec, but it's very convenient)\\n   *\\n   * @return {Number} A decimal between 0 and 1 representing the percent\\n   * @method bufferedPercent\\n   */\\n\\n  Player.prototype.bufferedPercent = function bufferedPercent() {\\n    return _utilsBufferJs.bufferedPercent(this.buffered(), this.duration());\\n  };\\n\\n  /**\\n   * Get the ending time of the last buffered time range\\n   * This is used in the progress bar to encapsulate all time ranges.\\n   *\\n   * @return {Number} The end of the last buffered time range\\n   * @method bufferedEnd\\n   */\\n\\n  Player.prototype.bufferedEnd = function bufferedEnd() {\\n    var buffered = this.buffered(),\\n        duration = this.duration(),\\n        end = buffered.end(buffered.length - 1);\\n\\n    if (end > duration) {\\n      end = duration;\\n    }\\n\\n    return end;\\n  };\\n\\n  /**\\n   * Get or set the current volume of the media\\n   * ```js\\n   *     // get\\n   *     var howLoudIsIt = myPlayer.volume();\\n   *     // set\\n   *     myPlayer.volume(0.5); // Set volume to half\\n   * ```\\n   * 0 is off (muted), 1.0 is all the way up, 0.5 is half way.\\n   *\\n   * @param  {Number} percentAsDecimal The new volume as a decimal percent\\n   * @return {Number}              The current volume when getting\\n   * @return {Player}              self when setting\\n   * @method volume\\n   */\\n\\n  Player.prototype.volume = function volume(percentAsDecimal) {\\n    var vol = undefined;\\n\\n    if (percentAsDecimal !== undefined) {\\n      vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal))); // Force value to between 0 and 1\\n      this.cache_.volume = vol;\\n      this.techCall_('setVolume', vol);\\n\\n      return this;\\n    }\\n\\n    // Default to 1 when returning current volume.\\n    vol = parseFloat(this.techGet_('volume'));\\n    return isNaN(vol) ? 1 : vol;\\n  };\\n\\n  /**\\n   * Get the current muted state, or turn mute on or off\\n   * ```js\\n   *     // get\\n   *     var isVolumeMuted = myPlayer.muted();\\n   *     // set\\n   *     myPlayer.muted(true); // mute the volume\\n   * ```\\n   *\\n   * @param  {Boolean=} muted True to mute, false to unmute\\n   * @return {Boolean} True if mute is on, false if not when getting\\n   * @return {Player} self when setting mute\\n   * @method muted\\n   */\\n\\n  Player.prototype.muted = function muted(_muted) {\\n    if (_muted !== undefined) {\\n      this.techCall_('setMuted', _muted);\\n      return this;\\n    }\\n    return this.techGet_('muted') || false; // Default to false\\n  };\\n\\n  // Check if current tech can support native fullscreen\\n  // (e.g. with built in controls like iOS, so not our flash swf)\\n  /**\\n   * Check to see if fullscreen is supported\\n   *\\n   * @return {Boolean}\\n   * @method supportsFullScreen\\n   */\\n\\n  Player.prototype.supportsFullScreen = function supportsFullScreen() {\\n    return this.techGet_('supportsFullScreen') || false;\\n  };\\n\\n  /**\\n   * Check if the player is in fullscreen mode\\n   * ```js\\n   *     // get\\n   *     var fullscreenOrNot = myPlayer.isFullscreen();\\n   *     // set\\n   *     myPlayer.isFullscreen(true); // tell the player it's in fullscreen\\n   * ```\\n   * NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official\\n   * property and instead document.fullscreenElement is used. But isFullscreen is\\n   * still a valuable property for internal player workings.\\n   *\\n   * @param  {Boolean=} isFS Update the player's fullscreen state\\n   * @return {Boolean} true if fullscreen false if not when getting\\n   * @return {Player} self when setting\\n   * @method isFullscreen\\n   */\\n\\n  Player.prototype.isFullscreen = function isFullscreen(isFS) {\\n    if (isFS !== undefined) {\\n      this.isFullscreen_ = !!isFS;\\n      return this;\\n    }\\n    return !!this.isFullscreen_;\\n  };\\n\\n  /**\\n   * Increase the size of the video to full screen\\n   * ```js\\n   *     myPlayer.requestFullscreen();\\n   * ```\\n   * In some browsers, full screen is not supported natively, so it enters\\n   * \\\"full window mode\\\", where the video fills the browser window.\\n   * In browsers and devices that support native full screen, sometimes the\\n   * browser's default controls will be shown, and not the Video.js custom skin.\\n   * This includes most mobile devices (iOS, Android) and older versions of\\n   * Safari.\\n   *\\n   * @return {Player} self\\n   * @method requestFullscreen\\n   */\\n\\n  Player.prototype.requestFullscreen = function requestFullscreen() {\\n    var fsApi = _fullscreenApiJs2['default'];\\n\\n    this.isFullscreen(true);\\n\\n    if (fsApi.requestFullscreen) {\\n      // the browser supports going fullscreen at the element level so we can\\n      // take the controls fullscreen as well as the video\\n\\n      // Trigger fullscreenchange event after change\\n      // We have to specifically add this each time, and remove\\n      // when canceling fullscreen. Otherwise if there's multiple\\n      // players on a page, they would all be reacting to the same fullscreen\\n      // events\\n      Events.on(_globalDocument2['default'], fsApi.fullscreenchange, Fn.bind(this, function documentFullscreenChange(e) {\\n        this.isFullscreen(_globalDocument2['default'][fsApi.fullscreenElement]);\\n\\n        // If cancelling fullscreen, remove event listener.\\n        if (this.isFullscreen() === false) {\\n          Events.off(_globalDocument2['default'], fsApi.fullscreenchange, documentFullscreenChange);\\n        }\\n\\n        this.trigger('fullscreenchange');\\n      }));\\n\\n      this.el_[fsApi.requestFullscreen]();\\n    } else if (this.tech_.supportsFullScreen()) {\\n      // we can't take the video.js controls fullscreen but we can go fullscreen\\n      // with native controls\\n      this.techCall_('enterFullScreen');\\n    } else {\\n      // fullscreen isn't supported so we'll just stretch the video element to\\n      // fill the viewport\\n      this.enterFullWindow();\\n      this.trigger('fullscreenchange');\\n    }\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Return the video to its normal size after having been in full screen mode\\n   * ```js\\n   *     myPlayer.exitFullscreen();\\n   * ```\\n   *\\n   * @return {Player} self\\n   * @method exitFullscreen\\n   */\\n\\n  Player.prototype.exitFullscreen = function exitFullscreen() {\\n    var fsApi = _fullscreenApiJs2['default'];\\n    this.isFullscreen(false);\\n\\n    // Check for browser element fullscreen support\\n    if (fsApi.requestFullscreen) {\\n      _globalDocument2['default'][fsApi.exitFullscreen]();\\n    } else if (this.tech_.supportsFullScreen()) {\\n      this.techCall_('exitFullScreen');\\n    } else {\\n      this.exitFullWindow();\\n      this.trigger('fullscreenchange');\\n    }\\n\\n    return this;\\n  };\\n\\n  /**\\n   * When fullscreen isn't supported we can stretch the video container to as wide as the browser will let us.\\n   *\\n   * @method enterFullWindow\\n   */\\n\\n  Player.prototype.enterFullWindow = function enterFullWindow() {\\n    this.isFullWindow = true;\\n\\n    // Storing original doc overflow value to return to when fullscreen is off\\n    this.docOrigOverflow = _globalDocument2['default'].documentElement.style.overflow;\\n\\n    // Add listener for esc key to exit fullscreen\\n    Events.on(_globalDocument2['default'], 'keydown', Fn.bind(this, this.fullWindowOnEscKey));\\n\\n    // Hide any scroll bars\\n    _globalDocument2['default'].documentElement.style.overflow = 'hidden';\\n\\n    // Apply fullscreen styles\\n    Dom.addElClass(_globalDocument2['default'].body, 'vjs-full-window');\\n\\n    this.trigger('enterFullWindow');\\n  };\\n\\n  /**\\n   * Check for call to either exit full window or full screen on ESC key\\n   *\\n   * @param {String} event Event to check for key press\\n   * @method fullWindowOnEscKey\\n   */\\n\\n  Player.prototype.fullWindowOnEscKey = function fullWindowOnEscKey(event) {\\n    if (event.keyCode === 27) {\\n      if (this.isFullscreen() === true) {\\n        this.exitFullscreen();\\n      } else {\\n        this.exitFullWindow();\\n      }\\n    }\\n  };\\n\\n  /**\\n   * Exit full window\\n   *\\n   * @method exitFullWindow\\n   */\\n\\n  Player.prototype.exitFullWindow = function exitFullWindow() {\\n    this.isFullWindow = false;\\n    Events.off(_globalDocument2['default'], 'keydown', this.fullWindowOnEscKey);\\n\\n    // Unhide scroll bars.\\n    _globalDocument2['default'].documentElement.style.overflow = this.docOrigOverflow;\\n\\n    // Remove fullscreen styles\\n    Dom.removeElClass(_globalDocument2['default'].body, 'vjs-full-window');\\n\\n    // Resize the box, controller, and poster to original sizes\\n    // this.positionAll();\\n    this.trigger('exitFullWindow');\\n  };\\n\\n  /**\\n   * Check whether the player can play a given mimetype\\n   *\\n   * @param {String} type The mimetype to check\\n   * @return {String} 'probably', 'maybe', or '' (empty string)\\n   * @method canPlayType\\n   */\\n\\n  Player.prototype.canPlayType = function canPlayType(type) {\\n    var can = undefined;\\n\\n    // Loop through each playback technology in the options order\\n    for (var i = 0, j = this.options_.techOrder; i < j.length; i++) {\\n      var techName = _utilsToTitleCaseJs2['default'](j[i]);\\n      var tech = _techTechJs2['default'].getTech(techName);\\n\\n      // Support old behavior of techs being registered as components.\\n      // Remove once that deprecated behavior is removed.\\n      if (!tech) {\\n        tech = _componentJs2['default'].getComponent(techName);\\n      }\\n\\n      // Check if the current tech is defined before continuing\\n      if (!tech) {\\n        _utilsLogJs2['default'].error('The \\\"' + techName + '\\\" tech is undefined. Skipped browser support check for that tech.');\\n        continue;\\n      }\\n\\n      // Check if the browser supports this technology\\n      if (tech.isSupported()) {\\n        can = tech.canPlayType(type);\\n\\n        if (can) {\\n          return can;\\n        }\\n      }\\n    }\\n\\n    return '';\\n  };\\n\\n  /**\\n   * Select source based on tech-order or source-order\\n   * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,\\n   * defaults to tech-order selection\\n   *\\n   * @param {Array} sources The sources for a media asset\\n   * @return {Object|Boolean} Object of source and tech order, otherwise false\\n   * @method selectSource\\n   */\\n\\n  Player.prototype.selectSource = function selectSource(sources) {\\n    var _this3 = this;\\n\\n    // Get only the techs specified in `techOrder` that exist and are supported by the\\n    // current platform\\n    var techs = this.options_.techOrder.map(_utilsToTitleCaseJs2['default']).map(function (techName) {\\n      // `Component.getComponent(...)` is for support of old behavior of techs\\n      // being registered as components.\\n      // Remove once that deprecated behavior is removed.\\n      return [techName, _techTechJs2['default'].getTech(techName) || _componentJs2['default'].getComponent(techName)];\\n    }).filter(function (_ref) {\\n      var techName = _ref[0];\\n      var tech = _ref[1];\\n\\n      // Check if the current tech is defined before continuing\\n      if (tech) {\\n        // Check if the browser supports this technology\\n        return tech.isSupported();\\n      }\\n\\n      _utilsLogJs2['default'].error('The \\\"' + techName + '\\\" tech is undefined. Skipped browser support check for that tech.');\\n      return false;\\n    });\\n\\n    // Iterate over each `innerArray` element once per `outerArray` element and execute\\n    // `tester` with both. If `tester` returns a non-falsy value, exit early and return\\n    // that value.\\n    var findFirstPassingTechSourcePair = function findFirstPassingTechSourcePair(outerArray, innerArray, tester) {\\n      var found = undefined;\\n\\n      outerArray.some(function (outerChoice) {\\n        return innerArray.some(function (innerChoice) {\\n          found = tester(outerChoice, innerChoice);\\n\\n          if (found) {\\n            return true;\\n          }\\n        });\\n      });\\n\\n      return found;\\n    };\\n\\n    var foundSourceAndTech = undefined;\\n    var flip = function flip(fn) {\\n      return function (a, b) {\\n        return fn(b, a);\\n      };\\n    };\\n    var finder = function finder(_ref2, source) {\\n      var techName = _ref2[0];\\n      var tech = _ref2[1];\\n\\n      if (tech.canPlaySource(source, _this3.options_[techName.toLowerCase()])) {\\n        return { source: source, tech: techName };\\n      }\\n    };\\n\\n    // Depending on the truthiness of `options.sourceOrder`, we swap the order of techs and sources\\n    // to select from them based on their priority.\\n    if (this.options_.sourceOrder) {\\n      // Source-first ordering\\n      foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));\\n    } else {\\n      // Tech-first ordering\\n      foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);\\n    }\\n\\n    return foundSourceAndTech || false;\\n  };\\n\\n  /**\\n   * The source function updates the video source\\n   * There are three types of variables you can pass as the argument.\\n   * **URL String**: A URL to the the video file. Use this method if you are sure\\n   * the current playback technology (HTML5/Flash) can support the source you\\n   * provide. Currently only MP4 files can be used in both HTML5 and Flash.\\n   * ```js\\n   *     myPlayer.src(\\\"http://www.example.com/path/to/video.mp4\\\");\\n   * ```\\n   * **Source Object (or element):* * A javascript object containing information\\n   * about the source file. Use this method if you want the player to determine if\\n   * it can support the file using the type information.\\n   * ```js\\n   *     myPlayer.src({ type: \\\"video/mp4\\\", src: \\\"http://www.example.com/path/to/video.mp4\\\" });\\n   * ```\\n   * **Array of Source Objects:* * To provide multiple versions of the source so\\n   * that it can be played using HTML5 across browsers you can use an array of\\n   * source objects. Video.js will detect which version is supported and load that\\n   * file.\\n   * ```js\\n   *     myPlayer.src([\\n   *       { type: \\\"video/mp4\\\", src: \\\"http://www.example.com/path/to/video.mp4\\\" },\\n   *       { type: \\\"video/webm\\\", src: \\\"http://www.example.com/path/to/video.webm\\\" },\\n   *       { type: \\\"video/ogg\\\", src: \\\"http://www.example.com/path/to/video.ogv\\\" }\\n   *     ]);\\n   * ```\\n   *\\n   * @param  {String|Object|Array=} source The source URL, object, or array of sources\\n   * @return {String} The current video source when getting\\n   * @return {String} The player when setting\\n   * @method src\\n   */\\n\\n  Player.prototype.src = function src(source) {\\n    if (source === undefined) {\\n      return this.techGet_('src');\\n    }\\n\\n    var currentTech = _techTechJs2['default'].getTech(this.techName_);\\n    // Support old behavior of techs being registered as components.\\n    // Remove once that deprecated behavior is removed.\\n    if (!currentTech) {\\n      currentTech = _componentJs2['default'].getComponent(this.techName_);\\n    }\\n\\n    // case: Array of source objects to choose from and pick the best to play\\n    if (Array.isArray(source)) {\\n      this.sourceList_(source);\\n\\n      // case: URL String (http://myvideo...)\\n    } else if (typeof source === 'string') {\\n        // create a source object from the string\\n        this.src({ src: source });\\n\\n        // case: Source object { src: '', type: '' ... }\\n      } else if (source instanceof Object) {\\n          // check if the source has a type and the loaded tech cannot play the source\\n          // if there's no type we'll just try the current tech\\n          if (source.type && !currentTech.canPlaySource(source, this.options_[this.techName_.toLowerCase()])) {\\n            // create a source list with the current source and send through\\n            // the tech loop to check for a compatible technology\\n            this.sourceList_([source]);\\n          } else {\\n            this.cache_.src = source.src;\\n            this.currentType_ = source.type || '';\\n\\n            // wait until the tech is ready to set the source\\n            this.ready(function () {\\n\\n              // The setSource tech method was added with source handlers\\n              // so older techs won't support it\\n              // We need to check the direct prototype for the case where subclasses\\n              // of the tech do not support source handlers\\n              if (currentTech.prototype.hasOwnProperty('setSource')) {\\n                this.techCall_('setSource', source);\\n              } else {\\n                this.techCall_('src', source.src);\\n              }\\n\\n              if (this.options_.preload === 'auto') {\\n                this.load();\\n              }\\n\\n              if (this.options_.autoplay) {\\n                this.play();\\n              }\\n\\n              // Set the source synchronously if possible (#2326)\\n            }, true);\\n          }\\n        }\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Handle an array of source objects\\n   *\\n   * @param  {Array} sources Array of source objects\\n   * @private\\n   * @method sourceList_\\n   */\\n\\n  Player.prototype.sourceList_ = function sourceList_(sources) {\\n    var sourceTech = this.selectSource(sources);\\n\\n    if (sourceTech) {\\n      if (sourceTech.tech === this.techName_) {\\n        // if this technology is already loaded, set the source\\n        this.src(sourceTech.source);\\n      } else {\\n        // load this technology with the chosen source\\n        this.loadTech_(sourceTech.tech, sourceTech.source);\\n      }\\n    } else {\\n      // We need to wrap this in a timeout to give folks a chance to add error event handlers\\n      this.setTimeout(function () {\\n        this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) });\\n      }, 0);\\n\\n      // we could not find an appropriate tech, but let's still notify the delegate that this is it\\n      // this needs a better comment about why this is needed\\n      this.triggerReady();\\n    }\\n  };\\n\\n  /**\\n   * Begin loading the src data.\\n   *\\n   * @return {Player} Returns the player\\n   * @method load\\n   */\\n\\n  Player.prototype.load = function load() {\\n    this.techCall_('load');\\n    return this;\\n  };\\n\\n  /**\\n   * Reset the player. Loads the first tech in the techOrder,\\n   * and calls `reset` on the tech`.\\n   *\\n   * @return {Player} Returns the player\\n   * @method reset\\n   */\\n\\n  Player.prototype.reset = function reset() {\\n    this.loadTech_(_utilsToTitleCaseJs2['default'](this.options_.techOrder[0]), null);\\n    this.techCall_('reset');\\n    return this;\\n  };\\n\\n  /**\\n   * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4\\n   * Can be used in conjuction with `currentType` to assist in rebuilding the current source object.\\n   *\\n   * @return {String} The current source\\n   * @method currentSrc\\n   */\\n\\n  Player.prototype.currentSrc = function currentSrc() {\\n    return this.techGet_('currentSrc') || this.cache_.src || '';\\n  };\\n\\n  /**\\n   * Get the current source type e.g. video/mp4\\n   * This can allow you rebuild the current source object so that you could load the same\\n   * source and tech later\\n   *\\n   * @return {String} The source MIME type\\n   * @method currentType\\n   */\\n\\n  Player.prototype.currentType = function currentType() {\\n    return this.currentType_ || '';\\n  };\\n\\n  /**\\n   * Get or set the preload attribute\\n   *\\n   * @param {Boolean} value Boolean to determine if preload should be used\\n   * @return {String} The preload attribute value when getting\\n   * @return {Player} Returns the player when setting\\n   * @method preload\\n   */\\n\\n  Player.prototype.preload = function preload(value) {\\n    if (value !== undefined) {\\n      this.techCall_('setPreload', value);\\n      this.options_.preload = value;\\n      return this;\\n    }\\n    return this.techGet_('preload');\\n  };\\n\\n  /**\\n   * Get or set the autoplay attribute.\\n   *\\n   * @param {Boolean} value Boolean to determine if video should autoplay\\n   * @return {String} The autoplay attribute value when getting\\n   * @return {Player} Returns the player when setting\\n   * @method autoplay\\n   */\\n\\n  Player.prototype.autoplay = function autoplay(value) {\\n    if (value !== undefined) {\\n      this.techCall_('setAutoplay', value);\\n      this.options_.autoplay = value;\\n      return this;\\n    }\\n    return this.techGet_('autoplay', value);\\n  };\\n\\n  /**\\n   * Get or set the loop attribute on the video element.\\n   *\\n   * @param {Boolean} value Boolean to determine if video should loop\\n   * @return {String} The loop attribute value when getting\\n   * @return {Player} Returns the player when setting\\n   * @method loop\\n   */\\n\\n  Player.prototype.loop = function loop(value) {\\n    if (value !== undefined) {\\n      this.techCall_('setLoop', value);\\n      this.options_['loop'] = value;\\n      return this;\\n    }\\n    return this.techGet_('loop');\\n  };\\n\\n  /**\\n   * Get or set the poster image source url\\n   *\\n   * ##### EXAMPLE:\\n   * ```js\\n   *     // get\\n   *     var currentPoster = myPlayer.poster();\\n   *     // set\\n   *     myPlayer.poster('http://example.com/myImage.jpg');\\n   * ```\\n   *\\n   * @param  {String=} src Poster image source URL\\n   * @return {String} poster URL when getting\\n   * @return {Player} self when setting\\n   * @method poster\\n   */\\n\\n  Player.prototype.poster = function poster(src) {\\n    if (src === undefined) {\\n      return this.poster_;\\n    }\\n\\n    // The correct way to remove a poster is to set as an empty string\\n    // other falsey values will throw errors\\n    if (!src) {\\n      src = '';\\n    }\\n\\n    // update the internal poster variable\\n    this.poster_ = src;\\n\\n    // update the tech's poster\\n    this.techCall_('setPoster', src);\\n\\n    // alert components that the poster has been set\\n    this.trigger('posterchange');\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Some techs (e.g. YouTube) can provide a poster source in an\\n   * asynchronous way. We want the poster component to use this\\n   * poster source so that it covers up the tech's controls.\\n   * (YouTube's play button). However we only want to use this\\n   * soruce if the player user hasn't set a poster through\\n   * the normal APIs.\\n   *\\n   * @private\\n   * @method handleTechPosterChange_\\n   */\\n\\n  Player.prototype.handleTechPosterChange_ = function handleTechPosterChange_() {\\n    if (!this.poster_ && this.tech_ && this.tech_.poster) {\\n      this.poster_ = this.tech_.poster() || '';\\n\\n      // Let components know the poster has changed\\n      this.trigger('posterchange');\\n    }\\n  };\\n\\n  /**\\n   * Get or set whether or not the controls are showing.\\n   *\\n   * @param  {Boolean} bool Set controls to showing or not\\n   * @return {Boolean}    Controls are showing\\n   * @method controls\\n   */\\n\\n  Player.prototype.controls = function controls(bool) {\\n    if (bool !== undefined) {\\n      bool = !!bool; // force boolean\\n      // Don't trigger a change event unless it actually changed\\n      if (this.controls_ !== bool) {\\n        this.controls_ = bool;\\n\\n        if (this.usingNativeControls()) {\\n          this.techCall_('setControls', bool);\\n        }\\n\\n        if (bool) {\\n          this.removeClass('vjs-controls-disabled');\\n          this.addClass('vjs-controls-enabled');\\n          this.trigger('controlsenabled');\\n\\n          if (!this.usingNativeControls()) {\\n            this.addTechControlsListeners_();\\n          }\\n        } else {\\n          this.removeClass('vjs-controls-enabled');\\n          this.addClass('vjs-controls-disabled');\\n          this.trigger('controlsdisabled');\\n\\n          if (!this.usingNativeControls()) {\\n            this.removeTechControlsListeners_();\\n          }\\n        }\\n      }\\n      return this;\\n    }\\n    return !!this.controls_;\\n  };\\n\\n  /**\\n   * Toggle native controls on/off. Native controls are the controls built into\\n   * devices (e.g. default iPhone controls), Flash, or other techs\\n   * (e.g. Vimeo Controls)\\n   * **This should only be set by the current tech, because only the tech knows\\n   * if it can support native controls**\\n   *\\n   * @param  {Boolean} bool    True signals that native controls are on\\n   * @return {Player}      Returns the player\\n   * @private\\n   * @method usingNativeControls\\n   */\\n\\n  Player.prototype.usingNativeControls = function usingNativeControls(bool) {\\n    if (bool !== undefined) {\\n      bool = !!bool; // force boolean\\n      // Don't trigger a change event unless it actually changed\\n      if (this.usingNativeControls_ !== bool) {\\n        this.usingNativeControls_ = bool;\\n        if (bool) {\\n          this.addClass('vjs-using-native-controls');\\n\\n          /**\\n            * player is using the native device controls\\n           *\\n            * @event usingnativecontrols\\n            * @memberof Player\\n            * @instance\\n            * @private\\n            */\\n          this.trigger('usingnativecontrols');\\n        } else {\\n          this.removeClass('vjs-using-native-controls');\\n\\n          /**\\n            * player is using the custom HTML controls\\n           *\\n            * @event usingcustomcontrols\\n            * @memberof Player\\n            * @instance\\n            * @private\\n            */\\n          this.trigger('usingcustomcontrols');\\n        }\\n      }\\n      return this;\\n    }\\n    return !!this.usingNativeControls_;\\n  };\\n\\n  /**\\n   * Set or get the current MediaError\\n   *\\n   * @param  {*} err A MediaError or a String/Number to be turned into a MediaError\\n   * @return {MediaError|null}     when getting\\n   * @return {Player}              when setting\\n   * @method error\\n   */\\n\\n  Player.prototype.error = function error(err) {\\n    if (err === undefined) {\\n      return this.error_ || null;\\n    }\\n\\n    // restoring to default\\n    if (err === null) {\\n      this.error_ = err;\\n      this.removeClass('vjs-error');\\n      if (this.errorDisplay) {\\n        this.errorDisplay.close();\\n      }\\n      return this;\\n    }\\n\\n    this.error_ = new _mediaErrorJs2['default'](err);\\n\\n    // add the vjs-error classname to the player\\n    this.addClass('vjs-error');\\n\\n    // log the name of the error type and any message\\n    // ie8 just logs \\\"[object object]\\\" if you just log the error object\\n    _utilsLogJs2['default'].error('(CODE:' + this.error_.code + ' ' + _mediaErrorJs2['default'].errorTypes[this.error_.code] + ')', this.error_.message, this.error_);\\n\\n    // fire an error event on the player\\n    this.trigger('error');\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Returns whether or not the player is in the \\\"ended\\\" state.\\n   *\\n   * @return {Boolean} True if the player is in the ended state, false if not.\\n   * @method ended\\n   */\\n\\n  Player.prototype.ended = function ended() {\\n    return this.techGet_('ended');\\n  };\\n\\n  /**\\n   * Returns whether or not the player is in the \\\"seeking\\\" state.\\n   *\\n   * @return {Boolean} True if the player is in the seeking state, false if not.\\n   * @method seeking\\n   */\\n\\n  Player.prototype.seeking = function seeking() {\\n    return this.techGet_('seeking');\\n  };\\n\\n  /**\\n   * Returns the TimeRanges of the media that are currently available\\n   * for seeking to.\\n   *\\n   * @return {TimeRanges} the seekable intervals of the media timeline\\n   * @method seekable\\n   */\\n\\n  Player.prototype.seekable = function seekable() {\\n    return this.techGet_('seekable');\\n  };\\n\\n  /**\\n   * Report user activity\\n   *\\n   * @param {Object} event Event object\\n   * @method reportUserActivity\\n   */\\n\\n  Player.prototype.reportUserActivity = function reportUserActivity(event) {\\n    this.userActivity_ = true;\\n  };\\n\\n  /**\\n   * Get/set if user is active\\n   *\\n   * @param {Boolean} bool Value when setting\\n   * @return {Boolean} Value if user is active user when getting\\n   * @method userActive\\n   */\\n\\n  Player.prototype.userActive = function userActive(bool) {\\n    if (bool !== undefined) {\\n      bool = !!bool;\\n      if (bool !== this.userActive_) {\\n        this.userActive_ = bool;\\n        if (bool) {\\n          // If the user was inactive and is now active we want to reset the\\n          // inactivity timer\\n          this.userActivity_ = true;\\n          this.removeClass('vjs-user-inactive');\\n          this.addClass('vjs-user-active');\\n          this.trigger('useractive');\\n        } else {\\n          // We're switching the state to inactive manually, so erase any other\\n          // activity\\n          this.userActivity_ = false;\\n\\n          // Chrome/Safari/IE have bugs where when you change the cursor it can\\n          // trigger a mousemove event. This causes an issue when you're hiding\\n          // the cursor when the user is inactive, and a mousemove signals user\\n          // activity. Making it impossible to go into inactive mode. Specifically\\n          // this happens in fullscreen when we really need to hide the cursor.\\n          //\\n          // When this gets resolved in ALL browsers it can be removed\\n          // https://code.google.com/p/chromium/issues/detail?id=103041\\n          if (this.tech_) {\\n            this.tech_.one('mousemove', function (e) {\\n              e.stopPropagation();\\n              e.preventDefault();\\n            });\\n          }\\n\\n          this.removeClass('vjs-user-active');\\n          this.addClass('vjs-user-inactive');\\n          this.trigger('userinactive');\\n        }\\n      }\\n      return this;\\n    }\\n    return this.userActive_;\\n  };\\n\\n  /**\\n   * Listen for user activity based on timeout value\\n   *\\n   * @private\\n   * @method listenForUserActivity_\\n   */\\n\\n  Player.prototype.listenForUserActivity_ = function listenForUserActivity_() {\\n    var mouseInProgress = undefined,\\n        lastMoveX = undefined,\\n        lastMoveY = undefined;\\n\\n    var handleActivity = Fn.bind(this, this.reportUserActivity);\\n\\n    var handleMouseMove = function handleMouseMove(e) {\\n      // #1068 - Prevent mousemove spamming\\n      // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970\\n      if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {\\n        lastMoveX = e.screenX;\\n        lastMoveY = e.screenY;\\n        handleActivity();\\n      }\\n    };\\n\\n    var handleMouseDown = function handleMouseDown() {\\n      handleActivity();\\n      // For as long as the they are touching the device or have their mouse down,\\n      // we consider them active even if they're not moving their finger or mouse.\\n      // So we want to continue to update that they are active\\n      this.clearInterval(mouseInProgress);\\n      // Setting userActivity=true now and setting the interval to the same time\\n      // as the activityCheck interval (250) should ensure we never miss the\\n      // next activityCheck\\n      mouseInProgress = this.setInterval(handleActivity, 250);\\n    };\\n\\n    var handleMouseUp = function handleMouseUp(event) {\\n      handleActivity();\\n      // Stop the interval that maintains activity if the mouse/touch is down\\n      this.clearInterval(mouseInProgress);\\n    };\\n\\n    // Any mouse movement will be considered user activity\\n    this.on('mousedown', handleMouseDown);\\n    this.on('mousemove', handleMouseMove);\\n    this.on('mouseup', handleMouseUp);\\n\\n    // Listen for keyboard navigation\\n    // Shouldn't need to use inProgress interval because of key repeat\\n    this.on('keydown', handleActivity);\\n    this.on('keyup', handleActivity);\\n\\n    // Run an interval every 250 milliseconds instead of stuffing everything into\\n    // the mousemove/touchmove function itself, to prevent performance degradation.\\n    // `this.reportUserActivity` simply sets this.userActivity_ to true, which\\n    // then gets picked up by this loop\\n    // http://ejohn.org/blog/learning-from-twitter/\\n    var inactivityTimeout = undefined;\\n    var activityCheck = this.setInterval(function () {\\n      // Check to see if mouse/touch activity has happened\\n      if (this.userActivity_) {\\n        // Reset the activity tracker\\n        this.userActivity_ = false;\\n\\n        // If the user state was inactive, set the state to active\\n        this.userActive(true);\\n\\n        // Clear any existing inactivity timeout to start the timer over\\n        this.clearTimeout(inactivityTimeout);\\n\\n        var timeout = this.options_['inactivityTimeout'];\\n        if (timeout > 0) {\\n          // In <timeout> milliseconds, if no more activity has occurred the\\n          // user will be considered inactive\\n          inactivityTimeout = this.setTimeout(function () {\\n            // Protect against the case where the inactivityTimeout can trigger just\\n            // before the next user activity is picked up by the activityCheck loop\\n            // causing a flicker\\n            if (!this.userActivity_) {\\n              this.userActive(false);\\n            }\\n          }, timeout);\\n        }\\n      }\\n    }, 250);\\n  };\\n\\n  /**\\n   * Gets or sets the current playback rate.  A playback rate of\\n   * 1.0 represents normal speed and 0.5 would indicate half-speed\\n   * playback, for instance.\\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate\\n   *\\n   * @param  {Number} rate    New playback rate to set.\\n   * @return {Number}         Returns the new playback rate when setting\\n   * @return {Number}         Returns the current playback rate when getting\\n   * @method playbackRate\\n   */\\n\\n  Player.prototype.playbackRate = function playbackRate(rate) {\\n    if (rate !== undefined) {\\n      this.techCall_('setPlaybackRate', rate);\\n      return this;\\n    }\\n\\n    if (this.tech_ && this.tech_['featuresPlaybackRate']) {\\n      return this.techGet_('playbackRate');\\n    } else {\\n      return 1.0;\\n    }\\n  };\\n\\n  /**\\n   * Gets or sets the audio flag\\n   *\\n   * @param  {Boolean} bool    True signals that this is an audio player.\\n   * @return {Boolean}         Returns true if player is audio, false if not when getting\\n   * @return {Player}      Returns the player if setting\\n   * @private\\n   * @method isAudio\\n   */\\n\\n  Player.prototype.isAudio = function isAudio(bool) {\\n    if (bool !== undefined) {\\n      this.isAudio_ = !!bool;\\n      return this;\\n    }\\n\\n    return !!this.isAudio_;\\n  };\\n\\n  /**\\n   * Returns the current state of network activity for the element, from\\n   * the codes in the list below.\\n   * - NETWORK_EMPTY (numeric value 0)\\n   *   The element has not yet been initialised. All attributes are in\\n   *   their initial states.\\n   * - NETWORK_IDLE (numeric value 1)\\n   *   The element's resource selection algorithm is active and has\\n   *   selected a resource, but it is not actually using the network at\\n   *   this time.\\n   * - NETWORK_LOADING (numeric value 2)\\n   *   The user agent is actively trying to download data.\\n   * - NETWORK_NO_SOURCE (numeric value 3)\\n   *   The element's resource selection algorithm is active, but it has\\n   *   not yet found a resource to use.\\n   *\\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states\\n   * @return {Number} the current network activity state\\n   * @method networkState\\n   */\\n\\n  Player.prototype.networkState = function networkState() {\\n    return this.techGet_('networkState');\\n  };\\n\\n  /**\\n   * Returns a value that expresses the current state of the element\\n   * with respect to rendering the current playback position, from the\\n   * codes in the list below.\\n   * - HAVE_NOTHING (numeric value 0)\\n   *   No information regarding the media resource is available.\\n   * - HAVE_METADATA (numeric value 1)\\n   *   Enough of the resource has been obtained that the duration of the\\n   *   resource is available.\\n   * - HAVE_CURRENT_DATA (numeric value 2)\\n   *   Data for the immediate current playback position is available.\\n   * - HAVE_FUTURE_DATA (numeric value 3)\\n   *   Data for the immediate current playback position is available, as\\n   *   well as enough data for the user agent to advance the current\\n   *   playback position in the direction of playback.\\n   * - HAVE_ENOUGH_DATA (numeric value 4)\\n   *   The user agent estimates that enough data is available for\\n   *   playback to proceed uninterrupted.\\n   *\\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate\\n   * @return {Number} the current playback rendering state\\n   * @method readyState\\n   */\\n\\n  Player.prototype.readyState = function readyState() {\\n    return this.techGet_('readyState');\\n  };\\n\\n  /**\\n   * Get a video track list\\n   * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist\\n   *\\n   * @return {VideoTrackList} thes current video track list\\n   * @method videoTracks\\n   */\\n\\n  Player.prototype.videoTracks = function videoTracks() {\\n    // if we have not yet loadTech_, we create videoTracks_\\n    // these will be passed to the tech during loading\\n    if (!this.tech_) {\\n      this.videoTracks_ = this.videoTracks_ || new _tracksVideoTrackListJs2['default']();\\n      return this.videoTracks_;\\n    }\\n\\n    return this.tech_.videoTracks();\\n  };\\n\\n  /**\\n   * Get an audio track list\\n   * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist\\n   *\\n   * @return {AudioTrackList} thes current audio track list\\n   * @method audioTracks\\n   */\\n\\n  Player.prototype.audioTracks = function audioTracks() {\\n    // if we have not yet loadTech_, we create videoTracks_\\n    // these will be passed to the tech during loading\\n    if (!this.tech_) {\\n      this.audioTracks_ = this.audioTracks_ || new _tracksAudioTrackListJs2['default']();\\n      return this.audioTracks_;\\n    }\\n\\n    return this.tech_.audioTracks();\\n  };\\n\\n  /*\\n    * Text tracks are tracks of timed text events.\\n    * Captions - text displayed over the video for the hearing impaired\\n    * Subtitles - text displayed over the video for those who don't understand language in the video\\n    * Chapters - text displayed in a menu allowing the user to jump to particular points (chapters) in the video\\n    * Descriptions (not supported yet) - audio descriptions that are read back to the user by a screen reading device\\n    */\\n\\n  /**\\n   * Get an array of associated text tracks. captions, subtitles, chapters, descriptions\\n   * http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks\\n   *\\n   * @return {Array}           Array of track objects\\n   * @method textTracks\\n   */\\n\\n  Player.prototype.textTracks = function textTracks() {\\n    // cannot use techGet_ directly because it checks to see whether the tech is ready.\\n    // Flash is unlikely to be ready in time but textTracks should still work.\\n    return this.tech_ && this.tech_['textTracks']();\\n  };\\n\\n  /**\\n   * Get an array of remote text tracks\\n   *\\n   * @return {Array}\\n   * @method remoteTextTracks\\n   */\\n\\n  Player.prototype.remoteTextTracks = function remoteTextTracks() {\\n    return this.tech_ && this.tech_['remoteTextTracks']();\\n  };\\n\\n  /**\\n   * Get an array of remote html track elements\\n   *\\n   * @return {HTMLTrackElement[]}\\n   * @method remoteTextTrackEls\\n   */\\n\\n  Player.prototype.remoteTextTrackEls = function remoteTextTrackEls() {\\n    return this.tech_ && this.tech_['remoteTextTrackEls']();\\n  };\\n\\n  /**\\n   * Add a text track\\n   * In addition to the W3C settings we allow adding additional info through options.\\n   * http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack\\n   *\\n   * @param {String}  kind        Captions, subtitles, chapters, descriptions, or metadata\\n   * @param {String=} label       Optional label\\n   * @param {String=} language    Optional language\\n   * @method addTextTrack\\n   */\\n\\n  Player.prototype.addTextTrack = function addTextTrack(kind, label, language) {\\n    return this.tech_ && this.tech_['addTextTrack'](kind, label, language);\\n  };\\n\\n  /**\\n   * Add a remote text track\\n   *\\n   * @param {Object} options    Options for remote text track\\n   * @method addRemoteTextTrack\\n   */\\n\\n  Player.prototype.addRemoteTextTrack = function addRemoteTextTrack(options) {\\n    return this.tech_ && this.tech_['addRemoteTextTrack'](options);\\n  };\\n\\n  /**\\n   * Remove a remote text track\\n   *\\n   * @param {Object} track    Remote text track to remove\\n   * @method removeRemoteTextTrack\\n   */\\n  // destructure the input into an object with a track argument, defaulting to arguments[0]\\n  // default the whole argument to an empty object if nothing was passed in\\n\\n  Player.prototype.removeRemoteTextTrack = function removeRemoteTextTrack() {\\n    var _ref3 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\\n\\n    var _ref3$track = _ref3.track;\\n    var track = _ref3$track === undefined ? arguments[0] : _ref3$track;\\n    // jshint ignore:line\\n    this.tech_ && this.tech_['removeRemoteTextTrack'](track);\\n  };\\n\\n  /**\\n   * Get video width\\n   *\\n   * @return {Number} Video width\\n   * @method videoWidth\\n   */\\n\\n  Player.prototype.videoWidth = function videoWidth() {\\n    return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;\\n  };\\n\\n  /**\\n   * Get video height\\n   *\\n   * @return {Number} Video height\\n   * @method videoHeight\\n   */\\n\\n  Player.prototype.videoHeight = function videoHeight() {\\n    return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;\\n  };\\n\\n  // Methods to add support for\\n  // initialTime: function(){ return this.techCall_('initialTime'); },\\n  // startOffsetTime: function(){ return this.techCall_('startOffsetTime'); },\\n  // played: function(){ return this.techCall_('played'); },\\n  // defaultPlaybackRate: function(){ return this.techCall_('defaultPlaybackRate'); },\\n  // defaultMuted: function(){ return this.techCall_('defaultMuted'); }\\n\\n  /**\\n   * The player's language code\\n   * NOTE: The language should be set in the player options if you want the\\n   * the controls to be built with a specific language. Changing the lanugage\\n   * later will not update controls text.\\n   *\\n   * @param {String} code  The locale string\\n   * @return {String}      The locale string when getting\\n   * @return {Player}      self when setting\\n   * @method language\\n   */\\n\\n  Player.prototype.language = function language(code) {\\n    if (code === undefined) {\\n      return this.language_;\\n    }\\n\\n    this.language_ = ('' + code).toLowerCase();\\n    return this;\\n  };\\n\\n  /**\\n   * Get the player's language dictionary\\n   * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time\\n   * Languages specified directly in the player options have precedence\\n   *\\n   * @return {Array} Array of languages\\n   * @method languages\\n   */\\n\\n  Player.prototype.languages = function languages() {\\n    return _utilsMergeOptionsJs2['default'](Player.prototype.options_.languages, this.languages_);\\n  };\\n\\n  /**\\n   * Converts track info to JSON\\n   *\\n   * @return {Object} JSON object of options\\n   * @method toJSON\\n   */\\n\\n  Player.prototype.toJSON = function toJSON() {\\n    var options = _utilsMergeOptionsJs2['default'](this.options_);\\n    var tracks = options.tracks;\\n\\n    options.tracks = [];\\n\\n    for (var i = 0; i < tracks.length; i++) {\\n      var track = tracks[i];\\n\\n      // deep merge tracks and null out player so no circular references\\n      track = _utilsMergeOptionsJs2['default'](track);\\n      track.player = undefined;\\n      options.tracks[i] = track;\\n    }\\n\\n    return options;\\n  };\\n\\n  /**\\n   * Creates a simple modal dialog (an instance of the `ModalDialog`\\n   * component) that immediately overlays the player with arbitrary\\n   * content and removes itself when closed.\\n   *\\n   * @param {String|Function|Element|Array|Null} content\\n   *        Same as `ModalDialog#content`'s param of the same name.\\n   *\\n   *        The most straight-forward usage is to provide a string or DOM\\n   *        element.\\n   *\\n   * @param {Object} [options]\\n   *        Extra options which will be passed on to the `ModalDialog`.\\n   *\\n   * @return {ModalDialog}\\n   */\\n\\n  Player.prototype.createModal = function createModal(content, options) {\\n    var player = this;\\n\\n    options = options || {};\\n    options.content = content || '';\\n\\n    var modal = new _modalDialog2['default'](player, options);\\n\\n    player.addChild(modal);\\n    modal.on('dispose', function () {\\n      player.removeChild(modal);\\n    });\\n\\n    return modal.open();\\n  };\\n\\n  /**\\n   * Gets tag settings\\n   *\\n   * @param {Element} tag The player tag\\n   * @return {Array} An array of sources and track objects\\n   * @static\\n   * @method getTagSettings\\n   */\\n\\n  Player.getTagSettings = function getTagSettings(tag) {\\n    var baseOptions = {\\n      'sources': [],\\n      'tracks': []\\n    };\\n\\n    var tagOptions = Dom.getElAttributes(tag);\\n    var dataSetup = tagOptions['data-setup'];\\n\\n    // Check if data-setup attr exists.\\n    if (dataSetup !== null) {\\n      // Parse options JSON\\n\\n      var _safeParseTuple = _safeJsonParseTuple2['default'](dataSetup || '{}');\\n\\n      var err = _safeParseTuple[0];\\n      var data = _safeParseTuple[1];\\n\\n      if (err) {\\n        _utilsLogJs2['default'].error(err);\\n      }\\n      _objectAssign2['default'](tagOptions, data);\\n    }\\n\\n    _objectAssign2['default'](baseOptions, tagOptions);\\n\\n    // Get tag children settings\\n    if (tag.hasChildNodes()) {\\n      var children = tag.childNodes;\\n\\n      for (var i = 0, j = children.length; i < j; i++) {\\n        var child = children[i];\\n        // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/\\n        var childName = child.nodeName.toLowerCase();\\n        if (childName === 'source') {\\n          baseOptions.sources.push(Dom.getElAttributes(child));\\n        } else if (childName === 'track') {\\n          baseOptions.tracks.push(Dom.getElAttributes(child));\\n        }\\n      }\\n    }\\n\\n    return baseOptions;\\n  };\\n\\n  return Player;\\n})(_componentJs2['default']);\\n\\nPlayer.players = {};\\n\\nvar navigator = _globalWindow2['default'].navigator;\\n/*\\n * Player instance options, surfaced using options\\n * options = Player.prototype.options_\\n * Make changes in options, not here.\\n *\\n * @type {Object}\\n * @private\\n */\\nPlayer.prototype.options_ = {\\n  // Default order of fallback technology\\n  techOrder: ['html5', 'flash'],\\n  // techOrder: ['flash','html5'],\\n\\n  html5: {},\\n  flash: {},\\n\\n  // defaultVolume: 0.85,\\n  defaultVolume: 0.00, // The freakin seaguls are driving me crazy!\\n\\n  // default inactivity timeout\\n  inactivityTimeout: 2000,\\n\\n  // default playback rates\\n  playbackRates: [],\\n  // Add playback rate selection by adding rates\\n  // 'playbackRates': [0.5, 1, 1.5, 2],\\n\\n  // Included control sets\\n  children: ['mediaLoader', 'posterImage', 'textTrackDisplay', 'loadingSpinner', 'bigPlayButton', 'controlBar', 'errorDisplay', 'textTrackSettings'],\\n\\n  language: navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language || 'en',\\n\\n  // locales and their language translations\\n  languages: {},\\n\\n  // Default message to show when a video cannot be played.\\n  notSupportedMessage: 'No compatible source was found for this media.'\\n};\\n\\n/**\\n * Fired when the user agent begins looking for media data\\n *\\n * @event loadstart\\n */\\nPlayer.prototype.handleTechLoadStart_;\\n\\n/**\\n * Fired when the player has initial duration and dimension information\\n *\\n * @event loadedmetadata\\n */\\nPlayer.prototype.handleLoadedMetaData_;\\n\\n/**\\n * Fired when the player receives text data\\n *\\n * @event textdata\\n */\\nPlayer.prototype.handleTextData_;\\n\\n/**\\n * Fired when the player has downloaded data at the current playback position\\n *\\n * @event loadeddata\\n */\\nPlayer.prototype.handleLoadedData_;\\n\\n/**\\n * Fired when the user is active, e.g. moves the mouse over the player\\n *\\n * @event useractive\\n */\\nPlayer.prototype.handleUserActive_;\\n\\n/**\\n * Fired when the user is inactive, e.g. a short delay after the last mouse move or control interaction\\n *\\n * @event userinactive\\n */\\nPlayer.prototype.handleUserInactive_;\\n\\n/**\\n * Fired when the current playback position has changed *\\n * During playback this is fired every 15-250 milliseconds, depending on the\\n * playback technology in use.\\n *\\n * @event timeupdate\\n */\\nPlayer.prototype.handleTimeUpdate_;\\n\\n/**\\n * Fired when video playback ends\\n *\\n * @event ended\\n */\\nPlayer.prototype.handleTechEnded_;\\n\\n/**\\n * Fired when the volume changes\\n *\\n * @event volumechange\\n */\\nPlayer.prototype.handleVolumeChange_;\\n\\n/**\\n * Fired when an error occurs\\n *\\n * @event error\\n */\\nPlayer.prototype.handleError_;\\n\\nPlayer.prototype.flexNotSupported_ = function () {\\n  var elem = _globalDocument2['default'].createElement('i');\\n\\n  // Note: We don't actually use flexBasis (or flexOrder), but it's one of the more\\n  // common flex features that we can rely on when checking for flex support.\\n  return !('flexBasis' in elem.style || 'webkitFlexBasis' in elem.style || 'mozFlexBasis' in elem.style || 'msFlexBasis' in elem.style || 'msFlexOrder' in elem.style) /* IE10-specific (2012 flex spec)  */;\\n};\\n\\n_componentJs2['default'].registerComponent('Player', Player);\\nexports['default'] = Player;\\nmodule.exports = exports['default'];\\n// If empty string, make it a parsable json object.\\n\\n},{\\\"./big-play-button.js\\\":63,\\\"./component.js\\\":67,\\\"./control-bar/control-bar.js\\\":70,\\\"./error-display.js\\\":103,\\\"./fullscreen-api.js\\\":106,\\\"./loading-spinner.js\\\":107,\\\"./media-error.js\\\":108,\\\"./modal-dialog\\\":112,\\\"./poster-image.js\\\":117,\\\"./tech/html5.js\\\":122,\\\"./tech/loader.js\\\":123,\\\"./tech/tech.js\\\":124,\\\"./tracks/audio-track-list.js\\\":125,\\\"./tracks/text-track-display.js\\\":130,\\\"./tracks/text-track-list-converter.js\\\":131,\\\"./tracks/text-track-settings.js\\\":133,\\\"./tracks/video-track-list.js\\\":138,\\\"./utils/browser.js\\\":140,\\\"./utils/buffer.js\\\":141,\\\"./utils/dom.js\\\":142,\\\"./utils/events.js\\\":143,\\\"./utils/fn.js\\\":144,\\\"./utils/guid.js\\\":146,\\\"./utils/log.js\\\":147,\\\"./utils/merge-options.js\\\":148,\\\"./utils/stylesheet.js\\\":149,\\\"./utils/time-ranges.js\\\":150,\\\"./utils/to-title-case.js\\\":151,\\\"global/document\\\":1,\\\"global/window\\\":2,\\\"object.assign\\\":45,\\\"safe-json-parse/tuple\\\":54}],114:[function(_dereq_,module,exports){\\n/**\\n * @file plugins.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _playerJs = _dereq_('./player.js');\\n\\nvar _playerJs2 = _interopRequireDefault(_playerJs);\\n\\n/**\\n * The method for registering a video.js plugin\\n *\\n * @param  {String} name The name of the plugin\\n * @param  {Function} init The function that is run when the player inits\\n * @method plugin\\n */\\nvar plugin = function plugin(name, init) {\\n  _playerJs2['default'].prototype[name] = init;\\n};\\n\\nexports['default'] = plugin;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./player.js\\\":113}],115:[function(_dereq_,module,exports){\\n/**\\n * @file popup-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _clickableComponentJs = _dereq_('../clickable-component.js');\\n\\nvar _clickableComponentJs2 = _interopRequireDefault(_clickableComponentJs);\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _popupJs = _dereq_('./popup.js');\\n\\nvar _popupJs2 = _interopRequireDefault(_popupJs);\\n\\nvar _utilsDomJs = _dereq_('../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsToTitleCaseJs = _dereq_('../utils/to-title-case.js');\\n\\nvar _utilsToTitleCaseJs2 = _interopRequireDefault(_utilsToTitleCaseJs);\\n\\n/**\\n * A button class with a popup control\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends ClickableComponent\\n * @class PopupButton\\n */\\n\\nvar PopupButton = (function (_ClickableComponent) {\\n  _inherits(PopupButton, _ClickableComponent);\\n\\n  function PopupButton(player) {\\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n\\n    _classCallCheck(this, PopupButton);\\n\\n    _ClickableComponent.call(this, player, options);\\n\\n    this.update();\\n  }\\n\\n  /**\\n   * Update popup\\n   *\\n   * @method update\\n   */\\n\\n  PopupButton.prototype.update = function update() {\\n    var popup = this.createPopup();\\n\\n    if (this.popup) {\\n      this.removeChild(this.popup);\\n    }\\n\\n    this.popup = popup;\\n    this.addChild(popup);\\n\\n    if (this.items && this.items.length === 0) {\\n      this.hide();\\n    } else if (this.items && this.items.length > 1) {\\n      this.show();\\n    }\\n  };\\n\\n  /**\\n   * Create popup - Override with specific functionality for component\\n   *\\n   * @return {Popup} The constructed popup\\n   * @method createPopup\\n   */\\n\\n  PopupButton.prototype.createPopup = function createPopup() {};\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  PopupButton.prototype.createEl = function createEl() {\\n    return _ClickableComponent.prototype.createEl.call(this, 'div', {\\n      className: this.buildCSSClass()\\n    });\\n  };\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  PopupButton.prototype.buildCSSClass = function buildCSSClass() {\\n    var menuButtonClass = 'vjs-menu-button';\\n\\n    // If the inline option is passed, we want to use different styles altogether.\\n    if (this.options_.inline === true) {\\n      menuButtonClass += '-inline';\\n    } else {\\n      menuButtonClass += '-popup';\\n    }\\n\\n    return 'vjs-menu-button ' + menuButtonClass + ' ' + _ClickableComponent.prototype.buildCSSClass.call(this);\\n  };\\n\\n  return PopupButton;\\n})(_clickableComponentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('PopupButton', PopupButton);\\nexports['default'] = PopupButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../clickable-component.js\\\":65,\\\"../component.js\\\":67,\\\"../utils/dom.js\\\":142,\\\"../utils/fn.js\\\":144,\\\"../utils/to-title-case.js\\\":151,\\\"./popup.js\\\":116}],116:[function(_dereq_,module,exports){\\n/**\\n * @file popup.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsDomJs = _dereq_('../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsEventsJs = _dereq_('../utils/events.js');\\n\\nvar Events = _interopRequireWildcard(_utilsEventsJs);\\n\\n/**\\n * The Popup component is used to build pop up controls.\\n *\\n * @extends Component\\n * @class Popup\\n */\\n\\nvar Popup = (function (_Component) {\\n  _inherits(Popup, _Component);\\n\\n  function Popup() {\\n    _classCallCheck(this, Popup);\\n\\n    _Component.apply(this, arguments);\\n  }\\n\\n  /**\\n   * Add a popup item to the popup\\n   *\\n   * @param {Object|String} component Component or component type to add\\n   * @method addItem\\n   */\\n\\n  Popup.prototype.addItem = function addItem(component) {\\n    this.addChild(component);\\n    component.on('click', Fn.bind(this, function () {\\n      this.unlockShowing();\\n    }));\\n  };\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  Popup.prototype.createEl = function createEl() {\\n    var contentElType = this.options_.contentElType || 'ul';\\n    this.contentEl_ = Dom.createEl(contentElType, {\\n      className: 'vjs-menu-content'\\n    });\\n    var el = _Component.prototype.createEl.call(this, 'div', {\\n      append: this.contentEl_,\\n      className: 'vjs-menu'\\n    });\\n    el.appendChild(this.contentEl_);\\n\\n    // Prevent clicks from bubbling up. Needed for Popup Buttons,\\n    // where a click on the parent is significant\\n    Events.on(el, 'click', function (event) {\\n      event.preventDefault();\\n      event.stopImmediatePropagation();\\n    });\\n\\n    return el;\\n  };\\n\\n  return Popup;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('Popup', Popup);\\nexports['default'] = Popup;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component.js\\\":67,\\\"../utils/dom.js\\\":142,\\\"../utils/events.js\\\":143,\\\"../utils/fn.js\\\":144}],117:[function(_dereq_,module,exports){\\n/**\\n * @file poster-image.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _clickableComponentJs = _dereq_('./clickable-component.js');\\n\\nvar _clickableComponentJs2 = _interopRequireDefault(_clickableComponentJs);\\n\\nvar _componentJs = _dereq_('./component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsFnJs = _dereq_('./utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsDomJs = _dereq_('./utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsBrowserJs = _dereq_('./utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\n/**\\n * The component that handles showing the poster image.\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Button\\n * @class PosterImage\\n */\\n\\nvar PosterImage = (function (_ClickableComponent) {\\n  _inherits(PosterImage, _ClickableComponent);\\n\\n  function PosterImage(player, options) {\\n    _classCallCheck(this, PosterImage);\\n\\n    _ClickableComponent.call(this, player, options);\\n\\n    this.update();\\n    player.on('posterchange', Fn.bind(this, this.update));\\n  }\\n\\n  /**\\n   * Clean up the poster image\\n   *\\n   * @method dispose\\n   */\\n\\n  PosterImage.prototype.dispose = function dispose() {\\n    this.player().off('posterchange', this.update);\\n    _ClickableComponent.prototype.dispose.call(this);\\n  };\\n\\n  /**\\n   * Create the poster's image element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  PosterImage.prototype.createEl = function createEl() {\\n    var el = Dom.createEl('div', {\\n      className: 'vjs-poster',\\n\\n      // Don't want poster to be tabbable.\\n      tabIndex: -1\\n    });\\n\\n    // To ensure the poster image resizes while maintaining its original aspect\\n    // ratio, use a div with `background-size` when available. For browsers that\\n    // do not support `background-size` (e.g. IE8), fall back on using a regular\\n    // img element.\\n    if (!browser.BACKGROUND_SIZE_SUPPORTED) {\\n      this.fallbackImg_ = Dom.createEl('img');\\n      el.appendChild(this.fallbackImg_);\\n    }\\n\\n    return el;\\n  };\\n\\n  /**\\n   * Event handler for updates to the player's poster source\\n   *\\n   * @method update\\n   */\\n\\n  PosterImage.prototype.update = function update() {\\n    var url = this.player().poster();\\n\\n    this.setSrc(url);\\n\\n    // If there's no poster source we should display:none on this component\\n    // so it's not still clickable or right-clickable\\n    if (url) {\\n      this.show();\\n    } else {\\n      this.hide();\\n    }\\n  };\\n\\n  /**\\n   * Set the poster source depending on the display method\\n   *\\n   * @param {String} url The URL to the poster source\\n   * @method setSrc\\n   */\\n\\n  PosterImage.prototype.setSrc = function setSrc(url) {\\n    if (this.fallbackImg_) {\\n      this.fallbackImg_.src = url;\\n    } else {\\n      var backgroundImage = '';\\n      // Any falsey values should stay as an empty string, otherwise\\n      // this will throw an extra error\\n      if (url) {\\n        backgroundImage = 'url(\\\"' + url + '\\\")';\\n      }\\n\\n      this.el_.style.backgroundImage = backgroundImage;\\n    }\\n  };\\n\\n  /**\\n   * Event handler for clicks on the poster image\\n   *\\n   * @method handleClick\\n   */\\n\\n  PosterImage.prototype.handleClick = function handleClick() {\\n    // We don't want a click to trigger playback when controls are disabled\\n    // but CSS should be hiding the poster to prevent that from happening\\n    if (this.player_.paused()) {\\n      this.player_.play();\\n    } else {\\n      this.player_.pause();\\n    }\\n  };\\n\\n  return PosterImage;\\n})(_clickableComponentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('PosterImage', PosterImage);\\nexports['default'] = PosterImage;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./clickable-component.js\\\":65,\\\"./component.js\\\":67,\\\"./utils/browser.js\\\":140,\\\"./utils/dom.js\\\":142,\\\"./utils/fn.js\\\":144}],118:[function(_dereq_,module,exports){\\n/**\\n * @file setup.js\\n *\\n * Functions for automatically setting up a player\\n * based on the data-setup attribute of the video tag\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nvar _utilsEventsJs = _dereq_('./utils/events.js');\\n\\nvar Events = _interopRequireWildcard(_utilsEventsJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _windowLoaded = false;\\nvar videojs = undefined;\\n\\n// Automatically set up any tags that have a data-setup attribute\\nvar autoSetup = function autoSetup() {\\n  // One day, when we stop supporting IE8, go back to this, but in the meantime...*hack hack hack*\\n  // var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));\\n  // var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));\\n  // var mediaEls = vids.concat(audios);\\n\\n  // Because IE8 doesn't support calling slice on a node list, we need to loop through each list of elements\\n  // to build up a new, combined list of elements.\\n  var vids = _globalDocument2['default'].getElementsByTagName('video');\\n  var audios = _globalDocument2['default'].getElementsByTagName('audio');\\n  var mediaEls = [];\\n  if (vids && vids.length > 0) {\\n    for (var i = 0, e = vids.length; i < e; i++) {\\n      mediaEls.push(vids[i]);\\n    }\\n  }\\n  if (audios && audios.length > 0) {\\n    for (var i = 0, e = audios.length; i < e; i++) {\\n      mediaEls.push(audios[i]);\\n    }\\n  }\\n\\n  // Check if any media elements exist\\n  if (mediaEls && mediaEls.length > 0) {\\n\\n    for (var i = 0, e = mediaEls.length; i < e; i++) {\\n      var mediaEl = mediaEls[i];\\n\\n      // Check if element exists, has getAttribute func.\\n      // IE seems to consider typeof el.getAttribute == 'object' instead of 'function' like expected, at least when loading the player immediately.\\n      if (mediaEl && mediaEl.getAttribute) {\\n\\n        // Make sure this player hasn't already been set up.\\n        if (mediaEl['player'] === undefined) {\\n          var options = mediaEl.getAttribute('data-setup');\\n\\n          // Check if data-setup attr exists.\\n          // We only auto-setup if they've added the data-setup attr.\\n          if (options !== null) {\\n            // Create new video.js instance.\\n            var player = videojs(mediaEl);\\n          }\\n        }\\n\\n        // If getAttribute isn't defined, we need to wait for the DOM.\\n      } else {\\n          autoSetupTimeout(1);\\n          break;\\n        }\\n    }\\n\\n    // No videos were found, so keep looping unless page is finished loading.\\n  } else if (!_windowLoaded) {\\n      autoSetupTimeout(1);\\n    }\\n};\\n\\n// Pause to let the DOM keep processing\\nvar autoSetupTimeout = function autoSetupTimeout(wait, vjs) {\\n  if (vjs) {\\n    videojs = vjs;\\n  }\\n\\n  setTimeout(autoSetup, wait);\\n};\\n\\nif (_globalDocument2['default'].readyState === 'complete') {\\n  _windowLoaded = true;\\n} else {\\n  Events.one(_globalWindow2['default'], 'load', function () {\\n    _windowLoaded = true;\\n  });\\n}\\n\\nvar hasLoaded = function hasLoaded() {\\n  return _windowLoaded;\\n};\\n\\nexports.autoSetup = autoSetup;\\nexports.autoSetupTimeout = autoSetupTimeout;\\nexports.hasLoaded = hasLoaded;\\n\\n},{\\\"./utils/events.js\\\":143,\\\"global/document\\\":1,\\\"global/window\\\":2}],119:[function(_dereq_,module,exports){\\n/**\\n * @file slider.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsDomJs = _dereq_('../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _objectAssign = _dereq_('object.assign');\\n\\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\\n\\n/**\\n * The base functionality for sliders like the volume bar and seek bar\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class Slider\\n */\\n\\nvar Slider = (function (_Component) {\\n  _inherits(Slider, _Component);\\n\\n  function Slider(player, options) {\\n    _classCallCheck(this, Slider);\\n\\n    _Component.call(this, player, options);\\n\\n    // Set property names to bar to match with the child Slider class is looking for\\n    this.bar = this.getChild(this.options_.barName);\\n\\n    // Set a horizontal or vertical class on the slider depending on the slider type\\n    this.vertical(!!this.options_.vertical);\\n\\n    this.on('mousedown', this.handleMouseDown);\\n    this.on('touchstart', this.handleMouseDown);\\n    this.on('focus', this.handleFocus);\\n    this.on('blur', this.handleBlur);\\n    this.on('click', this.handleClick);\\n\\n    this.on(player, 'controlsvisible', this.update);\\n    this.on(player, this.playerEvent, this.update);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @param {String} type Type of element to create\\n   * @param {Object=} props List of properties in Object form\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  Slider.prototype.createEl = function createEl(type) {\\n    var props = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n    var attributes = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\\n\\n    // Add the slider element class to all sub classes\\n    props.className = props.className + ' vjs-slider';\\n    props = _objectAssign2['default']({\\n      tabIndex: 0\\n    }, props);\\n\\n    attributes = _objectAssign2['default']({\\n      'role': 'slider',\\n      'aria-valuenow': 0,\\n      'aria-valuemin': 0,\\n      'aria-valuemax': 100,\\n      tabIndex: 0\\n    }, attributes);\\n\\n    return _Component.prototype.createEl.call(this, type, props, attributes);\\n  };\\n\\n  /**\\n   * Handle mouse down on slider\\n   *\\n   * @param {Object} event Mouse down event object\\n   * @method handleMouseDown\\n   */\\n\\n  Slider.prototype.handleMouseDown = function handleMouseDown(event) {\\n    var doc = this.bar.el_.ownerDocument;\\n\\n    event.preventDefault();\\n    Dom.blockTextSelection();\\n\\n    this.addClass('vjs-sliding');\\n    this.trigger('slideractive');\\n\\n    this.on(doc, 'mousemove', this.handleMouseMove);\\n    this.on(doc, 'mouseup', this.handleMouseUp);\\n    this.on(doc, 'touchmove', this.handleMouseMove);\\n    this.on(doc, 'touchend', this.handleMouseUp);\\n\\n    this.handleMouseMove(event);\\n  };\\n\\n  /**\\n   * To be overridden by a subclass\\n   *\\n   * @method handleMouseMove\\n   */\\n\\n  Slider.prototype.handleMouseMove = function handleMouseMove() {};\\n\\n  /**\\n   * Handle mouse up on Slider\\n   *\\n   * @method handleMouseUp\\n   */\\n\\n  Slider.prototype.handleMouseUp = function handleMouseUp() {\\n    var doc = this.bar.el_.ownerDocument;\\n\\n    Dom.unblockTextSelection();\\n\\n    this.removeClass('vjs-sliding');\\n    this.trigger('sliderinactive');\\n\\n    this.off(doc, 'mousemove', this.handleMouseMove);\\n    this.off(doc, 'mouseup', this.handleMouseUp);\\n    this.off(doc, 'touchmove', this.handleMouseMove);\\n    this.off(doc, 'touchend', this.handleMouseUp);\\n\\n    this.update();\\n  };\\n\\n  /**\\n   * Update slider\\n   *\\n   * @method update\\n   */\\n\\n  Slider.prototype.update = function update() {\\n    // In VolumeBar init we have a setTimeout for update that pops and update to the end of the\\n    // execution stack. The player is destroyed before then update will cause an error\\n    if (!this.el_) return;\\n\\n    // If scrubbing, we could use a cached value to make the handle keep up with the user's mouse.\\n    // On HTML5 browsers scrubbing is really smooth, but some flash players are slow, so we might want to utilize this later.\\n    // var progress =  (this.player_.scrubbing()) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();\\n    var progress = this.getPercent();\\n    var bar = this.bar;\\n\\n    // If there's no bar...\\n    if (!bar) return;\\n\\n    // Protect against no duration and other division issues\\n    if (typeof progress !== 'number' || progress !== progress || progress < 0 || progress === Infinity) {\\n      progress = 0;\\n    }\\n\\n    // Convert to a percentage for setting\\n    var percentage = (progress * 100).toFixed(2) + '%';\\n\\n    // Set the new bar width or height\\n    if (this.vertical()) {\\n      bar.el().style.height = percentage;\\n    } else {\\n      bar.el().style.width = percentage;\\n    }\\n  };\\n\\n  /**\\n   * Calculate distance for slider\\n   *\\n   * @param {Object} event Event object\\n   * @method calculateDistance\\n   */\\n\\n  Slider.prototype.calculateDistance = function calculateDistance(event) {\\n    var position = Dom.getPointerPosition(this.el_, event);\\n    if (this.vertical()) {\\n      return position.y;\\n    }\\n    return position.x;\\n  };\\n\\n  /**\\n   * Handle on focus for slider\\n   *\\n   * @method handleFocus\\n   */\\n\\n  Slider.prototype.handleFocus = function handleFocus() {\\n    this.on(this.bar.el_.ownerDocument, 'keydown', this.handleKeyPress);\\n  };\\n\\n  /**\\n   * Handle key press for slider\\n   *\\n   * @param {Object} event Event object\\n   * @method handleKeyPress\\n   */\\n\\n  Slider.prototype.handleKeyPress = function handleKeyPress(event) {\\n    if (event.which === 37 || event.which === 40) {\\n      // Left and Down Arrows\\n      event.preventDefault();\\n      this.stepBack();\\n    } else if (event.which === 38 || event.which === 39) {\\n      // Up and Right Arrows\\n      event.preventDefault();\\n      this.stepForward();\\n    }\\n  };\\n\\n  /**\\n   * Handle on blur for slider\\n   *\\n   * @method handleBlur\\n   */\\n\\n  Slider.prototype.handleBlur = function handleBlur() {\\n    this.off(this.bar.el_.ownerDocument, 'keydown', this.handleKeyPress);\\n  };\\n\\n  /**\\n   * Listener for click events on slider, used to prevent clicks\\n   *   from bubbling up to parent elements like button menus.\\n   *\\n   * @param {Object} event Event object\\n   * @method handleClick\\n   */\\n\\n  Slider.prototype.handleClick = function handleClick(event) {\\n    event.stopImmediatePropagation();\\n    event.preventDefault();\\n  };\\n\\n  /**\\n   * Get/set if slider is horizontal for vertical\\n   *\\n   * @param {Boolean} bool True if slider is vertical, false is horizontal\\n   * @return {Boolean} True if slider is vertical, false is horizontal\\n   * @method vertical\\n   */\\n\\n  Slider.prototype.vertical = function vertical(bool) {\\n    if (bool === undefined) {\\n      return this.vertical_ || false;\\n    }\\n\\n    this.vertical_ = !!bool;\\n\\n    if (this.vertical_) {\\n      this.addClass('vjs-slider-vertical');\\n    } else {\\n      this.addClass('vjs-slider-horizontal');\\n    }\\n\\n    return this;\\n  };\\n\\n  return Slider;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('Slider', Slider);\\nexports['default'] = Slider;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component.js\\\":67,\\\"../utils/dom.js\\\":142,\\\"object.assign\\\":45}],120:[function(_dereq_,module,exports){\\n/**\\n * @file flash-rtmp.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\nfunction FlashRtmpDecorator(Flash) {\\n  Flash.streamingFormats = {\\n    'rtmp/mp4': 'MP4',\\n    'rtmp/flv': 'FLV'\\n  };\\n\\n  Flash.streamFromParts = function (connection, stream) {\\n    return connection + '&' + stream;\\n  };\\n\\n  Flash.streamToParts = function (src) {\\n    var parts = {\\n      connection: '',\\n      stream: ''\\n    };\\n\\n    if (!src) return parts;\\n\\n    // Look for the normal URL separator we expect, '&'.\\n    // If found, we split the URL into two pieces around the\\n    // first '&'.\\n    var connEnd = src.search(/&(?!\\\\w+=)/);\\n    var streamBegin = undefined;\\n    if (connEnd !== -1) {\\n      streamBegin = connEnd + 1;\\n    } else {\\n      // If there's not a '&', we use the last '/' as the delimiter.\\n      connEnd = streamBegin = src.lastIndexOf('/') + 1;\\n      if (connEnd === 0) {\\n        // really, there's not a '/'?\\n        connEnd = streamBegin = src.length;\\n      }\\n    }\\n    parts.connection = src.substring(0, connEnd);\\n    parts.stream = src.substring(streamBegin, src.length);\\n\\n    return parts;\\n  };\\n\\n  Flash.isStreamingType = function (srcType) {\\n    return srcType in Flash.streamingFormats;\\n  };\\n\\n  // RTMP has four variations, any string starting\\n  // with one of these protocols should be valid\\n  Flash.RTMP_RE = /^rtmp[set]?:\\\\/\\\\//i;\\n\\n  Flash.isStreamingSrc = function (src) {\\n    return Flash.RTMP_RE.test(src);\\n  };\\n\\n  /**\\n   * A source handler for RTMP urls\\n   * @type {Object}\\n   */\\n  Flash.rtmpSourceHandler = {};\\n\\n  /**\\n   * Check if Flash can play the given videotype\\n   * @param  {String} type    The mimetype to check\\n   * @return {String}         'probably', 'maybe', or '' (empty string)\\n   */\\n  Flash.rtmpSourceHandler.canPlayType = function (type) {\\n    if (Flash.isStreamingType(type)) {\\n      return 'maybe';\\n    }\\n\\n    return '';\\n  };\\n\\n  /**\\n   * Check if Flash can handle the source natively\\n   * @param  {Object} source  The source object\\n   * @param  {Object} options The options passed to the tech\\n   * @return {String}         'probably', 'maybe', or '' (empty string)\\n   */\\n  Flash.rtmpSourceHandler.canHandleSource = function (source, options) {\\n    var can = Flash.rtmpSourceHandler.canPlayType(source.type);\\n\\n    if (can) {\\n      return can;\\n    }\\n\\n    if (Flash.isStreamingSrc(source.src)) {\\n      return 'maybe';\\n    }\\n\\n    return '';\\n  };\\n\\n  /**\\n   * Pass the source to the flash object\\n   * Adaptive source handlers will have more complicated workflows before passing\\n   * video data to the video element\\n   * @param  {Object} source   The source object\\n   * @param  {Flash}  tech     The instance of the Flash tech\\n   * @param  {Object} options  The options to pass to the source\\n   */\\n  Flash.rtmpSourceHandler.handleSource = function (source, tech, options) {\\n    var srcParts = Flash.streamToParts(source.src);\\n\\n    tech['setRtmpConnection'](srcParts.connection);\\n    tech['setRtmpStream'](srcParts.stream);\\n  };\\n\\n  // Register the native source handler\\n  Flash.registerSourceHandler(Flash.rtmpSourceHandler);\\n\\n  return Flash;\\n}\\n\\nexports['default'] = FlashRtmpDecorator;\\nmodule.exports = exports['default'];\\n\\n},{}],121:[function(_dereq_,module,exports){\\n/**\\n * @file flash.js\\n * VideoJS-SWF - Custom Flash Player with HTML5-ish API\\n * https://github.com/zencoder/video-js-swf\\n * Not using setupTriggers. Using global onEvent func to distribute events\\n */\\n\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _tech = _dereq_('./tech');\\n\\nvar _tech2 = _interopRequireDefault(_tech);\\n\\nvar _utilsDomJs = _dereq_('../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsUrlJs = _dereq_('../utils/url.js');\\n\\nvar Url = _interopRequireWildcard(_utilsUrlJs);\\n\\nvar _utilsTimeRangesJs = _dereq_('../utils/time-ranges.js');\\n\\nvar _flashRtmp = _dereq_('./flash-rtmp');\\n\\nvar _flashRtmp2 = _interopRequireDefault(_flashRtmp);\\n\\nvar _component = _dereq_('../component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _objectAssign = _dereq_('object.assign');\\n\\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\\n\\nvar navigator = _globalWindow2['default'].navigator;\\n/**\\n * Flash Media Controller - Wrapper for fallback SWF API\\n *\\n * @param {Object=} options Object of option names and values\\n * @param {Function=} ready Ready callback function\\n * @extends Tech\\n * @class Flash\\n */\\n\\nvar Flash = (function (_Tech) {\\n  _inherits(Flash, _Tech);\\n\\n  function Flash(options, ready) {\\n    _classCallCheck(this, Flash);\\n\\n    _Tech.call(this, options, ready);\\n\\n    // Set the source when ready\\n    if (options.source) {\\n      this.ready(function () {\\n        this.setSource(options.source);\\n      }, true);\\n    }\\n\\n    // Having issues with Flash reloading on certain page actions (hide/resize/fullscreen) in certain browsers\\n    // This allows resetting the playhead when we catch the reload\\n    if (options.startTime) {\\n      this.ready(function () {\\n        this.load();\\n        this.play();\\n        this.currentTime(options.startTime);\\n      }, true);\\n    }\\n\\n    // Add global window functions that the swf expects\\n    // A 4.x workflow we weren't able to solve for in 5.0\\n    // because of the need to hard code these functions\\n    // into the swf for security reasons\\n    _globalWindow2['default'].videojs = _globalWindow2['default'].videojs || {};\\n    _globalWindow2['default'].videojs.Flash = _globalWindow2['default'].videojs.Flash || {};\\n    _globalWindow2['default'].videojs.Flash.onReady = Flash.onReady;\\n    _globalWindow2['default'].videojs.Flash.onEvent = Flash.onEvent;\\n    _globalWindow2['default'].videojs.Flash.onError = Flash.onError;\\n\\n    this.on('seeked', function () {\\n      this.lastSeekTarget_ = undefined;\\n    });\\n  }\\n\\n  // Create setters and getters for attributes\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  Flash.prototype.createEl = function createEl() {\\n    var options = this.options_;\\n\\n    // If video.js is hosted locally you should also set the location\\n    // for the hosted swf, which should be relative to the page (not video.js)\\n    // Otherwise this adds a CDN url.\\n    // The CDN also auto-adds a swf URL for that specific version.\\n    if (!options.swf) {\\n      options.swf = '//vjs.zencdn.net/swf/5.1.0/video-js.swf';\\n    }\\n\\n    // Generate ID for swf object\\n    var objId = options.techId;\\n\\n    // Merge default flashvars with ones passed in to init\\n    var flashVars = _objectAssign2['default']({\\n\\n      // SWF Callback Functions\\n      'readyFunction': 'videojs.Flash.onReady',\\n      'eventProxyFunction': 'videojs.Flash.onEvent',\\n      'errorEventProxyFunction': 'videojs.Flash.onError',\\n\\n      // Player Settings\\n      'autoplay': options.autoplay,\\n      'preload': options.preload,\\n      'loop': options.loop,\\n      'muted': options.muted\\n\\n    }, options.flashVars);\\n\\n    // Merge default parames with ones passed in\\n    var params = _objectAssign2['default']({\\n      'wmode': 'opaque', // Opaque is needed to overlay controls, but can affect playback performance\\n      'bgcolor': '#000000' // Using bgcolor prevents a white flash when the object is loading\\n    }, options.params);\\n\\n    // Merge default attributes with ones passed in\\n    var attributes = _objectAssign2['default']({\\n      'id': objId,\\n      'name': objId, // Both ID and Name needed or swf to identify itself\\n      'class': 'vjs-tech'\\n    }, options.attributes);\\n\\n    this.el_ = Flash.embed(options.swf, flashVars, params, attributes);\\n    this.el_.tech = this;\\n\\n    return this.el_;\\n  };\\n\\n  /**\\n   * Play for flash tech\\n   *\\n   * @method play\\n   */\\n\\n  Flash.prototype.play = function play() {\\n    if (this.ended()) {\\n      this.setCurrentTime(0);\\n    }\\n    this.el_.vjs_play();\\n  };\\n\\n  /**\\n   * Pause for flash tech\\n   *\\n   * @method pause\\n   */\\n\\n  Flash.prototype.pause = function pause() {\\n    this.el_.vjs_pause();\\n  };\\n\\n  /**\\n   * Get/set video\\n   *\\n   * @param {Object=} src Source object\\n   * @return {Object}\\n   * @method src\\n   */\\n\\n  Flash.prototype.src = function src(_src) {\\n    if (_src === undefined) {\\n      return this.currentSrc();\\n    }\\n\\n    // Setting src through `src` not `setSrc` will be deprecated\\n    return this.setSrc(_src);\\n  };\\n\\n  /**\\n   * Set video\\n   *\\n   * @param {Object=} src Source object\\n   * @deprecated\\n   * @method setSrc\\n   */\\n\\n  Flash.prototype.setSrc = function setSrc(src) {\\n    // Make sure source URL is absolute.\\n    src = Url.getAbsoluteURL(src);\\n    this.el_.vjs_src(src);\\n\\n    // Currently the SWF doesn't autoplay if you load a source later.\\n    // e.g. Load player w/ no source, wait 2s, set src.\\n    if (this.autoplay()) {\\n      var tech = this;\\n      this.setTimeout(function () {\\n        tech.play();\\n      }, 0);\\n    }\\n  };\\n\\n  /**\\n   * Returns true if the tech is currently seeking.\\n   * @return {boolean} true if seeking\\n   */\\n\\n  Flash.prototype.seeking = function seeking() {\\n    return this.lastSeekTarget_ !== undefined;\\n  };\\n\\n  /**\\n   * Set current time\\n   *\\n   * @param {Number} time Current time of video\\n   * @method setCurrentTime\\n   */\\n\\n  Flash.prototype.setCurrentTime = function setCurrentTime(time) {\\n    var seekable = this.seekable();\\n    if (seekable.length) {\\n      // clamp to the current seekable range\\n      time = time > seekable.start(0) ? time : seekable.start(0);\\n      time = time < seekable.end(seekable.length - 1) ? time : seekable.end(seekable.length - 1);\\n\\n      this.lastSeekTarget_ = time;\\n      this.trigger('seeking');\\n      this.el_.vjs_setProperty('currentTime', time);\\n      _Tech.prototype.setCurrentTime.call(this);\\n    }\\n  };\\n\\n  /**\\n   * Get current time\\n   *\\n   * @param {Number=} time Current time of video\\n   * @return {Number} Current time\\n   * @method currentTime\\n   */\\n\\n  Flash.prototype.currentTime = function currentTime(time) {\\n    // when seeking make the reported time keep up with the requested time\\n    // by reading the time we're seeking to\\n    if (this.seeking()) {\\n      return this.lastSeekTarget_ || 0;\\n    }\\n    return this.el_.vjs_getProperty('currentTime');\\n  };\\n\\n  /**\\n   * Get current source\\n   *\\n   * @method currentSrc\\n   */\\n\\n  Flash.prototype.currentSrc = function currentSrc() {\\n    if (this.currentSource_) {\\n      return this.currentSource_.src;\\n    } else {\\n      return this.el_.vjs_getProperty('currentSrc');\\n    }\\n  };\\n\\n  /**\\n   * Get media duration\\n   *\\n   * @returns {Number} Media duration\\n   */\\n\\n  Flash.prototype.duration = function duration() {\\n    if (this.readyState() === 0) {\\n      return NaN;\\n    } else {\\n      var duration = this.el_.vjs_getProperty('duration');\\n      return duration >= 0 ? duration : Infinity;\\n    }\\n  };\\n\\n  /**\\n   * Load media into player\\n   *\\n   * @method load\\n   */\\n\\n  Flash.prototype.load = function load() {\\n    this.el_.vjs_load();\\n  };\\n\\n  /**\\n   * Get poster\\n   *\\n   * @method poster\\n   */\\n\\n  Flash.prototype.poster = function poster() {\\n    this.el_.vjs_getProperty('poster');\\n  };\\n\\n  /**\\n   * Poster images are not handled by the Flash tech so make this a no-op\\n   *\\n   * @method setPoster\\n   */\\n\\n  Flash.prototype.setPoster = function setPoster() {};\\n\\n  /**\\n   * Determine if can seek in media\\n   *\\n   * @return {TimeRangeObject}\\n   * @method seekable\\n   */\\n\\n  Flash.prototype.seekable = function seekable() {\\n    var duration = this.duration();\\n    if (duration === 0) {\\n      return _utilsTimeRangesJs.createTimeRange();\\n    }\\n    return _utilsTimeRangesJs.createTimeRange(0, duration);\\n  };\\n\\n  /**\\n   * Get buffered time range\\n   *\\n   * @return {TimeRangeObject}\\n   * @method buffered\\n   */\\n\\n  Flash.prototype.buffered = function buffered() {\\n    var ranges = this.el_.vjs_getProperty('buffered');\\n    if (ranges.length === 0) {\\n      return _utilsTimeRangesJs.createTimeRange();\\n    }\\n    return _utilsTimeRangesJs.createTimeRange(ranges[0][0], ranges[0][1]);\\n  };\\n\\n  /**\\n   * Get fullscreen support -\\n   * Flash does not allow fullscreen through javascript\\n   * so always returns false\\n   *\\n   * @return {Boolean} false\\n   * @method supportsFullScreen\\n   */\\n\\n  Flash.prototype.supportsFullScreen = function supportsFullScreen() {\\n    return false; // Flash does not allow fullscreen through javascript\\n  };\\n\\n  /**\\n   * Request to enter fullscreen\\n   * Flash does not allow fullscreen through javascript\\n   * so always returns false\\n   *\\n   * @return {Boolean} false\\n   * @method enterFullScreen\\n   */\\n\\n  Flash.prototype.enterFullScreen = function enterFullScreen() {\\n    return false;\\n  };\\n\\n  return Flash;\\n})(_tech2['default']);\\n\\nvar _api = Flash.prototype;\\nvar _readWrite = 'rtmpConnection,rtmpStream,preload,defaultPlaybackRate,playbackRate,autoplay,loop,mediaGroup,controller,controls,volume,muted,defaultMuted'.split(',');\\nvar _readOnly = 'networkState,readyState,initialTime,startOffsetTime,paused,ended,videoWidth,videoHeight'.split(',');\\n\\nfunction _createSetter(attr) {\\n  var attrUpper = attr.charAt(0).toUpperCase() + attr.slice(1);\\n  _api['set' + attrUpper] = function (val) {\\n    return this.el_.vjs_setProperty(attr, val);\\n  };\\n}\\nfunction _createGetter(attr) {\\n  _api[attr] = function () {\\n    return this.el_.vjs_getProperty(attr);\\n  };\\n}\\n\\n// Create getter and setters for all read/write attributes\\nfor (var i = 0; i < _readWrite.length; i++) {\\n  _createGetter(_readWrite[i]);\\n  _createSetter(_readWrite[i]);\\n}\\n\\n// Create getters for read-only attributes\\nfor (var i = 0; i < _readOnly.length; i++) {\\n  _createGetter(_readOnly[i]);\\n}\\n\\n/* Flash Support Testing -------------------------------------------------------- */\\n\\nFlash.isSupported = function () {\\n  return Flash.version()[0] >= 10;\\n  // return swfobject.hasFlashPlayerVersion('10');\\n};\\n\\n// Add Source Handler pattern functions to this tech\\n_tech2['default'].withSourceHandlers(Flash);\\n\\n/*\\n * The default native source handler.\\n * This simply passes the source to the video element. Nothing fancy.\\n *\\n * @param  {Object} source   The source object\\n * @param  {Flash} tech  The instance of the Flash tech\\n */\\nFlash.nativeSourceHandler = {};\\n\\n/**\\n * Check if Flash can play the given videotype\\n * @param  {String} type    The mimetype to check\\n * @return {String}         'probably', 'maybe', or '' (empty string)\\n */\\nFlash.nativeSourceHandler.canPlayType = function (type) {\\n  if (type in Flash.formats) {\\n    return 'maybe';\\n  }\\n\\n  return '';\\n};\\n\\n/*\\n * Check Flash can handle the source natively\\n *\\n * @param  {Object} source  The source object\\n * @param  {Object} options The options passed to the tech\\n * @return {String}         'probably', 'maybe', or '' (empty string)\\n */\\nFlash.nativeSourceHandler.canHandleSource = function (source, options) {\\n  var type;\\n\\n  function guessMimeType(src) {\\n    var ext = Url.getFileExtension(src);\\n    if (ext) {\\n      return 'video/' + ext;\\n    }\\n    return '';\\n  }\\n\\n  if (!source.type) {\\n    type = guessMimeType(source.src);\\n  } else {\\n    // Strip code information from the type because we don't get that specific\\n    type = source.type.replace(/;.*/, '').toLowerCase();\\n  }\\n\\n  return Flash.nativeSourceHandler.canPlayType(type);\\n};\\n\\n/*\\n * Pass the source to the flash object\\n * Adaptive source handlers will have more complicated workflows before passing\\n * video data to the video element\\n *\\n * @param  {Object} source   The source object\\n * @param  {Flash}  tech     The instance of the Flash tech\\n * @param  {Object} options  The options to pass to the source\\n */\\nFlash.nativeSourceHandler.handleSource = function (source, tech, options) {\\n  tech.setSrc(source.src);\\n};\\n\\n/*\\n * Clean up the source handler when disposing the player or switching sources..\\n * (no cleanup is needed when supporting the format natively)\\n */\\nFlash.nativeSourceHandler.dispose = function () {};\\n\\n// Register the native source handler\\nFlash.registerSourceHandler(Flash.nativeSourceHandler);\\n\\nFlash.formats = {\\n  'video/flv': 'FLV',\\n  'video/x-flv': 'FLV',\\n  'video/mp4': 'MP4',\\n  'video/m4v': 'MP4'\\n};\\n\\nFlash.onReady = function (currSwf) {\\n  var el = Dom.getEl(currSwf);\\n  var tech = el && el.tech;\\n\\n  // if there is no el then the tech has been disposed\\n  // and the tech element was removed from the player div\\n  if (tech && tech.el()) {\\n    // check that the flash object is really ready\\n    Flash.checkReady(tech);\\n  }\\n};\\n\\n// The SWF isn't always ready when it says it is. Sometimes the API functions still need to be added to the object.\\n// If it's not ready, we set a timeout to check again shortly.\\nFlash.checkReady = function (tech) {\\n  // stop worrying if the tech has been disposed\\n  if (!tech.el()) {\\n    return;\\n  }\\n\\n  // check if API property exists\\n  if (tech.el().vjs_getProperty) {\\n    // tell tech it's ready\\n    tech.triggerReady();\\n  } else {\\n    // wait longer\\n    this.setTimeout(function () {\\n      Flash['checkReady'](tech);\\n    }, 50);\\n  }\\n};\\n\\n// Trigger events from the swf on the player\\nFlash.onEvent = function (swfID, eventName) {\\n  var tech = Dom.getEl(swfID).tech;\\n  tech.trigger(eventName, Array.prototype.slice.call(arguments, 2));\\n};\\n\\n// Log errors from the swf\\nFlash.onError = function (swfID, err) {\\n  var tech = Dom.getEl(swfID).tech;\\n\\n  // trigger MEDIA_ERR_SRC_NOT_SUPPORTED\\n  if (err === 'srcnotfound') {\\n    return tech.error(4);\\n  }\\n\\n  // trigger a custom error\\n  tech.error('FLASH: ' + err);\\n};\\n\\n// Flash Version Check\\nFlash.version = function () {\\n  var version = '0,0,0';\\n\\n  // IE\\n  try {\\n    version = new _globalWindow2['default'].ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\\\\D+/g, ',').match(/^,?(.+),?$/)[1];\\n\\n    // other browsers\\n  } catch (e) {\\n    try {\\n      if (navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin) {\\n        version = (navigator.plugins['Shockwave Flash 2.0'] || navigator.plugins['Shockwave Flash']).description.replace(/\\\\D+/g, ',').match(/^,?(.+),?$/)[1];\\n      }\\n    } catch (err) {}\\n  }\\n  return version.split(',');\\n};\\n\\n// Flash embedding method. Only used in non-iframe mode\\nFlash.embed = function (swf, flashVars, params, attributes) {\\n  var code = Flash.getEmbedCode(swf, flashVars, params, attributes);\\n\\n  // Get element by embedding code and retrieving created element\\n  var obj = Dom.createEl('div', { innerHTML: code }).childNodes[0];\\n\\n  return obj;\\n};\\n\\nFlash.getEmbedCode = function (swf, flashVars, params, attributes) {\\n  var objTag = '<object type=\\\"application/x-shockwave-flash\\\" ';\\n  var flashVarsString = '';\\n  var paramsString = '';\\n  var attrsString = '';\\n\\n  // Convert flash vars to string\\n  if (flashVars) {\\n    Object.getOwnPropertyNames(flashVars).forEach(function (key) {\\n      flashVarsString += key + '=' + flashVars[key] + '&amp;';\\n    });\\n  }\\n\\n  // Add swf, flashVars, and other default params\\n  params = _objectAssign2['default']({\\n    'movie': swf,\\n    'flashvars': flashVarsString,\\n    'allowScriptAccess': 'always', // Required to talk to swf\\n    'allowNetworking': 'all' // All should be default, but having security issues.\\n  }, params);\\n\\n  // Create param tags string\\n  Object.getOwnPropertyNames(params).forEach(function (key) {\\n    paramsString += '<param name=\\\"' + key + '\\\" value=\\\"' + params[key] + '\\\" />';\\n  });\\n\\n  attributes = _objectAssign2['default']({\\n    // Add swf to attributes (need both for IE and Others to work)\\n    'data': swf,\\n\\n    // Default to 100% width/height\\n    'width': '100%',\\n    'height': '100%'\\n\\n  }, attributes);\\n\\n  // Create Attributes string\\n  Object.getOwnPropertyNames(attributes).forEach(function (key) {\\n    attrsString += key + '=\\\"' + attributes[key] + '\\\" ';\\n  });\\n\\n  return '' + objTag + attrsString + '>' + paramsString + '</object>';\\n};\\n\\n// Run Flash through the RTMP decorator\\n_flashRtmp2['default'](Flash);\\n\\n_component2['default'].registerComponent('Flash', Flash);\\n_tech2['default'].registerTech('Flash', Flash);\\nexports['default'] = Flash;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component\\\":67,\\\"../utils/dom.js\\\":142,\\\"../utils/time-ranges.js\\\":150,\\\"../utils/url.js\\\":152,\\\"./flash-rtmp\\\":120,\\\"./tech\\\":124,\\\"global/window\\\":2,\\\"object.assign\\\":45}],122:[function(_dereq_,module,exports){\\n/**\\n * @file html5.js\\n * HTML5 Media Controller - Wrapper for HTML5 Media API\\n */\\n\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nvar _templateObject = _taggedTemplateLiteralLoose(['Text Tracks are being loaded from another origin but the crossorigin attribute isn\\\\'t used. \\\\n            This may prevent text tracks from loading.'], ['Text Tracks are being loaded from another origin but the crossorigin attribute isn\\\\'t used. \\\\n            This may prevent text tracks from loading.']);\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nfunction _taggedTemplateLiteralLoose(strings, raw) { strings.raw = raw; return strings; }\\n\\nvar _techJs = _dereq_('./tech.js');\\n\\nvar _techJs2 = _interopRequireDefault(_techJs);\\n\\nvar _component = _dereq_('../component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _utilsDomJs = _dereq_('../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsUrlJs = _dereq_('../utils/url.js');\\n\\nvar Url = _interopRequireWildcard(_utilsUrlJs);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsLogJs = _dereq_('../utils/log.js');\\n\\nvar _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);\\n\\nvar _tsml = _dereq_('tsml');\\n\\nvar _tsml2 = _interopRequireDefault(_tsml);\\n\\nvar _srcJsTracksTextTrackJs = _dereq_('../../../src/js/tracks/text-track.js');\\n\\nvar _srcJsTracksTextTrackJs2 = _interopRequireDefault(_srcJsTracksTextTrackJs);\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _objectAssign = _dereq_('object.assign');\\n\\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\\n\\nvar _utilsMergeOptionsJs = _dereq_('../utils/merge-options.js');\\n\\nvar _utilsMergeOptionsJs2 = _interopRequireDefault(_utilsMergeOptionsJs);\\n\\nvar _utilsToTitleCaseJs = _dereq_('../utils/to-title-case.js');\\n\\nvar _utilsToTitleCaseJs2 = _interopRequireDefault(_utilsToTitleCaseJs);\\n\\n/**\\n * HTML5 Media Controller - Wrapper for HTML5 Media API\\n *\\n * @param {Object=} options Object of option names and values\\n * @param {Function=} ready Ready callback function\\n * @extends Tech\\n * @class Html5\\n */\\n\\nvar Html5 = (function (_Tech) {\\n  _inherits(Html5, _Tech);\\n\\n  function Html5(options, ready) {\\n    var _this = this;\\n\\n    _classCallCheck(this, Html5);\\n\\n    _Tech.call(this, options, ready);\\n\\n    var source = options.source;\\n    var crossoriginTracks = false;\\n\\n    // Set the source if one is provided\\n    // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)\\n    // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source\\n    // anyway so the error gets fired.\\n    if (source && (this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {\\n      this.setSource(source);\\n    } else {\\n      this.handleLateInit_(this.el_);\\n    }\\n\\n    if (this.el_.hasChildNodes()) {\\n\\n      var nodes = this.el_.childNodes;\\n      var nodesLength = nodes.length;\\n      var removeNodes = [];\\n\\n      while (nodesLength--) {\\n        var node = nodes[nodesLength];\\n        var nodeName = node.nodeName.toLowerCase();\\n\\n        if (nodeName === 'track') {\\n          if (!this.featuresNativeTextTracks) {\\n            // Empty video tag tracks so the built-in player doesn't use them also.\\n            // This may not be fast enough to stop HTML5 browsers from reading the tags\\n            // so we'll need to turn off any default tracks if we're manually doing\\n            // captions and subtitles. videoElement.textTracks\\n            removeNodes.push(node);\\n          } else {\\n            // store HTMLTrackElement and TextTrack to remote list\\n            this.remoteTextTrackEls().addTrackElement_(node);\\n            this.remoteTextTracks().addTrack_(node.track);\\n            if (!crossoriginTracks && !this.el_.hasAttribute('crossorigin') && Url.isCrossOrigin(node.src)) {\\n              crossoriginTracks = true;\\n            }\\n          }\\n        }\\n      }\\n\\n      for (var i = 0; i < removeNodes.length; i++) {\\n        this.el_.removeChild(removeNodes[i]);\\n      }\\n    }\\n\\n    var trackTypes = ['audio', 'video'];\\n\\n    // ProxyNativeTextTracks\\n    trackTypes.forEach(function (type) {\\n      var capitalType = _utilsToTitleCaseJs2['default'](type);\\n\\n      if (!_this['featuresNative' + capitalType + 'Tracks']) {\\n        return;\\n      }\\n      var tl = _this.el()[type + 'Tracks'];\\n\\n      if (tl && tl.addEventListener) {\\n        tl.addEventListener('change', Fn.bind(_this, _this['handle' + capitalType + 'TrackChange_']));\\n        tl.addEventListener('addtrack', Fn.bind(_this, _this['handle' + capitalType + 'TrackAdd_']));\\n        tl.addEventListener('removetrack', Fn.bind(_this, _this['handle' + capitalType + 'TrackRemove_']));\\n\\n        // Remove (native) trackts that are not used anymore\\n        _this.on('loadstart', _this['removeOld' + capitalType + 'Tracks_']);\\n      }\\n    });\\n\\n    if (this.featuresNativeTextTracks) {\\n      if (crossoriginTracks) {\\n        _utilsLogJs2['default'].warn(_tsml2['default'](_templateObject));\\n      }\\n\\n      this.handleTextTrackChange_ = Fn.bind(this, this.handleTextTrackChange);\\n      this.handleTextTrackAdd_ = Fn.bind(this, this.handleTextTrackAdd);\\n      this.handleTextTrackRemove_ = Fn.bind(this, this.handleTextTrackRemove);\\n      this.proxyNativeTextTracks_();\\n    }\\n\\n    // Determine if native controls should be used\\n    // Our goal should be to get the custom controls on mobile solid everywhere\\n    // so we can remove this all together. Right now this will block custom\\n    // controls on touch enabled laptops like the Chrome Pixel\\n    if ((browser.TOUCH_ENABLED || browser.IS_IPHONE || browser.IS_NATIVE_ANDROID) && options.nativeControlsForTouch === true) {\\n      this.setControls(true);\\n    }\\n\\n    this.triggerReady();\\n  }\\n\\n  /* HTML5 Support Testing ---------------------------------------------------- */\\n\\n  /*\\n  * Element for testing browser HTML5 video capabilities\\n  *\\n  * @type {Element}\\n  * @constant\\n  * @private\\n  */\\n\\n  /**\\n   * Dispose of html5 media element\\n   *\\n   * @method dispose\\n   */\\n\\n  Html5.prototype.dispose = function dispose() {\\n    var _this2 = this;\\n\\n    // Un-ProxyNativeTracks\\n    ['audio', 'video', 'text'].forEach(function (type) {\\n      var capitalType = _utilsToTitleCaseJs2['default'](type);\\n      var tl = _this2.el_[type + 'Tracks'];\\n\\n      if (tl && tl.removeEventListener) {\\n        tl.removeEventListener('change', _this2['handle' + capitalType + 'TrackChange_']);\\n        tl.removeEventListener('addtrack', _this2['handle' + capitalType + 'TrackAdd_']);\\n        tl.removeEventListener('removetrack', _this2['handle' + capitalType + 'TrackRemove_']);\\n      }\\n\\n      // Stop removing old text tracks\\n      if (tl) {\\n        _this2.off('loadstart', _this2['removeOld' + capitalType + 'Tracks_']);\\n      }\\n    });\\n\\n    Html5.disposeMediaElement(this.el_);\\n    // tech will handle clearing of the emulated track list\\n    _Tech.prototype.dispose.call(this);\\n  };\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  Html5.prototype.createEl = function createEl() {\\n    var el = this.options_.tag;\\n\\n    // Check if this browser supports moving the element into the box.\\n    // On the iPhone video will break if you move the element,\\n    // So we have to create a brand new element.\\n    if (!el || this['movingMediaElementInDOM'] === false) {\\n\\n      // If the original tag is still there, clone and remove it.\\n      if (el) {\\n        var clone = el.cloneNode(true);\\n        el.parentNode.insertBefore(clone, el);\\n        Html5.disposeMediaElement(el);\\n        el = clone;\\n      } else {\\n        el = _globalDocument2['default'].createElement('video');\\n\\n        // determine if native controls should be used\\n        var tagAttributes = this.options_.tag && Dom.getElAttributes(this.options_.tag);\\n        var attributes = _utilsMergeOptionsJs2['default']({}, tagAttributes);\\n        if (!browser.TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {\\n          delete attributes.controls;\\n        }\\n\\n        Dom.setElAttributes(el, _objectAssign2['default'](attributes, {\\n          id: this.options_.techId,\\n          'class': 'vjs-tech'\\n        }));\\n      }\\n    }\\n\\n    // Update specific tag settings, in case they were overridden\\n    var settingsAttrs = ['autoplay', 'preload', 'loop', 'muted'];\\n    for (var i = settingsAttrs.length - 1; i >= 0; i--) {\\n      var attr = settingsAttrs[i];\\n      var overwriteAttrs = {};\\n      if (typeof this.options_[attr] !== 'undefined') {\\n        overwriteAttrs[attr] = this.options_[attr];\\n      }\\n      Dom.setElAttributes(el, overwriteAttrs);\\n    }\\n\\n    return el;\\n    // jenniisawesome = true;\\n  };\\n\\n  // If we're loading the playback object after it has started loading\\n  // or playing the video (often with autoplay on) then the loadstart event\\n  // has already fired and we need to fire it manually because many things\\n  // rely on it.\\n\\n  Html5.prototype.handleLateInit_ = function handleLateInit_(el) {\\n    var _this3 = this;\\n\\n    if (el.networkState === 0 || el.networkState === 3) {\\n      // The video element hasn't started loading the source yet\\n      // or didn't find a source\\n      return;\\n    }\\n\\n    if (el.readyState === 0) {\\n      var _ret = (function () {\\n        // NetworkState is set synchronously BUT loadstart is fired at the\\n        // end of the current stack, usually before setInterval(fn, 0).\\n        // So at this point we know loadstart may have already fired or is\\n        // about to fire, and either way the player hasn't seen it yet.\\n        // We don't want to fire loadstart prematurely here and cause a\\n        // double loadstart so we'll wait and see if it happens between now\\n        // and the next loop, and fire it if not.\\n        // HOWEVER, we also want to make sure it fires before loadedmetadata\\n        // which could also happen between now and the next loop, so we'll\\n        // watch for that also.\\n        var loadstartFired = false;\\n        var setLoadstartFired = function setLoadstartFired() {\\n          loadstartFired = true;\\n        };\\n        _this3.on('loadstart', setLoadstartFired);\\n\\n        var triggerLoadstart = function triggerLoadstart() {\\n          // We did miss the original loadstart. Make sure the player\\n          // sees loadstart before loadedmetadata\\n          if (!loadstartFired) {\\n            this.trigger('loadstart');\\n          }\\n        };\\n        _this3.on('loadedmetadata', triggerLoadstart);\\n\\n        _this3.ready(function () {\\n          this.off('loadstart', setLoadstartFired);\\n          this.off('loadedmetadata', triggerLoadstart);\\n\\n          if (!loadstartFired) {\\n            // We did miss the original native loadstart. Fire it now.\\n            this.trigger('loadstart');\\n          }\\n        });\\n\\n        return {\\n          v: undefined\\n        };\\n      })();\\n\\n      if (typeof _ret === 'object') return _ret.v;\\n    }\\n\\n    // From here on we know that loadstart already fired and we missed it.\\n    // The other readyState events aren't as much of a problem if we double\\n    // them, so not going to go to as much trouble as loadstart to prevent\\n    // that unless we find reason to.\\n    var eventsToTrigger = ['loadstart'];\\n\\n    // loadedmetadata: newly equal to HAVE_METADATA (1) or greater\\n    eventsToTrigger.push('loadedmetadata');\\n\\n    // loadeddata: newly increased to HAVE_CURRENT_DATA (2) or greater\\n    if (el.readyState >= 2) {\\n      eventsToTrigger.push('loadeddata');\\n    }\\n\\n    // canplay: newly increased to HAVE_FUTURE_DATA (3) or greater\\n    if (el.readyState >= 3) {\\n      eventsToTrigger.push('canplay');\\n    }\\n\\n    // canplaythrough: newly equal to HAVE_ENOUGH_DATA (4)\\n    if (el.readyState >= 4) {\\n      eventsToTrigger.push('canplaythrough');\\n    }\\n\\n    // We still need to give the player time to add event listeners\\n    this.ready(function () {\\n      eventsToTrigger.forEach(function (type) {\\n        this.trigger(type);\\n      }, this);\\n    });\\n  };\\n\\n  Html5.prototype.proxyNativeTextTracks_ = function proxyNativeTextTracks_() {\\n    var tt = this.el().textTracks;\\n\\n    if (tt) {\\n      // Add tracks - if player is initialised after DOM loaded, textTracks\\n      // will not trigger addtrack\\n      for (var i = 0; i < tt.length; i++) {\\n        this.textTracks().addTrack_(tt[i]);\\n      }\\n\\n      if (tt.addEventListener) {\\n        tt.addEventListener('change', this.handleTextTrackChange_);\\n        tt.addEventListener('addtrack', this.handleTextTrackAdd_);\\n        tt.addEventListener('removetrack', this.handleTextTrackRemove_);\\n      }\\n\\n      // Remove (native) texttracks that are not used anymore\\n      this.on('loadstart', this.removeOldTextTracks_);\\n    }\\n  };\\n\\n  Html5.prototype.handleTextTrackChange = function handleTextTrackChange(e) {\\n    var tt = this.textTracks();\\n    this.textTracks().trigger({\\n      type: 'change',\\n      target: tt,\\n      currentTarget: tt,\\n      srcElement: tt\\n    });\\n  };\\n\\n  Html5.prototype.handleTextTrackAdd = function handleTextTrackAdd(e) {\\n    this.textTracks().addTrack_(e.track);\\n  };\\n\\n  Html5.prototype.handleTextTrackRemove = function handleTextTrackRemove(e) {\\n    this.textTracks().removeTrack_(e.track);\\n  };\\n\\n  Html5.prototype.handleVideoTrackChange_ = function handleVideoTrackChange_(e) {\\n    var vt = this.videoTracks();\\n    this.videoTracks().trigger({\\n      type: 'change',\\n      target: vt,\\n      currentTarget: vt,\\n      srcElement: vt\\n    });\\n  };\\n\\n  Html5.prototype.handleVideoTrackAdd_ = function handleVideoTrackAdd_(e) {\\n    this.videoTracks().addTrack_(e.track);\\n  };\\n\\n  Html5.prototype.handleVideoTrackRemove_ = function handleVideoTrackRemove_(e) {\\n    this.videoTracks().removeTrack_(e.track);\\n  };\\n\\n  Html5.prototype.handleAudioTrackChange_ = function handleAudioTrackChange_(e) {\\n    var audioTrackList = this.audioTracks();\\n    this.audioTracks().trigger({\\n      type: 'change',\\n      target: audioTrackList,\\n      currentTarget: audioTrackList,\\n      srcElement: audioTrackList\\n    });\\n  };\\n\\n  Html5.prototype.handleAudioTrackAdd_ = function handleAudioTrackAdd_(e) {\\n    this.audioTracks().addTrack_(e.track);\\n  };\\n\\n  Html5.prototype.handleAudioTrackRemove_ = function handleAudioTrackRemove_(e) {\\n    this.audioTracks().removeTrack_(e.track);\\n  };\\n\\n  /**\\n   * This is a helper function that is used in removeOldTextTracks_, removeOldAudioTracks_ and\\n   * removeOldVideoTracks_\\n   * @param {Track[]} techTracks Tracks for this tech\\n   * @param {Track[]} elTracks Tracks for the HTML5 video element\\n   * @private\\n   */\\n\\n  Html5.prototype.removeOldTracks_ = function removeOldTracks_(techTracks, elTracks) {\\n    // This will loop over the techTracks and check if they are still used by the HTML5 video element\\n    // If not, they will be removed from the emulated list\\n    var removeTracks = [];\\n    if (!elTracks) {\\n      return;\\n    }\\n\\n    for (var i = 0; i < techTracks.length; i++) {\\n      var techTrack = techTracks[i];\\n\\n      var found = false;\\n      for (var j = 0; j < elTracks.length; j++) {\\n        if (elTracks[j] === techTrack) {\\n          found = true;\\n          break;\\n        }\\n      }\\n\\n      if (!found) {\\n        removeTracks.push(techTrack);\\n      }\\n    }\\n\\n    for (var i = 0; i < removeTracks.length; i++) {\\n      var _track = removeTracks[i];\\n      techTracks.removeTrack_(_track);\\n    }\\n  };\\n\\n  Html5.prototype.removeOldTextTracks_ = function removeOldTextTracks_() {\\n    var techTracks = this.textTracks();\\n    var elTracks = this.el().textTracks;\\n    this.removeOldTracks_(techTracks, elTracks);\\n  };\\n\\n  Html5.prototype.removeOldAudioTracks_ = function removeOldAudioTracks_() {\\n    var techTracks = this.audioTracks();\\n    var elTracks = this.el().audioTracks;\\n    this.removeOldTracks_(techTracks, elTracks);\\n  };\\n\\n  Html5.prototype.removeOldVideoTracks_ = function removeOldVideoTracks_() {\\n    var techTracks = this.videoTracks();\\n    var elTracks = this.el().videoTracks;\\n    this.removeOldTracks_(techTracks, elTracks);\\n  };\\n\\n  /**\\n   * Play for html5 tech\\n   *\\n   * @method play\\n   */\\n\\n  Html5.prototype.play = function play() {\\n    var playPromise = this.el_.play();\\n\\n    // Catch/silence error when a pause interrupts a play request\\n    // on browsers which return a promise\\n    if (playPromise !== undefined && typeof playPromise.then === 'function') {\\n      playPromise.then(null, function (e) {});\\n    }\\n  };\\n\\n  /**\\n   * Pause for html5 tech\\n   *\\n   * @method pause\\n   */\\n\\n  Html5.prototype.pause = function pause() {\\n    this.el_.pause();\\n  };\\n\\n  /**\\n   * Paused for html5 tech\\n   *\\n   * @return {Boolean}\\n   * @method paused\\n   */\\n\\n  Html5.prototype.paused = function paused() {\\n    return this.el_.paused;\\n  };\\n\\n  /**\\n   * Get current time\\n   *\\n   * @return {Number}\\n   * @method currentTime\\n   */\\n\\n  Html5.prototype.currentTime = function currentTime() {\\n    return this.el_.currentTime;\\n  };\\n\\n  /**\\n   * Set current time\\n   *\\n   * @param {Number} seconds Current time of video\\n   * @method setCurrentTime\\n   */\\n\\n  Html5.prototype.setCurrentTime = function setCurrentTime(seconds) {\\n    try {\\n      this.el_.currentTime = seconds;\\n    } catch (e) {\\n      _utilsLogJs2['default'](e, 'Video is not ready. (Video.js)');\\n      // this.warning(VideoJS.warnings.videoNotReady);\\n    }\\n  };\\n\\n  /**\\n   * Get duration\\n   *\\n   * @return {Number}\\n   * @method duration\\n   */\\n\\n  Html5.prototype.duration = function duration() {\\n    return this.el_.duration || 0;\\n  };\\n\\n  /**\\n   * Get a TimeRange object that represents the intersection\\n   * of the time ranges for which the user agent has all\\n   * relevant media\\n   *\\n   * @return {TimeRangeObject}\\n   * @method buffered\\n   */\\n\\n  Html5.prototype.buffered = function buffered() {\\n    return this.el_.buffered;\\n  };\\n\\n  /**\\n   * Get volume level\\n   *\\n   * @return {Number}\\n   * @method volume\\n   */\\n\\n  Html5.prototype.volume = function volume() {\\n    return this.el_.volume;\\n  };\\n\\n  /**\\n   * Set volume level\\n   *\\n   * @param {Number} percentAsDecimal Volume percent as a decimal\\n   * @method setVolume\\n   */\\n\\n  Html5.prototype.setVolume = function setVolume(percentAsDecimal) {\\n    this.el_.volume = percentAsDecimal;\\n  };\\n\\n  /**\\n   * Get if muted\\n   *\\n   * @return {Boolean}\\n   * @method muted\\n   */\\n\\n  Html5.prototype.muted = function muted() {\\n    return this.el_.muted;\\n  };\\n\\n  /**\\n   * Set muted\\n   *\\n   * @param {Boolean} If player is to be muted or note\\n   * @method setMuted\\n   */\\n\\n  Html5.prototype.setMuted = function setMuted(muted) {\\n    this.el_.muted = muted;\\n  };\\n\\n  /**\\n   * Get player width\\n   *\\n   * @return {Number}\\n   * @method width\\n   */\\n\\n  Html5.prototype.width = function width() {\\n    return this.el_.offsetWidth;\\n  };\\n\\n  /**\\n   * Get player height\\n   *\\n   * @return {Number}\\n   * @method height\\n   */\\n\\n  Html5.prototype.height = function height() {\\n    return this.el_.offsetHeight;\\n  };\\n\\n  /**\\n   * Get if there is fullscreen support\\n   *\\n   * @return {Boolean}\\n   * @method supportsFullScreen\\n   */\\n\\n  Html5.prototype.supportsFullScreen = function supportsFullScreen() {\\n    if (typeof this.el_.webkitEnterFullScreen === 'function') {\\n      var userAgent = _globalWindow2['default'].navigator.userAgent;\\n      // Seems to be broken in Chromium/Chrome && Safari in Leopard\\n      if (/Android/.test(userAgent) || !/Chrome|Mac OS X 10.5/.test(userAgent)) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  };\\n\\n  /**\\n   * Request to enter fullscreen\\n   *\\n   * @method enterFullScreen\\n   */\\n\\n  Html5.prototype.enterFullScreen = function enterFullScreen() {\\n    var video = this.el_;\\n\\n    if ('webkitDisplayingFullscreen' in video) {\\n      this.one('webkitbeginfullscreen', function () {\\n        this.one('webkitendfullscreen', function () {\\n          this.trigger('fullscreenchange', { isFullscreen: false });\\n        });\\n\\n        this.trigger('fullscreenchange', { isFullscreen: true });\\n      });\\n    }\\n\\n    if (video.paused && video.networkState <= video.HAVE_METADATA) {\\n      // attempt to prime the video element for programmatic access\\n      // this isn't necessary on the desktop but shouldn't hurt\\n      this.el_.play();\\n\\n      // playing and pausing synchronously during the transition to fullscreen\\n      // can get iOS ~6.1 devices into a play/pause loop\\n      this.setTimeout(function () {\\n        video.pause();\\n        video.webkitEnterFullScreen();\\n      }, 0);\\n    } else {\\n      video.webkitEnterFullScreen();\\n    }\\n  };\\n\\n  /**\\n   * Request to exit fullscreen\\n   *\\n   * @method exitFullScreen\\n   */\\n\\n  Html5.prototype.exitFullScreen = function exitFullScreen() {\\n    this.el_.webkitExitFullScreen();\\n  };\\n\\n  /**\\n   * Get/set video\\n   *\\n   * @param {Object=} src Source object\\n   * @return {Object}\\n   * @method src\\n   */\\n\\n  Html5.prototype.src = function src(_src) {\\n    if (_src === undefined) {\\n      return this.el_.src;\\n    } else {\\n      // Setting src through `src` instead of `setSrc` will be deprecated\\n      this.setSrc(_src);\\n    }\\n  };\\n\\n  /**\\n   * Set video\\n   *\\n   * @param {Object} src Source object\\n   * @deprecated\\n   * @method setSrc\\n   */\\n\\n  Html5.prototype.setSrc = function setSrc(src) {\\n    this.el_.src = src;\\n  };\\n\\n  /**\\n   * Load media into player\\n   *\\n   * @method load\\n   */\\n\\n  Html5.prototype.load = function load() {\\n    this.el_.load();\\n  };\\n\\n  /**\\n   * Reset the tech. Removes all sources and calls `load`.\\n   *\\n   * @method reset\\n   */\\n\\n  Html5.prototype.reset = function reset() {\\n    Html5.resetMediaElement(this.el_);\\n  };\\n\\n  /**\\n   * Get current source\\n   *\\n   * @return {Object}\\n   * @method currentSrc\\n   */\\n\\n  Html5.prototype.currentSrc = function currentSrc() {\\n    if (this.currentSource_) {\\n      return this.currentSource_.src;\\n    } else {\\n      return this.el_.currentSrc;\\n    }\\n  };\\n\\n  /**\\n   * Get poster\\n   *\\n   * @return {String}\\n   * @method poster\\n   */\\n\\n  Html5.prototype.poster = function poster() {\\n    return this.el_.poster;\\n  };\\n\\n  /**\\n   * Set poster\\n   *\\n   * @param {String} val URL to poster image\\n   * @method\\n   */\\n\\n  Html5.prototype.setPoster = function setPoster(val) {\\n    this.el_.poster = val;\\n  };\\n\\n  /**\\n   * Get preload attribute\\n   *\\n   * @return {String}\\n   * @method preload\\n   */\\n\\n  Html5.prototype.preload = function preload() {\\n    return this.el_.preload;\\n  };\\n\\n  /**\\n   * Set preload attribute\\n   *\\n   * @param {String} val Value for preload attribute\\n   * @method setPreload\\n   */\\n\\n  Html5.prototype.setPreload = function setPreload(val) {\\n    this.el_.preload = val;\\n  };\\n\\n  /**\\n   * Get autoplay attribute\\n   *\\n   * @return {String}\\n   * @method autoplay\\n   */\\n\\n  Html5.prototype.autoplay = function autoplay() {\\n    return this.el_.autoplay;\\n  };\\n\\n  /**\\n   * Set autoplay attribute\\n   *\\n   * @param {String} val Value for preload attribute\\n   * @method setAutoplay\\n   */\\n\\n  Html5.prototype.setAutoplay = function setAutoplay(val) {\\n    this.el_.autoplay = val;\\n  };\\n\\n  /**\\n   * Get controls attribute\\n   *\\n   * @return {String}\\n   * @method controls\\n   */\\n\\n  Html5.prototype.controls = function controls() {\\n    return this.el_.controls;\\n  };\\n\\n  /**\\n   * Set controls attribute\\n   *\\n   * @param {String} val Value for controls attribute\\n   * @method setControls\\n   */\\n\\n  Html5.prototype.setControls = function setControls(val) {\\n    this.el_.controls = !!val;\\n  };\\n\\n  /**\\n   * Get loop attribute\\n   *\\n   * @return {String}\\n   * @method loop\\n   */\\n\\n  Html5.prototype.loop = function loop() {\\n    return this.el_.loop;\\n  };\\n\\n  /**\\n   * Set loop attribute\\n   *\\n   * @param {String} val Value for loop attribute\\n   * @method setLoop\\n   */\\n\\n  Html5.prototype.setLoop = function setLoop(val) {\\n    this.el_.loop = val;\\n  };\\n\\n  /**\\n   * Get error value\\n   *\\n   * @return {String}\\n   * @method error\\n   */\\n\\n  Html5.prototype.error = function error() {\\n    return this.el_.error;\\n  };\\n\\n  /**\\n   * Get whether or not the player is in the \\\"seeking\\\" state\\n   *\\n   * @return {Boolean}\\n   * @method seeking\\n   */\\n\\n  Html5.prototype.seeking = function seeking() {\\n    return this.el_.seeking;\\n  };\\n\\n  /**\\n   * Get a TimeRanges object that represents the\\n   * ranges of the media resource to which it is possible\\n   * for the user agent to seek.\\n   *\\n   * @return {TimeRangeObject}\\n   * @method seekable\\n   */\\n\\n  Html5.prototype.seekable = function seekable() {\\n    return this.el_.seekable;\\n  };\\n\\n  /**\\n   * Get if video ended\\n   *\\n   * @return {Boolean}\\n   * @method ended\\n   */\\n\\n  Html5.prototype.ended = function ended() {\\n    return this.el_.ended;\\n  };\\n\\n  /**\\n   * Get the value of the muted content attribute\\n   * This attribute has no dynamic effect, it only\\n   * controls the default state of the element\\n   *\\n   * @return {Boolean}\\n   * @method defaultMuted\\n   */\\n\\n  Html5.prototype.defaultMuted = function defaultMuted() {\\n    return this.el_.defaultMuted;\\n  };\\n\\n  /**\\n   * Get desired speed at which the media resource is to play\\n   *\\n   * @return {Number}\\n   * @method playbackRate\\n   */\\n\\n  Html5.prototype.playbackRate = function playbackRate() {\\n    return this.el_.playbackRate;\\n  };\\n\\n  /**\\n   * Returns a TimeRanges object that represents the ranges of the\\n   * media resource that the user agent has played.\\n   * @return {TimeRangeObject} the range of points on the media\\n   * timeline that has been reached through normal playback\\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-played\\n   */\\n\\n  Html5.prototype.played = function played() {\\n    return this.el_.played;\\n  };\\n\\n  /**\\n   * Set desired speed at which the media resource is to play\\n   *\\n   * @param {Number} val Speed at which the media resource is to play\\n   * @method setPlaybackRate\\n   */\\n\\n  Html5.prototype.setPlaybackRate = function setPlaybackRate(val) {\\n    this.el_.playbackRate = val;\\n  };\\n\\n  /**\\n   * Get the current state of network activity for the element, from\\n   * the list below\\n   * NETWORK_EMPTY (numeric value 0)\\n   * NETWORK_IDLE (numeric value 1)\\n   * NETWORK_LOADING (numeric value 2)\\n   * NETWORK_NO_SOURCE (numeric value 3)\\n   *\\n   * @return {Number}\\n   * @method networkState\\n   */\\n\\n  Html5.prototype.networkState = function networkState() {\\n    return this.el_.networkState;\\n  };\\n\\n  /**\\n   * Get a value that expresses the current state of the element\\n   * with respect to rendering the current playback position, from\\n   * the codes in the list below\\n   * HAVE_NOTHING (numeric value 0)\\n   * HAVE_METADATA (numeric value 1)\\n   * HAVE_CURRENT_DATA (numeric value 2)\\n   * HAVE_FUTURE_DATA (numeric value 3)\\n   * HAVE_ENOUGH_DATA (numeric value 4)\\n   *\\n   * @return {Number}\\n   * @method readyState\\n   */\\n\\n  Html5.prototype.readyState = function readyState() {\\n    return this.el_.readyState;\\n  };\\n\\n  /**\\n   * Get width of video\\n   *\\n   * @return {Number}\\n   * @method videoWidth\\n   */\\n\\n  Html5.prototype.videoWidth = function videoWidth() {\\n    return this.el_.videoWidth;\\n  };\\n\\n  /**\\n   * Get height of video\\n   *\\n   * @return {Number}\\n   * @method videoHeight\\n   */\\n\\n  Html5.prototype.videoHeight = function videoHeight() {\\n    return this.el_.videoHeight;\\n  };\\n\\n  /**\\n   * Get text tracks\\n   *\\n   * @return {TextTrackList}\\n   * @method textTracks\\n   */\\n\\n  Html5.prototype.textTracks = function textTracks() {\\n    return _Tech.prototype.textTracks.call(this);\\n  };\\n\\n  /**\\n   * Creates and returns a text track object\\n   *\\n   * @param {String} kind Text track kind (subtitles, captions, descriptions\\n   *                                       chapters and metadata)\\n   * @param {String=} label Label to identify the text track\\n   * @param {String=} language Two letter language abbreviation\\n   * @return {TextTrackObject}\\n   * @method addTextTrack\\n   */\\n\\n  Html5.prototype.addTextTrack = function addTextTrack(kind, label, language) {\\n    if (!this['featuresNativeTextTracks']) {\\n      return _Tech.prototype.addTextTrack.call(this, kind, label, language);\\n    }\\n\\n    return this.el_.addTextTrack(kind, label, language);\\n  };\\n\\n  /**\\n   * Creates a remote text track object and returns a html track element\\n   *\\n   * @param {Object} options The object should contain values for\\n   * kind, language, label and src (location of the WebVTT file)\\n   * @return {HTMLTrackElement}\\n   * @method addRemoteTextTrack\\n   */\\n\\n  Html5.prototype.addRemoteTextTrack = function addRemoteTextTrack() {\\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\\n\\n    if (!this['featuresNativeTextTracks']) {\\n      return _Tech.prototype.addRemoteTextTrack.call(this, options);\\n    }\\n\\n    var htmlTrackElement = _globalDocument2['default'].createElement('track');\\n\\n    if (options.kind) {\\n      htmlTrackElement.kind = options.kind;\\n    }\\n    if (options.label) {\\n      htmlTrackElement.label = options.label;\\n    }\\n    if (options.language || options.srclang) {\\n      htmlTrackElement.srclang = options.language || options.srclang;\\n    }\\n    if (options['default']) {\\n      htmlTrackElement['default'] = options['default'];\\n    }\\n    if (options.id) {\\n      htmlTrackElement.id = options.id;\\n    }\\n    if (options.src) {\\n      htmlTrackElement.src = options.src;\\n    }\\n\\n    this.el().appendChild(htmlTrackElement);\\n\\n    // store HTMLTrackElement and TextTrack to remote list\\n    this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);\\n    this.remoteTextTracks().addTrack_(htmlTrackElement.track);\\n\\n    return htmlTrackElement;\\n  };\\n\\n  /**\\n   * Remove remote text track from TextTrackList object\\n   *\\n   * @param {TextTrackObject} track Texttrack object to remove\\n   * @method removeRemoteTextTrack\\n   */\\n\\n  Html5.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track) {\\n    if (!this['featuresNativeTextTracks']) {\\n      return _Tech.prototype.removeRemoteTextTrack.call(this, track);\\n    }\\n\\n    var tracks = undefined,\\n        i = undefined;\\n\\n    var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);\\n\\n    // remove HTMLTrackElement and TextTrack from remote list\\n    this.remoteTextTrackEls().removeTrackElement_(trackElement);\\n    this.remoteTextTracks().removeTrack_(track);\\n\\n    tracks = this.$$('track');\\n\\n    i = tracks.length;\\n    while (i--) {\\n      if (track === tracks[i] || track === tracks[i].track) {\\n        this.el().removeChild(tracks[i]);\\n      }\\n    }\\n  };\\n\\n  return Html5;\\n})(_techJs2['default']);\\n\\nHtml5.TEST_VID = _globalDocument2['default'].createElement('video');\\nvar track = _globalDocument2['default'].createElement('track');\\ntrack.kind = 'captions';\\ntrack.srclang = 'en';\\ntrack.label = 'English';\\nHtml5.TEST_VID.appendChild(track);\\n\\n/*\\n * Check if HTML5 video is supported by this browser/device\\n *\\n * @return {Boolean}\\n */\\nHtml5.isSupported = function () {\\n  // IE9 with no Media Player is a LIAR! (#984)\\n  try {\\n    Html5.TEST_VID['volume'] = 0.5;\\n  } catch (e) {\\n    return false;\\n  }\\n\\n  return !!Html5.TEST_VID.canPlayType;\\n};\\n\\n// Add Source Handler pattern functions to this tech\\n_techJs2['default'].withSourceHandlers(Html5);\\n\\n/*\\n * The default native source handler.\\n * This simply passes the source to the video element. Nothing fancy.\\n *\\n * @param  {Object} source   The source object\\n * @param  {Html5} tech  The instance of the HTML5 tech\\n */\\nHtml5.nativeSourceHandler = {};\\n\\n/*\\n * Check if the video element can play the given videotype\\n *\\n * @param  {String} type    The mimetype to check\\n * @return {String}         'probably', 'maybe', or '' (empty string)\\n */\\nHtml5.nativeSourceHandler.canPlayType = function (type) {\\n  // IE9 on Windows 7 without MediaPlayer throws an error here\\n  // https://github.com/videojs/video.js/issues/519\\n  try {\\n    return Html5.TEST_VID.canPlayType(type);\\n  } catch (e) {\\n    return '';\\n  }\\n};\\n\\n/*\\n * Check if the video element can handle the source natively\\n *\\n * @param  {Object} source  The source object\\n * @param  {Object} options The options passed to the tech\\n * @return {String}         'probably', 'maybe', or '' (empty string)\\n */\\nHtml5.nativeSourceHandler.canHandleSource = function (source, options) {\\n  var match, ext;\\n\\n  // If a type was provided we should rely on that\\n  if (source.type) {\\n    return Html5.nativeSourceHandler.canPlayType(source.type);\\n  } else if (source.src) {\\n    // If no type, fall back to checking 'video/[EXTENSION]'\\n    ext = Url.getFileExtension(source.src);\\n\\n    return Html5.nativeSourceHandler.canPlayType('video/' + ext);\\n  }\\n\\n  return '';\\n};\\n\\n/*\\n * Pass the source to the video element\\n * Adaptive source handlers will have more complicated workflows before passing\\n * video data to the video element\\n *\\n * @param  {Object} source   The source object\\n * @param  {Html5}  tech     The instance of the Html5 tech\\n * @param  {Object} options  The options to pass to the source\\n */\\nHtml5.nativeSourceHandler.handleSource = function (source, tech, options) {\\n  tech.setSrc(source.src);\\n};\\n\\n/*\\n* Clean up the source handler when disposing the player or switching sources..\\n* (no cleanup is needed when supporting the format natively)\\n*/\\nHtml5.nativeSourceHandler.dispose = function () {};\\n\\n// Register the native source handler\\nHtml5.registerSourceHandler(Html5.nativeSourceHandler);\\n\\n/*\\n * Check if the volume can be changed in this browser/device.\\n * Volume cannot be changed in a lot of mobile devices.\\n * Specifically, it can't be changed from 1 on iOS.\\n *\\n * @return {Boolean}\\n */\\nHtml5.canControlVolume = function () {\\n  // IE will error if Windows Media Player not installed #3315\\n  try {\\n    var volume = Html5.TEST_VID.volume;\\n    Html5.TEST_VID.volume = volume / 2 + 0.1;\\n    return volume !== Html5.TEST_VID.volume;\\n  } catch (e) {\\n    return false;\\n  }\\n};\\n\\n/*\\n * Check if playbackRate is supported in this browser/device.\\n *\\n * @return {Boolean}\\n */\\nHtml5.canControlPlaybackRate = function () {\\n  // Playback rate API is implemented in Android Chrome, but doesn't do anything\\n  // https://github.com/videojs/video.js/issues/3180\\n  if (browser.IS_ANDROID && browser.IS_CHROME) {\\n    return false;\\n  }\\n  // IE will error if Windows Media Player not installed #3315\\n  try {\\n    var playbackRate = Html5.TEST_VID.playbackRate;\\n    Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;\\n    return playbackRate !== Html5.TEST_VID.playbackRate;\\n  } catch (e) {\\n    return false;\\n  }\\n};\\n\\n/*\\n * Check to see if native text tracks are supported by this browser/device\\n *\\n * @return {Boolean}\\n */\\nHtml5.supportsNativeTextTracks = function () {\\n  var supportsTextTracks;\\n\\n  // Figure out native text track support\\n  // If mode is a number, we cannot change it because it'll disappear from view.\\n  // Browsers with numeric modes include IE10 and older (<=2013) samsung android models.\\n  // Firefox isn't playing nice either with modifying the mode\\n  // TODO: Investigate firefox: https://github.com/videojs/video.js/issues/1862\\n  supportsTextTracks = !!Html5.TEST_VID.textTracks;\\n  if (supportsTextTracks && Html5.TEST_VID.textTracks.length > 0) {\\n    supportsTextTracks = typeof Html5.TEST_VID.textTracks[0]['mode'] !== 'number';\\n  }\\n  if (supportsTextTracks && browser.IS_FIREFOX) {\\n    supportsTextTracks = false;\\n  }\\n  if (supportsTextTracks && !('onremovetrack' in Html5.TEST_VID.textTracks)) {\\n    supportsTextTracks = false;\\n  }\\n\\n  return supportsTextTracks;\\n};\\n\\n/*\\n * Check to see if native video tracks are supported by this browser/device\\n *\\n * @return {Boolean}\\n */\\nHtml5.supportsNativeVideoTracks = function () {\\n  var supportsVideoTracks = !!Html5.TEST_VID.videoTracks;\\n  return supportsVideoTracks;\\n};\\n\\n/*\\n * Check to see if native audio tracks are supported by this browser/device\\n *\\n * @return {Boolean}\\n */\\nHtml5.supportsNativeAudioTracks = function () {\\n  var supportsAudioTracks = !!Html5.TEST_VID.audioTracks;\\n  return supportsAudioTracks;\\n};\\n\\n/**\\n * An array of events available on the Html5 tech.\\n *\\n * @private\\n * @type {Array}\\n */\\nHtml5.Events = ['loadstart', 'suspend', 'abort', 'error', 'emptied', 'stalled', 'loadedmetadata', 'loadeddata', 'canplay', 'canplaythrough', 'playing', 'waiting', 'seeking', 'seeked', 'ended', 'durationchange', 'timeupdate', 'progress', 'play', 'pause', 'ratechange', 'volumechange'];\\n\\n/*\\n * Set the tech's volume control support status\\n *\\n * @type {Boolean}\\n */\\nHtml5.prototype['featuresVolumeControl'] = Html5.canControlVolume();\\n\\n/*\\n * Set the tech's playbackRate support status\\n *\\n * @type {Boolean}\\n */\\nHtml5.prototype['featuresPlaybackRate'] = Html5.canControlPlaybackRate();\\n\\n/*\\n * Set the tech's status on moving the video element.\\n * In iOS, if you move a video element in the DOM, it breaks video playback.\\n *\\n * @type {Boolean}\\n */\\nHtml5.prototype['movingMediaElementInDOM'] = !browser.IS_IOS;\\n\\n/*\\n * Set the the tech's fullscreen resize support status.\\n * HTML video is able to automatically resize when going to fullscreen.\\n * (No longer appears to be used. Can probably be removed.)\\n */\\nHtml5.prototype['featuresFullscreenResize'] = true;\\n\\n/*\\n * Set the tech's progress event support status\\n * (this disables the manual progress events of the Tech)\\n */\\nHtml5.prototype['featuresProgressEvents'] = true;\\n\\n/*\\n * Sets the tech's status on native text track support\\n *\\n * @type {Boolean}\\n */\\nHtml5.prototype['featuresNativeTextTracks'] = Html5.supportsNativeTextTracks();\\n\\n/**\\n * Sets the tech's status on native text track support\\n *\\n * @type {Boolean}\\n */\\nHtml5.prototype['featuresNativeVideoTracks'] = Html5.supportsNativeVideoTracks();\\n\\n/**\\n * Sets the tech's status on native audio track support\\n *\\n * @type {Boolean}\\n */\\nHtml5.prototype['featuresNativeAudioTracks'] = Html5.supportsNativeAudioTracks();\\n\\n// HTML5 Feature detection and Device Fixes --------------------------------- //\\nvar canPlayType = undefined;\\nvar mpegurlRE = /^application\\\\/(?:x-|vnd\\\\.apple\\\\.)mpegurl/i;\\nvar mp4RE = /^video\\\\/mp4/i;\\n\\nHtml5.patchCanPlayType = function () {\\n  // Android 4.0 and above can play HLS to some extent but it reports being unable to do so\\n  if (browser.ANDROID_VERSION >= 4.0) {\\n    if (!canPlayType) {\\n      canPlayType = Html5.TEST_VID.constructor.prototype.canPlayType;\\n    }\\n\\n    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {\\n      if (type && mpegurlRE.test(type)) {\\n        return 'maybe';\\n      }\\n      return canPlayType.call(this, type);\\n    };\\n  }\\n\\n  // Override Android 2.2 and less canPlayType method which is broken\\n  if (browser.IS_OLD_ANDROID) {\\n    if (!canPlayType) {\\n      canPlayType = Html5.TEST_VID.constructor.prototype.canPlayType;\\n    }\\n\\n    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {\\n      if (type && mp4RE.test(type)) {\\n        return 'maybe';\\n      }\\n      return canPlayType.call(this, type);\\n    };\\n  }\\n};\\n\\nHtml5.unpatchCanPlayType = function () {\\n  var r = Html5.TEST_VID.constructor.prototype.canPlayType;\\n  Html5.TEST_VID.constructor.prototype.canPlayType = canPlayType;\\n  canPlayType = null;\\n  return r;\\n};\\n\\n// by default, patch the video element\\nHtml5.patchCanPlayType();\\n\\nHtml5.disposeMediaElement = function (el) {\\n  if (!el) {\\n    return;\\n  }\\n\\n  if (el.parentNode) {\\n    el.parentNode.removeChild(el);\\n  }\\n\\n  // remove any child track or source nodes to prevent their loading\\n  while (el.hasChildNodes()) {\\n    el.removeChild(el.firstChild);\\n  }\\n\\n  // remove any src reference. not setting `src=''` because that causes a warning\\n  // in firefox\\n  el.removeAttribute('src');\\n\\n  // force the media element to update its loading state by calling load()\\n  // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)\\n  if (typeof el.load === 'function') {\\n    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\\n    (function () {\\n      try {\\n        el.load();\\n      } catch (e) {\\n        // not supported\\n      }\\n    })();\\n  }\\n};\\n\\nHtml5.resetMediaElement = function (el) {\\n  if (!el) {\\n    return;\\n  }\\n\\n  var sources = el.querySelectorAll('source');\\n  var i = sources.length;\\n  while (i--) {\\n    el.removeChild(sources[i]);\\n  }\\n\\n  // remove any src reference.\\n  // not setting `src=''` because that throws an error\\n  el.removeAttribute('src');\\n\\n  if (typeof el.load === 'function') {\\n    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\\n    (function () {\\n      try {\\n        el.load();\\n      } catch (e) {}\\n    })();\\n  }\\n};\\n\\n_component2['default'].registerComponent('Html5', Html5);\\n_techJs2['default'].registerTech('Html5', Html5);\\nexports['default'] = Html5;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../../src/js/tracks/text-track.js\\\":134,\\\"../component\\\":67,\\\"../utils/browser.js\\\":140,\\\"../utils/dom.js\\\":142,\\\"../utils/fn.js\\\":144,\\\"../utils/log.js\\\":147,\\\"../utils/merge-options.js\\\":148,\\\"../utils/to-title-case.js\\\":151,\\\"../utils/url.js\\\":152,\\\"./tech.js\\\":124,\\\"global/document\\\":1,\\\"global/window\\\":2,\\\"object.assign\\\":45,\\\"tsml\\\":55}],123:[function(_dereq_,module,exports){\\n/**\\n * @file loader.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _techJs = _dereq_('./tech.js');\\n\\nvar _techJs2 = _interopRequireDefault(_techJs);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _utilsToTitleCaseJs = _dereq_('../utils/to-title-case.js');\\n\\nvar _utilsToTitleCaseJs2 = _interopRequireDefault(_utilsToTitleCaseJs);\\n\\n/**\\n * The Media Loader is the component that decides which playback technology to load\\n * when the player is initialized.\\n *\\n * @param {Object} player  Main Player\\n * @param {Object=} options Object of option names and values\\n * @param {Function=} ready    Ready callback function\\n * @extends Component\\n * @class MediaLoader\\n */\\n\\nvar MediaLoader = (function (_Component) {\\n  _inherits(MediaLoader, _Component);\\n\\n  function MediaLoader(player, options, ready) {\\n    _classCallCheck(this, MediaLoader);\\n\\n    _Component.call(this, player, options, ready);\\n\\n    // If there are no sources when the player is initialized,\\n    // load the first supported playback technology.\\n\\n    if (!options.playerOptions['sources'] || options.playerOptions['sources'].length === 0) {\\n      for (var i = 0, j = options.playerOptions['techOrder']; i < j.length; i++) {\\n        var techName = _utilsToTitleCaseJs2['default'](j[i]);\\n        var tech = _techJs2['default'].getTech(techName);\\n        // Support old behavior of techs being registered as components.\\n        // Remove once that deprecated behavior is removed.\\n        if (!techName) {\\n          tech = _componentJs2['default'].getComponent(techName);\\n        }\\n\\n        // Check if the browser supports this technology\\n        if (tech && tech.isSupported()) {\\n          player.loadTech_(techName);\\n          break;\\n        }\\n      }\\n    } else {\\n      // // Loop through playback technologies (HTML5, Flash) and check for support.\\n      // // Then load the best source.\\n      // // A few assumptions here:\\n      // //   All playback technologies respect preload false.\\n      player.src(options.playerOptions['sources']);\\n    }\\n  }\\n\\n  return MediaLoader;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('MediaLoader', MediaLoader);\\nexports['default'] = MediaLoader;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component.js\\\":67,\\\"../utils/to-title-case.js\\\":151,\\\"./tech.js\\\":124,\\\"global/window\\\":2}],124:[function(_dereq_,module,exports){\\n/**\\n * @file tech.js\\n * Media Technology Controller - Base class for media playback\\n * technology controllers like Flash and HTML5\\n */\\n\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _component = _dereq_('../component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _tracksHtmlTrackElement = _dereq_('../tracks/html-track-element');\\n\\nvar _tracksHtmlTrackElement2 = _interopRequireDefault(_tracksHtmlTrackElement);\\n\\nvar _tracksHtmlTrackElementList = _dereq_('../tracks/html-track-element-list');\\n\\nvar _tracksHtmlTrackElementList2 = _interopRequireDefault(_tracksHtmlTrackElementList);\\n\\nvar _utilsMergeOptionsJs = _dereq_('../utils/merge-options.js');\\n\\nvar _utilsMergeOptionsJs2 = _interopRequireDefault(_utilsMergeOptionsJs);\\n\\nvar _tracksTextTrack = _dereq_('../tracks/text-track');\\n\\nvar _tracksTextTrack2 = _interopRequireDefault(_tracksTextTrack);\\n\\nvar _tracksTextTrackList = _dereq_('../tracks/text-track-list');\\n\\nvar _tracksTextTrackList2 = _interopRequireDefault(_tracksTextTrackList);\\n\\nvar _tracksVideoTrack = _dereq_('../tracks/video-track');\\n\\nvar _tracksVideoTrack2 = _interopRequireDefault(_tracksVideoTrack);\\n\\nvar _tracksVideoTrackList = _dereq_('../tracks/video-track-list');\\n\\nvar _tracksVideoTrackList2 = _interopRequireDefault(_tracksVideoTrackList);\\n\\nvar _tracksAudioTrackList = _dereq_('../tracks/audio-track-list');\\n\\nvar _tracksAudioTrackList2 = _interopRequireDefault(_tracksAudioTrackList);\\n\\nvar _tracksAudioTrack = _dereq_('../tracks/audio-track');\\n\\nvar _tracksAudioTrack2 = _interopRequireDefault(_tracksAudioTrack);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsLogJs = _dereq_('../utils/log.js');\\n\\nvar _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);\\n\\nvar _utilsTimeRangesJs = _dereq_('../utils/time-ranges.js');\\n\\nvar _utilsBufferJs = _dereq_('../utils/buffer.js');\\n\\nvar _mediaErrorJs = _dereq_('../media-error.js');\\n\\nvar _mediaErrorJs2 = _interopRequireDefault(_mediaErrorJs);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\n/**\\n * Base class for media (HTML5 Video, Flash) controllers\\n *\\n * @param {Object=} options Options object\\n * @param {Function=} ready Ready callback function\\n * @extends Component\\n * @class Tech\\n */\\n\\nvar Tech = (function (_Component) {\\n  _inherits(Tech, _Component);\\n\\n  function Tech() {\\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\\n    var ready = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];\\n\\n    _classCallCheck(this, Tech);\\n\\n    // we don't want the tech to report user activity automatically.\\n    // This is done manually in addControlsListeners\\n    options.reportTouchActivity = false;\\n    _Component.call(this, null, options, ready);\\n\\n    // keep track of whether the current source has played at all to\\n    // implement a very limited played()\\n    this.hasStarted_ = false;\\n    this.on('playing', function () {\\n      this.hasStarted_ = true;\\n    });\\n    this.on('loadstart', function () {\\n      this.hasStarted_ = false;\\n    });\\n\\n    this.textTracks_ = options.textTracks;\\n    this.videoTracks_ = options.videoTracks;\\n    this.audioTracks_ = options.audioTracks;\\n\\n    // Manually track progress in cases where the browser/flash player doesn't report it.\\n    if (!this.featuresProgressEvents) {\\n      this.manualProgressOn();\\n    }\\n\\n    // Manually track timeupdates in cases where the browser/flash player doesn't report it.\\n    if (!this.featuresTimeupdateEvents) {\\n      this.manualTimeUpdatesOn();\\n    }\\n\\n    if (options.nativeCaptions === false || options.nativeTextTracks === false) {\\n      this.featuresNativeTextTracks = false;\\n    }\\n\\n    if (!this.featuresNativeTextTracks) {\\n      this.on('ready', this.emulateTextTracks);\\n    }\\n\\n    this.initTextTrackListeners();\\n    this.initTrackListeners();\\n\\n    // Turn on component tap events\\n    this.emitTapEvents();\\n  }\\n\\n  /**\\n   * List of associated text tracks\\n   *\\n   * @type {TextTrackList}\\n   * @private\\n   */\\n\\n  /* Fallbacks for unsupported event types\\n  ================================================================================ */\\n  // Manually trigger progress events based on changes to the buffered amount\\n  // Many flash players and older HTML5 browsers don't send progress or progress-like events\\n  /**\\n   * Turn on progress events\\n   *\\n   * @method manualProgressOn\\n   */\\n\\n  Tech.prototype.manualProgressOn = function manualProgressOn() {\\n    this.on('durationchange', this.onDurationChange);\\n\\n    this.manualProgress = true;\\n\\n    // Trigger progress watching when a source begins loading\\n    this.one('ready', this.trackProgress);\\n  };\\n\\n  /**\\n   * Turn off progress events\\n   *\\n   * @method manualProgressOff\\n   */\\n\\n  Tech.prototype.manualProgressOff = function manualProgressOff() {\\n    this.manualProgress = false;\\n    this.stopTrackingProgress();\\n\\n    this.off('durationchange', this.onDurationChange);\\n  };\\n\\n  /**\\n   * Track progress\\n   *\\n   * @method trackProgress\\n   */\\n\\n  Tech.prototype.trackProgress = function trackProgress() {\\n    this.stopTrackingProgress();\\n    this.progressInterval = this.setInterval(Fn.bind(this, function () {\\n      // Don't trigger unless buffered amount is greater than last time\\n\\n      var numBufferedPercent = this.bufferedPercent();\\n\\n      if (this.bufferedPercent_ !== numBufferedPercent) {\\n        this.trigger('progress');\\n      }\\n\\n      this.bufferedPercent_ = numBufferedPercent;\\n\\n      if (numBufferedPercent === 1) {\\n        this.stopTrackingProgress();\\n      }\\n    }), 500);\\n  };\\n\\n  /**\\n   * Update duration\\n   *\\n   * @method onDurationChange\\n   */\\n\\n  Tech.prototype.onDurationChange = function onDurationChange() {\\n    this.duration_ = this.duration();\\n  };\\n\\n  /**\\n   * Create and get TimeRange object for buffering\\n   *\\n   * @return {TimeRangeObject}\\n   * @method buffered\\n   */\\n\\n  Tech.prototype.buffered = function buffered() {\\n    return _utilsTimeRangesJs.createTimeRange(0, 0);\\n  };\\n\\n  /**\\n   * Get buffered percent\\n   *\\n   * @return {Number}\\n   * @method bufferedPercent\\n   */\\n\\n  Tech.prototype.bufferedPercent = function bufferedPercent() {\\n    return _utilsBufferJs.bufferedPercent(this.buffered(), this.duration_);\\n  };\\n\\n  /**\\n   * Stops tracking progress by clearing progress interval\\n   *\\n   * @method stopTrackingProgress\\n   */\\n\\n  Tech.prototype.stopTrackingProgress = function stopTrackingProgress() {\\n    this.clearInterval(this.progressInterval);\\n  };\\n\\n  /*! Time Tracking -------------------------------------------------------------- */\\n  /**\\n   * Set event listeners for on play and pause and tracking current time\\n   *\\n   * @method manualTimeUpdatesOn\\n   */\\n\\n  Tech.prototype.manualTimeUpdatesOn = function manualTimeUpdatesOn() {\\n    this.manualTimeUpdates = true;\\n\\n    this.on('play', this.trackCurrentTime);\\n    this.on('pause', this.stopTrackingCurrentTime);\\n  };\\n\\n  /**\\n   * Remove event listeners for on play and pause and tracking current time\\n   *\\n   * @method manualTimeUpdatesOff\\n   */\\n\\n  Tech.prototype.manualTimeUpdatesOff = function manualTimeUpdatesOff() {\\n    this.manualTimeUpdates = false;\\n    this.stopTrackingCurrentTime();\\n    this.off('play', this.trackCurrentTime);\\n    this.off('pause', this.stopTrackingCurrentTime);\\n  };\\n\\n  /**\\n   * Tracks current time\\n   *\\n   * @method trackCurrentTime\\n   */\\n\\n  Tech.prototype.trackCurrentTime = function trackCurrentTime() {\\n    if (this.currentTimeInterval) {\\n      this.stopTrackingCurrentTime();\\n    }\\n    this.currentTimeInterval = this.setInterval(function () {\\n      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });\\n    }, 250); // 42 = 24 fps // 250 is what Webkit uses // FF uses 15\\n  };\\n\\n  /**\\n   * Turn off play progress tracking (when paused or dragging)\\n   *\\n   * @method stopTrackingCurrentTime\\n   */\\n\\n  Tech.prototype.stopTrackingCurrentTime = function stopTrackingCurrentTime() {\\n    this.clearInterval(this.currentTimeInterval);\\n\\n    // #1002 - if the video ends right before the next timeupdate would happen,\\n    // the progress bar won't make it all the way to the end\\n    this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });\\n  };\\n\\n  /**\\n   * Turn off any manual progress or timeupdate tracking\\n   *\\n   * @method dispose\\n   */\\n\\n  Tech.prototype.dispose = function dispose() {\\n\\n    // clear out all tracks because we can't reuse them between techs\\n    this.clearTracks(['audio', 'video', 'text']);\\n\\n    // Turn off any manual progress or timeupdate tracking\\n    if (this.manualProgress) {\\n      this.manualProgressOff();\\n    }\\n\\n    if (this.manualTimeUpdates) {\\n      this.manualTimeUpdatesOff();\\n    }\\n\\n    _Component.prototype.dispose.call(this);\\n  };\\n\\n  /**\\n   * clear out a track list, or multiple track lists\\n   *\\n   * Note: Techs without source handlers should call this between\\n   * sources for video & audio tracks, as usually you don't want\\n   * to use them between tracks and we have no automatic way to do\\n   * it for you\\n   *\\n   * @method clearTracks\\n   * @param {Array|String} types type(s) of track lists to empty\\n   */\\n\\n  Tech.prototype.clearTracks = function clearTracks(types) {\\n    var _this = this;\\n\\n    types = [].concat(types);\\n    // clear out all tracks because we can't reuse them between techs\\n    types.forEach(function (type) {\\n      var list = _this[type + 'Tracks']() || [];\\n      var i = list.length;\\n      while (i--) {\\n        var track = list[i];\\n        if (type === 'text') {\\n          _this.removeRemoteTextTrack(track);\\n        }\\n        list.removeTrack_(track);\\n      }\\n    });\\n  };\\n\\n  /**\\n   * Reset the tech. Removes all sources and resets readyState.\\n   *\\n   * @method reset\\n   */\\n\\n  Tech.prototype.reset = function reset() {};\\n\\n  /**\\n   * When invoked without an argument, returns a MediaError object\\n   * representing the current error state of the player or null if\\n   * there is no error. When invoked with an argument, set the current\\n   * error state of the player.\\n   * @param {MediaError=} err    Optional an error object\\n   * @return {MediaError}        the current error object or null\\n   * @method error\\n   */\\n\\n  Tech.prototype.error = function error(err) {\\n    if (err !== undefined) {\\n      this.error_ = new _mediaErrorJs2['default'](err);\\n      this.trigger('error');\\n    }\\n    return this.error_;\\n  };\\n\\n  /**\\n   * Return the time ranges that have been played through for the\\n   * current source. This implementation is incomplete. It does not\\n   * track the played time ranges, only whether the source has played\\n   * at all or not.\\n   * @return {TimeRangeObject} a single time range if this video has\\n   * played or an empty set of ranges if not.\\n   * @method played\\n   */\\n\\n  Tech.prototype.played = function played() {\\n    if (this.hasStarted_) {\\n      return _utilsTimeRangesJs.createTimeRange(0, 0);\\n    }\\n    return _utilsTimeRangesJs.createTimeRange();\\n  };\\n\\n  /**\\n   * Set current time\\n   *\\n   * @method setCurrentTime\\n   */\\n\\n  Tech.prototype.setCurrentTime = function setCurrentTime() {\\n    // improve the accuracy of manual timeupdates\\n    if (this.manualTimeUpdates) {\\n      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });\\n    }\\n  };\\n\\n  /**\\n   * Initialize texttrack listeners\\n   *\\n   * @method initTextTrackListeners\\n   */\\n\\n  Tech.prototype.initTextTrackListeners = function initTextTrackListeners() {\\n    var textTrackListChanges = Fn.bind(this, function () {\\n      this.trigger('texttrackchange');\\n    });\\n\\n    var tracks = this.textTracks();\\n\\n    if (!tracks) return;\\n\\n    tracks.addEventListener('removetrack', textTrackListChanges);\\n    tracks.addEventListener('addtrack', textTrackListChanges);\\n\\n    this.on('dispose', Fn.bind(this, function () {\\n      tracks.removeEventListener('removetrack', textTrackListChanges);\\n      tracks.removeEventListener('addtrack', textTrackListChanges);\\n    }));\\n  };\\n\\n  /**\\n   * Initialize audio and video track listeners\\n   *\\n   * @method initTrackListeners\\n   */\\n\\n  Tech.prototype.initTrackListeners = function initTrackListeners() {\\n    var _this2 = this;\\n\\n    var trackTypes = ['video', 'audio'];\\n\\n    trackTypes.forEach(function (type) {\\n      var trackListChanges = function trackListChanges() {\\n        _this2.trigger(type + 'trackchange');\\n      };\\n\\n      var tracks = _this2[type + 'Tracks']();\\n\\n      tracks.addEventListener('removetrack', trackListChanges);\\n      tracks.addEventListener('addtrack', trackListChanges);\\n\\n      _this2.on('dispose', function () {\\n        tracks.removeEventListener('removetrack', trackListChanges);\\n        tracks.removeEventListener('addtrack', trackListChanges);\\n      });\\n    });\\n  };\\n\\n  /**\\n   * Emulate texttracks\\n   *\\n   * @method emulateTextTracks\\n   */\\n\\n  Tech.prototype.emulateTextTracks = function emulateTextTracks() {\\n    var _this3 = this;\\n\\n    var tracks = this.textTracks();\\n    if (!tracks) {\\n      return;\\n    }\\n\\n    if (!_globalWindow2['default']['WebVTT'] && this.el().parentNode != null) {\\n      (function () {\\n        var script = _globalDocument2['default'].createElement('script');\\n        script.src = _this3.options_['vtt.js'] || 'https://cdn.rawgit.com/gkatsev/vtt.js/vjs-v0.12.1/dist/vtt.min.js';\\n        script.onload = function () {\\n          _this3.trigger('vttjsloaded');\\n        };\\n        script.onerror = function () {\\n          _this3.trigger('vttjserror');\\n        };\\n        _this3.on('dispose', function () {\\n          script.onload = null;\\n          script.onerror = null;\\n        });\\n        // but have not loaded yet and we set it to true before the inject so that\\n        // we don't overwrite the injected window.WebVTT if it loads right away\\n        _globalWindow2['default']['WebVTT'] = true;\\n        _this3.el().parentNode.appendChild(script);\\n      })();\\n    }\\n\\n    var updateDisplay = function updateDisplay() {\\n      return _this3.trigger('texttrackchange');\\n    };\\n    var textTracksChanges = function textTracksChanges() {\\n      updateDisplay();\\n\\n      for (var i = 0; i < tracks.length; i++) {\\n        var track = tracks[i];\\n        track.removeEventListener('cuechange', updateDisplay);\\n        if (track.mode === 'showing') {\\n          track.addEventListener('cuechange', updateDisplay);\\n        }\\n      }\\n    };\\n\\n    textTracksChanges();\\n    tracks.addEventListener('change', textTracksChanges);\\n\\n    this.on('dispose', function () {\\n      tracks.removeEventListener('change', textTracksChanges);\\n    });\\n  };\\n\\n  /**\\n   * Get videotracks\\n   *\\n   * @returns {VideoTrackList}\\n   * @method videoTracks\\n   */\\n\\n  Tech.prototype.videoTracks = function videoTracks() {\\n    this.videoTracks_ = this.videoTracks_ || new _tracksVideoTrackList2['default']();\\n    return this.videoTracks_;\\n  };\\n\\n  /**\\n   * Get audiotracklist\\n   *\\n   * @returns {AudioTrackList}\\n   * @method audioTracks\\n   */\\n\\n  Tech.prototype.audioTracks = function audioTracks() {\\n    this.audioTracks_ = this.audioTracks_ || new _tracksAudioTrackList2['default']();\\n    return this.audioTracks_;\\n  };\\n\\n  /*\\n   * Provide default methods for text tracks.\\n   *\\n   * Html5 tech overrides these.\\n   */\\n\\n  /**\\n   * Get texttracks\\n   *\\n   * @returns {TextTrackList}\\n   * @method textTracks\\n   */\\n\\n  Tech.prototype.textTracks = function textTracks() {\\n    this.textTracks_ = this.textTracks_ || new _tracksTextTrackList2['default']();\\n    return this.textTracks_;\\n  };\\n\\n  /**\\n   * Get remote texttracks\\n   *\\n   * @returns {TextTrackList}\\n   * @method remoteTextTracks\\n   */\\n\\n  Tech.prototype.remoteTextTracks = function remoteTextTracks() {\\n    this.remoteTextTracks_ = this.remoteTextTracks_ || new _tracksTextTrackList2['default']();\\n    return this.remoteTextTracks_;\\n  };\\n\\n  /**\\n   * Get remote htmltrackelements\\n   *\\n   * @returns {HTMLTrackElementList}\\n   * @method remoteTextTrackEls\\n   */\\n\\n  Tech.prototype.remoteTextTrackEls = function remoteTextTrackEls() {\\n    this.remoteTextTrackEls_ = this.remoteTextTrackEls_ || new _tracksHtmlTrackElementList2['default']();\\n    return this.remoteTextTrackEls_;\\n  };\\n\\n  /**\\n   * Creates and returns a remote text track object\\n   *\\n   * @param {String} kind Text track kind (subtitles, captions, descriptions\\n   *                                       chapters and metadata)\\n   * @param {String=} label Label to identify the text track\\n   * @param {String=} language Two letter language abbreviation\\n   * @return {TextTrackObject}\\n   * @method addTextTrack\\n   */\\n\\n  Tech.prototype.addTextTrack = function addTextTrack(kind, label, language) {\\n    if (!kind) {\\n      throw new Error('TextTrack kind is required but was not provided');\\n    }\\n\\n    return createTrackHelper(this, kind, label, language);\\n  };\\n\\n  /**\\n   * Creates a remote text track object and returns a emulated html track element\\n   *\\n   * @param {Object} options The object should contain values for\\n   * kind, language, label and src (location of the WebVTT file)\\n   * @return {HTMLTrackElement}\\n   * @method addRemoteTextTrack\\n   */\\n\\n  Tech.prototype.addRemoteTextTrack = function addRemoteTextTrack(options) {\\n    var track = _utilsMergeOptionsJs2['default'](options, {\\n      tech: this\\n    });\\n\\n    var htmlTrackElement = new _tracksHtmlTrackElement2['default'](track);\\n\\n    // store HTMLTrackElement and TextTrack to remote list\\n    this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);\\n    this.remoteTextTracks().addTrack_(htmlTrackElement.track);\\n\\n    // must come after remoteTextTracks()\\n    this.textTracks().addTrack_(htmlTrackElement.track);\\n\\n    return htmlTrackElement;\\n  };\\n\\n  /**\\n   * Remove remote texttrack\\n   *\\n   * @param {TextTrackObject} track Texttrack to remove\\n   * @method removeRemoteTextTrack\\n   */\\n\\n  Tech.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track) {\\n    this.textTracks().removeTrack_(track);\\n\\n    var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);\\n\\n    // remove HTMLTrackElement and TextTrack from remote list\\n    this.remoteTextTrackEls().removeTrackElement_(trackElement);\\n    this.remoteTextTracks().removeTrack_(track);\\n  };\\n\\n  /**\\n   * Provide a default setPoster method for techs\\n   * Poster support for techs should be optional, so we don't want techs to\\n   * break if they don't have a way to set a poster.\\n   *\\n   * @method setPoster\\n   */\\n\\n  Tech.prototype.setPoster = function setPoster() {};\\n\\n  /*\\n   * Check if the tech can support the given type\\n   *\\n   * The base tech does not support any type, but source handlers might\\n   * overwrite this.\\n   *\\n   * @param  {String} type    The mimetype to check\\n   * @return {String}         'probably', 'maybe', or '' (empty string)\\n   */\\n\\n  Tech.prototype.canPlayType = function canPlayType() {\\n    return '';\\n  };\\n\\n  /*\\n   * Return whether the argument is a Tech or not.\\n   * Can be passed either a Class like `Html5` or a instance like `player.tech_`\\n   *\\n   * @param {Object} component An item to check\\n   * @return {Boolean}         Whether it is a tech or not\\n   */\\n\\n  Tech.isTech = function isTech(component) {\\n    return component.prototype instanceof Tech || component instanceof Tech || component === Tech;\\n  };\\n\\n  /**\\n   * Registers a Tech\\n   *\\n   * @param {String} name Name of the Tech to register\\n   * @param {Object} tech The tech to register\\n   * @static\\n   * @method registerComponent\\n   */\\n\\n  Tech.registerTech = function registerTech(name, tech) {\\n    if (!Tech.techs_) {\\n      Tech.techs_ = {};\\n    }\\n\\n    if (!Tech.isTech(tech)) {\\n      throw new Error('Tech ' + name + ' must be a Tech');\\n    }\\n\\n    Tech.techs_[name] = tech;\\n    return tech;\\n  };\\n\\n  /**\\n   * Gets a component by name\\n   *\\n   * @param {String} name Name of the component to get\\n   * @return {Component}\\n   * @static\\n   * @method getComponent\\n   */\\n\\n  Tech.getTech = function getTech(name) {\\n    if (Tech.techs_ && Tech.techs_[name]) {\\n      return Tech.techs_[name];\\n    }\\n\\n    if (_globalWindow2['default'] && _globalWindow2['default'].videojs && _globalWindow2['default'].videojs[name]) {\\n      _utilsLogJs2['default'].warn('The ' + name + ' tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)');\\n      return _globalWindow2['default'].videojs[name];\\n    }\\n  };\\n\\n  return Tech;\\n})(_component2['default']);\\n\\nTech.prototype.textTracks_;\\n\\n/**\\n * List of associated audio tracks\\n *\\n * @type {AudioTrackList}\\n * @private\\n */\\nTech.prototype.audioTracks_;\\n\\n/**\\n * List of associated video tracks\\n *\\n * @type {VideoTrackList}\\n * @private\\n */\\nTech.prototype.videoTracks_;\\n\\nvar createTrackHelper = function createTrackHelper(self, kind, label, language) {\\n  var options = arguments.length <= 4 || arguments[4] === undefined ? {} : arguments[4];\\n\\n  var tracks = self.textTracks();\\n\\n  options.kind = kind;\\n\\n  if (label) {\\n    options.label = label;\\n  }\\n  if (language) {\\n    options.language = language;\\n  }\\n  options.tech = self;\\n\\n  var track = new _tracksTextTrack2['default'](options);\\n  tracks.addTrack_(track);\\n\\n  return track;\\n};\\n\\nTech.prototype.featuresVolumeControl = true;\\n\\n// Resizing plugins using request fullscreen reloads the plugin\\nTech.prototype.featuresFullscreenResize = false;\\nTech.prototype.featuresPlaybackRate = false;\\n\\n// Optional events that we can manually mimic with timers\\n// currently not triggered by video-js-swf\\nTech.prototype.featuresProgressEvents = false;\\nTech.prototype.featuresTimeupdateEvents = false;\\n\\nTech.prototype.featuresNativeTextTracks = false;\\n\\n/*\\n * A functional mixin for techs that want to use the Source Handler pattern.\\n *\\n * ##### EXAMPLE:\\n *\\n *   Tech.withSourceHandlers.call(MyTech);\\n *\\n */\\nTech.withSourceHandlers = function (_Tech) {\\n  /*\\n   * Register a source handler\\n   * Source handlers are scripts for handling specific formats.\\n   * The source handler pattern is used for adaptive formats (HLS, DASH) that\\n   * manually load video data and feed it into a Source Buffer (Media Source Extensions)\\n   * @param  {Function} handler  The source handler\\n   * @param  {Boolean}  first    Register it before any existing handlers\\n   */\\n  _Tech.registerSourceHandler = function (handler, index) {\\n    var handlers = _Tech.sourceHandlers;\\n\\n    if (!handlers) {\\n      handlers = _Tech.sourceHandlers = [];\\n    }\\n\\n    if (index === undefined) {\\n      // add to the end of the list\\n      index = handlers.length;\\n    }\\n\\n    handlers.splice(index, 0, handler);\\n  };\\n\\n  /*\\n   * Check if the tech can support the given type\\n   * @param  {String} type    The mimetype to check\\n   * @return {String}         'probably', 'maybe', or '' (empty string)\\n   */\\n  _Tech.canPlayType = function (type) {\\n    var handlers = _Tech.sourceHandlers || [];\\n    var can = undefined;\\n\\n    for (var i = 0; i < handlers.length; i++) {\\n      can = handlers[i].canPlayType(type);\\n\\n      if (can) {\\n        return can;\\n      }\\n    }\\n\\n    return '';\\n  };\\n\\n  /*\\n   * Return the first source handler that supports the source\\n   * TODO: Answer question: should 'probably' be prioritized over 'maybe'\\n   * @param  {Object} source  The source object\\n   * @param  {Object} options The options passed to the tech\\n   * @returns {Object}       The first source handler that supports the source\\n   * @returns {null}         Null if no source handler is found\\n   */\\n  _Tech.selectSourceHandler = function (source, options) {\\n    var handlers = _Tech.sourceHandlers || [];\\n    var can = undefined;\\n\\n    for (var i = 0; i < handlers.length; i++) {\\n      can = handlers[i].canHandleSource(source, options);\\n\\n      if (can) {\\n        return handlers[i];\\n      }\\n    }\\n\\n    return null;\\n  };\\n\\n  /*\\n   * Check if the tech can support the given source\\n   * @param  {Object} srcObj  The source object\\n   * @param  {Object} options The options passed to the tech\\n   * @return {String}         'probably', 'maybe', or '' (empty string)\\n   */\\n  _Tech.canPlaySource = function (srcObj, options) {\\n    var sh = _Tech.selectSourceHandler(srcObj, options);\\n\\n    if (sh) {\\n      return sh.canHandleSource(srcObj, options);\\n    }\\n\\n    return '';\\n  };\\n\\n  /*\\n   * When using a source handler, prefer its implementation of\\n   * any function normally provided by the tech.\\n   */\\n  var deferrable = ['seekable', 'duration'];\\n\\n  deferrable.forEach(function (fnName) {\\n    var originalFn = this[fnName];\\n\\n    if (typeof originalFn !== 'function') {\\n      return;\\n    }\\n\\n    this[fnName] = function () {\\n      if (this.sourceHandler_ && this.sourceHandler_[fnName]) {\\n        return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);\\n      }\\n      return originalFn.apply(this, arguments);\\n    };\\n  }, _Tech.prototype);\\n\\n  /*\\n   * Create a function for setting the source using a source object\\n   * and source handlers.\\n   * Should never be called unless a source handler was found.\\n   * @param {Object} source  A source object with src and type keys\\n   * @return {Tech} self\\n   */\\n  _Tech.prototype.setSource = function (source) {\\n    var sh = _Tech.selectSourceHandler(source, this.options_);\\n\\n    if (!sh) {\\n      // Fall back to a native source hander when unsupported sources are\\n      // deliberately set\\n      if (_Tech.nativeSourceHandler) {\\n        sh = _Tech.nativeSourceHandler;\\n      } else {\\n        _utilsLogJs2['default'].error('No source hander found for the current source.');\\n      }\\n    }\\n\\n    // Dispose any existing source handler\\n    this.disposeSourceHandler();\\n    this.off('dispose', this.disposeSourceHandler);\\n\\n    // if we have a source and get another one\\n    // then we are loading something new\\n    // than clear all of our current tracks\\n    if (this.currentSource_) {\\n      this.clearTracks(['audio', 'video']);\\n\\n      this.currentSource_ = null;\\n    }\\n\\n    if (sh !== _Tech.nativeSourceHandler) {\\n\\n      this.currentSource_ = source;\\n\\n      // Catch if someone replaced the src without calling setSource.\\n      // If they do, set currentSource_ to null and dispose our source handler.\\n      this.off(this.el_, 'loadstart', _Tech.prototype.firstLoadStartListener_);\\n      this.off(this.el_, 'loadstart', _Tech.prototype.successiveLoadStartListener_);\\n      this.one(this.el_, 'loadstart', _Tech.prototype.firstLoadStartListener_);\\n    }\\n\\n    this.sourceHandler_ = sh.handleSource(source, this, this.options_);\\n    this.on('dispose', this.disposeSourceHandler);\\n\\n    return this;\\n  };\\n\\n  // On the first loadstart after setSource\\n  _Tech.prototype.firstLoadStartListener_ = function () {\\n    this.one(this.el_, 'loadstart', _Tech.prototype.successiveLoadStartListener_);\\n  };\\n\\n  // On successive loadstarts when setSource has not been called again\\n  _Tech.prototype.successiveLoadStartListener_ = function () {\\n    this.currentSource_ = null;\\n    this.disposeSourceHandler();\\n    this.one(this.el_, 'loadstart', _Tech.prototype.successiveLoadStartListener_);\\n  };\\n\\n  /*\\n   * Clean up any existing source handler\\n   */\\n  _Tech.prototype.disposeSourceHandler = function () {\\n    if (this.sourceHandler_ && this.sourceHandler_.dispose) {\\n      this.off(this.el_, 'loadstart', _Tech.prototype.firstLoadStartListener_);\\n      this.off(this.el_, 'loadstart', _Tech.prototype.successiveLoadStartListener_);\\n      this.sourceHandler_.dispose();\\n      this.sourceHandler_ = null;\\n    }\\n  };\\n};\\n\\n_component2['default'].registerComponent('Tech', Tech);\\n// Old name for Tech\\n_component2['default'].registerComponent('MediaTechController', Tech);\\nTech.registerTech('Tech', Tech);\\nexports['default'] = Tech;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component\\\":67,\\\"../media-error.js\\\":108,\\\"../tracks/audio-track\\\":126,\\\"../tracks/audio-track-list\\\":125,\\\"../tracks/html-track-element\\\":128,\\\"../tracks/html-track-element-list\\\":127,\\\"../tracks/text-track\\\":134,\\\"../tracks/text-track-list\\\":132,\\\"../tracks/video-track\\\":139,\\\"../tracks/video-track-list\\\":138,\\\"../utils/buffer.js\\\":141,\\\"../utils/fn.js\\\":144,\\\"../utils/log.js\\\":147,\\\"../utils/merge-options.js\\\":148,\\\"../utils/time-ranges.js\\\":150,\\\"global/document\\\":1,\\\"global/window\\\":2}],125:[function(_dereq_,module,exports){\\n/**\\n * @file audio-track-list.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _trackList = _dereq_('./track-list');\\n\\nvar _trackList2 = _interopRequireDefault(_trackList);\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\n/**\\n * anywhere we call this function we diverge from the spec\\n * as we only support one enabled audiotrack at a time\\n *\\n * @param {Array|AudioTrackList} list list to work on\\n * @param {AudioTrack} track the track to skip\\n */\\nvar disableOthers = function disableOthers(list, track) {\\n  for (var i = 0; i < list.length; i++) {\\n    if (track.id === list[i].id) {\\n      continue;\\n    }\\n    // another audio track is enabled, disable it\\n    list[i].enabled = false;\\n  }\\n};\\n/**\\n * A list of possible audio tracks. All functionality is in the\\n * base class Tracklist and the spec for AudioTrackList is located at:\\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist\\n *\\n * interface AudioTrackList : EventTarget {\\n *   readonly attribute unsigned long length;\\n *   getter AudioTrack (unsigned long index);\\n *   AudioTrack? getTrackById(DOMString id);\\n *\\n *   attribute EventHandler onchange;\\n *   attribute EventHandler onaddtrack;\\n *   attribute EventHandler onremovetrack;\\n * };\\n *\\n * @param {AudioTrack[]} tracks a list of audio tracks to instantiate the list with\\n * @extends TrackList\\n * @class AudioTrackList\\n */\\n\\nvar AudioTrackList = (function (_TrackList) {\\n  _inherits(AudioTrackList, _TrackList);\\n\\n  function AudioTrackList() {\\n    var tracks = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\\n\\n    _classCallCheck(this, AudioTrackList);\\n\\n    var list = undefined;\\n\\n    // make sure only 1 track is enabled\\n    // sorted from last index to first index\\n    for (var i = tracks.length - 1; i >= 0; i--) {\\n      if (tracks[i].enabled) {\\n        disableOthers(tracks, tracks[i]);\\n        break;\\n      }\\n    }\\n\\n    // IE8 forces us to implement inheritance ourselves\\n    // as it does not support Object.defineProperty properly\\n    if (browser.IS_IE8) {\\n      list = _globalDocument2['default'].createElement('custom');\\n      for (var prop in _trackList2['default'].prototype) {\\n        if (prop !== 'constructor') {\\n          list[prop] = _trackList2['default'].prototype[prop];\\n        }\\n      }\\n      for (var prop in AudioTrackList.prototype) {\\n        if (prop !== 'constructor') {\\n          list[prop] = AudioTrackList.prototype[prop];\\n        }\\n      }\\n    }\\n\\n    list = _TrackList.call(this, tracks, list);\\n    list.changing_ = false;\\n\\n    return list;\\n  }\\n\\n  AudioTrackList.prototype.addTrack_ = function addTrack_(track) {\\n    var _this = this;\\n\\n    if (track.enabled) {\\n      disableOthers(this, track);\\n    }\\n\\n    _TrackList.prototype.addTrack_.call(this, track);\\n    // native tracks don't have this\\n    if (!track.addEventListener) {\\n      return;\\n    }\\n\\n    track.addEventListener('enabledchange', function () {\\n      // when we are disabling other tracks (since we don't support\\n      // more than one track at a time) we will set changing_\\n      // to true so that we don't trigger additional change events\\n      if (_this.changing_) {\\n        return;\\n      }\\n      _this.changing_ = true;\\n      disableOthers(_this, track);\\n      _this.changing_ = false;\\n      _this.trigger('change');\\n    });\\n  };\\n\\n  AudioTrackList.prototype.addTrack = function addTrack(track) {\\n    this.addTrack_(track);\\n  };\\n\\n  AudioTrackList.prototype.removeTrack = function removeTrack(track) {\\n    _TrackList.prototype.removeTrack_.call(this, track);\\n  };\\n\\n  return AudioTrackList;\\n})(_trackList2['default']);\\n\\nexports['default'] = AudioTrackList;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../utils/browser.js\\\":140,\\\"./track-list\\\":136,\\\"global/document\\\":1}],126:[function(_dereq_,module,exports){\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _trackEnums = _dereq_('./track-enums');\\n\\nvar _track = _dereq_('./track');\\n\\nvar _track2 = _interopRequireDefault(_track);\\n\\nvar _utilsMergeOptions = _dereq_('../utils/merge-options');\\n\\nvar _utilsMergeOptions2 = _interopRequireDefault(_utilsMergeOptions);\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\n/**\\n * A single audio text track as defined in:\\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotrack\\n *\\n * interface AudioTrack {\\n *   readonly attribute DOMString id;\\n *   readonly attribute DOMString kind;\\n *   readonly attribute DOMString label;\\n *   readonly attribute DOMString language;\\n *   attribute boolean enabled;\\n * };\\n *\\n * @param {Object=} options Object of option names and values\\n * @class AudioTrack\\n */\\n\\nvar AudioTrack = (function (_Track) {\\n  _inherits(AudioTrack, _Track);\\n\\n  function AudioTrack() {\\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\\n\\n    _classCallCheck(this, AudioTrack);\\n\\n    var settings = _utilsMergeOptions2['default'](options, {\\n      kind: _trackEnums.AudioTrackKind[options.kind] || ''\\n    });\\n    // on IE8 this will be a document element\\n    // for every other browser this will be a normal object\\n    var track = _Track.call(this, settings);\\n    var enabled = false;\\n\\n    if (browser.IS_IE8) {\\n      for (var prop in AudioTrack.prototype) {\\n        if (prop !== 'constructor') {\\n          track[prop] = AudioTrack.prototype[prop];\\n        }\\n      }\\n    }\\n\\n    Object.defineProperty(track, 'enabled', {\\n      get: function get() {\\n        return enabled;\\n      },\\n      set: function set(newEnabled) {\\n        // an invalid or unchanged value\\n        if (typeof newEnabled !== 'boolean' || newEnabled === enabled) {\\n          return;\\n        }\\n        enabled = newEnabled;\\n        this.trigger('enabledchange');\\n      }\\n    });\\n\\n    // if the user sets this track to selected then\\n    // set selected to that true value otherwise\\n    // we keep it false\\n    if (settings.enabled) {\\n      track.enabled = settings.enabled;\\n    }\\n    track.loaded_ = true;\\n\\n    return track;\\n  }\\n\\n  return AudioTrack;\\n})(_track2['default']);\\n\\nexports['default'] = AudioTrack;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../utils/browser.js\\\":140,\\\"../utils/merge-options\\\":148,\\\"./track\\\":137,\\\"./track-enums\\\":135}],127:[function(_dereq_,module,exports){\\n/**\\n * @file html-track-element-list.js\\n */\\n\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar HtmlTrackElementList = (function () {\\n  function HtmlTrackElementList() {\\n    var trackElements = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\\n\\n    _classCallCheck(this, HtmlTrackElementList);\\n\\n    var list = this;\\n\\n    if (browser.IS_IE8) {\\n      list = _globalDocument2['default'].createElement('custom');\\n\\n      for (var prop in HtmlTrackElementList.prototype) {\\n        if (prop !== 'constructor') {\\n          list[prop] = HtmlTrackElementList.prototype[prop];\\n        }\\n      }\\n    }\\n\\n    list.trackElements_ = [];\\n\\n    Object.defineProperty(list, 'length', {\\n      get: function get() {\\n        return this.trackElements_.length;\\n      }\\n    });\\n\\n    for (var i = 0, _length = trackElements.length; i < _length; i++) {\\n      list.addTrackElement_(trackElements[i]);\\n    }\\n\\n    if (browser.IS_IE8) {\\n      return list;\\n    }\\n  }\\n\\n  HtmlTrackElementList.prototype.addTrackElement_ = function addTrackElement_(trackElement) {\\n    this.trackElements_.push(trackElement);\\n  };\\n\\n  HtmlTrackElementList.prototype.getTrackElementByTrack_ = function getTrackElementByTrack_(track) {\\n    var trackElement_ = undefined;\\n\\n    for (var i = 0, _length2 = this.trackElements_.length; i < _length2; i++) {\\n      if (track === this.trackElements_[i].track) {\\n        trackElement_ = this.trackElements_[i];\\n\\n        break;\\n      }\\n    }\\n\\n    return trackElement_;\\n  };\\n\\n  HtmlTrackElementList.prototype.removeTrackElement_ = function removeTrackElement_(trackElement) {\\n    for (var i = 0, _length3 = this.trackElements_.length; i < _length3; i++) {\\n      if (trackElement === this.trackElements_[i]) {\\n        this.trackElements_.splice(i, 1);\\n\\n        break;\\n      }\\n    }\\n  };\\n\\n  return HtmlTrackElementList;\\n})();\\n\\nexports['default'] = HtmlTrackElementList;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../utils/browser.js\\\":140,\\\"global/document\\\":1}],128:[function(_dereq_,module,exports){\\n/**\\n * @file html-track-element.js\\n */\\n\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _eventTarget = _dereq_('../event-target');\\n\\nvar _eventTarget2 = _interopRequireDefault(_eventTarget);\\n\\nvar _tracksTextTrack = _dereq_('../tracks/text-track');\\n\\nvar _tracksTextTrack2 = _interopRequireDefault(_tracksTextTrack);\\n\\nvar NONE = 0;\\nvar LOADING = 1;\\nvar LOADED = 2;\\nvar ERROR = 3;\\n\\n/**\\n * https://html.spec.whatwg.org/multipage/embedded-content.html#htmltrackelement\\n *\\n * interface HTMLTrackElement : HTMLElement {\\n *   attribute DOMString kind;\\n *   attribute DOMString src;\\n *   attribute DOMString srclang;\\n *   attribute DOMString label;\\n *   attribute boolean default;\\n *\\n *   const unsigned short NONE = 0;\\n *   const unsigned short LOADING = 1;\\n *   const unsigned short LOADED = 2;\\n *   const unsigned short ERROR = 3;\\n *   readonly attribute unsigned short readyState;\\n *\\n *   readonly attribute TextTrack track;\\n * };\\n *\\n * @param {Object} options TextTrack configuration\\n * @class HTMLTrackElement\\n */\\n\\nvar HTMLTrackElement = (function (_EventTarget) {\\n  _inherits(HTMLTrackElement, _EventTarget);\\n\\n  function HTMLTrackElement() {\\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\\n\\n    _classCallCheck(this, HTMLTrackElement);\\n\\n    _EventTarget.call(this);\\n\\n    var readyState = undefined,\\n        trackElement = this;\\n\\n    if (browser.IS_IE8) {\\n      trackElement = _globalDocument2['default'].createElement('custom');\\n\\n      for (var prop in HTMLTrackElement.prototype) {\\n        if (prop !== 'constructor') {\\n          trackElement[prop] = HTMLTrackElement.prototype[prop];\\n        }\\n      }\\n    }\\n\\n    var track = new _tracksTextTrack2['default'](options);\\n\\n    trackElement.kind = track.kind;\\n    trackElement.src = track.src;\\n    trackElement.srclang = track.language;\\n    trackElement.label = track.label;\\n    trackElement['default'] = track['default'];\\n\\n    Object.defineProperty(trackElement, 'readyState', {\\n      get: function get() {\\n        return readyState;\\n      }\\n    });\\n\\n    Object.defineProperty(trackElement, 'track', {\\n      get: function get() {\\n        return track;\\n      }\\n    });\\n\\n    readyState = NONE;\\n\\n    track.addEventListener('loadeddata', function () {\\n      readyState = LOADED;\\n\\n      trackElement.trigger({\\n        type: 'load',\\n        target: trackElement\\n      });\\n    });\\n\\n    if (browser.IS_IE8) {\\n      return trackElement;\\n    }\\n  }\\n\\n  return HTMLTrackElement;\\n})(_eventTarget2['default']);\\n\\nHTMLTrackElement.prototype.allowedEvents_ = {\\n  load: 'load'\\n};\\n\\nHTMLTrackElement.NONE = NONE;\\nHTMLTrackElement.LOADING = LOADING;\\nHTMLTrackElement.LOADED = LOADED;\\nHTMLTrackElement.ERROR = ERROR;\\n\\nexports['default'] = HTMLTrackElement;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../event-target\\\":104,\\\"../tracks/text-track\\\":134,\\\"../utils/browser.js\\\":140,\\\"global/document\\\":1}],129:[function(_dereq_,module,exports){\\n/**\\n * @file text-track-cue-list.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\n/**\\n * A List of text track cues as defined in:\\n * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist\\n *\\n * interface TextTrackCueList {\\n *   readonly attribute unsigned long length;\\n *   getter TextTrackCue (unsigned long index);\\n *   TextTrackCue? getCueById(DOMString id);\\n * };\\n *\\n * @param {Array} cues A list of cues to be initialized with\\n * @class TextTrackCueList\\n */\\n\\nvar TextTrackCueList = (function () {\\n  function TextTrackCueList(cues) {\\n    _classCallCheck(this, TextTrackCueList);\\n\\n    var list = this;\\n\\n    if (browser.IS_IE8) {\\n      list = _globalDocument2['default'].createElement('custom');\\n\\n      for (var prop in TextTrackCueList.prototype) {\\n        if (prop !== 'constructor') {\\n          list[prop] = TextTrackCueList.prototype[prop];\\n        }\\n      }\\n    }\\n\\n    TextTrackCueList.prototype.setCues_.call(list, cues);\\n\\n    Object.defineProperty(list, 'length', {\\n      get: function get() {\\n        return this.length_;\\n      }\\n    });\\n\\n    if (browser.IS_IE8) {\\n      return list;\\n    }\\n  }\\n\\n  /**\\n   * A setter for cues in this list\\n   *\\n   * @param {Array} cues an array of cues\\n   * @method setCues_\\n   * @private\\n   */\\n\\n  TextTrackCueList.prototype.setCues_ = function setCues_(cues) {\\n    var oldLength = this.length || 0;\\n    var i = 0;\\n    var l = cues.length;\\n\\n    this.cues_ = cues;\\n    this.length_ = cues.length;\\n\\n    var defineProp = function defineProp(index) {\\n      if (!('' + index in this)) {\\n        Object.defineProperty(this, '' + index, {\\n          get: function get() {\\n            return this.cues_[index];\\n          }\\n        });\\n      }\\n    };\\n\\n    if (oldLength < l) {\\n      i = oldLength;\\n\\n      for (; i < l; i++) {\\n        defineProp.call(this, i);\\n      }\\n    }\\n  };\\n\\n  /**\\n   * Get a cue that is currently in the Cue list by id\\n   *\\n   * @param {String} id\\n   * @method getCueById\\n   * @return {Object} a single cue\\n   */\\n\\n  TextTrackCueList.prototype.getCueById = function getCueById(id) {\\n    var result = null;\\n\\n    for (var i = 0, l = this.length; i < l; i++) {\\n      var cue = this[i];\\n\\n      if (cue.id === id) {\\n        result = cue;\\n        break;\\n      }\\n    }\\n\\n    return result;\\n  };\\n\\n  return TextTrackCueList;\\n})();\\n\\nexports['default'] = TextTrackCueList;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../utils/browser.js\\\":140,\\\"global/document\\\":1}],130:[function(_dereq_,module,exports){\\n/**\\n * @file text-track-display.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _component = _dereq_('../component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _menuMenuJs = _dereq_('../menu/menu.js');\\n\\nvar _menuMenuJs2 = _interopRequireDefault(_menuMenuJs);\\n\\nvar _menuMenuItemJs = _dereq_('../menu/menu-item.js');\\n\\nvar _menuMenuItemJs2 = _interopRequireDefault(_menuMenuItemJs);\\n\\nvar _menuMenuButtonJs = _dereq_('../menu/menu-button.js');\\n\\nvar _menuMenuButtonJs2 = _interopRequireDefault(_menuMenuButtonJs);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar darkGray = '#222';\\nvar lightGray = '#ccc';\\nvar fontMap = {\\n  monospace: 'monospace',\\n  sansSerif: 'sans-serif',\\n  serif: 'serif',\\n  monospaceSansSerif: '\\\"Andale Mono\\\", \\\"Lucida Console\\\", monospace',\\n  monospaceSerif: '\\\"Courier New\\\", monospace',\\n  proportionalSansSerif: 'sans-serif',\\n  proportionalSerif: 'serif',\\n  casual: '\\\"Comic Sans MS\\\", Impact, fantasy',\\n  script: '\\\"Monotype Corsiva\\\", cursive',\\n  smallcaps: '\\\"Andale Mono\\\", \\\"Lucida Console\\\", monospace, sans-serif'\\n};\\n\\n/**\\n * The component for displaying text track cues\\n *\\n * @param {Object} player  Main Player\\n * @param {Object=} options Object of option names and values\\n * @param {Function=} ready    Ready callback function\\n * @extends Component\\n * @class TextTrackDisplay\\n */\\n\\nvar TextTrackDisplay = (function (_Component) {\\n  _inherits(TextTrackDisplay, _Component);\\n\\n  function TextTrackDisplay(player, options, ready) {\\n    _classCallCheck(this, TextTrackDisplay);\\n\\n    _Component.call(this, player, options, ready);\\n\\n    player.on('loadstart', Fn.bind(this, this.toggleDisplay));\\n    player.on('texttrackchange', Fn.bind(this, this.updateDisplay));\\n\\n    // This used to be called during player init, but was causing an error\\n    // if a track should show by default and the display hadn't loaded yet.\\n    // Should probably be moved to an external track loader when we support\\n    // tracks that don't need a display.\\n    player.ready(Fn.bind(this, function () {\\n      if (player.tech_ && player.tech_['featuresNativeTextTracks']) {\\n        this.hide();\\n        return;\\n      }\\n\\n      player.on('fullscreenchange', Fn.bind(this, this.updateDisplay));\\n\\n      var tracks = this.options_.playerOptions['tracks'] || [];\\n      for (var i = 0; i < tracks.length; i++) {\\n        var track = tracks[i];\\n        this.player_.addRemoteTextTrack(track);\\n      }\\n\\n      var modes = { 'captions': 1, 'subtitles': 1 };\\n      var trackList = this.player_.textTracks();\\n      var firstDesc = undefined;\\n      var firstCaptions = undefined;\\n\\n      if (trackList) {\\n        for (var i = 0; i < trackList.length; i++) {\\n          var track = trackList[i];\\n          if (track['default']) {\\n            if (track.kind === 'descriptions' && !firstDesc) {\\n              firstDesc = track;\\n            } else if (track.kind in modes && !firstCaptions) {\\n              firstCaptions = track;\\n            }\\n          }\\n        }\\n\\n        // We want to show the first default track but captions and subtitles\\n        // take precedence over descriptions.\\n        // So, display the first default captions or subtitles track\\n        // and otherwise the first default descriptions track.\\n        if (firstCaptions) {\\n          firstCaptions.mode = 'showing';\\n        } else if (firstDesc) {\\n          firstDesc.mode = 'showing';\\n        }\\n      }\\n    }));\\n  }\\n\\n  /**\\n  * Add cue HTML to display\\n  *\\n  * @param {Number} color Hex number for color, like #f0e\\n  * @param {Number} opacity Value for opacity,0.0 - 1.0\\n  * @return {RGBAColor} In the form 'rgba(255, 0, 0, 0.3)'\\n  * @method constructColor\\n  */\\n\\n  /**\\n   * Toggle display texttracks\\n   *\\n   * @method toggleDisplay\\n   */\\n\\n  TextTrackDisplay.prototype.toggleDisplay = function toggleDisplay() {\\n    if (this.player_.tech_ && this.player_.tech_['featuresNativeTextTracks']) {\\n      this.hide();\\n    } else {\\n      this.show();\\n    }\\n  };\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  TextTrackDisplay.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-text-track-display'\\n    }, {\\n      'aria-live': 'assertive',\\n      'aria-atomic': 'true'\\n    });\\n  };\\n\\n  /**\\n   * Clear display texttracks\\n   *\\n   * @method clearDisplay\\n   */\\n\\n  TextTrackDisplay.prototype.clearDisplay = function clearDisplay() {\\n    if (typeof _globalWindow2['default']['WebVTT'] === 'function') {\\n      _globalWindow2['default']['WebVTT']['processCues'](_globalWindow2['default'], [], this.el_);\\n    }\\n  };\\n\\n  /**\\n   * Update display texttracks\\n   *\\n   * @method updateDisplay\\n   */\\n\\n  TextTrackDisplay.prototype.updateDisplay = function updateDisplay() {\\n    var tracks = this.player_.textTracks();\\n\\n    this.clearDisplay();\\n\\n    if (!tracks) {\\n      return;\\n    }\\n\\n    // Track display prioritization model: if multiple tracks are 'showing',\\n    //  display the first 'subtitles' or 'captions' track which is 'showing',\\n    //  otherwise display the first 'descriptions' track which is 'showing'\\n\\n    var descriptionsTrack = null;\\n    var captionsSubtitlesTrack = null;\\n\\n    var i = tracks.length;\\n    while (i--) {\\n      var track = tracks[i];\\n      if (track['mode'] === 'showing') {\\n        if (track['kind'] === 'descriptions') {\\n          descriptionsTrack = track;\\n        } else {\\n          captionsSubtitlesTrack = track;\\n        }\\n      }\\n    }\\n\\n    if (captionsSubtitlesTrack) {\\n      this.updateForTrack(captionsSubtitlesTrack);\\n    } else if (descriptionsTrack) {\\n      this.updateForTrack(descriptionsTrack);\\n    }\\n  };\\n\\n  /**\\n   * Add texttrack to texttrack list\\n   *\\n   * @param {TextTrackObject} track Texttrack object to be added to list\\n   * @method updateForTrack\\n   */\\n\\n  TextTrackDisplay.prototype.updateForTrack = function updateForTrack(track) {\\n    if (typeof _globalWindow2['default']['WebVTT'] !== 'function' || !track['activeCues']) {\\n      return;\\n    }\\n\\n    var overrides = this.player_['textTrackSettings'].getValues();\\n\\n    var cues = [];\\n    for (var _i = 0; _i < track['activeCues'].length; _i++) {\\n      cues.push(track['activeCues'][_i]);\\n    }\\n\\n    _globalWindow2['default']['WebVTT']['processCues'](_globalWindow2['default'], cues, this.el_);\\n\\n    var i = cues.length;\\n    while (i--) {\\n      var cue = cues[i];\\n      if (!cue) {\\n        continue;\\n      }\\n\\n      var cueDiv = cue.displayState;\\n      if (overrides.color) {\\n        cueDiv.firstChild.style.color = overrides.color;\\n      }\\n      if (overrides.textOpacity) {\\n        tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));\\n      }\\n      if (overrides.backgroundColor) {\\n        cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;\\n      }\\n      if (overrides.backgroundOpacity) {\\n        tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));\\n      }\\n      if (overrides.windowColor) {\\n        if (overrides.windowOpacity) {\\n          tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));\\n        } else {\\n          cueDiv.style.backgroundColor = overrides.windowColor;\\n        }\\n      }\\n      if (overrides.edgeStyle) {\\n        if (overrides.edgeStyle === 'dropshadow') {\\n          cueDiv.firstChild.style.textShadow = '2px 2px 3px ' + darkGray + ', 2px 2px 4px ' + darkGray + ', 2px 2px 5px ' + darkGray;\\n        } else if (overrides.edgeStyle === 'raised') {\\n          cueDiv.firstChild.style.textShadow = '1px 1px ' + darkGray + ', 2px 2px ' + darkGray + ', 3px 3px ' + darkGray;\\n        } else if (overrides.edgeStyle === 'depressed') {\\n          cueDiv.firstChild.style.textShadow = '1px 1px ' + lightGray + ', 0 1px ' + lightGray + ', -1px -1px ' + darkGray + ', 0 -1px ' + darkGray;\\n        } else if (overrides.edgeStyle === 'uniform') {\\n          cueDiv.firstChild.style.textShadow = '0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray;\\n        }\\n      }\\n      if (overrides.fontPercent && overrides.fontPercent !== 1) {\\n        var fontSize = _globalWindow2['default'].parseFloat(cueDiv.style.fontSize);\\n        cueDiv.style.fontSize = fontSize * overrides.fontPercent + 'px';\\n        cueDiv.style.height = 'auto';\\n        cueDiv.style.top = 'auto';\\n        cueDiv.style.bottom = '2px';\\n      }\\n      if (overrides.fontFamily && overrides.fontFamily !== 'default') {\\n        if (overrides.fontFamily === 'small-caps') {\\n          cueDiv.firstChild.style.fontVariant = 'small-caps';\\n        } else {\\n          cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];\\n        }\\n      }\\n    }\\n  };\\n\\n  return TextTrackDisplay;\\n})(_component2['default']);\\n\\nfunction constructColor(color, opacity) {\\n  return 'rgba(' +\\n  // color looks like \\\"#f0e\\\"\\n  parseInt(color[1] + color[1], 16) + ',' + parseInt(color[2] + color[2], 16) + ',' + parseInt(color[3] + color[3], 16) + ',' + opacity + ')';\\n}\\n\\n/**\\n * Try to update style\\n * Some style changes will throw an error, particularly in IE8. Those should be noops.\\n *\\n * @param {Element} el The element to be styles\\n * @param {CSSProperty} style The CSS property to be styled\\n * @param {CSSStyle} rule The actual style to be applied to the property\\n * @method tryUpdateStyle\\n */\\nfunction tryUpdateStyle(el, style, rule) {\\n  //\\n  try {\\n    el.style[style] = rule;\\n  } catch (e) {}\\n}\\n\\n_component2['default'].registerComponent('TextTrackDisplay', TextTrackDisplay);\\nexports['default'] = TextTrackDisplay;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component\\\":67,\\\"../menu/menu-button.js\\\":109,\\\"../menu/menu-item.js\\\":110,\\\"../menu/menu.js\\\":111,\\\"../utils/fn.js\\\":144,\\\"global/document\\\":1,\\\"global/window\\\":2}],131:[function(_dereq_,module,exports){\\n/**\\n * Utilities for capturing text track state and re-creating tracks\\n * based on a capture.\\n *\\n * @file text-track-list-converter.js\\n */\\n\\n/**\\n * Examine a single text track and return a JSON-compatible javascript\\n * object that represents the text track's state.\\n * @param track {TextTrackObject} the text track to query\\n * @return {Object} a serializable javascript representation of the\\n * @private\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\nvar trackToJson_ = function trackToJson_(track) {\\n  var ret = ['kind', 'label', 'language', 'id', 'inBandMetadataTrackDispatchType', 'mode', 'src'].reduce(function (acc, prop, i) {\\n    if (track[prop]) {\\n      acc[prop] = track[prop];\\n    }\\n\\n    return acc;\\n  }, {\\n    cues: track.cues && Array.prototype.map.call(track.cues, function (cue) {\\n      return {\\n        startTime: cue.startTime,\\n        endTime: cue.endTime,\\n        text: cue.text,\\n        id: cue.id\\n      };\\n    })\\n  });\\n\\n  return ret;\\n};\\n\\n/**\\n * Examine a tech and return a JSON-compatible javascript array that\\n * represents the state of all text tracks currently configured. The\\n * return array is compatible with `jsonToTextTracks`.\\n * @param tech {tech} the tech object to query\\n * @return {Array} a serializable javascript representation of the\\n * @function textTracksToJson\\n */\\nvar textTracksToJson = function textTracksToJson(tech) {\\n\\n  var trackEls = tech.$$('track');\\n\\n  var trackObjs = Array.prototype.map.call(trackEls, function (t) {\\n    return t.track;\\n  });\\n  var tracks = Array.prototype.map.call(trackEls, function (trackEl) {\\n    var json = trackToJson_(trackEl.track);\\n    if (trackEl.src) {\\n      json.src = trackEl.src;\\n    }\\n    return json;\\n  });\\n\\n  return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function (track) {\\n    return trackObjs.indexOf(track) === -1;\\n  }).map(trackToJson_));\\n};\\n\\n/**\\n * Creates a set of remote text tracks on a tech based on an array of\\n * javascript text track representations.\\n * @param json {Array} an array of text track representation objects,\\n * like those that would be produced by `textTracksToJson`\\n * @param tech {tech} the tech to create text tracks on\\n * @function jsonToTextTracks\\n */\\nvar jsonToTextTracks = function jsonToTextTracks(json, tech) {\\n  json.forEach(function (track) {\\n    var addedTrack = tech.addRemoteTextTrack(track).track;\\n    if (!track.src && track.cues) {\\n      track.cues.forEach(function (cue) {\\n        return addedTrack.addCue(cue);\\n      });\\n    }\\n  });\\n\\n  return tech.textTracks();\\n};\\n\\nexports['default'] = { textTracksToJson: textTracksToJson, jsonToTextTracks: jsonToTextTracks, trackToJson_: trackToJson_ };\\nmodule.exports = exports['default'];\\n\\n},{}],132:[function(_dereq_,module,exports){\\n/**\\n * @file text-track-list.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _trackList = _dereq_('./track-list');\\n\\nvar _trackList2 = _interopRequireDefault(_trackList);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\n/**\\n * A list of possible text tracks. All functionality is in the\\n * base class TrackList. The spec for TextTrackList is located at:\\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist\\n *\\n * interface TextTrackList : EventTarget {\\n *   readonly attribute unsigned long length;\\n *   getter TextTrack (unsigned long index);\\n *   TextTrack? getTrackById(DOMString id);\\n *\\n *   attribute EventHandler onchange;\\n *   attribute EventHandler onaddtrack;\\n *   attribute EventHandler onremovetrack;\\n * };\\n *\\n * @param {TextTrack[]} tracks A list of tracks to initialize the list with\\n * @extends TrackList\\n * @class TextTrackList\\n */\\n\\nvar TextTrackList = (function (_TrackList) {\\n  _inherits(TextTrackList, _TrackList);\\n\\n  function TextTrackList() {\\n    var tracks = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\\n\\n    _classCallCheck(this, TextTrackList);\\n\\n    var list = undefined;\\n\\n    // IE8 forces us to implement inheritance ourselves\\n    // as it does not support Object.defineProperty properly\\n    if (browser.IS_IE8) {\\n      list = _globalDocument2['default'].createElement('custom');\\n      for (var prop in _trackList2['default'].prototype) {\\n        if (prop !== 'constructor') {\\n          list[prop] = _trackList2['default'].prototype[prop];\\n        }\\n      }\\n      for (var prop in TextTrackList.prototype) {\\n        if (prop !== 'constructor') {\\n          list[prop] = TextTrackList.prototype[prop];\\n        }\\n      }\\n    }\\n\\n    list = _TrackList.call(this, tracks, list);\\n    return list;\\n  }\\n\\n  TextTrackList.prototype.addTrack_ = function addTrack_(track) {\\n    _TrackList.prototype.addTrack_.call(this, track);\\n    track.addEventListener('modechange', Fn.bind(this, function () {\\n      this.trigger('change');\\n    }));\\n  };\\n\\n  /**\\n   * Remove TextTrack from TextTrackList\\n   * NOTE: Be mindful of what is passed in as it may be a HTMLTrackElement\\n   *\\n   * @param {TextTrack} rtrack\\n   * @method removeTrack_\\n   * @private\\n   */\\n\\n  TextTrackList.prototype.removeTrack_ = function removeTrack_(rtrack) {\\n    var track = undefined;\\n\\n    for (var i = 0, l = this.length; i < l; i++) {\\n      if (this[i] === rtrack) {\\n        track = this[i];\\n        if (track.off) {\\n          track.off();\\n        }\\n\\n        this.tracks_.splice(i, 1);\\n\\n        break;\\n      }\\n    }\\n\\n    if (!track) {\\n      return;\\n    }\\n\\n    this.trigger({\\n      track: track,\\n      type: 'removetrack'\\n    });\\n  };\\n\\n  /**\\n   * Get a TextTrack from TextTrackList by a tracks id\\n   *\\n   * @param {String} id - the id of the track to get\\n   * @method getTrackById\\n   * @return {TextTrack}\\n   * @private\\n   */\\n\\n  TextTrackList.prototype.getTrackById = function getTrackById(id) {\\n    var result = null;\\n\\n    for (var i = 0, l = this.length; i < l; i++) {\\n      var track = this[i];\\n\\n      if (track.id === id) {\\n        result = track;\\n        break;\\n      }\\n    }\\n\\n    return result;\\n  };\\n\\n  return TextTrackList;\\n})(_trackList2['default']);\\n\\nexports['default'] = TextTrackList;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../utils/browser.js\\\":140,\\\"../utils/fn.js\\\":144,\\\"./track-list\\\":136,\\\"global/document\\\":1}],133:[function(_dereq_,module,exports){\\n/**\\n * @file text-track-settings.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _component = _dereq_('../component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _utilsEventsJs = _dereq_('../utils/events.js');\\n\\nvar Events = _interopRequireWildcard(_utilsEventsJs);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsLogJs = _dereq_('../utils/log.js');\\n\\nvar _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);\\n\\nvar _safeJsonParseTuple = _dereq_('safe-json-parse/tuple');\\n\\nvar _safeJsonParseTuple2 = _interopRequireDefault(_safeJsonParseTuple);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\n/**\\n * Manipulate settings of texttracks\\n *\\n * @param {Object} player  Main Player\\n * @param {Object=} options Object of option names and values\\n * @extends Component\\n * @class TextTrackSettings\\n */\\n\\nvar TextTrackSettings = (function (_Component) {\\n  _inherits(TextTrackSettings, _Component);\\n\\n  function TextTrackSettings(player, options) {\\n    _classCallCheck(this, TextTrackSettings);\\n\\n    _Component.call(this, player, options);\\n    this.hide();\\n\\n    // Grab `persistTextTrackSettings` from the player options if not passed in child options\\n    if (options.persistTextTrackSettings === undefined) {\\n      this.options_.persistTextTrackSettings = this.options_.playerOptions.persistTextTrackSettings;\\n    }\\n\\n    Events.on(this.$('.vjs-done-button'), 'click', Fn.bind(this, function () {\\n      this.saveSettings();\\n      this.hide();\\n    }));\\n\\n    Events.on(this.$('.vjs-default-button'), 'click', Fn.bind(this, function () {\\n      this.$('.vjs-fg-color > select').selectedIndex = 0;\\n      this.$('.vjs-bg-color > select').selectedIndex = 0;\\n      this.$('.window-color > select').selectedIndex = 0;\\n      this.$('.vjs-text-opacity > select').selectedIndex = 0;\\n      this.$('.vjs-bg-opacity > select').selectedIndex = 0;\\n      this.$('.vjs-window-opacity > select').selectedIndex = 0;\\n      this.$('.vjs-edge-style select').selectedIndex = 0;\\n      this.$('.vjs-font-family select').selectedIndex = 0;\\n      this.$('.vjs-font-percent select').selectedIndex = 2;\\n      this.updateDisplay();\\n    }));\\n\\n    Events.on(this.$('.vjs-fg-color > select'), 'change', Fn.bind(this, this.updateDisplay));\\n    Events.on(this.$('.vjs-bg-color > select'), 'change', Fn.bind(this, this.updateDisplay));\\n    Events.on(this.$('.window-color > select'), 'change', Fn.bind(this, this.updateDisplay));\\n    Events.on(this.$('.vjs-text-opacity > select'), 'change', Fn.bind(this, this.updateDisplay));\\n    Events.on(this.$('.vjs-bg-opacity > select'), 'change', Fn.bind(this, this.updateDisplay));\\n    Events.on(this.$('.vjs-window-opacity > select'), 'change', Fn.bind(this, this.updateDisplay));\\n    Events.on(this.$('.vjs-font-percent select'), 'change', Fn.bind(this, this.updateDisplay));\\n    Events.on(this.$('.vjs-edge-style select'), 'change', Fn.bind(this, this.updateDisplay));\\n    Events.on(this.$('.vjs-font-family select'), 'change', Fn.bind(this, this.updateDisplay));\\n\\n    if (this.options_.persistTextTrackSettings) {\\n      this.restoreSettings();\\n    }\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  TextTrackSettings.prototype.createEl = function createEl() {\\n    var uniqueId = this.id_;\\n    var dialogLabelId = 'TTsettingsDialogLabel-' + uniqueId;\\n    var dialogDescriptionId = 'TTsettingsDialogDescription-' + uniqueId;\\n\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-caption-settings vjs-modal-overlay',\\n      innerHTML: captionOptionsMenuTemplate(uniqueId, dialogLabelId, dialogDescriptionId),\\n      tabIndex: -1\\n    }, {\\n      role: 'dialog',\\n      'aria-labelledby': dialogLabelId,\\n      'aria-describedby': dialogDescriptionId\\n    });\\n  };\\n\\n  /**\\n   * Get texttrack settings\\n   * Settings are\\n   * .vjs-edge-style\\n   * .vjs-font-family\\n   * .vjs-fg-color\\n   * .vjs-text-opacity\\n   * .vjs-bg-color\\n   * .vjs-bg-opacity\\n   * .window-color\\n   * .vjs-window-opacity\\n   *\\n   * @return {Object}\\n   * @method getValues\\n   */\\n\\n  TextTrackSettings.prototype.getValues = function getValues() {\\n    var textEdge = getSelectedOptionValue(this.$('.vjs-edge-style select'));\\n    var fontFamily = getSelectedOptionValue(this.$('.vjs-font-family select'));\\n    var fgColor = getSelectedOptionValue(this.$('.vjs-fg-color > select'));\\n    var textOpacity = getSelectedOptionValue(this.$('.vjs-text-opacity > select'));\\n    var bgColor = getSelectedOptionValue(this.$('.vjs-bg-color > select'));\\n    var bgOpacity = getSelectedOptionValue(this.$('.vjs-bg-opacity > select'));\\n    var windowColor = getSelectedOptionValue(this.$('.window-color > select'));\\n    var windowOpacity = getSelectedOptionValue(this.$('.vjs-window-opacity > select'));\\n    var fontPercent = _globalWindow2['default']['parseFloat'](getSelectedOptionValue(this.$('.vjs-font-percent > select')));\\n\\n    var result = {\\n      'backgroundOpacity': bgOpacity,\\n      'textOpacity': textOpacity,\\n      'windowOpacity': windowOpacity,\\n      'edgeStyle': textEdge,\\n      'fontFamily': fontFamily,\\n      'color': fgColor,\\n      'backgroundColor': bgColor,\\n      'windowColor': windowColor,\\n      'fontPercent': fontPercent\\n    };\\n    for (var _name in result) {\\n      if (result[_name] === '' || result[_name] === 'none' || _name === 'fontPercent' && result[_name] === 1.00) {\\n        delete result[_name];\\n      }\\n    }\\n    return result;\\n  };\\n\\n  /**\\n   * Set texttrack settings\\n   * Settings are\\n   * .vjs-edge-style\\n   * .vjs-font-family\\n   * .vjs-fg-color\\n   * .vjs-text-opacity\\n   * .vjs-bg-color\\n   * .vjs-bg-opacity\\n   * .window-color\\n   * .vjs-window-opacity\\n   *\\n   * @param {Object} values Object with texttrack setting values\\n   * @method setValues\\n   */\\n\\n  TextTrackSettings.prototype.setValues = function setValues(values) {\\n    setSelectedOption(this.$('.vjs-edge-style select'), values.edgeStyle);\\n    setSelectedOption(this.$('.vjs-font-family select'), values.fontFamily);\\n    setSelectedOption(this.$('.vjs-fg-color > select'), values.color);\\n    setSelectedOption(this.$('.vjs-text-opacity > select'), values.textOpacity);\\n    setSelectedOption(this.$('.vjs-bg-color > select'), values.backgroundColor);\\n    setSelectedOption(this.$('.vjs-bg-opacity > select'), values.backgroundOpacity);\\n    setSelectedOption(this.$('.window-color > select'), values.windowColor);\\n    setSelectedOption(this.$('.vjs-window-opacity > select'), values.windowOpacity);\\n\\n    var fontPercent = values.fontPercent;\\n\\n    if (fontPercent) {\\n      fontPercent = fontPercent.toFixed(2);\\n    }\\n\\n    setSelectedOption(this.$('.vjs-font-percent > select'), fontPercent);\\n  };\\n\\n  /**\\n   * Restore texttrack settings\\n   *\\n   * @method restoreSettings\\n   */\\n\\n  TextTrackSettings.prototype.restoreSettings = function restoreSettings() {\\n    var err = undefined,\\n        values = undefined;\\n\\n    try {\\n      var _safeParseTuple = _safeJsonParseTuple2['default'](_globalWindow2['default'].localStorage.getItem('vjs-text-track-settings'));\\n\\n      err = _safeParseTuple[0];\\n      values = _safeParseTuple[1];\\n\\n      if (err) {\\n        _utilsLogJs2['default'].error(err);\\n      }\\n    } catch (e) {\\n      _utilsLogJs2['default'].warn(e);\\n    }\\n\\n    if (values) {\\n      this.setValues(values);\\n    }\\n  };\\n\\n  /**\\n   * Save texttrack settings to local storage\\n   *\\n   * @method saveSettings\\n   */\\n\\n  TextTrackSettings.prototype.saveSettings = function saveSettings() {\\n    if (!this.options_.persistTextTrackSettings) {\\n      return;\\n    }\\n\\n    var values = this.getValues();\\n    try {\\n      if (Object.getOwnPropertyNames(values).length > 0) {\\n        _globalWindow2['default'].localStorage.setItem('vjs-text-track-settings', JSON.stringify(values));\\n      } else {\\n        _globalWindow2['default'].localStorage.removeItem('vjs-text-track-settings');\\n      }\\n    } catch (e) {\\n      _utilsLogJs2['default'].warn(e);\\n    }\\n  };\\n\\n  /**\\n   * Update display of texttrack settings\\n   *\\n   * @method updateDisplay\\n   */\\n\\n  TextTrackSettings.prototype.updateDisplay = function updateDisplay() {\\n    var ttDisplay = this.player_.getChild('textTrackDisplay');\\n    if (ttDisplay) {\\n      ttDisplay.updateDisplay();\\n    }\\n  };\\n\\n  return TextTrackSettings;\\n})(_component2['default']);\\n\\n_component2['default'].registerComponent('TextTrackSettings', TextTrackSettings);\\n\\nfunction getSelectedOptionValue(target) {\\n  var selectedOption = undefined;\\n  // not all browsers support selectedOptions, so, fallback to options\\n  if (target.selectedOptions) {\\n    selectedOption = target.selectedOptions[0];\\n  } else if (target.options) {\\n    selectedOption = target.options[target.options.selectedIndex];\\n  }\\n\\n  return selectedOption.value;\\n}\\n\\nfunction setSelectedOption(target, value) {\\n  if (!value) {\\n    return;\\n  }\\n\\n  var i = undefined;\\n  for (i = 0; i < target.options.length; i++) {\\n    var option = target.options[i];\\n    if (option.value === value) {\\n      break;\\n    }\\n  }\\n\\n  target.selectedIndex = i;\\n}\\n\\nfunction captionOptionsMenuTemplate(uniqueId, dialogLabelId, dialogDescriptionId) {\\n\\n  var template = '\\\\n    <div role=\\\"document\\\">\\\\n      <div role=\\\"heading\\\" aria-level=\\\"1\\\" id=\\\"' + dialogLabelId + '\\\" class=\\\"vjs-control-text\\\">Captions Settings Dialog</div>\\\\n      <div id=\\\"' + dialogDescriptionId + '\\\" class=\\\"vjs-control-text\\\">Beginning of dialog window. Escape will cancel and close the window.</div>\\\\n      <div class=\\\"vjs-tracksettings\\\">\\\\n        <div class=\\\"vjs-tracksettings-colors\\\">\\\\n          <fieldset class=\\\"vjs-fg-color vjs-tracksetting\\\">\\\\n            <legend>Text</legend>\\\\n            <label class=\\\"vjs-label\\\" for=\\\"captions-foreground-color-' + uniqueId + '\\\">Color</label>\\\\n            <select id=\\\"captions-foreground-color-' + uniqueId + '\\\">\\\\n              <option value=\\\"#FFF\\\" selected>White</option>\\\\n              <option value=\\\"#000\\\">Black</option>\\\\n              <option value=\\\"#F00\\\">Red</option>\\\\n              <option value=\\\"#0F0\\\">Green</option>\\\\n              <option value=\\\"#00F\\\">Blue</option>\\\\n              <option value=\\\"#FF0\\\">Yellow</option>\\\\n              <option value=\\\"#F0F\\\">Magenta</option>\\\\n              <option value=\\\"#0FF\\\">Cyan</option>\\\\n            </select>\\\\n            <span class=\\\"vjs-text-opacity vjs-opacity\\\">\\\\n              <label class=\\\"vjs-label\\\" for=\\\"captions-foreground-opacity-' + uniqueId + '\\\">Transparency</label>\\\\n              <select id=\\\"captions-foreground-opacity-' + uniqueId + '\\\">\\\\n                <option value=\\\"1\\\" selected>Opaque</option>\\\\n                <option value=\\\"0.5\\\">Semi-Opaque</option>\\\\n              </select>\\\\n            </span>\\\\n          </fieldset>\\\\n          <fieldset class=\\\"vjs-bg-color vjs-tracksetting\\\">\\\\n            <legend>Background</legend>\\\\n            <label class=\\\"vjs-label\\\" for=\\\"captions-background-color-' + uniqueId + '\\\">Color</label>\\\\n            <select id=\\\"captions-background-color-' + uniqueId + '\\\">\\\\n              <option value=\\\"#000\\\" selected>Black</option>\\\\n              <option value=\\\"#FFF\\\">White</option>\\\\n              <option value=\\\"#F00\\\">Red</option>\\\\n              <option value=\\\"#0F0\\\">Green</option>\\\\n              <option value=\\\"#00F\\\">Blue</option>\\\\n              <option value=\\\"#FF0\\\">Yellow</option>\\\\n              <option value=\\\"#F0F\\\">Magenta</option>\\\\n              <option value=\\\"#0FF\\\">Cyan</option>\\\\n            </select>\\\\n            <span class=\\\"vjs-bg-opacity vjs-opacity\\\">\\\\n              <label class=\\\"vjs-label\\\" for=\\\"captions-background-opacity-' + uniqueId + '\\\">Transparency</label>\\\\n              <select id=\\\"captions-background-opacity-' + uniqueId + '\\\">\\\\n                <option value=\\\"1\\\" selected>Opaque</option>\\\\n                <option value=\\\"0.5\\\">Semi-Transparent</option>\\\\n                <option value=\\\"0\\\">Transparent</option>\\\\n              </select>\\\\n            </span>\\\\n          </fieldset>\\\\n          <fieldset class=\\\"window-color vjs-tracksetting\\\">\\\\n            <legend>Window</legend>\\\\n            <label class=\\\"vjs-label\\\" for=\\\"captions-window-color-' + uniqueId + '\\\">Color</label>\\\\n            <select id=\\\"captions-window-color-' + uniqueId + '\\\">\\\\n              <option value=\\\"#000\\\" selected>Black</option>\\\\n              <option value=\\\"#FFF\\\">White</option>\\\\n              <option value=\\\"#F00\\\">Red</option>\\\\n              <option value=\\\"#0F0\\\">Green</option>\\\\n              <option value=\\\"#00F\\\">Blue</option>\\\\n              <option value=\\\"#FF0\\\">Yellow</option>\\\\n              <option value=\\\"#F0F\\\">Magenta</option>\\\\n              <option value=\\\"#0FF\\\">Cyan</option>\\\\n            </select>\\\\n            <span class=\\\"vjs-window-opacity vjs-opacity\\\">\\\\n              <label class=\\\"vjs-label\\\" for=\\\"captions-window-opacity-' + uniqueId + '\\\">Transparency</label>\\\\n              <select id=\\\"captions-window-opacity-' + uniqueId + '\\\">\\\\n                <option value=\\\"0\\\" selected>Transparent</option>\\\\n                <option value=\\\"0.5\\\">Semi-Transparent</option>\\\\n                <option value=\\\"1\\\">Opaque</option>\\\\n              </select>\\\\n            </span>\\\\n          </fieldset>\\\\n        </div> <!-- vjs-tracksettings-colors -->\\\\n        <div class=\\\"vjs-tracksettings-font\\\">\\\\n          <div class=\\\"vjs-font-percent vjs-tracksetting\\\">\\\\n            <label class=\\\"vjs-label\\\" for=\\\"captions-font-size-' + uniqueId + '\\\">Font Size</label>\\\\n            <select id=\\\"captions-font-size-' + uniqueId + '\\\">\\\\n              <option value=\\\"0.50\\\">50%</option>\\\\n              <option value=\\\"0.75\\\">75%</option>\\\\n              <option value=\\\"1.00\\\" selected>100%</option>\\\\n              <option value=\\\"1.25\\\">125%</option>\\\\n              <option value=\\\"1.50\\\">150%</option>\\\\n              <option value=\\\"1.75\\\">175%</option>\\\\n              <option value=\\\"2.00\\\">200%</option>\\\\n              <option value=\\\"3.00\\\">300%</option>\\\\n              <option value=\\\"4.00\\\">400%</option>\\\\n            </select>\\\\n          </div>\\\\n          <div class=\\\"vjs-edge-style vjs-tracksetting\\\">\\\\n            <label class=\\\"vjs-label\\\" for=\\\"captions-edge-style-' + uniqueId + '\\\">Text Edge Style</label>\\\\n            <select id=\\\"captions-edge-style-' + uniqueId + '\\\">\\\\n              <option value=\\\"none\\\" selected>None</option>\\\\n              <option value=\\\"raised\\\">Raised</option>\\\\n              <option value=\\\"depressed\\\">Depressed</option>\\\\n              <option value=\\\"uniform\\\">Uniform</option>\\\\n              <option value=\\\"dropshadow\\\">Dropshadow</option>\\\\n            </select>\\\\n          </div>\\\\n          <div class=\\\"vjs-font-family vjs-tracksetting\\\">\\\\n            <label class=\\\"vjs-label\\\" for=\\\"captions-font-family-' + uniqueId + '\\\">Font Family</label>\\\\n            <select id=\\\"captions-font-family-' + uniqueId + '\\\">\\\\n              <option value=\\\"proportionalSansSerif\\\" selected>Proportional Sans-Serif</option>\\\\n              <option value=\\\"monospaceSansSerif\\\">Monospace Sans-Serif</option>\\\\n              <option value=\\\"proportionalSerif\\\">Proportional Serif</option>\\\\n              <option value=\\\"monospaceSerif\\\">Monospace Serif</option>\\\\n              <option value=\\\"casual\\\">Casual</option>\\\\n              <option value=\\\"script\\\">Script</option>\\\\n              <option value=\\\"small-caps\\\">Small Caps</option>\\\\n            </select>\\\\n          </div>\\\\n        </div> <!-- vjs-tracksettings-font -->\\\\n        <div class=\\\"vjs-tracksettings-controls\\\">\\\\n          <button class=\\\"vjs-default-button\\\">Defaults</button>\\\\n          <button class=\\\"vjs-done-button\\\">Done</button>\\\\n        </div>\\\\n      </div> <!-- vjs-tracksettings -->\\\\n    </div> <!--  role=\\\"document\\\" -->';\\n\\n  return template;\\n}\\n\\nexports['default'] = TextTrackSettings;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component\\\":67,\\\"../utils/events.js\\\":143,\\\"../utils/fn.js\\\":144,\\\"../utils/log.js\\\":147,\\\"global/window\\\":2,\\\"safe-json-parse/tuple\\\":54}],134:[function(_dereq_,module,exports){\\n/**\\n * @file text-track.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _textTrackCueList = _dereq_('./text-track-cue-list');\\n\\nvar _textTrackCueList2 = _interopRequireDefault(_textTrackCueList);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _trackEnums = _dereq_('./track-enums');\\n\\nvar _utilsLogJs = _dereq_('../utils/log.js');\\n\\nvar _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _trackJs = _dereq_('./track.js');\\n\\nvar _trackJs2 = _interopRequireDefault(_trackJs);\\n\\nvar _utilsUrlJs = _dereq_('../utils/url.js');\\n\\nvar _xhr = _dereq_('xhr');\\n\\nvar _xhr2 = _interopRequireDefault(_xhr);\\n\\nvar _utilsMergeOptions = _dereq_('../utils/merge-options');\\n\\nvar _utilsMergeOptions2 = _interopRequireDefault(_utilsMergeOptions);\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\n/**\\n * takes a webvtt file contents and parses it into cues\\n *\\n * @param {String} srcContent webVTT file contents\\n * @param {Track} track track to addcues to\\n */\\nvar parseCues = function parseCues(srcContent, track) {\\n  var parser = new _globalWindow2['default'].WebVTT.Parser(_globalWindow2['default'], _globalWindow2['default'].vttjs, _globalWindow2['default'].WebVTT.StringDecoder());\\n  var errors = [];\\n\\n  parser.oncue = function (cue) {\\n    track.addCue(cue);\\n  };\\n\\n  parser.onparsingerror = function (error) {\\n    errors.push(error);\\n  };\\n\\n  parser.onflush = function () {\\n    track.trigger({\\n      type: 'loadeddata',\\n      target: track\\n    });\\n  };\\n\\n  parser.parse(srcContent);\\n  if (errors.length > 0) {\\n    if (console.groupCollapsed) {\\n      console.groupCollapsed('Text Track parsing errors for ' + track.src);\\n    }\\n    errors.forEach(function (error) {\\n      return _utilsLogJs2['default'].error(error);\\n    });\\n    if (console.groupEnd) {\\n      console.groupEnd();\\n    }\\n  }\\n\\n  parser.flush();\\n};\\n\\n/**\\n * load a track from a  specifed url\\n *\\n * @param {String} src url to load track from\\n * @param {Track} track track to addcues to\\n */\\nvar loadTrack = function loadTrack(src, track) {\\n  var opts = {\\n    uri: src\\n  };\\n  var crossOrigin = _utilsUrlJs.isCrossOrigin(src);\\n\\n  if (crossOrigin) {\\n    opts.cors = crossOrigin;\\n  }\\n\\n  _xhr2['default'](opts, Fn.bind(this, function (err, response, responseBody) {\\n    if (err) {\\n      return _utilsLogJs2['default'].error(err, response);\\n    }\\n\\n    track.loaded_ = true;\\n\\n    // Make sure that vttjs has loaded, otherwise, wait till it finished loading\\n    // NOTE: this is only used for the alt/video.novtt.js build\\n    if (typeof _globalWindow2['default'].WebVTT !== 'function') {\\n      if (track.tech_) {\\n        (function () {\\n          var loadHandler = function loadHandler() {\\n            return parseCues(responseBody, track);\\n          };\\n          track.tech_.on('vttjsloaded', loadHandler);\\n          track.tech_.on('vttjserror', function () {\\n            _utilsLogJs2['default'].error('vttjs failed to load, stopping trying to process ' + track.src);\\n            track.tech_.off('vttjsloaded', loadHandler);\\n          });\\n        })();\\n      }\\n    } else {\\n      parseCues(responseBody, track);\\n    }\\n  }));\\n};\\n\\n/**\\n * A single text track as defined in:\\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack\\n *\\n * interface TextTrack : EventTarget {\\n *   readonly attribute TextTrackKind kind;\\n *   readonly attribute DOMString label;\\n *   readonly attribute DOMString language;\\n *\\n *   readonly attribute DOMString id;\\n *   readonly attribute DOMString inBandMetadataTrackDispatchType;\\n *\\n *   attribute TextTrackMode mode;\\n *\\n *   readonly attribute TextTrackCueList? cues;\\n *   readonly attribute TextTrackCueList? activeCues;\\n *\\n *   void addCue(TextTrackCue cue);\\n *   void removeCue(TextTrackCue cue);\\n *\\n *   attribute EventHandler oncuechange;\\n * };\\n *\\n * @param {Object=} options Object of option names and values\\n * @extends Track\\n * @class TextTrack\\n */\\n\\nvar TextTrack = (function (_Track) {\\n  _inherits(TextTrack, _Track);\\n\\n  function TextTrack() {\\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\\n\\n    _classCallCheck(this, TextTrack);\\n\\n    if (!options.tech) {\\n      throw new Error('A tech was not provided.');\\n    }\\n\\n    var settings = _utilsMergeOptions2['default'](options, {\\n      kind: _trackEnums.TextTrackKind[options.kind] || 'subtitles',\\n      language: options.language || options.srclang || ''\\n    });\\n    var mode = _trackEnums.TextTrackMode[settings.mode] || 'disabled';\\n    var default_ = settings['default'];\\n\\n    if (settings.kind === 'metadata' || settings.kind === 'chapters') {\\n      mode = 'hidden';\\n    }\\n    // on IE8 this will be a document element\\n    // for every other browser this will be a normal object\\n    var tt = _Track.call(this, settings);\\n    tt.tech_ = settings.tech;\\n\\n    if (browser.IS_IE8) {\\n      for (var prop in TextTrack.prototype) {\\n        if (prop !== 'constructor') {\\n          tt[prop] = TextTrack.prototype[prop];\\n        }\\n      }\\n    }\\n\\n    tt.cues_ = [];\\n    tt.activeCues_ = [];\\n\\n    var cues = new _textTrackCueList2['default'](tt.cues_);\\n    var activeCues = new _textTrackCueList2['default'](tt.activeCues_);\\n    var changed = false;\\n    var timeupdateHandler = Fn.bind(tt, function () {\\n      this.activeCues;\\n      if (changed) {\\n        this.trigger('cuechange');\\n        changed = false;\\n      }\\n    });\\n\\n    if (mode !== 'disabled') {\\n      tt.tech_.on('timeupdate', timeupdateHandler);\\n    }\\n\\n    Object.defineProperty(tt, 'default', {\\n      get: function get() {\\n        return default_;\\n      },\\n      set: function set() {}\\n    });\\n\\n    Object.defineProperty(tt, 'mode', {\\n      get: function get() {\\n        return mode;\\n      },\\n      set: function set(newMode) {\\n        if (!_trackEnums.TextTrackMode[newMode]) {\\n          return;\\n        }\\n        mode = newMode;\\n        if (mode === 'showing') {\\n          this.tech_.on('timeupdate', timeupdateHandler);\\n        }\\n        this.trigger('modechange');\\n      }\\n    });\\n\\n    Object.defineProperty(tt, 'cues', {\\n      get: function get() {\\n        if (!this.loaded_) {\\n          return null;\\n        }\\n\\n        return cues;\\n      },\\n      set: function set() {}\\n    });\\n\\n    Object.defineProperty(tt, 'activeCues', {\\n      get: function get() {\\n        if (!this.loaded_) {\\n          return null;\\n        }\\n\\n        // nothing to do\\n        if (this.cues.length === 0) {\\n          return activeCues;\\n        }\\n\\n        var ct = this.tech_.currentTime();\\n        var active = [];\\n\\n        for (var i = 0, l = this.cues.length; i < l; i++) {\\n          var cue = this.cues[i];\\n\\n          if (cue.startTime <= ct && cue.endTime >= ct) {\\n            active.push(cue);\\n          } else if (cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct) {\\n            active.push(cue);\\n          }\\n        }\\n\\n        changed = false;\\n\\n        if (active.length !== this.activeCues_.length) {\\n          changed = true;\\n        } else {\\n          for (var i = 0; i < active.length; i++) {\\n            if (this.activeCues_.indexOf(active[i]) === -1) {\\n              changed = true;\\n            }\\n          }\\n        }\\n\\n        this.activeCues_ = active;\\n        activeCues.setCues_(this.activeCues_);\\n\\n        return activeCues;\\n      },\\n      set: function set() {}\\n    });\\n\\n    if (settings.src) {\\n      tt.src = settings.src;\\n      loadTrack(settings.src, tt);\\n    } else {\\n      tt.loaded_ = true;\\n    }\\n\\n    return tt;\\n  }\\n\\n  /**\\n   * cuechange - One or more cues in the track have become active or stopped being active.\\n   */\\n\\n  /**\\n   * add a cue to the internal list of cues\\n   *\\n   * @param {Object} cue the cue to add to our internal list\\n   * @method addCue\\n   */\\n\\n  TextTrack.prototype.addCue = function addCue(cue) {\\n    var tracks = this.tech_.textTracks();\\n\\n    if (tracks) {\\n      for (var i = 0; i < tracks.length; i++) {\\n        if (tracks[i] !== this) {\\n          tracks[i].removeCue(cue);\\n        }\\n      }\\n    }\\n\\n    this.cues_.push(cue);\\n    this.cues.setCues_(this.cues_);\\n  };\\n\\n  /**\\n   * remvoe a cue from our internal list\\n   *\\n   * @param {Object} removeCue the cue to remove from our internal list\\n   * @method removeCue\\n   */\\n\\n  TextTrack.prototype.removeCue = function removeCue(_removeCue) {\\n    var removed = false;\\n\\n    for (var i = 0, l = this.cues_.length; i < l; i++) {\\n      var cue = this.cues_[i];\\n\\n      if (cue === _removeCue) {\\n        this.cues_.splice(i, 1);\\n        removed = true;\\n      }\\n    }\\n\\n    if (removed) {\\n      this.cues.setCues_(this.cues_);\\n    }\\n  };\\n\\n  return TextTrack;\\n})(_trackJs2['default']);\\n\\nTextTrack.prototype.allowedEvents_ = {\\n  cuechange: 'cuechange'\\n};\\n\\nexports['default'] = TextTrack;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../utils/browser.js\\\":140,\\\"../utils/fn.js\\\":144,\\\"../utils/log.js\\\":147,\\\"../utils/merge-options\\\":148,\\\"../utils/url.js\\\":152,\\\"./text-track-cue-list\\\":129,\\\"./track-enums\\\":135,\\\"./track.js\\\":137,\\\"global/document\\\":1,\\\"global/window\\\":2,\\\"xhr\\\":56}],135:[function(_dereq_,module,exports){\\n/**\\n * @file track-kinds.js\\n */\\n\\n/**\\n * https://html.spec.whatwg.org/multipage/embedded-content.html#dom-videotrack-kind\\n *\\n * enum VideoTrackKind {\\n *   \\\"alternative\\\",\\n *   \\\"captions\\\",\\n *   \\\"main\\\",\\n *   \\\"sign\\\",\\n *   \\\"subtitles\\\",\\n *   \\\"commentary\\\",\\n *   \\\"\\\",\\n * };\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\nvar VideoTrackKind = {\\n  alternative: 'alternative',\\n  captions: 'captions',\\n  main: 'main',\\n  sign: 'sign',\\n  subtitles: 'subtitles',\\n  commentary: 'commentary'\\n};\\n\\n/**\\n * https://html.spec.whatwg.org/multipage/embedded-content.html#dom-audiotrack-kind\\n *\\n * enum AudioTrackKind {\\n *   \\\"alternative\\\",\\n *   \\\"descriptions\\\",\\n *   \\\"main\\\",\\n *   \\\"main-desc\\\",\\n *   \\\"translation\\\",\\n *   \\\"commentary\\\",\\n *   \\\"\\\",\\n * };\\n */\\nvar AudioTrackKind = {\\n  alternative: 'alternative',\\n  descriptions: 'descriptions',\\n  main: 'main',\\n  'main-desc': 'main-desc',\\n  translation: 'translation',\\n  commentary: 'commentary'\\n};\\n\\n/**\\n * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackkind\\n *\\n * enum TextTrackKind {\\n *   \\\"subtitles\\\",\\n *   \\\"captions\\\",\\n *   \\\"descriptions\\\",\\n *   \\\"chapters\\\",\\n *   \\\"metadata\\\"\\n * };\\n */\\nvar TextTrackKind = {\\n  subtitles: 'subtitles',\\n  captions: 'captions',\\n  descriptions: 'descriptions',\\n  chapters: 'chapters',\\n  metadata: 'metadata'\\n};\\n\\n/**\\n * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode\\n *\\n * enum TextTrackMode { \\\"disabled\\\",  \\\"hidden\\\",  \\\"showing\\\" };\\n */\\nvar TextTrackMode = {\\n  disabled: 'disabled',\\n  hidden: 'hidden',\\n  showing: 'showing'\\n};\\n\\n/* jshint ignore:start */\\n// we ignore jshint here because it does not see\\n// AudioTrackKind as defined here\\nexports['default'] = { VideoTrackKind: VideoTrackKind, AudioTrackKind: AudioTrackKind, TextTrackKind: TextTrackKind, TextTrackMode: TextTrackMode };\\n\\n/* jshint ignore:end */\\nmodule.exports = exports['default'];\\n\\n},{}],136:[function(_dereq_,module,exports){\\n/**\\n * @file track-list.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _eventTarget = _dereq_('../event-target');\\n\\nvar _eventTarget2 = _interopRequireDefault(_eventTarget);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\n/**\\n * Common functionaliy between Text, Audio, and Video TrackLists\\n * Interfaces defined in the following spec:\\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html\\n *\\n * @param {Track[]} tracks A list of tracks to initialize the list with\\n * @param {Object} list the child object with inheritance done manually for ie8\\n * @extends EventTarget\\n * @class TrackList\\n */\\n\\nvar TrackList = (function (_EventTarget) {\\n  _inherits(TrackList, _EventTarget);\\n\\n  function TrackList() {\\n    var tracks = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\\n    var list = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\\n\\n    _classCallCheck(this, TrackList);\\n\\n    _EventTarget.call(this);\\n    if (!list) {\\n      list = this;\\n      if (browser.IS_IE8) {\\n        list = _globalDocument2['default'].createElement('custom');\\n        for (var prop in TrackList.prototype) {\\n          if (prop !== 'constructor') {\\n            list[prop] = TrackList.prototype[prop];\\n          }\\n        }\\n      }\\n    }\\n\\n    list.tracks_ = [];\\n    Object.defineProperty(list, 'length', {\\n      get: function get() {\\n        return this.tracks_.length;\\n      }\\n    });\\n\\n    for (var i = 0; i < tracks.length; i++) {\\n      list.addTrack_(tracks[i]);\\n    }\\n\\n    return list;\\n  }\\n\\n  /**\\n   * change - One or more tracks in the track list have been enabled or disabled.\\n   * addtrack - A track has been added to the track list.\\n   * removetrack - A track has been removed from the track list.\\n   */\\n\\n  /**\\n   * Add a Track from TrackList\\n   *\\n   * @param {Mixed} track\\n   * @method addTrack_\\n   * @private\\n   */\\n\\n  TrackList.prototype.addTrack_ = function addTrack_(track) {\\n    var index = this.tracks_.length;\\n\\n    if (!('' + index in this)) {\\n      Object.defineProperty(this, index, {\\n        get: function get() {\\n          return this.tracks_[index];\\n        }\\n      });\\n    }\\n\\n    // Do not add duplicate tracks\\n    if (this.tracks_.indexOf(track) === -1) {\\n      this.tracks_.push(track);\\n      this.trigger({\\n        track: track,\\n        type: 'addtrack'\\n      });\\n    }\\n  };\\n\\n  /**\\n   * Remove a Track from TrackList\\n   *\\n   * @param {Track} rtrack track to be removed\\n   * @method removeTrack_\\n   * @private\\n   */\\n\\n  TrackList.prototype.removeTrack_ = function removeTrack_(rtrack) {\\n    var track = undefined;\\n\\n    for (var i = 0, l = this.length; i < l; i++) {\\n      if (this[i] === rtrack) {\\n        track = this[i];\\n        if (track.off) {\\n          track.off();\\n        }\\n\\n        this.tracks_.splice(i, 1);\\n\\n        break;\\n      }\\n    }\\n\\n    if (!track) {\\n      return;\\n    }\\n\\n    this.trigger({\\n      track: track,\\n      type: 'removetrack'\\n    });\\n  };\\n\\n  /**\\n   * Get a Track from the TrackList by a tracks id\\n   *\\n   * @param {String} id - the id of the track to get\\n   * @method getTrackById\\n   * @return {Track}\\n   * @private\\n   */\\n\\n  TrackList.prototype.getTrackById = function getTrackById(id) {\\n    var result = null;\\n\\n    for (var i = 0, l = this.length; i < l; i++) {\\n      var track = this[i];\\n      if (track.id === id) {\\n        result = track;\\n        break;\\n      }\\n    }\\n\\n    return result;\\n  };\\n\\n  return TrackList;\\n})(_eventTarget2['default']);\\n\\nTrackList.prototype.allowedEvents_ = {\\n  change: 'change',\\n  addtrack: 'addtrack',\\n  removetrack: 'removetrack'\\n};\\n\\n// emulate attribute EventHandler support to allow for feature detection\\nfor (var _event in TrackList.prototype.allowedEvents_) {\\n  TrackList.prototype['on' + _event] = null;\\n}\\n\\nexports['default'] = TrackList;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../event-target\\\":104,\\\"../utils/browser.js\\\":140,\\\"../utils/fn.js\\\":144,\\\"global/document\\\":1}],137:[function(_dereq_,module,exports){\\n/**\\n * @file track.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _utilsGuidJs = _dereq_('../utils/guid.js');\\n\\nvar Guid = _interopRequireWildcard(_utilsGuidJs);\\n\\nvar _eventTarget = _dereq_('../event-target');\\n\\nvar _eventTarget2 = _interopRequireDefault(_eventTarget);\\n\\n/**\\n * setup the common parts of an audio, video, or text track\\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html\\n *\\n * @param {String} type The type of track we are dealing with audio|video|text\\n * @param {Object=} options Object of option names and values\\n * @extends EventTarget\\n * @class Track\\n */\\n\\nvar Track = (function (_EventTarget) {\\n  _inherits(Track, _EventTarget);\\n\\n  function Track() {\\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\\n\\n    _classCallCheck(this, Track);\\n\\n    _EventTarget.call(this);\\n\\n    var track = this;\\n    if (browser.IS_IE8) {\\n      track = _globalDocument2['default'].createElement('custom');\\n      for (var prop in Track.prototype) {\\n        if (prop !== 'constructor') {\\n          track[prop] = Track.prototype[prop];\\n        }\\n      }\\n    }\\n\\n    var trackProps = {\\n      id: options.id || 'vjs_track_' + Guid.newGUID(),\\n      kind: options.kind || '',\\n      label: options.label || '',\\n      language: options.language || ''\\n    };\\n\\n    var _loop = function (key) {\\n      Object.defineProperty(track, key, {\\n        get: function get() {\\n          return trackProps[key];\\n        },\\n        set: function set() {}\\n      });\\n    };\\n\\n    for (var key in trackProps) {\\n      _loop(key);\\n    }\\n\\n    return track;\\n  }\\n\\n  return Track;\\n})(_eventTarget2['default']);\\n\\nexports['default'] = Track;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../event-target\\\":104,\\\"../utils/browser.js\\\":140,\\\"../utils/guid.js\\\":146,\\\"global/document\\\":1}],138:[function(_dereq_,module,exports){\\n/**\\n * @file video-track-list.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _trackList = _dereq_('./track-list');\\n\\nvar _trackList2 = _interopRequireDefault(_trackList);\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\n/**\\n * disable other video tracks before selecting the new one\\n *\\n * @param {Array|VideoTrackList} list list to work on\\n * @param {VideoTrack} track the track to skip\\n */\\nvar disableOthers = function disableOthers(list, track) {\\n  for (var i = 0; i < list.length; i++) {\\n    if (track.id === list[i].id) {\\n      continue;\\n    }\\n    // another audio track is enabled, disable it\\n    list[i].selected = false;\\n  }\\n};\\n\\n/**\\n* A list of possiblee video tracks. Most functionality is in the\\n * base class Tracklist and the spec for VideoTrackList is located at:\\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist\\n *\\n * interface VideoTrackList : EventTarget {\\n *   readonly attribute unsigned long length;\\n *   getter VideoTrack (unsigned long index);\\n *   VideoTrack? getTrackById(DOMString id);\\n *   readonly attribute long selectedIndex;\\n *\\n *   attribute EventHandler onchange;\\n *   attribute EventHandler onaddtrack;\\n *   attribute EventHandler onremovetrack;\\n * };\\n *\\n * @param {VideoTrack[]} tracks a list of video tracks to instantiate the list with\\n # @extends TrackList\\n * @class VideoTrackList\\n */\\n\\nvar VideoTrackList = (function (_TrackList) {\\n  _inherits(VideoTrackList, _TrackList);\\n\\n  function VideoTrackList() {\\n    var tracks = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\\n\\n    _classCallCheck(this, VideoTrackList);\\n\\n    var list = undefined;\\n\\n    // make sure only 1 track is enabled\\n    // sorted from last index to first index\\n    for (var i = tracks.length - 1; i >= 0; i--) {\\n      if (tracks[i].selected) {\\n        disableOthers(tracks, tracks[i]);\\n        break;\\n      }\\n    }\\n\\n    // IE8 forces us to implement inheritance ourselves\\n    // as it does not support Object.defineProperty properly\\n    if (browser.IS_IE8) {\\n      list = _globalDocument2['default'].createElement('custom');\\n      for (var prop in _trackList2['default'].prototype) {\\n        if (prop !== 'constructor') {\\n          list[prop] = _trackList2['default'].prototype[prop];\\n        }\\n      }\\n      for (var prop in VideoTrackList.prototype) {\\n        if (prop !== 'constructor') {\\n          list[prop] = VideoTrackList.prototype[prop];\\n        }\\n      }\\n    }\\n\\n    list = _TrackList.call(this, tracks, list);\\n    list.changing_ = false;\\n\\n    Object.defineProperty(list, 'selectedIndex', {\\n      get: function get() {\\n        for (var i = 0; i < this.length; i++) {\\n          if (this[i].selected) {\\n            return i;\\n          }\\n        }\\n        return -1;\\n      },\\n      set: function set() {}\\n    });\\n\\n    return list;\\n  }\\n\\n  VideoTrackList.prototype.addTrack_ = function addTrack_(track) {\\n    var _this = this;\\n\\n    if (track.selected) {\\n      disableOthers(this, track);\\n    }\\n\\n    _TrackList.prototype.addTrack_.call(this, track);\\n    // native tracks don't have this\\n    if (!track.addEventListener) {\\n      return;\\n    }\\n    track.addEventListener('selectedchange', function () {\\n      if (_this.changing_) {\\n        return;\\n      }\\n      _this.changing_ = true;\\n      disableOthers(_this, track);\\n      _this.changing_ = false;\\n      _this.trigger('change');\\n    });\\n  };\\n\\n  VideoTrackList.prototype.addTrack = function addTrack(track) {\\n    this.addTrack_(track);\\n  };\\n\\n  VideoTrackList.prototype.removeTrack = function removeTrack(track) {\\n    _TrackList.prototype.removeTrack_.call(this, track);\\n  };\\n\\n  return VideoTrackList;\\n})(_trackList2['default']);\\n\\nexports['default'] = VideoTrackList;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../utils/browser.js\\\":140,\\\"./track-list\\\":136,\\\"global/document\\\":1}],139:[function(_dereq_,module,exports){\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _trackEnums = _dereq_('./track-enums');\\n\\nvar _track = _dereq_('./track');\\n\\nvar _track2 = _interopRequireDefault(_track);\\n\\nvar _utilsMergeOptions = _dereq_('../utils/merge-options');\\n\\nvar _utilsMergeOptions2 = _interopRequireDefault(_utilsMergeOptions);\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\n/**\\n * A single video text track as defined in:\\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotrack\\n *\\n * interface VideoTrack {\\n *   readonly attribute DOMString id;\\n *   readonly attribute DOMString kind;\\n *   readonly attribute DOMString label;\\n *   readonly attribute DOMString language;\\n *   attribute boolean selected;\\n * };\\n *\\n * @param {Object=} options Object of option names and values\\n * @class VideoTrack\\n */\\n\\nvar VideoTrack = (function (_Track) {\\n  _inherits(VideoTrack, _Track);\\n\\n  function VideoTrack() {\\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\\n\\n    _classCallCheck(this, VideoTrack);\\n\\n    var settings = _utilsMergeOptions2['default'](options, {\\n      kind: _trackEnums.VideoTrackKind[options.kind] || ''\\n    });\\n\\n    // on IE8 this will be a document element\\n    // for every other browser this will be a normal object\\n    var track = _Track.call(this, settings);\\n    var selected = false;\\n\\n    if (browser.IS_IE8) {\\n      for (var prop in VideoTrack.prototype) {\\n        if (prop !== 'constructor') {\\n          track[prop] = VideoTrack.prototype[prop];\\n        }\\n      }\\n    }\\n\\n    Object.defineProperty(track, 'selected', {\\n      get: function get() {\\n        return selected;\\n      },\\n      set: function set(newSelected) {\\n        // an invalid or unchanged value\\n        if (typeof newSelected !== 'boolean' || newSelected === selected) {\\n          return;\\n        }\\n        selected = newSelected;\\n        this.trigger('selectedchange');\\n      }\\n    });\\n\\n    // if the user sets this track to selected then\\n    // set selected to that true value otherwise\\n    // we keep it false\\n    if (settings.selected) {\\n      track.selected = settings.selected;\\n    }\\n\\n    return track;\\n  }\\n\\n  return VideoTrack;\\n})(_track2['default']);\\n\\nexports['default'] = VideoTrack;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../utils/browser.js\\\":140,\\\"../utils/merge-options\\\":148,\\\"./track\\\":137,\\\"./track-enums\\\":135}],140:[function(_dereq_,module,exports){\\n/**\\n * @file browser.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar USER_AGENT = _globalWindow2['default'].navigator.userAgent;\\nvar webkitVersionMap = /AppleWebKit\\\\/([\\\\d.]+)/i.exec(USER_AGENT);\\nvar appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null;\\n\\n/*\\n * Device is an iPhone\\n *\\n * @type {Boolean}\\n * @constant\\n * @private\\n */\\nvar IS_IPAD = /iPad/i.test(USER_AGENT);\\n\\nexports.IS_IPAD = IS_IPAD;\\n// The Facebook app's UIWebView identifies as both an iPhone and iPad, so\\n// to identify iPhones, we need to exclude iPads.\\n// http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/\\nvar IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;\\nexports.IS_IPHONE = IS_IPHONE;\\nvar IS_IPOD = /iPod/i.test(USER_AGENT);\\nexports.IS_IPOD = IS_IPOD;\\nvar IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;\\n\\nexports.IS_IOS = IS_IOS;\\nvar IOS_VERSION = (function () {\\n  var match = USER_AGENT.match(/OS (\\\\d+)_/i);\\n  if (match && match[1]) {\\n    return match[1];\\n  }\\n})();\\n\\nexports.IOS_VERSION = IOS_VERSION;\\nvar IS_ANDROID = /Android/i.test(USER_AGENT);\\nexports.IS_ANDROID = IS_ANDROID;\\nvar ANDROID_VERSION = (function () {\\n  // This matches Android Major.Minor.Patch versions\\n  // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned\\n  var match = USER_AGENT.match(/Android (\\\\d+)(?:\\\\.(\\\\d+))?(?:\\\\.(\\\\d+))*/i),\\n      major,\\n      minor;\\n\\n  if (!match) {\\n    return null;\\n  }\\n\\n  major = match[1] && parseFloat(match[1]);\\n  minor = match[2] && parseFloat(match[2]);\\n\\n  if (major && minor) {\\n    return parseFloat(match[1] + '.' + match[2]);\\n  } else if (major) {\\n    return major;\\n  } else {\\n    return null;\\n  }\\n})();\\nexports.ANDROID_VERSION = ANDROID_VERSION;\\n// Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser\\nvar IS_OLD_ANDROID = IS_ANDROID && /webkit/i.test(USER_AGENT) && ANDROID_VERSION < 2.3;\\nexports.IS_OLD_ANDROID = IS_OLD_ANDROID;\\nvar IS_NATIVE_ANDROID = IS_ANDROID && ANDROID_VERSION < 5 && appleWebkitVersion < 537;\\n\\nexports.IS_NATIVE_ANDROID = IS_NATIVE_ANDROID;\\nvar IS_FIREFOX = /Firefox/i.test(USER_AGENT);\\nexports.IS_FIREFOX = IS_FIREFOX;\\nvar IS_EDGE = /Edge/i.test(USER_AGENT);\\nexports.IS_EDGE = IS_EDGE;\\nvar IS_CHROME = !IS_EDGE && /Chrome/i.test(USER_AGENT);\\nexports.IS_CHROME = IS_CHROME;\\nvar IS_IE8 = /MSIE\\\\s8\\\\.0/.test(USER_AGENT);\\nexports.IS_IE8 = IS_IE8;\\nvar IE_VERSION = (function (result) {\\n  return result && parseFloat(result[1]);\\n})(/MSIE\\\\s(\\\\d+)\\\\.\\\\d/.exec(USER_AGENT));\\n\\nexports.IE_VERSION = IE_VERSION;\\nvar TOUCH_ENABLED = !!('ontouchstart' in _globalWindow2['default'] || _globalWindow2['default'].DocumentTouch && _globalDocument2['default'] instanceof _globalWindow2['default'].DocumentTouch);\\nexports.TOUCH_ENABLED = TOUCH_ENABLED;\\nvar BACKGROUND_SIZE_SUPPORTED = ('backgroundSize' in _globalDocument2['default'].createElement('video').style);\\nexports.BACKGROUND_SIZE_SUPPORTED = BACKGROUND_SIZE_SUPPORTED;\\n\\n},{\\\"global/document\\\":1,\\\"global/window\\\":2}],141:[function(_dereq_,module,exports){\\n/**\\n * @file buffer.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\nexports.bufferedPercent = bufferedPercent;\\n\\nvar _timeRangesJs = _dereq_('./time-ranges.js');\\n\\n/**\\n * Compute how much your video has been buffered\\n *\\n * @param  {Object} Buffered object\\n * @param  {Number} Total duration\\n * @return {Number} Percent buffered of the total duration\\n * @private\\n * @function bufferedPercent\\n */\\n\\nfunction bufferedPercent(buffered, duration) {\\n  var bufferedDuration = 0,\\n      start,\\n      end;\\n\\n  if (!duration) {\\n    return 0;\\n  }\\n\\n  if (!buffered || !buffered.length) {\\n    buffered = _timeRangesJs.createTimeRange(0, 0);\\n  }\\n\\n  for (var i = 0; i < buffered.length; i++) {\\n    start = buffered.start(i);\\n    end = buffered.end(i);\\n\\n    // buffered end can be bigger than duration by a very small fraction\\n    if (end > duration) {\\n      end = duration;\\n    }\\n\\n    bufferedDuration += end - start;\\n  }\\n\\n  return bufferedDuration / duration;\\n}\\n\\n},{\\\"./time-ranges.js\\\":150}],142:[function(_dereq_,module,exports){\\n/**\\n * @file dom.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\nexports.getEl = getEl;\\nexports.createEl = createEl;\\nexports.textContent = textContent;\\nexports.insertElFirst = insertElFirst;\\nexports.getElData = getElData;\\nexports.hasElData = hasElData;\\nexports.removeElData = removeElData;\\nexports.hasElClass = hasElClass;\\nexports.addElClass = addElClass;\\nexports.removeElClass = removeElClass;\\nexports.toggleElClass = toggleElClass;\\nexports.setElAttributes = setElAttributes;\\nexports.getElAttributes = getElAttributes;\\nexports.blockTextSelection = blockTextSelection;\\nexports.unblockTextSelection = unblockTextSelection;\\nexports.findElPosition = findElPosition;\\nexports.getPointerPosition = getPointerPosition;\\nexports.isEl = isEl;\\nexports.isTextNode = isTextNode;\\nexports.emptyEl = emptyEl;\\nexports.normalizeContent = normalizeContent;\\nexports.appendContent = appendContent;\\nexports.insertContent = insertContent;\\n\\nvar _templateObject = _taggedTemplateLiteralLoose(['Setting attributes in the second argument of createEl()\\\\n                has been deprecated. Use the third argument instead.\\\\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.'], ['Setting attributes in the second argument of createEl()\\\\n                has been deprecated. Use the third argument instead.\\\\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.']);\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _taggedTemplateLiteralLoose(strings, raw) { strings.raw = raw; return strings; }\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _guidJs = _dereq_('./guid.js');\\n\\nvar Guid = _interopRequireWildcard(_guidJs);\\n\\nvar _logJs = _dereq_('./log.js');\\n\\nvar _logJs2 = _interopRequireDefault(_logJs);\\n\\nvar _tsml = _dereq_('tsml');\\n\\nvar _tsml2 = _interopRequireDefault(_tsml);\\n\\n/**\\n * Detect if a value is a string with any non-whitespace characters.\\n *\\n * @param  {String} str\\n * @return {Boolean}\\n */\\nfunction isNonBlankString(str) {\\n  return typeof str === 'string' && /\\\\S/.test(str);\\n}\\n\\n/**\\n * Throws an error if the passed string has whitespace. This is used by\\n * class methods to be relatively consistent with the classList API.\\n *\\n * @param  {String} str\\n * @return {Boolean}\\n */\\nfunction throwIfWhitespace(str) {\\n  if (/\\\\s/.test(str)) {\\n    throw new Error('class has illegal whitespace characters');\\n  }\\n}\\n\\n/**\\n * Produce a regular expression for matching a class name.\\n *\\n * @param  {String} className\\n * @return {RegExp}\\n */\\nfunction classRegExp(className) {\\n  return new RegExp('(^|\\\\\\\\s)' + className + '($|\\\\\\\\s)');\\n}\\n\\n/**\\n * Creates functions to query the DOM using a given method.\\n *\\n * @function createQuerier\\n * @private\\n * @param  {String} method\\n * @return {Function}\\n */\\nfunction createQuerier(method) {\\n  return function (selector, context) {\\n    if (!isNonBlankString(selector)) {\\n      return _globalDocument2['default'][method](null);\\n    }\\n    if (isNonBlankString(context)) {\\n      context = _globalDocument2['default'].querySelector(context);\\n    }\\n    return (isEl(context) ? context : _globalDocument2['default'])[method](selector);\\n  };\\n}\\n\\n/**\\n * Shorthand for document.getElementById()\\n * Also allows for CSS (jQuery) ID syntax. But nothing other than IDs.\\n *\\n * @param  {String} id  Element ID\\n * @return {Element}    Element with supplied ID\\n * @function getEl\\n */\\n\\nfunction getEl(id) {\\n  if (id.indexOf('#') === 0) {\\n    id = id.slice(1);\\n  }\\n\\n  return _globalDocument2['default'].getElementById(id);\\n}\\n\\n/**\\n * Creates an element and applies properties.\\n *\\n * @param  {String} [tagName='div'] Name of tag to be created.\\n * @param  {Object} [properties={}] Element properties to be applied.\\n * @param  {Object} [attributes={}] Element attributes to be applied.\\n * @return {Element}\\n * @function createEl\\n */\\n\\nfunction createEl() {\\n  var tagName = arguments.length <= 0 || arguments[0] === undefined ? 'div' : arguments[0];\\n  var properties = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n  var attributes = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\\n\\n  var el = _globalDocument2['default'].createElement(tagName);\\n\\n  Object.getOwnPropertyNames(properties).forEach(function (propName) {\\n    var val = properties[propName];\\n\\n    // See #2176\\n    // We originally were accepting both properties and attributes in the\\n    // same object, but that doesn't work so well.\\n    if (propName.indexOf('aria-') !== -1 || propName === 'role' || propName === 'type') {\\n      _logJs2['default'].warn(_tsml2['default'](_templateObject, propName, val));\\n      el.setAttribute(propName, val);\\n    } else {\\n      el[propName] = val;\\n    }\\n  });\\n\\n  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\\n    var val = attributes[attrName];\\n    el.setAttribute(attrName, attributes[attrName]);\\n  });\\n\\n  return el;\\n}\\n\\n/**\\n * Injects text into an element, replacing any existing contents entirely.\\n *\\n * @param  {Element} el\\n * @param  {String} text\\n * @return {Element}\\n * @function textContent\\n */\\n\\nfunction textContent(el, text) {\\n  if (typeof el.textContent === 'undefined') {\\n    el.innerText = text;\\n  } else {\\n    el.textContent = text;\\n  }\\n}\\n\\n/**\\n * Insert an element as the first child node of another\\n *\\n * @param  {Element} child   Element to insert\\n * @param  {Element} parent Element to insert child into\\n * @private\\n * @function insertElFirst\\n */\\n\\nfunction insertElFirst(child, parent) {\\n  if (parent.firstChild) {\\n    parent.insertBefore(child, parent.firstChild);\\n  } else {\\n    parent.appendChild(child);\\n  }\\n}\\n\\n/**\\n * Element Data Store. Allows for binding data to an element without putting it directly on the element.\\n * Ex. Event listeners are stored here.\\n * (also from jsninja.com, slightly modified and updated for closure compiler)\\n *\\n * @type {Object}\\n * @private\\n */\\nvar elData = {};\\n\\n/*\\n * Unique attribute name to store an element's guid in\\n *\\n * @type {String}\\n * @constant\\n * @private\\n */\\nvar elIdAttr = 'vdata' + new Date().getTime();\\n\\n/**\\n * Returns the cache object where data for an element is stored\\n *\\n * @param  {Element} el Element to store data for.\\n * @return {Object}\\n * @function getElData\\n */\\n\\nfunction getElData(el) {\\n  var id = el[elIdAttr];\\n\\n  if (!id) {\\n    id = el[elIdAttr] = Guid.newGUID();\\n  }\\n\\n  if (!elData[id]) {\\n    elData[id] = {};\\n  }\\n\\n  return elData[id];\\n}\\n\\n/**\\n * Returns whether or not an element has cached data\\n *\\n * @param  {Element} el A dom element\\n * @return {Boolean}\\n * @private\\n * @function hasElData\\n */\\n\\nfunction hasElData(el) {\\n  var id = el[elIdAttr];\\n\\n  if (!id) {\\n    return false;\\n  }\\n\\n  return !!Object.getOwnPropertyNames(elData[id]).length;\\n}\\n\\n/**\\n * Delete data for the element from the cache and the guid attr from getElementById\\n *\\n * @param  {Element} el Remove data for an element\\n * @private\\n * @function removeElData\\n */\\n\\nfunction removeElData(el) {\\n  var id = el[elIdAttr];\\n\\n  if (!id) {\\n    return;\\n  }\\n\\n  // Remove all stored data\\n  delete elData[id];\\n\\n  // Remove the elIdAttr property from the DOM node\\n  try {\\n    delete el[elIdAttr];\\n  } catch (e) {\\n    if (el.removeAttribute) {\\n      el.removeAttribute(elIdAttr);\\n    } else {\\n      // IE doesn't appear to support removeAttribute on the document element\\n      el[elIdAttr] = null;\\n    }\\n  }\\n}\\n\\n/**\\n * Check if an element has a CSS class\\n *\\n * @function hasElClass\\n * @param {Element} element Element to check\\n * @param {String} classToCheck Classname to check\\n */\\n\\nfunction hasElClass(element, classToCheck) {\\n  if (element.classList) {\\n    return element.classList.contains(classToCheck);\\n  } else {\\n    throwIfWhitespace(classToCheck);\\n    return classRegExp(classToCheck).test(element.className);\\n  }\\n}\\n\\n/**\\n * Add a CSS class name to an element\\n *\\n * @function addElClass\\n * @param {Element} element    Element to add class name to\\n * @param {String} classToAdd Classname to add\\n */\\n\\nfunction addElClass(element, classToAdd) {\\n  if (element.classList) {\\n    element.classList.add(classToAdd);\\n\\n    // Don't need to `throwIfWhitespace` here because `hasElClass` will do it\\n    // in the case of classList not being supported.\\n  } else if (!hasElClass(element, classToAdd)) {\\n      element.className = (element.className + ' ' + classToAdd).trim();\\n    }\\n\\n  return element;\\n}\\n\\n/**\\n * Remove a CSS class name from an element\\n *\\n * @function removeElClass\\n * @param {Element} element    Element to remove from class name\\n * @param {String} classToRemove Classname to remove\\n */\\n\\nfunction removeElClass(element, classToRemove) {\\n  if (element.classList) {\\n    element.classList.remove(classToRemove);\\n  } else {\\n    throwIfWhitespace(classToRemove);\\n    element.className = element.className.split(/\\\\s+/).filter(function (c) {\\n      return c !== classToRemove;\\n    }).join(' ');\\n  }\\n\\n  return element;\\n}\\n\\n/**\\n * Adds or removes a CSS class name on an element depending on an optional\\n * condition or the presence/absence of the class name.\\n *\\n * @function toggleElClass\\n * @param    {Element} element\\n * @param    {String} classToToggle\\n * @param    {Boolean|Function} [predicate]\\n *           Can be a function that returns a Boolean. If `true`, the class\\n *           will be added; if `false`, the class will be removed. If not\\n *           given, the class will be added if not present and vice versa.\\n */\\n\\nfunction toggleElClass(element, classToToggle, predicate) {\\n\\n  // This CANNOT use `classList` internally because IE does not support the\\n  // second parameter to the `classList.toggle()` method! Which is fine because\\n  // `classList` will be used by the add/remove functions.\\n  var has = hasElClass(element, classToToggle);\\n\\n  if (typeof predicate === 'function') {\\n    predicate = predicate(element, classToToggle);\\n  }\\n\\n  if (typeof predicate !== 'boolean') {\\n    predicate = !has;\\n  }\\n\\n  // If the necessary class operation matches the current state of the\\n  // element, no action is required.\\n  if (predicate === has) {\\n    return;\\n  }\\n\\n  if (predicate) {\\n    addElClass(element, classToToggle);\\n  } else {\\n    removeElClass(element, classToToggle);\\n  }\\n\\n  return element;\\n}\\n\\n/**\\n * Apply attributes to an HTML element.\\n *\\n * @param  {Element} el         Target element.\\n * @param  {Object=} attributes Element attributes to be applied.\\n * @private\\n * @function setElAttributes\\n */\\n\\nfunction setElAttributes(el, attributes) {\\n  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\\n    var attrValue = attributes[attrName];\\n\\n    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {\\n      el.removeAttribute(attrName);\\n    } else {\\n      el.setAttribute(attrName, attrValue === true ? '' : attrValue);\\n    }\\n  });\\n}\\n\\n/**\\n * Get an element's attribute values, as defined on the HTML tag\\n * Attributes are not the same as properties. They're defined on the tag\\n * or with setAttribute (which shouldn't be used with HTML)\\n * This will return true or false for boolean attributes.\\n *\\n * @param  {Element} tag Element from which to get tag attributes\\n * @return {Object}\\n * @private\\n * @function getElAttributes\\n */\\n\\nfunction getElAttributes(tag) {\\n  var obj, knownBooleans, attrs, attrName, attrVal;\\n\\n  obj = {};\\n\\n  // known boolean attributes\\n  // we can check for matching boolean properties, but older browsers\\n  // won't know about HTML5 boolean attributes that we still read from\\n  knownBooleans = ',' + 'autoplay,controls,loop,muted,default' + ',';\\n\\n  if (tag && tag.attributes && tag.attributes.length > 0) {\\n    attrs = tag.attributes;\\n\\n    for (var i = attrs.length - 1; i >= 0; i--) {\\n      attrName = attrs[i].name;\\n      attrVal = attrs[i].value;\\n\\n      // check for known booleans\\n      // the matching element property will return a value for typeof\\n      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {\\n        // the value of an included boolean attribute is typically an empty\\n        // string ('') which would equal false if we just check for a false value.\\n        // we also don't want support bad code like autoplay='false'\\n        attrVal = attrVal !== null ? true : false;\\n      }\\n\\n      obj[attrName] = attrVal;\\n    }\\n  }\\n\\n  return obj;\\n}\\n\\n/**\\n * Attempt to block the ability to select text while dragging controls\\n *\\n * @return {Boolean}\\n * @function blockTextSelection\\n */\\n\\nfunction blockTextSelection() {\\n  _globalDocument2['default'].body.focus();\\n  _globalDocument2['default'].onselectstart = function () {\\n    return false;\\n  };\\n}\\n\\n/**\\n * Turn off text selection blocking\\n *\\n * @return {Boolean}\\n * @function unblockTextSelection\\n */\\n\\nfunction unblockTextSelection() {\\n  _globalDocument2['default'].onselectstart = function () {\\n    return true;\\n  };\\n}\\n\\n/**\\n * Offset Left\\n * getBoundingClientRect technique from\\n * John Resig http://ejohn.org/blog/getboundingclientrect-is-awesome/\\n *\\n * @function findElPosition\\n * @param {Element} el Element from which to get offset\\n * @return {Object}\\n */\\n\\nfunction findElPosition(el) {\\n  var box = undefined;\\n\\n  if (el.getBoundingClientRect && el.parentNode) {\\n    box = el.getBoundingClientRect();\\n  }\\n\\n  if (!box) {\\n    return {\\n      left: 0,\\n      top: 0\\n    };\\n  }\\n\\n  var docEl = _globalDocument2['default'].documentElement;\\n  var body = _globalDocument2['default'].body;\\n\\n  var clientLeft = docEl.clientLeft || body.clientLeft || 0;\\n  var scrollLeft = _globalWindow2['default'].pageXOffset || body.scrollLeft;\\n  var left = box.left + scrollLeft - clientLeft;\\n\\n  var clientTop = docEl.clientTop || body.clientTop || 0;\\n  var scrollTop = _globalWindow2['default'].pageYOffset || body.scrollTop;\\n  var top = box.top + scrollTop - clientTop;\\n\\n  // Android sometimes returns slightly off decimal values, so need to round\\n  return {\\n    left: Math.round(left),\\n    top: Math.round(top)\\n  };\\n}\\n\\n/**\\n * Get pointer position in element\\n * Returns an object with x and y coordinates.\\n * The base on the coordinates are the bottom left of the element.\\n *\\n * @function getPointerPosition\\n * @param {Element} el Element on which to get the pointer position on\\n * @param {Event} event Event object\\n * @return {Object} This object will have x and y coordinates corresponding to the mouse position\\n */\\n\\nfunction getPointerPosition(el, event) {\\n  var position = {};\\n  var box = findElPosition(el);\\n  var boxW = el.offsetWidth;\\n  var boxH = el.offsetHeight;\\n\\n  var boxY = box.top;\\n  var boxX = box.left;\\n  var pageY = event.pageY;\\n  var pageX = event.pageX;\\n\\n  if (event.changedTouches) {\\n    pageX = event.changedTouches[0].pageX;\\n    pageY = event.changedTouches[0].pageY;\\n  }\\n\\n  position.y = Math.max(0, Math.min(1, (boxY - pageY + boxH) / boxH));\\n  position.x = Math.max(0, Math.min(1, (pageX - boxX) / boxW));\\n\\n  return position;\\n}\\n\\n/**\\n * Determines, via duck typing, whether or not a value is a DOM element.\\n *\\n * @function isEl\\n * @param    {Mixed} value\\n * @return   {Boolean}\\n */\\n\\nfunction isEl(value) {\\n  return !!value && typeof value === 'object' && value.nodeType === 1;\\n}\\n\\n/**\\n * Determines, via duck typing, whether or not a value is a text node.\\n *\\n * @param  {Mixed} value\\n * @return {Boolean}\\n */\\n\\nfunction isTextNode(value) {\\n  return !!value && typeof value === 'object' && value.nodeType === 3;\\n}\\n\\n/**\\n * Empties the contents of an element.\\n *\\n * @function emptyEl\\n * @param    {Element} el\\n * @return   {Element}\\n */\\n\\nfunction emptyEl(el) {\\n  while (el.firstChild) {\\n    el.removeChild(el.firstChild);\\n  }\\n  return el;\\n}\\n\\n/**\\n * Normalizes content for eventual insertion into the DOM.\\n *\\n * This allows a wide range of content definition methods, but protects\\n * from falling into the trap of simply writing to `innerHTML`, which is\\n * an XSS concern.\\n *\\n * The content for an element can be passed in multiple types and\\n * combinations, whose behavior is as follows:\\n *\\n * - String\\n *   Normalized into a text node.\\n *\\n * - Element, TextNode\\n *   Passed through.\\n *\\n * - Array\\n *   A one-dimensional array of strings, elements, nodes, or functions (which\\n *   return single strings, elements, or nodes).\\n *\\n * - Function\\n *   If the sole argument, is expected to produce a string, element,\\n *   node, or array.\\n *\\n * @function normalizeContent\\n * @param    {String|Element|TextNode|Array|Function} content\\n * @return   {Array}\\n */\\n\\nfunction normalizeContent(content) {\\n\\n  // First, invoke content if it is a function. If it produces an array,\\n  // that needs to happen before normalization.\\n  if (typeof content === 'function') {\\n    content = content();\\n  }\\n\\n  // Next up, normalize to an array, so one or many items can be normalized,\\n  // filtered, and returned.\\n  return (Array.isArray(content) ? content : [content]).map(function (value) {\\n\\n    // First, invoke value if it is a function to produce a new value,\\n    // which will be subsequently normalized to a Node of some kind.\\n    if (typeof value === 'function') {\\n      value = value();\\n    }\\n\\n    if (isEl(value) || isTextNode(value)) {\\n      return value;\\n    }\\n\\n    if (typeof value === 'string' && /\\\\S/.test(value)) {\\n      return _globalDocument2['default'].createTextNode(value);\\n    }\\n  }).filter(function (value) {\\n    return value;\\n  });\\n}\\n\\n/**\\n * Normalizes and appends content to an element.\\n *\\n * @function appendContent\\n * @param    {Element} el\\n * @param    {String|Element|TextNode|Array|Function} content\\n *           See: `normalizeContent`\\n * @return   {Element}\\n */\\n\\nfunction appendContent(el, content) {\\n  normalizeContent(content).forEach(function (node) {\\n    return el.appendChild(node);\\n  });\\n  return el;\\n}\\n\\n/**\\n * Normalizes and inserts content into an element; this is identical to\\n * `appendContent()`, except it empties the element first.\\n *\\n * @function insertContent\\n * @param    {Element} el\\n * @param    {String|Element|TextNode|Array|Function} content\\n *           See: `normalizeContent`\\n * @return   {Element}\\n */\\n\\nfunction insertContent(el, content) {\\n  return appendContent(emptyEl(el), content);\\n}\\n\\n/**\\n * Finds a single DOM element matching `selector` within the optional\\n * `context` of another DOM element (defaulting to `document`).\\n *\\n * @function $\\n * @param    {String} selector\\n *           A valid CSS selector, which will be passed to `querySelector`.\\n *\\n * @param    {Element|String} [context=document]\\n *           A DOM element within which to query. Can also be a selector\\n *           string in which case the first matching element will be used\\n *           as context. If missing (or no element matches selector), falls\\n *           back to `document`.\\n *\\n * @return   {Element|null}\\n */\\nvar $ = createQuerier('querySelector');\\n\\nexports.$ = $;\\n/**\\n * Finds a all DOM elements matching `selector` within the optional\\n * `context` of another DOM element (defaulting to `document`).\\n *\\n * @function $$\\n * @param    {String} selector\\n *           A valid CSS selector, which will be passed to `querySelectorAll`.\\n *\\n * @param    {Element|String} [context=document]\\n *           A DOM element within which to query. Can also be a selector\\n *           string in which case the first matching element will be used\\n *           as context. If missing (or no element matches selector), falls\\n *           back to `document`.\\n *\\n * @return   {NodeList}\\n */\\nvar $$ = createQuerier('querySelectorAll');\\nexports.$$ = $$;\\n\\n},{\\\"./guid.js\\\":146,\\\"./log.js\\\":147,\\\"global/document\\\":1,\\\"global/window\\\":2,\\\"tsml\\\":55}],143:[function(_dereq_,module,exports){\\n/**\\n * @file events.js\\n *\\n * Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)\\n * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)\\n * This should work very similarly to jQuery's events, however it's based off the book version which isn't as\\n * robust as jquery's, so there's probably some differences.\\n */\\n\\n'use strict';\\n\\nexports.__esModule = true;\\nexports.on = on;\\nexports.off = off;\\nexports.trigger = trigger;\\nexports.one = one;\\nexports.fixEvent = fixEvent;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nvar _domJs = _dereq_('./dom.js');\\n\\nvar Dom = _interopRequireWildcard(_domJs);\\n\\nvar _guidJs = _dereq_('./guid.js');\\n\\nvar Guid = _interopRequireWildcard(_guidJs);\\n\\nvar _logJs = _dereq_('./log.js');\\n\\nvar _logJs2 = _interopRequireDefault(_logJs);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\n/**\\n * Add an event listener to element\\n * It stores the handler function in a separate cache object\\n * and adds a generic handler to the element's event,\\n * along with a unique id (guid) to the element.\\n *\\n * @param  {Element|Object}   elem Element or object to bind listeners to\\n * @param  {String|Array}   type Type of event to bind to.\\n * @param  {Function} fn   Event listener.\\n * @method on\\n */\\n\\nfunction on(elem, type, fn) {\\n  if (Array.isArray(type)) {\\n    return _handleMultipleEvents(on, elem, type, fn);\\n  }\\n\\n  var data = Dom.getElData(elem);\\n\\n  // We need a place to store all our handler data\\n  if (!data.handlers) data.handlers = {};\\n\\n  if (!data.handlers[type]) data.handlers[type] = [];\\n\\n  if (!fn.guid) fn.guid = Guid.newGUID();\\n\\n  data.handlers[type].push(fn);\\n\\n  if (!data.dispatcher) {\\n    data.disabled = false;\\n\\n    data.dispatcher = function (event, hash) {\\n\\n      if (data.disabled) return;\\n      event = fixEvent(event);\\n\\n      var handlers = data.handlers[event.type];\\n\\n      if (handlers) {\\n        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.\\n        var handlersCopy = handlers.slice(0);\\n\\n        for (var m = 0, n = handlersCopy.length; m < n; m++) {\\n          if (event.isImmediatePropagationStopped()) {\\n            break;\\n          } else {\\n            try {\\n              handlersCopy[m].call(elem, event, hash);\\n            } catch (e) {\\n              _logJs2['default'].error(e);\\n            }\\n          }\\n        }\\n      }\\n    };\\n  }\\n\\n  if (data.handlers[type].length === 1) {\\n    if (elem.addEventListener) {\\n      elem.addEventListener(type, data.dispatcher, false);\\n    } else if (elem.attachEvent) {\\n      elem.attachEvent('on' + type, data.dispatcher);\\n    }\\n  }\\n}\\n\\n/**\\n * Removes event listeners from an element\\n *\\n * @param  {Element|Object}   elem Object to remove listeners from\\n * @param  {String|Array=}   type Type of listener to remove. Don't include to remove all events from element.\\n * @param  {Function} fn   Specific listener to remove. Don't include to remove listeners for an event type.\\n * @method off\\n */\\n\\nfunction off(elem, type, fn) {\\n  // Don't want to add a cache object through getElData if not needed\\n  if (!Dom.hasElData(elem)) return;\\n\\n  var data = Dom.getElData(elem);\\n\\n  // If no events exist, nothing to unbind\\n  if (!data.handlers) {\\n    return;\\n  }\\n\\n  if (Array.isArray(type)) {\\n    return _handleMultipleEvents(off, elem, type, fn);\\n  }\\n\\n  // Utility function\\n  var removeType = function removeType(t) {\\n    data.handlers[t] = [];\\n    _cleanUpEvents(elem, t);\\n  };\\n\\n  // Are we removing all bound events?\\n  if (!type) {\\n    for (var t in data.handlers) {\\n      removeType(t);\\n    }return;\\n  }\\n\\n  var handlers = data.handlers[type];\\n\\n  // If no handlers exist, nothing to unbind\\n  if (!handlers) return;\\n\\n  // If no listener was provided, remove all listeners for type\\n  if (!fn) {\\n    removeType(type);\\n    return;\\n  }\\n\\n  // We're only removing a single handler\\n  if (fn.guid) {\\n    for (var n = 0; n < handlers.length; n++) {\\n      if (handlers[n].guid === fn.guid) {\\n        handlers.splice(n--, 1);\\n      }\\n    }\\n  }\\n\\n  _cleanUpEvents(elem, type);\\n}\\n\\n/**\\n * Trigger an event for an element\\n *\\n * @param  {Element|Object}      elem  Element to trigger an event on\\n * @param  {Event|Object|String} event A string (the type) or an event object with a type attribute\\n * @param  {Object} [hash] data hash to pass along with the event\\n * @return {Boolean=} Returned only if default was prevented\\n * @method trigger\\n */\\n\\nfunction trigger(elem, event, hash) {\\n  // Fetches element data and a reference to the parent (for bubbling).\\n  // Don't want to add a data object to cache for every parent,\\n  // so checking hasElData first.\\n  var elemData = Dom.hasElData(elem) ? Dom.getElData(elem) : {};\\n  var parent = elem.parentNode || elem.ownerDocument;\\n  // type = event.type || event,\\n  // handler;\\n\\n  // If an event name was passed as a string, creates an event out of it\\n  if (typeof event === 'string') {\\n    event = { type: event, target: elem };\\n  }\\n  // Normalizes the event properties.\\n  event = fixEvent(event);\\n\\n  // If the passed element has a dispatcher, executes the established handlers.\\n  if (elemData.dispatcher) {\\n    elemData.dispatcher.call(elem, event, hash);\\n  }\\n\\n  // Unless explicitly stopped or the event does not bubble (e.g. media events)\\n  // recursively calls this function to bubble the event up the DOM.\\n  if (parent && !event.isPropagationStopped() && event.bubbles === true) {\\n    trigger.call(null, parent, event, hash);\\n\\n    // If at the top of the DOM, triggers the default action unless disabled.\\n  } else if (!parent && !event.defaultPrevented) {\\n      var targetData = Dom.getElData(event.target);\\n\\n      // Checks if the target has a default action for this event.\\n      if (event.target[event.type]) {\\n        // Temporarily disables event dispatching on the target as we have already executed the handler.\\n        targetData.disabled = true;\\n        // Executes the default action.\\n        if (typeof event.target[event.type] === 'function') {\\n          event.target[event.type]();\\n        }\\n        // Re-enables event dispatching.\\n        targetData.disabled = false;\\n      }\\n    }\\n\\n  // Inform the triggerer if the default was prevented by returning false\\n  return !event.defaultPrevented;\\n}\\n\\n/**\\n * Trigger a listener only once for an event\\n *\\n * @param  {Element|Object}   elem Element or object to\\n * @param  {String|Array}   type Name/type of event\\n * @param  {Function} fn Event handler function\\n * @method one\\n */\\n\\nfunction one(elem, type, fn) {\\n  if (Array.isArray(type)) {\\n    return _handleMultipleEvents(one, elem, type, fn);\\n  }\\n  var func = function func() {\\n    off(elem, type, func);\\n    fn.apply(this, arguments);\\n  };\\n  // copy the guid to the new function so it can removed using the original function's ID\\n  func.guid = fn.guid = fn.guid || Guid.newGUID();\\n  on(elem, type, func);\\n}\\n\\n/**\\n * Fix a native event to have standard property values\\n *\\n * @param  {Object} event Event object to fix\\n * @return {Object}\\n * @private\\n * @method fixEvent\\n */\\n\\nfunction fixEvent(event) {\\n\\n  function returnTrue() {\\n    return true;\\n  }\\n  function returnFalse() {\\n    return false;\\n  }\\n\\n  // Test if fixing up is needed\\n  // Used to check if !event.stopPropagation instead of isPropagationStopped\\n  // But native events return true for stopPropagation, but don't have\\n  // other expected methods like isPropagationStopped. Seems to be a problem\\n  // with the Javascript Ninja code. So we're just overriding all events now.\\n  if (!event || !event.isPropagationStopped) {\\n    var old = event || _globalWindow2['default'].event;\\n\\n    event = {};\\n    // Clone the old object so that we can modify the values event = {};\\n    // IE8 Doesn't like when you mess with native event properties\\n    // Firefox returns false for event.hasOwnProperty('type') and other props\\n    //  which makes copying more difficult.\\n    // TODO: Probably best to create a whitelist of event props\\n    for (var key in old) {\\n      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y\\n      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation\\n      // and webkitMovementX/Y\\n      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation' && key !== 'webkitMovementX' && key !== 'webkitMovementY') {\\n        // Chrome 32+ warns if you try to copy deprecated returnValue, but\\n        // we still want to if preventDefault isn't supported (IE8).\\n        if (!(key === 'returnValue' && old.preventDefault)) {\\n          event[key] = old[key];\\n        }\\n      }\\n    }\\n\\n    // The event occurred on this element\\n    if (!event.target) {\\n      event.target = event.srcElement || _globalDocument2['default'];\\n    }\\n\\n    // Handle which other element the event is related to\\n    if (!event.relatedTarget) {\\n      event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;\\n    }\\n\\n    // Stop the default browser action\\n    event.preventDefault = function () {\\n      if (old.preventDefault) {\\n        old.preventDefault();\\n      }\\n      event.returnValue = false;\\n      old.returnValue = false;\\n      event.defaultPrevented = true;\\n    };\\n\\n    event.defaultPrevented = false;\\n\\n    // Stop the event from bubbling\\n    event.stopPropagation = function () {\\n      if (old.stopPropagation) {\\n        old.stopPropagation();\\n      }\\n      event.cancelBubble = true;\\n      old.cancelBubble = true;\\n      event.isPropagationStopped = returnTrue;\\n    };\\n\\n    event.isPropagationStopped = returnFalse;\\n\\n    // Stop the event from bubbling and executing other handlers\\n    event.stopImmediatePropagation = function () {\\n      if (old.stopImmediatePropagation) {\\n        old.stopImmediatePropagation();\\n      }\\n      event.isImmediatePropagationStopped = returnTrue;\\n      event.stopPropagation();\\n    };\\n\\n    event.isImmediatePropagationStopped = returnFalse;\\n\\n    // Handle mouse position\\n    if (event.clientX != null) {\\n      var doc = _globalDocument2['default'].documentElement,\\n          body = _globalDocument2['default'].body;\\n\\n      event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\\n      event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\\n    }\\n\\n    // Handle key presses\\n    event.which = event.charCode || event.keyCode;\\n\\n    // Fix button for mouse clicks:\\n    // 0 == left; 1 == middle; 2 == right\\n    if (event.button != null) {\\n      event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;\\n    }\\n  }\\n\\n  // Returns fixed-up instance\\n  return event;\\n}\\n\\n/**\\n * Clean up the listener cache and dispatchers\\n*\\n * @param  {Element|Object} elem Element to clean up\\n * @param  {String} type Type of event to clean up\\n * @private\\n * @method _cleanUpEvents\\n */\\nfunction _cleanUpEvents(elem, type) {\\n  var data = Dom.getElData(elem);\\n\\n  // Remove the events of a particular type if there are none left\\n  if (data.handlers[type].length === 0) {\\n    delete data.handlers[type];\\n    // data.handlers[type] = null;\\n    // Setting to null was causing an error with data.handlers\\n\\n    // Remove the meta-handler from the element\\n    if (elem.removeEventListener) {\\n      elem.removeEventListener(type, data.dispatcher, false);\\n    } else if (elem.detachEvent) {\\n      elem.detachEvent('on' + type, data.dispatcher);\\n    }\\n  }\\n\\n  // Remove the events object if there are no types left\\n  if (Object.getOwnPropertyNames(data.handlers).length <= 0) {\\n    delete data.handlers;\\n    delete data.dispatcher;\\n    delete data.disabled;\\n  }\\n\\n  // Finally remove the element data if there is no data left\\n  if (Object.getOwnPropertyNames(data).length === 0) {\\n    Dom.removeElData(elem);\\n  }\\n}\\n\\n/**\\n * Loops through an array of event types and calls the requested method for each type.\\n *\\n * @param  {Function} fn   The event method we want to use.\\n * @param  {Element|Object} elem Element or object to bind listeners to\\n * @param  {String}   type Type of event to bind to.\\n * @param  {Function} callback   Event listener.\\n * @private\\n * @function _handleMultipleEvents\\n */\\nfunction _handleMultipleEvents(fn, elem, types, callback) {\\n  types.forEach(function (type) {\\n    //Call the event method for each one of the types\\n    fn(elem, type, callback);\\n  });\\n}\\n\\n},{\\\"./dom.js\\\":142,\\\"./guid.js\\\":146,\\\"./log.js\\\":147,\\\"global/document\\\":1,\\\"global/window\\\":2}],144:[function(_dereq_,module,exports){\\n/**\\n * @file fn.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nvar _guidJs = _dereq_('./guid.js');\\n\\n/**\\n * Bind (a.k.a proxy or Context). A simple method for changing the context of a function\\n * It also stores a unique id on the function so it can be easily removed from events\\n *\\n * @param  {*}   context The object to bind as scope\\n * @param  {Function} fn      The function to be bound to a scope\\n * @param  {Number=}   uid     An optional unique ID for the function to be set\\n * @return {Function}\\n * @private\\n * @method bind\\n */\\nvar bind = function bind(context, fn, uid) {\\n  // Make sure the function has a unique ID\\n  if (!fn.guid) {\\n    fn.guid = _guidJs.newGUID();\\n  }\\n\\n  // Create the new function that changes the context\\n  var ret = function ret() {\\n    return fn.apply(context, arguments);\\n  };\\n\\n  // Allow for the ability to individualize this function\\n  // Needed in the case where multiple objects might share the same prototype\\n  // IF both items add an event listener with the same function, then you try to remove just one\\n  // it will remove both because they both have the same guid.\\n  // when using this, you need to use the bind method when you remove the listener as well.\\n  // currently used in text tracks\\n  ret.guid = uid ? uid + '_' + fn.guid : fn.guid;\\n\\n  return ret;\\n};\\nexports.bind = bind;\\n\\n},{\\\"./guid.js\\\":146}],145:[function(_dereq_,module,exports){\\n/**\\n * @file format-time.js\\n *\\n * Format seconds as a time string, H:MM:SS or M:SS\\n * Supplying a guide (in seconds) will force a number of leading zeros\\n * to cover the length of the guide\\n *\\n * @param  {Number} seconds Number of seconds to be turned into a string\\n * @param  {Number} guide   Number (in seconds) to model the string after\\n * @return {String}         Time formatted as H:MM:SS or M:SS\\n * @private\\n * @function formatTime\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\nfunction formatTime(seconds) {\\n  var guide = arguments.length <= 1 || arguments[1] === undefined ? seconds : arguments[1];\\n  return (function () {\\n    seconds = seconds < 0 ? 0 : seconds;\\n    var s = Math.floor(seconds % 60);\\n    var m = Math.floor(seconds / 60 % 60);\\n    var h = Math.floor(seconds / 3600);\\n    var gm = Math.floor(guide / 60 % 60);\\n    var gh = Math.floor(guide / 3600);\\n\\n    // handle invalid times\\n    if (isNaN(seconds) || seconds === Infinity) {\\n      // '-' is false for all relational operators (e.g. <, >=) so this setting\\n      // will add the minimum number of fields specified by the guide\\n      h = m = s = '-';\\n    }\\n\\n    // Check if we need to show hours\\n    h = h > 0 || gh > 0 ? h + ':' : '';\\n\\n    // If hours are showing, we may need to add a leading zero.\\n    // Always show at least one digit of minutes.\\n    m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':';\\n\\n    // Check if leading zero is need for seconds\\n    s = s < 10 ? '0' + s : s;\\n\\n    return h + m + s;\\n  })();\\n}\\n\\nexports['default'] = formatTime;\\nmodule.exports = exports['default'];\\n\\n},{}],146:[function(_dereq_,module,exports){\\n/**\\n * @file guid.js\\n *\\n * Unique ID for an element or function\\n * @type {Number}\\n * @private\\n */\\n\\\"use strict\\\";\\n\\nexports.__esModule = true;\\nexports.newGUID = newGUID;\\nvar _guid = 1;\\n\\n/**\\n * Get the next unique ID\\n *\\n * @return {String} \\n * @function newGUID\\n */\\n\\nfunction newGUID() {\\n  return _guid++;\\n}\\n\\n},{}],147:[function(_dereq_,module,exports){\\n/**\\n * @file log.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _browser = _dereq_('./browser');\\n\\n/**\\n * Log messages to the console and history based on the type of message\\n *\\n * @param  {String} type\\n *         The name of the console method to use.\\n * @param  {Array} args\\n *         The arguments to be passed to the matching console method.\\n * @param  {Boolean} [stringify]\\n *         By default, only old IEs should get console argument stringification,\\n *         but this is exposed as a parameter to facilitate testing.\\n */\\nvar logByType = function logByType(type, args) {\\n  var stringify = arguments.length <= 2 || arguments[2] === undefined ? !!_browser.IE_VERSION && _browser.IE_VERSION < 11 : arguments[2];\\n\\n  var console = _globalWindow2['default'].console;\\n\\n  // If there's no console then don't try to output messages, but they will\\n  // still be stored in `log.history`.\\n  //\\n  // Was setting these once outside of this function, but containing them\\n  // in the function makes it easier to test cases where console doesn't exist\\n  // when the module is executed.\\n  var fn = console && console[type] || function () {};\\n\\n  if (type !== 'log') {\\n\\n    // add the type to the front of the message when it's not \\\"log\\\"\\n    args.unshift(type.toUpperCase() + ':');\\n  }\\n\\n  // add to history\\n  log.history.push(args);\\n\\n  // add console prefix after adding to history\\n  args.unshift('VIDEOJS:');\\n\\n  // IEs previous to 11 log objects uselessly as \\\"[object Object]\\\"; so, JSONify\\n  // objects and arrays for those less-capable browsers.\\n  if (stringify) {\\n    args = args.map(function (a) {\\n      if (a && typeof a === 'object' || Array.isArray(a)) {\\n        try {\\n          return JSON.stringify(a);\\n        } catch (x) {}\\n      }\\n\\n      // Cast to string before joining, so we get null and undefined explicitly\\n      // included in output (as we would in a modern console).\\n      return String(a);\\n    }).join(' ');\\n  }\\n\\n  // Old IE versions do not allow .apply() for console methods (they are\\n  // reported as objects rather than functions).\\n  if (!fn.apply) {\\n    fn(args);\\n  } else {\\n    fn[Array.isArray(args) ? 'apply' : 'call'](console, args);\\n  }\\n};\\n\\nexports.logByType = logByType;\\n/**\\n * Log plain debug messages\\n *\\n * @function log\\n */\\nfunction log() {\\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\\n    args[_key] = arguments[_key];\\n  }\\n\\n  logByType('log', args);\\n}\\n\\n/**\\n * Keep a history of log messages\\n *\\n * @type {Array}\\n */\\nlog.history = [];\\n\\n/**\\n * Log error messages\\n *\\n * @method error\\n */\\nlog.error = function () {\\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\\n    args[_key2] = arguments[_key2];\\n  }\\n\\n  return logByType('error', args);\\n};\\n\\n/**\\n * Log warning messages\\n *\\n * @method warn\\n */\\nlog.warn = function () {\\n  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\\n    args[_key3] = arguments[_key3];\\n  }\\n\\n  return logByType('warn', args);\\n};\\n\\nexports['default'] = log;\\n\\n},{\\\"./browser\\\":140,\\\"global/window\\\":2}],148:[function(_dereq_,module,exports){\\n/**\\n * @file merge-options.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\nexports['default'] = mergeOptions;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _lodashCompatObjectMerge = _dereq_('lodash-compat/object/merge');\\n\\nvar _lodashCompatObjectMerge2 = _interopRequireDefault(_lodashCompatObjectMerge);\\n\\nfunction isPlain(obj) {\\n  return !!obj && typeof obj === 'object' && obj.toString() === '[object Object]' && obj.constructor === Object;\\n}\\n\\n/**\\n * Merge customizer. video.js simply overwrites non-simple objects\\n * (like arrays) instead of attempting to overlay them.\\n * @see https://lodash.com/docs#merge\\n */\\nvar customizer = function customizer(destination, source) {\\n  // If we're not working with a plain object, copy the value as is\\n  // If source is an array, for instance, it will replace destination\\n  if (!isPlain(source)) {\\n    return source;\\n  }\\n\\n  // If the new value is a plain object but the first object value is not\\n  // we need to create a new object for the first object to merge with.\\n  // This makes it consistent with how merge() works by default\\n  // and also protects from later changes the to first object affecting\\n  // the second object's values.\\n  if (!isPlain(destination)) {\\n    return mergeOptions(source);\\n  }\\n};\\n\\n/**\\n * Merge one or more options objects, recursively merging **only**\\n * plain object properties.  Previously `deepMerge`.\\n *\\n * @param  {...Object} source One or more objects to merge\\n * @returns {Object}          a new object that is the union of all\\n * provided objects\\n * @function mergeOptions\\n */\\n\\nfunction mergeOptions() {\\n  // contruct the call dynamically to handle the variable number of\\n  // objects to merge\\n  var args = Array.prototype.slice.call(arguments);\\n\\n  // unshift an empty object into the front of the call as the target\\n  // of the merge\\n  args.unshift({});\\n\\n  // customize conflict resolution to match our historical merge behavior\\n  args.push(customizer);\\n\\n  _lodashCompatObjectMerge2['default'].apply(null, args);\\n\\n  // return the mutated result object\\n  return args[0];\\n}\\n\\nmodule.exports = exports['default'];\\n\\n},{\\\"lodash-compat/object/merge\\\":40}],149:[function(_dereq_,module,exports){\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar createStyleElement = function createStyleElement(className) {\\n  var style = _globalDocument2['default'].createElement('style');\\n  style.className = className;\\n\\n  return style;\\n};\\n\\nexports.createStyleElement = createStyleElement;\\nvar setTextContent = function setTextContent(el, content) {\\n  if (el.styleSheet) {\\n    el.styleSheet.cssText = content;\\n  } else {\\n    el.textContent = content;\\n  }\\n};\\nexports.setTextContent = setTextContent;\\n\\n},{\\\"global/document\\\":1}],150:[function(_dereq_,module,exports){\\n'use strict';\\n\\nexports.__esModule = true;\\nexports.createTimeRanges = createTimeRanges;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _logJs = _dereq_('./log.js');\\n\\nvar _logJs2 = _interopRequireDefault(_logJs);\\n\\n/**\\n * @file time-ranges.js\\n *\\n * Should create a fake TimeRange object\\n * Mimics an HTML5 time range instance, which has functions that\\n * return the start and end times for a range\\n * TimeRanges are returned by the buffered() method\\n *\\n * @param  {(Number|Array)} Start of a single range or an array of ranges\\n * @param  {Number} End of a single range\\n * @private\\n * @method createTimeRanges\\n */\\n\\nfunction createTimeRanges(start, end) {\\n  if (Array.isArray(start)) {\\n    return createTimeRangesObj(start);\\n  } else if (start === undefined || end === undefined) {\\n    return createTimeRangesObj();\\n  }\\n  return createTimeRangesObj([[start, end]]);\\n}\\n\\nexports.createTimeRange = createTimeRanges;\\n\\nfunction createTimeRangesObj(ranges) {\\n  if (ranges === undefined || ranges.length === 0) {\\n    return {\\n      length: 0,\\n      start: function start() {\\n        throw new Error('This TimeRanges object is empty');\\n      },\\n      end: function end() {\\n        throw new Error('This TimeRanges object is empty');\\n      }\\n    };\\n  }\\n  return {\\n    length: ranges.length,\\n    start: getRange.bind(null, 'start', 0, ranges),\\n    end: getRange.bind(null, 'end', 1, ranges)\\n  };\\n}\\n\\nfunction getRange(fnName, valueIndex, ranges, rangeIndex) {\\n  if (rangeIndex === undefined) {\\n    _logJs2['default'].warn('DEPRECATED: Function \\\\'' + fnName + '\\\\' on \\\\'TimeRanges\\\\' called without an index argument.');\\n    rangeIndex = 0;\\n  }\\n  rangeCheck(fnName, rangeIndex, ranges.length - 1);\\n  return ranges[rangeIndex][valueIndex];\\n}\\n\\nfunction rangeCheck(fnName, index, maxIndex) {\\n  if (index < 0 || index > maxIndex) {\\n    throw new Error('Failed to execute \\\\'' + fnName + '\\\\' on \\\\'TimeRanges\\\\': The index provided (' + index + ') is greater than or equal to the maximum bound (' + maxIndex + ').');\\n  }\\n}\\n\\n},{\\\"./log.js\\\":147}],151:[function(_dereq_,module,exports){\\n/**\\n * @file to-title-case.js\\n *\\n * Uppercase the first letter of a string\\n *\\n * @param  {String} string String to be uppercased\\n * @return {String}\\n * @private\\n * @method toTitleCase\\n */\\n\\\"use strict\\\";\\n\\nexports.__esModule = true;\\nfunction toTitleCase(string) {\\n  return string.charAt(0).toUpperCase() + string.slice(1);\\n}\\n\\nexports[\\\"default\\\"] = toTitleCase;\\nmodule.exports = exports[\\\"default\\\"];\\n\\n},{}],152:[function(_dereq_,module,exports){\\n/**\\n * @file url.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\n/**\\n * Resolve and parse the elements of a URL\\n *\\n * @param  {String} url The url to parse\\n * @return {Object}     An object of url details\\n * @method parseUrl\\n */\\nvar parseUrl = function parseUrl(url) {\\n  var props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];\\n\\n  // add the url to an anchor and let the browser parse the URL\\n  var a = _globalDocument2['default'].createElement('a');\\n  a.href = url;\\n\\n  // IE8 (and 9?) Fix\\n  // ie8 doesn't parse the URL correctly until the anchor is actually\\n  // added to the body, and an innerHTML is needed to trigger the parsing\\n  var addToBody = a.host === '' && a.protocol !== 'file:';\\n  var div = undefined;\\n  if (addToBody) {\\n    div = _globalDocument2['default'].createElement('div');\\n    div.innerHTML = '<a href=\\\"' + url + '\\\"></a>';\\n    a = div.firstChild;\\n    // prevent the div from affecting layout\\n    div.setAttribute('style', 'display:none; position:absolute;');\\n    _globalDocument2['default'].body.appendChild(div);\\n  }\\n\\n  // Copy the specific URL properties to a new object\\n  // This is also needed for IE8 because the anchor loses its\\n  // properties when it's removed from the dom\\n  var details = {};\\n  for (var i = 0; i < props.length; i++) {\\n    details[props[i]] = a[props[i]];\\n  }\\n\\n  // IE9 adds the port to the host property unlike everyone else. If\\n  // a port identifier is added for standard ports, strip it.\\n  if (details.protocol === 'http:') {\\n    details.host = details.host.replace(/:80$/, '');\\n  }\\n  if (details.protocol === 'https:') {\\n    details.host = details.host.replace(/:443$/, '');\\n  }\\n\\n  if (addToBody) {\\n    _globalDocument2['default'].body.removeChild(div);\\n  }\\n\\n  return details;\\n};\\n\\nexports.parseUrl = parseUrl;\\n/**\\n * Get absolute version of relative URL. Used to tell flash correct URL.\\n * http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue\\n *\\n * @param  {String} url URL to make absolute\\n * @return {String}     Absolute URL\\n * @private\\n * @method getAbsoluteURL\\n */\\nvar getAbsoluteURL = function getAbsoluteURL(url) {\\n  // Check if absolute URL\\n  if (!url.match(/^https?:\\\\/\\\\//)) {\\n    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.\\n    var div = _globalDocument2['default'].createElement('div');\\n    div.innerHTML = '<a href=\\\"' + url + '\\\">x</a>';\\n    url = div.firstChild.href;\\n  }\\n\\n  return url;\\n};\\n\\nexports.getAbsoluteURL = getAbsoluteURL;\\n/**\\n * Returns the extension of the passed file name. It will return an empty string if you pass an invalid path\\n *\\n * @param {String}    path    The fileName path like '/path/to/file.mp4'\\n * @returns {String}          The extension in lower case or an empty string if no extension could be found.\\n * @method getFileExtension\\n */\\nvar getFileExtension = function getFileExtension(path) {\\n  if (typeof path === 'string') {\\n    var splitPathRe = /^(\\\\/?)([\\\\s\\\\S]*?)((?:\\\\.{1,2}|[^\\\\/]+?)(\\\\.([^\\\\.\\\\/\\\\?]+)))(?:[\\\\/]*|[\\\\?].*)$/i;\\n    var pathParts = splitPathRe.exec(path);\\n\\n    if (pathParts) {\\n      return pathParts.pop().toLowerCase();\\n    }\\n  }\\n\\n  return '';\\n};\\n\\nexports.getFileExtension = getFileExtension;\\n/**\\n * Returns whether the url passed is a cross domain request or not.\\n *\\n * @param {String} url The url to check\\n * @return {Boolean}   Whether it is a cross domain request or not\\n * @method isCrossOrigin\\n */\\nvar isCrossOrigin = function isCrossOrigin(url) {\\n  var winLoc = _globalWindow2['default'].location;\\n  var urlInfo = parseUrl(url);\\n\\n  // IE8 protocol relative urls will return ':' for protocol\\n  var srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;\\n\\n  // Check if url is for another domain/origin\\n  // IE8 doesn't know location.origin, so we won't rely on it here\\n  var crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;\\n\\n  return crossOrigin;\\n};\\nexports.isCrossOrigin = isCrossOrigin;\\n\\n},{\\\"global/document\\\":1,\\\"global/window\\\":2}],153:[function(_dereq_,module,exports){\\n/**\\n * @file video.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _setup = _dereq_('./setup');\\n\\nvar setup = _interopRequireWildcard(_setup);\\n\\nvar _utilsStylesheetJs = _dereq_('./utils/stylesheet.js');\\n\\nvar stylesheet = _interopRequireWildcard(_utilsStylesheetJs);\\n\\nvar _component = _dereq_('./component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _eventTarget = _dereq_('./event-target');\\n\\nvar _eventTarget2 = _interopRequireDefault(_eventTarget);\\n\\nvar _utilsEventsJs = _dereq_('./utils/events.js');\\n\\nvar Events = _interopRequireWildcard(_utilsEventsJs);\\n\\nvar _player = _dereq_('./player');\\n\\nvar _player2 = _interopRequireDefault(_player);\\n\\nvar _pluginsJs = _dereq_('./plugins.js');\\n\\nvar _pluginsJs2 = _interopRequireDefault(_pluginsJs);\\n\\nvar _srcJsUtilsMergeOptionsJs = _dereq_('../../src/js/utils/merge-options.js');\\n\\nvar _srcJsUtilsMergeOptionsJs2 = _interopRequireDefault(_srcJsUtilsMergeOptionsJs);\\n\\nvar _utilsFnJs = _dereq_('./utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _tracksTextTrackJs = _dereq_('./tracks/text-track.js');\\n\\nvar _tracksTextTrackJs2 = _interopRequireDefault(_tracksTextTrackJs);\\n\\nvar _tracksAudioTrackJs = _dereq_('./tracks/audio-track.js');\\n\\nvar _tracksAudioTrackJs2 = _interopRequireDefault(_tracksAudioTrackJs);\\n\\nvar _tracksVideoTrackJs = _dereq_('./tracks/video-track.js');\\n\\nvar _tracksVideoTrackJs2 = _interopRequireDefault(_tracksVideoTrackJs);\\n\\nvar _utilsTimeRangesJs = _dereq_('./utils/time-ranges.js');\\n\\nvar _utilsFormatTimeJs = _dereq_('./utils/format-time.js');\\n\\nvar _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);\\n\\nvar _utilsLogJs = _dereq_('./utils/log.js');\\n\\nvar _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);\\n\\nvar _utilsDomJs = _dereq_('./utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsBrowserJs = _dereq_('./utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\nvar _utilsUrlJs = _dereq_('./utils/url.js');\\n\\nvar Url = _interopRequireWildcard(_utilsUrlJs);\\n\\nvar _extendJs = _dereq_('./extend.js');\\n\\nvar _extendJs2 = _interopRequireDefault(_extendJs);\\n\\nvar _lodashCompatObjectMerge = _dereq_('lodash-compat/object/merge');\\n\\nvar _lodashCompatObjectMerge2 = _interopRequireDefault(_lodashCompatObjectMerge);\\n\\nvar _xhr = _dereq_('xhr');\\n\\nvar _xhr2 = _interopRequireDefault(_xhr);\\n\\n// Include the built-in techs\\n\\nvar _techTechJs = _dereq_('./tech/tech.js');\\n\\nvar _techTechJs2 = _interopRequireDefault(_techTechJs);\\n\\nvar _techHtml5Js = _dereq_('./tech/html5.js');\\n\\nvar _techHtml5Js2 = _interopRequireDefault(_techHtml5Js);\\n\\nvar _techFlashJs = _dereq_('./tech/flash.js');\\n\\nvar _techFlashJs2 = _interopRequireDefault(_techFlashJs);\\n\\n// HTML5 Element Shim for IE8\\nif (typeof HTMLVideoElement === 'undefined') {\\n  _globalDocument2['default'].createElement('video');\\n  _globalDocument2['default'].createElement('audio');\\n  _globalDocument2['default'].createElement('track');\\n}\\n\\n/**\\n * Doubles as the main function for users to create a player instance and also\\n * the main library object.\\n * The `videojs` function can be used to initialize or retrieve a player.\\n * ```js\\n *     var myPlayer = videojs('my_video_id');\\n * ```\\n *\\n * @param  {String|Element} id      Video element or video element ID\\n * @param  {Object=} options        Optional options object for config/settings\\n * @param  {Function=} ready        Optional ready callback\\n * @return {Player}                 A player instance\\n * @mixes videojs\\n * @method videojs\\n */\\nfunction videojs(id, options, ready) {\\n  var tag = undefined; // Element of ID\\n\\n  // Allow for element or ID to be passed in\\n  // String ID\\n  if (typeof id === 'string') {\\n\\n    // Adjust for jQuery ID syntax\\n    if (id.indexOf('#') === 0) {\\n      id = id.slice(1);\\n    }\\n\\n    // If a player instance has already been created for this ID return it.\\n    if (videojs.getPlayers()[id]) {\\n\\n      // If options or ready funtion are passed, warn\\n      if (options) {\\n        _utilsLogJs2['default'].warn('Player \\\"' + id + '\\\" is already initialised. Options will not be applied.');\\n      }\\n\\n      if (ready) {\\n        videojs.getPlayers()[id].ready(ready);\\n      }\\n\\n      return videojs.getPlayers()[id];\\n\\n      // Otherwise get element for ID\\n    } else {\\n        tag = Dom.getEl(id);\\n      }\\n\\n    // ID is a media element\\n  } else {\\n      tag = id;\\n    }\\n\\n  // Check for a useable element\\n  if (!tag || !tag.nodeName) {\\n    // re: nodeName, could be a box div also\\n    throw new TypeError('The element or ID supplied is not valid. (videojs)'); // Returns\\n  }\\n\\n  // Element may have a player attr referring to an already created player instance.\\n  // If not, set up a new player and return the instance.\\n  return tag['player'] || _player2['default'].players[tag.playerId] || new _player2['default'](tag, options, ready);\\n}\\n\\n// Add default styles\\nif (_globalWindow2['default'].VIDEOJS_NO_DYNAMIC_STYLE !== true) {\\n  var style = Dom.$('.vjs-styles-defaults');\\n\\n  if (!style) {\\n    style = stylesheet.createStyleElement('vjs-styles-defaults');\\n    var head = Dom.$('head');\\n    head.insertBefore(style, head.firstChild);\\n    stylesheet.setTextContent(style, '\\\\n      .video-js {\\\\n        width: 300px;\\\\n        height: 150px;\\\\n      }\\\\n\\\\n      .vjs-fluid {\\\\n        padding-top: 56.25%\\\\n      }\\\\n    ');\\n  }\\n}\\n\\n// Run Auto-load players\\n// You have to wait at least once in case this script is loaded after your video in the DOM (weird behavior only with minified version)\\nsetup.autoSetupTimeout(1, videojs);\\n\\n/*\\n * Current software version (semver)\\n *\\n * @type {String}\\n */\\nvideojs.VERSION = '5.11.6';\\n\\n/**\\n * The global options object. These are the settings that take effect\\n * if no overrides are specified when the player is created.\\n *\\n * ```js\\n *     videojs.options.autoplay = true\\n *     // -> all players will autoplay by default\\n * ```\\n *\\n * @type {Object}\\n */\\nvideojs.options = _player2['default'].prototype.options_;\\n\\n/**\\n * Get an object with the currently created players, keyed by player ID\\n *\\n * @return {Object} The created players\\n * @mixes videojs\\n * @method getPlayers\\n */\\nvideojs.getPlayers = function () {\\n  return _player2['default'].players;\\n};\\n\\n/**\\n * Expose players object.\\n *\\n * @memberOf videojs\\n * @property {Object} players\\n */\\nvideojs.players = _player2['default'].players;\\n\\n/**\\n * Get a component class object by name\\n * ```js\\n *     var VjsButton = videojs.getComponent('Button');\\n *     // Create a new instance of the component\\n *     var myButton = new VjsButton(myPlayer);\\n * ```\\n *\\n * @return {Component} Component identified by name\\n * @mixes videojs\\n * @method getComponent\\n */\\nvideojs.getComponent = _component2['default'].getComponent;\\n\\n/**\\n * Register a component so it can referred to by name\\n * Used when adding to other\\n * components, either through addChild\\n * `component.addChild('myComponent')`\\n * or through default children options\\n * `{ children: ['myComponent'] }`.\\n * ```js\\n *     // Get a component to subclass\\n *     var VjsButton = videojs.getComponent('Button');\\n *     // Subclass the component (see 'extend' doc for more info)\\n *     var MySpecialButton = videojs.extend(VjsButton, {});\\n *     // Register the new component\\n *     VjsButton.registerComponent('MySepcialButton', MySepcialButton);\\n *     // (optionally) add the new component as a default player child\\n *     myPlayer.addChild('MySepcialButton');\\n * ```\\n * NOTE: You could also just initialize the component before adding.\\n * `component.addChild(new MyComponent());`\\n *\\n * @param {String} The class name of the component\\n * @param {Component} The component class\\n * @return {Component} The newly registered component\\n * @mixes videojs\\n * @method registerComponent\\n */\\nvideojs.registerComponent = function (name, comp) {\\n  if (_techTechJs2['default'].isTech(comp)) {\\n    _utilsLogJs2['default'].warn('The ' + name + ' tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)');\\n  }\\n\\n  _component2['default'].registerComponent.call(_component2['default'], name, comp);\\n};\\n\\n/**\\n * Get a Tech class object by name\\n * ```js\\n *     var Html5 = videojs.getTech('Html5');\\n *     // Create a new instance of the component\\n *     var html5 = new Html5(options);\\n * ```\\n *\\n * @return {Tech} Tech identified by name\\n * @mixes videojs\\n * @method getComponent\\n */\\nvideojs.getTech = _techTechJs2['default'].getTech;\\n\\n/**\\n * Register a Tech so it can referred to by name.\\n * This is used in the tech order for the player.\\n *\\n * ```js\\n *     // get the Html5 Tech\\n *     var Html5 = videojs.getTech('Html5');\\n *     var MyTech = videojs.extend(Html5, {});\\n *     // Register the new Tech\\n *     VjsButton.registerTech('Tech', MyTech);\\n *     var player = videojs('myplayer', {\\n *       techOrder: ['myTech', 'html5']\\n *     });\\n * ```\\n *\\n * @param {String} The class name of the tech\\n * @param {Tech} The tech class\\n * @return {Tech} The newly registered Tech\\n * @mixes videojs\\n * @method registerTech\\n */\\nvideojs.registerTech = _techTechJs2['default'].registerTech;\\n\\n/**\\n * A suite of browser and device tests\\n *\\n * @type {Object}\\n * @private\\n */\\nvideojs.browser = browser;\\n\\n/**\\n * Whether or not the browser supports touch events. Included for backward\\n * compatibility with 4.x, but deprecated. Use `videojs.browser.TOUCH_ENABLED`\\n * instead going forward.\\n *\\n * @deprecated\\n * @type {Boolean}\\n */\\nvideojs.TOUCH_ENABLED = browser.TOUCH_ENABLED;\\n\\n/**\\n * Subclass an existing class\\n * Mimics ES6 subclassing with the `extend` keyword\\n * ```js\\n *     // Create a basic javascript 'class'\\n *     function MyClass(name){\\n *       // Set a property at initialization\\n *       this.myName = name;\\n *     }\\n *     // Create an instance method\\n *     MyClass.prototype.sayMyName = function(){\\n *       alert(this.myName);\\n *     };\\n *     // Subclass the exisitng class and change the name\\n *     // when initializing\\n *     var MySubClass = videojs.extend(MyClass, {\\n *       constructor: function(name) {\\n *         // Call the super class constructor for the subclass\\n *         MyClass.call(this, name)\\n *       }\\n *     });\\n *     // Create an instance of the new sub class\\n *     var myInstance = new MySubClass('John');\\n *     myInstance.sayMyName(); // -> should alert \\\"John\\\"\\n * ```\\n *\\n * @param {Function} The Class to subclass\\n * @param {Object} An object including instace methods for the new class\\n *                   Optionally including a `constructor` function\\n * @return {Function} The newly created subclass\\n * @mixes videojs\\n * @method extend\\n */\\nvideojs.extend = _extendJs2['default'];\\n\\n/**\\n * Merge two options objects recursively\\n * Performs a deep merge like lodash.merge but **only merges plain objects**\\n * (not arrays, elements, anything else)\\n * Other values will be copied directly from the second object.\\n * ```js\\n *     var defaultOptions = {\\n *       foo: true,\\n *       bar: {\\n *         a: true,\\n *         b: [1,2,3]\\n *       }\\n *     };\\n *     var newOptions = {\\n *       foo: false,\\n *       bar: {\\n *         b: [4,5,6]\\n *       }\\n *     };\\n *     var result = videojs.mergeOptions(defaultOptions, newOptions);\\n *     // result.foo = false;\\n *     // result.bar.a = true;\\n *     // result.bar.b = [4,5,6];\\n * ```\\n *\\n * @param {Object} defaults  The options object whose values will be overriden\\n * @param {Object} overrides The options object with values to override the first\\n * @param {Object} etc       Any number of additional options objects\\n *\\n * @return {Object} a new object with the merged values\\n * @mixes videojs\\n * @method mergeOptions\\n */\\nvideojs.mergeOptions = _srcJsUtilsMergeOptionsJs2['default'];\\n\\n/**\\n * Change the context (this) of a function\\n *\\n *     videojs.bind(newContext, function(){\\n *       this === newContext\\n *     });\\n *\\n * NOTE: as of v5.0 we require an ES5 shim, so you should use the native\\n * `function(){}.bind(newContext);` instead of this.\\n *\\n * @param  {*}        context The object to bind as scope\\n * @param  {Function} fn      The function to be bound to a scope\\n * @param  {Number=}  uid     An optional unique ID for the function to be set\\n * @return {Function}\\n */\\nvideojs.bind = Fn.bind;\\n\\n/**\\n * Create a Video.js player plugin\\n * Plugins are only initialized when options for the plugin are included\\n * in the player options, or the plugin function on the player instance is\\n * called.\\n * **See the plugin guide in the docs for a more detailed example**\\n * ```js\\n *     // Make a plugin that alerts when the player plays\\n *     videojs.plugin('myPlugin', function(myPluginOptions) {\\n *       myPluginOptions = myPluginOptions || {};\\n *\\n *       var player = this;\\n *       var alertText = myPluginOptions.text || 'Player is playing!'\\n *\\n *       player.on('play', function(){\\n *         alert(alertText);\\n *       });\\n *     });\\n *     // USAGE EXAMPLES\\n *     // EXAMPLE 1: New player with plugin options, call plugin immediately\\n *     var player1 = videojs('idOne', {\\n *       myPlugin: {\\n *         text: 'Custom text!'\\n *       }\\n *     });\\n *     // Click play\\n *     // --> Should alert 'Custom text!'\\n *     // EXAMPLE 3: New player, initialize plugin later\\n *     var player3 = videojs('idThree');\\n *     // Click play\\n *     // --> NO ALERT\\n *     // Click pause\\n *     // Initialize plugin using the plugin function on the player instance\\n *     player3.myPlugin({\\n *       text: 'Plugin added later!'\\n *     });\\n *     // Click play\\n *     // --> Should alert 'Plugin added later!'\\n * ```\\n *\\n * @param {String} name The plugin name\\n * @param {Function} fn The plugin function that will be called with options\\n * @mixes videojs\\n * @method plugin\\n */\\nvideojs.plugin = _pluginsJs2['default'];\\n\\n/**\\n * Adding languages so that they're available to all players.\\n * ```js\\n *     videojs.addLanguage('es', { 'Hello': 'Hola' });\\n * ```\\n *\\n * @param  {String} code The language code or dictionary property\\n * @param  {Object} data The data values to be translated\\n * @return {Object} The resulting language dictionary object\\n * @mixes videojs\\n * @method addLanguage\\n */\\nvideojs.addLanguage = function (code, data) {\\n  var _merge;\\n\\n  code = ('' + code).toLowerCase();\\n  return _lodashCompatObjectMerge2['default'](videojs.options.languages, (_merge = {}, _merge[code] = data, _merge))[code];\\n};\\n\\n/**\\n * Log debug messages.\\n *\\n * @param {...Object} messages One or more messages to log\\n */\\nvideojs.log = _utilsLogJs2['default'];\\n\\n/**\\n * Creates an emulated TimeRange object.\\n *\\n * @param  {Number|Array} start Start time in seconds or an array of ranges\\n * @param  {Number} end   End time in seconds\\n * @return {Object}       Fake TimeRange object\\n * @method createTimeRange\\n */\\nvideojs.createTimeRange = videojs.createTimeRanges = _utilsTimeRangesJs.createTimeRanges;\\n\\n/**\\n * Format seconds as a time string, H:MM:SS or M:SS\\n * Supplying a guide (in seconds) will force a number of leading zeros\\n * to cover the length of the guide\\n *\\n * @param  {Number} seconds Number of seconds to be turned into a string\\n * @param  {Number} guide   Number (in seconds) to model the string after\\n * @return {String}         Time formatted as H:MM:SS or M:SS\\n * @method formatTime\\n */\\nvideojs.formatTime = _utilsFormatTimeJs2['default'];\\n\\n/**\\n * Resolve and parse the elements of a URL\\n *\\n * @param  {String} url The url to parse\\n * @return {Object}     An object of url details\\n * @method parseUrl\\n */\\nvideojs.parseUrl = Url.parseUrl;\\n\\n/**\\n * Returns whether the url passed is a cross domain request or not.\\n *\\n * @param {String} url The url to check\\n * @return {Boolean}   Whether it is a cross domain request or not\\n * @method isCrossOrigin\\n */\\nvideojs.isCrossOrigin = Url.isCrossOrigin;\\n\\n/**\\n * Event target class.\\n *\\n * @type {Function}\\n */\\nvideojs.EventTarget = _eventTarget2['default'];\\n\\n/**\\n * Add an event listener to element\\n * It stores the handler function in a separate cache object\\n * and adds a generic handler to the element's event,\\n * along with a unique id (guid) to the element.\\n *\\n * @param  {Element|Object}   elem Element or object to bind listeners to\\n * @param  {String|Array}   type Type of event to bind to.\\n * @param  {Function} fn   Event listener.\\n * @method on\\n */\\nvideojs.on = Events.on;\\n\\n/**\\n * Trigger a listener only once for an event\\n *\\n * @param  {Element|Object}   elem Element or object to\\n * @param  {String|Array}   type Name/type of event\\n * @param  {Function} fn Event handler function\\n * @method one\\n */\\nvideojs.one = Events.one;\\n\\n/**\\n * Removes event listeners from an element\\n *\\n * @param  {Element|Object}   elem Object to remove listeners from\\n * @param  {String|Array=}   type Type of listener to remove. Don't include to remove all events from element.\\n * @param  {Function} fn   Specific listener to remove. Don't include to remove listeners for an event type.\\n * @method off\\n */\\nvideojs.off = Events.off;\\n\\n/**\\n * Trigger an event for an element\\n *\\n * @param  {Element|Object}      elem  Element to trigger an event on\\n * @param  {Event|Object|String} event A string (the type) or an event object with a type attribute\\n * @param  {Object} [hash] data hash to pass along with the event\\n * @return {Boolean=} Returned only if default was prevented\\n * @method trigger\\n */\\nvideojs.trigger = Events.trigger;\\n\\n/**\\n * A cross-browser XMLHttpRequest wrapper. Here's a simple example:\\n *\\n *     videojs.xhr({\\n *       body: someJSONString,\\n *       uri: \\\"/foo\\\",\\n *       headers: {\\n *         \\\"Content-Type\\\": \\\"application/json\\\"\\n *       }\\n *     }, function (err, resp, body) {\\n *       // check resp.statusCode\\n *     });\\n *\\n * Check out the [full\\n * documentation](https://github.com/Raynos/xhr/blob/v2.1.0/README.md)\\n * for more options.\\n *\\n * @param {Object} options settings for the request.\\n * @return {XMLHttpRequest|XDomainRequest} the request object.\\n * @see https://github.com/Raynos/xhr\\n */\\nvideojs.xhr = _xhr2['default'];\\n\\n/**\\n * TextTrack class\\n *\\n * @type {Function}\\n */\\nvideojs.TextTrack = _tracksTextTrackJs2['default'];\\n\\n/**\\n * export the AudioTrack class so that source handlers can create\\n * AudioTracks and then add them to the players AudioTrackList\\n *\\n * @type {Function}\\n */\\nvideojs.AudioTrack = _tracksAudioTrackJs2['default'];\\n\\n/**\\n * export the VideoTrack class so that source handlers can create\\n * VideoTracks and then add them to the players VideoTrackList\\n *\\n * @type {Function}\\n */\\nvideojs.VideoTrack = _tracksVideoTrackJs2['default'];\\n\\n/**\\n * Determines, via duck typing, whether or not a value is a DOM element.\\n *\\n * @method isEl\\n * @param  {Mixed} value\\n * @return {Boolean}\\n */\\nvideojs.isEl = Dom.isEl;\\n\\n/**\\n * Determines, via duck typing, whether or not a value is a text node.\\n *\\n * @method isTextNode\\n * @param  {Mixed} value\\n * @return {Boolean}\\n */\\nvideojs.isTextNode = Dom.isTextNode;\\n\\n/**\\n * Creates an element and applies properties.\\n *\\n * @method createEl\\n * @param  {String} [tagName='div'] Name of tag to be created.\\n * @param  {Object} [properties={}] Element properties to be applied.\\n * @param  {Object} [attributes={}] Element attributes to be applied.\\n * @return {Element}\\n */\\nvideojs.createEl = Dom.createEl;\\n\\n/**\\n * Check if an element has a CSS class\\n *\\n * @method hasClass\\n * @param {Element} element Element to check\\n * @param {String} classToCheck Classname to check\\n */\\nvideojs.hasClass = Dom.hasElClass;\\n\\n/**\\n * Add a CSS class name to an element\\n *\\n * @method addClass\\n * @param {Element} element    Element to add class name to\\n * @param {String} classToAdd Classname to add\\n */\\nvideojs.addClass = Dom.addElClass;\\n\\n/**\\n * Remove a CSS class name from an element\\n *\\n * @method removeClass\\n * @param {Element} element    Element to remove from class name\\n * @param {String} classToRemove Classname to remove\\n */\\nvideojs.removeClass = Dom.removeElClass;\\n\\n/**\\n * Adds or removes a CSS class name on an element depending on an optional\\n * condition or the presence/absence of the class name.\\n *\\n * @method toggleElClass\\n * @param  {Element} element\\n * @param  {String} classToToggle\\n * @param  {Boolean|Function} [predicate]\\n *         Can be a function that returns a Boolean. If `true`, the class\\n *         will be added; if `false`, the class will be removed. If not\\n *         given, the class will be added if not present and vice versa.\\n */\\nvideojs.toggleClass = Dom.toggleElClass;\\n\\n/**\\n * Apply attributes to an HTML element.\\n *\\n * @method setAttributes\\n * @param  {Element} el         Target element.\\n * @param  {Object=} attributes Element attributes to be applied.\\n */\\nvideojs.setAttributes = Dom.setElAttributes;\\n\\n/**\\n * Get an element's attribute values, as defined on the HTML tag\\n * Attributes are not the same as properties. They're defined on the tag\\n * or with setAttribute (which shouldn't be used with HTML)\\n * This will return true or false for boolean attributes.\\n *\\n * @method getAttributes\\n * @param  {Element} tag Element from which to get tag attributes\\n * @return {Object}\\n */\\nvideojs.getAttributes = Dom.getElAttributes;\\n\\n/**\\n * Empties the contents of an element.\\n *\\n * @method emptyEl\\n * @param  {Element} el\\n * @return {Element}\\n */\\nvideojs.emptyEl = Dom.emptyEl;\\n\\n/**\\n * Normalizes and appends content to an element.\\n *\\n * The content for an element can be passed in multiple types and\\n * combinations, whose behavior is as follows:\\n *\\n * - String\\n *   Normalized into a text node.\\n *\\n * - Element, TextNode\\n *   Passed through.\\n *\\n * - Array\\n *   A one-dimensional array of strings, elements, nodes, or functions (which\\n *   return single strings, elements, or nodes).\\n *\\n * - Function\\n *   If the sole argument, is expected to produce a string, element,\\n *   node, or array.\\n *\\n * @method appendContent\\n * @param  {Element} el\\n * @param  {String|Element|TextNode|Array|Function} content\\n * @return {Element}\\n */\\nvideojs.appendContent = Dom.appendContent;\\n\\n/**\\n * Normalizes and inserts content into an element; this is identical to\\n * `appendContent()`, except it empties the element first.\\n *\\n * The content for an element can be passed in multiple types and\\n * combinations, whose behavior is as follows:\\n *\\n * - String\\n *   Normalized into a text node.\\n *\\n * - Element, TextNode\\n *   Passed through.\\n *\\n * - Array\\n *   A one-dimensional array of strings, elements, nodes, or functions (which\\n *   return single strings, elements, or nodes).\\n *\\n * - Function\\n *   If the sole argument, is expected to produce a string, element,\\n *   node, or array.\\n *\\n * @method insertContent\\n * @param  {Element} el\\n * @param  {String|Element|TextNode|Array|Function} content\\n * @return {Element}\\n */\\nvideojs.insertContent = Dom.insertContent;\\n\\n/*\\n * Custom Universal Module Definition (UMD)\\n *\\n * Video.js will never be a non-browser lib so we can simplify UMD a bunch and\\n * still support requirejs and browserify. This also needs to be closure\\n * compiler compatible, so string keys are used.\\n */\\nif (typeof define === 'function' && define['amd']) {\\n  define('videojs', [], function () {\\n    return videojs;\\n  });\\n\\n  // checking that module is an object too because of umdjs/umd#35\\n} else if (typeof exports === 'object' && typeof module === 'object') {\\n    module['exports'] = videojs;\\n  }\\n\\nexports['default'] = videojs;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../src/js/utils/merge-options.js\\\":148,\\\"./component\\\":67,\\\"./event-target\\\":104,\\\"./extend.js\\\":105,\\\"./player\\\":113,\\\"./plugins.js\\\":114,\\\"./setup\\\":118,\\\"./tech/flash.js\\\":121,\\\"./tech/html5.js\\\":122,\\\"./tech/tech.js\\\":124,\\\"./tracks/audio-track.js\\\":126,\\\"./tracks/text-track.js\\\":134,\\\"./tracks/video-track.js\\\":139,\\\"./utils/browser.js\\\":140,\\\"./utils/dom.js\\\":142,\\\"./utils/events.js\\\":143,\\\"./utils/fn.js\\\":144,\\\"./utils/format-time.js\\\":145,\\\"./utils/log.js\\\":147,\\\"./utils/stylesheet.js\\\":149,\\\"./utils/time-ranges.js\\\":150,\\\"./utils/url.js\\\":152,\\\"global/document\\\":1,\\\"global/window\\\":2,\\\"lodash-compat/object/merge\\\":40,\\\"xhr\\\":56}]},{},[153])(153)\\n});\\n\\n\\n//# sourceMappingURL=video.js.map\\n/* vtt.js - v0.12.1 (https://github.com/mozilla/vtt.js) built on 08-07-2015 */\\n\\n(function(root) {\\n  var vttjs = root.vttjs = {};\\n  var cueShim = vttjs.VTTCue;\\n  var regionShim = vttjs.VTTRegion;\\n  var oldVTTCue = root.VTTCue;\\n  var oldVTTRegion = root.VTTRegion;\\n\\n  vttjs.shim = function() {\\n    vttjs.VTTCue = cueShim;\\n    vttjs.VTTRegion = regionShim;\\n  };\\n\\n  vttjs.restore = function() {\\n    vttjs.VTTCue = oldVTTCue;\\n    vttjs.VTTRegion = oldVTTRegion;\\n  };\\n}(this));\\n\\n/**\\n * Copyright 2013 vtt.js Contributors\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *   http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n(function(root, vttjs) {\\n\\n  var autoKeyword = \\\"auto\\\";\\n  var directionSetting = {\\n    \\\"\\\": true,\\n    \\\"lr\\\": true,\\n    \\\"rl\\\": true\\n  };\\n  var alignSetting = {\\n    \\\"start\\\": true,\\n    \\\"middle\\\": true,\\n    \\\"end\\\": true,\\n    \\\"left\\\": true,\\n    \\\"right\\\": true\\n  };\\n\\n  function findDirectionSetting(value) {\\n    if (typeof value !== \\\"string\\\") {\\n      return false;\\n    }\\n    var dir = directionSetting[value.toLowerCase()];\\n    return dir ? value.toLowerCase() : false;\\n  }\\n\\n  function findAlignSetting(value) {\\n    if (typeof value !== \\\"string\\\") {\\n      return false;\\n    }\\n    var align = alignSetting[value.toLowerCase()];\\n    return align ? value.toLowerCase() : false;\\n  }\\n\\n  function extend(obj) {\\n    var i = 1;\\n    for (; i < arguments.length; i++) {\\n      var cobj = arguments[i];\\n      for (var p in cobj) {\\n        obj[p] = cobj[p];\\n      }\\n    }\\n\\n    return obj;\\n  }\\n\\n  function VTTCue(startTime, endTime, text) {\\n    var cue = this;\\n    var isIE8 = (/MSIE\\\\s8\\\\.0/).test(navigator.userAgent);\\n    var baseObj = {};\\n\\n    if (isIE8) {\\n      cue = document.createElement('custom');\\n    } else {\\n      baseObj.enumerable = true;\\n    }\\n\\n    /**\\n     * Shim implementation specific properties. These properties are not in\\n     * the spec.\\n     */\\n\\n    // Lets us know when the VTTCue's data has changed in such a way that we need\\n    // to recompute its display state. This lets us compute its display state\\n    // lazily.\\n    cue.hasBeenReset = false;\\n\\n    /**\\n     * VTTCue and TextTrackCue properties\\n     * http://dev.w3.org/html5/webvtt/#vttcue-interface\\n     */\\n\\n    var _id = \\\"\\\";\\n    var _pauseOnExit = false;\\n    var _startTime = startTime;\\n    var _endTime = endTime;\\n    var _text = text;\\n    var _region = null;\\n    var _vertical = \\\"\\\";\\n    var _snapToLines = true;\\n    var _line = \\\"auto\\\";\\n    var _lineAlign = \\\"start\\\";\\n    var _position = 50;\\n    var _positionAlign = \\\"middle\\\";\\n    var _size = 50;\\n    var _align = \\\"middle\\\";\\n\\n    Object.defineProperty(cue,\\n      \\\"id\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _id;\\n        },\\n        set: function(value) {\\n          _id = \\\"\\\" + value;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"pauseOnExit\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _pauseOnExit;\\n        },\\n        set: function(value) {\\n          _pauseOnExit = !!value;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"startTime\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _startTime;\\n        },\\n        set: function(value) {\\n          if (typeof value !== \\\"number\\\") {\\n            throw new TypeError(\\\"Start time must be set to a number.\\\");\\n          }\\n          _startTime = value;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"endTime\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _endTime;\\n        },\\n        set: function(value) {\\n          if (typeof value !== \\\"number\\\") {\\n            throw new TypeError(\\\"End time must be set to a number.\\\");\\n          }\\n          _endTime = value;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"text\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _text;\\n        },\\n        set: function(value) {\\n          _text = \\\"\\\" + value;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"region\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _region;\\n        },\\n        set: function(value) {\\n          _region = value;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"vertical\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _vertical;\\n        },\\n        set: function(value) {\\n          var setting = findDirectionSetting(value);\\n          // Have to check for false because the setting an be an empty string.\\n          if (setting === false) {\\n            throw new SyntaxError(\\\"An invalid or illegal string was specified.\\\");\\n          }\\n          _vertical = setting;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"snapToLines\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _snapToLines;\\n        },\\n        set: function(value) {\\n          _snapToLines = !!value;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"line\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _line;\\n        },\\n        set: function(value) {\\n          if (typeof value !== \\\"number\\\" && value !== autoKeyword) {\\n            throw new SyntaxError(\\\"An invalid number or illegal string was specified.\\\");\\n          }\\n          _line = value;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"lineAlign\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _lineAlign;\\n        },\\n        set: function(value) {\\n          var setting = findAlignSetting(value);\\n          if (!setting) {\\n            throw new SyntaxError(\\\"An invalid or illegal string was specified.\\\");\\n          }\\n          _lineAlign = setting;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"position\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _position;\\n        },\\n        set: function(value) {\\n          if (value < 0 || value > 100) {\\n            throw new Error(\\\"Position must be between 0 and 100.\\\");\\n          }\\n          _position = value;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"positionAlign\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _positionAlign;\\n        },\\n        set: function(value) {\\n          var setting = findAlignSetting(value);\\n          if (!setting) {\\n            throw new SyntaxError(\\\"An invalid or illegal string was specified.\\\");\\n          }\\n          _positionAlign = setting;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"size\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _size;\\n        },\\n        set: function(value) {\\n          if (value < 0 || value > 100) {\\n            throw new Error(\\\"Size must be between 0 and 100.\\\");\\n          }\\n          _size = value;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"align\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _align;\\n        },\\n        set: function(value) {\\n          var setting = findAlignSetting(value);\\n          if (!setting) {\\n            throw new SyntaxError(\\\"An invalid or illegal string was specified.\\\");\\n          }\\n          _align = setting;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    /**\\n     * Other <track> spec defined properties\\n     */\\n\\n    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\\n    cue.displayState = undefined;\\n\\n    if (isIE8) {\\n      return cue;\\n    }\\n  }\\n\\n  /**\\n   * VTTCue methods\\n   */\\n\\n  VTTCue.prototype.getCueAsHTML = function() {\\n    // Assume WebVTT.convertCueToDOMTree is on the global.\\n    return WebVTT.convertCueToDOMTree(window, this.text);\\n  };\\n\\n  root.VTTCue = root.VTTCue || VTTCue;\\n  vttjs.VTTCue = VTTCue;\\n}(this, (this.vttjs || {})));\\n\\n/**\\n * Copyright 2013 vtt.js Contributors\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *   http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n(function(root, vttjs) {\\n\\n  var scrollSetting = {\\n    \\\"\\\": true,\\n    \\\"up\\\": true\\n  };\\n\\n  function findScrollSetting(value) {\\n    if (typeof value !== \\\"string\\\") {\\n      return false;\\n    }\\n    var scroll = scrollSetting[value.toLowerCase()];\\n    return scroll ? value.toLowerCase() : false;\\n  }\\n\\n  function isValidPercentValue(value) {\\n    return typeof value === \\\"number\\\" && (value >= 0 && value <= 100);\\n  }\\n\\n  // VTTRegion shim http://dev.w3.org/html5/webvtt/#vttregion-interface\\n  function VTTRegion() {\\n    var _width = 100;\\n    var _lines = 3;\\n    var _regionAnchorX = 0;\\n    var _regionAnchorY = 100;\\n    var _viewportAnchorX = 0;\\n    var _viewportAnchorY = 100;\\n    var _scroll = \\\"\\\";\\n\\n    Object.defineProperties(this, {\\n      \\\"width\\\": {\\n        enumerable: true,\\n        get: function() {\\n          return _width;\\n        },\\n        set: function(value) {\\n          if (!isValidPercentValue(value)) {\\n            throw new Error(\\\"Width must be between 0 and 100.\\\");\\n          }\\n          _width = value;\\n        }\\n      },\\n      \\\"lines\\\": {\\n        enumerable: true,\\n        get: function() {\\n          return _lines;\\n        },\\n        set: function(value) {\\n          if (typeof value !== \\\"number\\\") {\\n            throw new TypeError(\\\"Lines must be set to a number.\\\");\\n          }\\n          _lines = value;\\n        }\\n      },\\n      \\\"regionAnchorY\\\": {\\n        enumerable: true,\\n        get: function() {\\n          return _regionAnchorY;\\n        },\\n        set: function(value) {\\n          if (!isValidPercentValue(value)) {\\n            throw new Error(\\\"RegionAnchorX must be between 0 and 100.\\\");\\n          }\\n          _regionAnchorY = value;\\n        }\\n      },\\n      \\\"regionAnchorX\\\": {\\n        enumerable: true,\\n        get: function() {\\n          return _regionAnchorX;\\n        },\\n        set: function(value) {\\n          if(!isValidPercentValue(value)) {\\n            throw new Error(\\\"RegionAnchorY must be between 0 and 100.\\\");\\n          }\\n          _regionAnchorX = value;\\n        }\\n      },\\n      \\\"viewportAnchorY\\\": {\\n        enumerable: true,\\n        get: function() {\\n          return _viewportAnchorY;\\n        },\\n        set: function(value) {\\n          if (!isValidPercentValue(value)) {\\n            throw new Error(\\\"ViewportAnchorY must be between 0 and 100.\\\");\\n          }\\n          _viewportAnchorY = value;\\n        }\\n      },\\n      \\\"viewportAnchorX\\\": {\\n        enumerable: true,\\n        get: function() {\\n          return _viewportAnchorX;\\n        },\\n        set: function(value) {\\n          if (!isValidPercentValue(value)) {\\n            throw new Error(\\\"ViewportAnchorX must be between 0 and 100.\\\");\\n          }\\n          _viewportAnchorX = value;\\n        }\\n      },\\n      \\\"scroll\\\": {\\n        enumerable: true,\\n        get: function() {\\n          return _scroll;\\n        },\\n        set: function(value) {\\n          var setting = findScrollSetting(value);\\n          // Have to check for false as an empty string is a legal value.\\n          if (setting === false) {\\n            throw new SyntaxError(\\\"An invalid or illegal string was specified.\\\");\\n          }\\n          _scroll = setting;\\n        }\\n      }\\n    });\\n  }\\n\\n  root.VTTRegion = root.VTTRegion || VTTRegion;\\n  vttjs.VTTRegion = VTTRegion;\\n}(this, (this.vttjs || {})));\\n\\n/**\\n * Copyright 2013 vtt.js Contributors\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *   http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\\n\\n(function(global) {\\n\\n  var _objCreate = Object.create || (function() {\\n    function F() {}\\n    return function(o) {\\n      if (arguments.length !== 1) {\\n        throw new Error('Object.create shim only accepts one parameter.');\\n      }\\n      F.prototype = o;\\n      return new F();\\n    };\\n  })();\\n\\n  // Creates a new ParserError object from an errorData object. The errorData\\n  // object should have default code and message properties. The default message\\n  // property can be overriden by passing in a message parameter.\\n  // See ParsingError.Errors below for acceptable errors.\\n  function ParsingError(errorData, message) {\\n    this.name = \\\"ParsingError\\\";\\n    this.code = errorData.code;\\n    this.message = message || errorData.message;\\n  }\\n  ParsingError.prototype = _objCreate(Error.prototype);\\n  ParsingError.prototype.constructor = ParsingError;\\n\\n  // ParsingError metadata for acceptable ParsingErrors.\\n  ParsingError.Errors = {\\n    BadSignature: {\\n      code: 0,\\n      message: \\\"Malformed WebVTT signature.\\\"\\n    },\\n    BadTimeStamp: {\\n      code: 1,\\n      message: \\\"Malformed time stamp.\\\"\\n    }\\n  };\\n\\n  // Try to parse input as a time stamp.\\n  function parseTimeStamp(input) {\\n\\n    function computeSeconds(h, m, s, f) {\\n      return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;\\n    }\\n\\n    var m = input.match(/^(\\\\d+):(\\\\d{2})(:\\\\d{2})?\\\\.(\\\\d{3})/);\\n    if (!m) {\\n      return null;\\n    }\\n\\n    if (m[3]) {\\n      // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]\\n      return computeSeconds(m[1], m[2], m[3].replace(\\\":\\\", \\\"\\\"), m[4]);\\n    } else if (m[1] > 59) {\\n      // Timestamp takes the form of [hours]:[minutes].[milliseconds]\\n      // First position is hours as it's over 59.\\n      return computeSeconds(m[1], m[2], 0,  m[4]);\\n    } else {\\n      // Timestamp takes the form of [minutes]:[seconds].[milliseconds]\\n      return computeSeconds(0, m[1], m[2], m[4]);\\n    }\\n  }\\n\\n  // A settings object holds key/value pairs and will ignore anything but the first\\n  // assignment to a specific key.\\n  function Settings() {\\n    this.values = _objCreate(null);\\n  }\\n\\n  Settings.prototype = {\\n    // Only accept the first assignment to any key.\\n    set: function(k, v) {\\n      if (!this.get(k) && v !== \\\"\\\") {\\n        this.values[k] = v;\\n      }\\n    },\\n    // Return the value for a key, or a default value.\\n    // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\\n    // a number of possible default values as properties where 'defaultKey' is\\n    // the key of the property that will be chosen; otherwise it's assumed to be\\n    // a single value.\\n    get: function(k, dflt, defaultKey) {\\n      if (defaultKey) {\\n        return this.has(k) ? this.values[k] : dflt[defaultKey];\\n      }\\n      return this.has(k) ? this.values[k] : dflt;\\n    },\\n    // Check whether we have a value for a key.\\n    has: function(k) {\\n      return k in this.values;\\n    },\\n    // Accept a setting if its one of the given alternatives.\\n    alt: function(k, v, a) {\\n      for (var n = 0; n < a.length; ++n) {\\n        if (v === a[n]) {\\n          this.set(k, v);\\n          break;\\n        }\\n      }\\n    },\\n    // Accept a setting if its a valid (signed) integer.\\n    integer: function(k, v) {\\n      if (/^-?\\\\d+$/.test(v)) { // integer\\n        this.set(k, parseInt(v, 10));\\n      }\\n    },\\n    // Accept a setting if its a valid percentage.\\n    percent: function(k, v) {\\n      var m;\\n      if ((m = v.match(/^([\\\\d]{1,3})(\\\\.[\\\\d]*)?%$/))) {\\n        v = parseFloat(v);\\n        if (v >= 0 && v <= 100) {\\n          this.set(k, v);\\n          return true;\\n        }\\n      }\\n      return false;\\n    }\\n  };\\n\\n  // Helper function to parse input into groups separated by 'groupDelim', and\\n  // interprete each group as a key/value pair separated by 'keyValueDelim'.\\n  function parseOptions(input, callback, keyValueDelim, groupDelim) {\\n    var groups = groupDelim ? input.split(groupDelim) : [input];\\n    for (var i in groups) {\\n      if (typeof groups[i] !== \\\"string\\\") {\\n        continue;\\n      }\\n      var kv = groups[i].split(keyValueDelim);\\n      if (kv.length !== 2) {\\n        continue;\\n      }\\n      var k = kv[0];\\n      var v = kv[1];\\n      callback(k, v);\\n    }\\n  }\\n\\n  function parseCue(input, cue, regionList) {\\n    // Remember the original input if we need to throw an error.\\n    var oInput = input;\\n    // 4.1 WebVTT timestamp\\n    function consumeTimeStamp() {\\n      var ts = parseTimeStamp(input);\\n      if (ts === null) {\\n        throw new ParsingError(ParsingError.Errors.BadTimeStamp,\\n                              \\\"Malformed timestamp: \\\" + oInput);\\n      }\\n      // Remove time stamp from input.\\n      input = input.replace(/^[^\\\\sa-zA-Z-]+/, \\\"\\\");\\n      return ts;\\n    }\\n\\n    // 4.4.2 WebVTT cue settings\\n    function consumeCueSettings(input, cue) {\\n      var settings = new Settings();\\n\\n      parseOptions(input, function (k, v) {\\n        switch (k) {\\n        case \\\"region\\\":\\n          // Find the last region we parsed with the same region id.\\n          for (var i = regionList.length - 1; i >= 0; i--) {\\n            if (regionList[i].id === v) {\\n              settings.set(k, regionList[i].region);\\n              break;\\n            }\\n          }\\n          break;\\n        case \\\"vertical\\\":\\n          settings.alt(k, v, [\\\"rl\\\", \\\"lr\\\"]);\\n          break;\\n        case \\\"line\\\":\\n          var vals = v.split(\\\",\\\"),\\n              vals0 = vals[0];\\n          settings.integer(k, vals0);\\n          settings.percent(k, vals0) ? settings.set(\\\"snapToLines\\\", false) : null;\\n          settings.alt(k, vals0, [\\\"auto\\\"]);\\n          if (vals.length === 2) {\\n            settings.alt(\\\"lineAlign\\\", vals[1], [\\\"start\\\", \\\"middle\\\", \\\"end\\\"]);\\n          }\\n          break;\\n        case \\\"position\\\":\\n          vals = v.split(\\\",\\\");\\n          settings.percent(k, vals[0]);\\n          if (vals.length === 2) {\\n            settings.alt(\\\"positionAlign\\\", vals[1], [\\\"start\\\", \\\"middle\\\", \\\"end\\\"]);\\n          }\\n          break;\\n        case \\\"size\\\":\\n          settings.percent(k, v);\\n          break;\\n        case \\\"align\\\":\\n          settings.alt(k, v, [\\\"start\\\", \\\"middle\\\", \\\"end\\\", \\\"left\\\", \\\"right\\\"]);\\n          break;\\n        }\\n      }, /:/, /\\\\s/);\\n\\n      // Apply default values for any missing fields.\\n      cue.region = settings.get(\\\"region\\\", null);\\n      cue.vertical = settings.get(\\\"vertical\\\", \\\"\\\");\\n      cue.line = settings.get(\\\"line\\\", \\\"auto\\\");\\n      cue.lineAlign = settings.get(\\\"lineAlign\\\", \\\"start\\\");\\n      cue.snapToLines = settings.get(\\\"snapToLines\\\", true);\\n      cue.size = settings.get(\\\"size\\\", 100);\\n      cue.align = settings.get(\\\"align\\\", \\\"middle\\\");\\n      cue.position = settings.get(\\\"position\\\", {\\n        start: 0,\\n        left: 0,\\n        middle: 50,\\n        end: 100,\\n        right: 100\\n      }, cue.align);\\n      cue.positionAlign = settings.get(\\\"positionAlign\\\", {\\n        start: \\\"start\\\",\\n        left: \\\"start\\\",\\n        middle: \\\"middle\\\",\\n        end: \\\"end\\\",\\n        right: \\\"end\\\"\\n      }, cue.align);\\n    }\\n\\n    function skipWhitespace() {\\n      input = input.replace(/^\\\\s+/, \\\"\\\");\\n    }\\n\\n    // 4.1 WebVTT cue timings.\\n    skipWhitespace();\\n    cue.startTime = consumeTimeStamp();   // (1) collect cue start time\\n    skipWhitespace();\\n    if (input.substr(0, 3) !== \\\"-->\\\") {     // (3) next characters must match \\\"-->\\\"\\n      throw new ParsingError(ParsingError.Errors.BadTimeStamp,\\n                             \\\"Malformed time stamp (time stamps must be separated by '-->'): \\\" +\\n                             oInput);\\n    }\\n    input = input.substr(3);\\n    skipWhitespace();\\n    cue.endTime = consumeTimeStamp();     // (5) collect cue end time\\n\\n    // 4.1 WebVTT cue settings list.\\n    skipWhitespace();\\n    consumeCueSettings(input, cue);\\n  }\\n\\n  var ESCAPE = {\\n    \\\"&amp;\\\": \\\"&\\\",\\n    \\\"&lt;\\\": \\\"<\\\",\\n    \\\"&gt;\\\": \\\">\\\",\\n    \\\"&lrm;\\\": \\\"\\\\u200e\\\",\\n    \\\"&rlm;\\\": \\\"\\\\u200f\\\",\\n    \\\"&nbsp;\\\": \\\"\\\\u00a0\\\"\\n  };\\n\\n  var TAG_NAME = {\\n    c: \\\"span\\\",\\n    i: \\\"i\\\",\\n    b: \\\"b\\\",\\n    u: \\\"u\\\",\\n    ruby: \\\"ruby\\\",\\n    rt: \\\"rt\\\",\\n    v: \\\"span\\\",\\n    lang: \\\"span\\\"\\n  };\\n\\n  var TAG_ANNOTATION = {\\n    v: \\\"title\\\",\\n    lang: \\\"lang\\\"\\n  };\\n\\n  var NEEDS_PARENT = {\\n    rt: \\\"ruby\\\"\\n  };\\n\\n  // Parse content into a document fragment.\\n  function parseContent(window, input) {\\n    function nextToken() {\\n      // Check for end-of-string.\\n      if (!input) {\\n        return null;\\n      }\\n\\n      // Consume 'n' characters from the input.\\n      function consume(result) {\\n        input = input.substr(result.length);\\n        return result;\\n      }\\n\\n      var m = input.match(/^([^<]*)(<[^>]+>?)?/);\\n      // If there is some text before the next tag, return it, otherwise return\\n      // the tag.\\n      return consume(m[1] ? m[1] : m[2]);\\n    }\\n\\n    // Unescape a string 's'.\\n    function unescape1(e) {\\n      return ESCAPE[e];\\n    }\\n    function unescape(s) {\\n      while ((m = s.match(/&(amp|lt|gt|lrm|rlm|nbsp);/))) {\\n        s = s.replace(m[0], unescape1);\\n      }\\n      return s;\\n    }\\n\\n    function shouldAdd(current, element) {\\n      return !NEEDS_PARENT[element.localName] ||\\n             NEEDS_PARENT[element.localName] === current.localName;\\n    }\\n\\n    // Create an element for this tag.\\n    function createElement(type, annotation) {\\n      var tagName = TAG_NAME[type];\\n      if (!tagName) {\\n        return null;\\n      }\\n      var element = window.document.createElement(tagName);\\n      element.localName = tagName;\\n      var name = TAG_ANNOTATION[type];\\n      if (name && annotation) {\\n        element[name] = annotation.trim();\\n      }\\n      return element;\\n    }\\n\\n    var rootDiv = window.document.createElement(\\\"div\\\"),\\n        current = rootDiv,\\n        t,\\n        tagStack = [];\\n\\n    while ((t = nextToken()) !== null) {\\n      if (t[0] === '<') {\\n        if (t[1] === \\\"/\\\") {\\n          // If the closing tag matches, move back up to the parent node.\\n          if (tagStack.length &&\\n              tagStack[tagStack.length - 1] === t.substr(2).replace(\\\">\\\", \\\"\\\")) {\\n            tagStack.pop();\\n            current = current.parentNode;\\n          }\\n          // Otherwise just ignore the end tag.\\n          continue;\\n        }\\n        var ts = parseTimeStamp(t.substr(1, t.length - 2));\\n        var node;\\n        if (ts) {\\n          // Timestamps are lead nodes as well.\\n          node = window.document.createProcessingInstruction(\\\"timestamp\\\", ts);\\n          current.appendChild(node);\\n          continue;\\n        }\\n        var m = t.match(/^<([^.\\\\s/0-9>]+)(\\\\.[^\\\\s\\\\\\\\>]+)?([^>\\\\\\\\]+)?(\\\\\\\\?)>?$/);\\n        // If we can't parse the tag, skip to the next tag.\\n        if (!m) {\\n          continue;\\n        }\\n        // Try to construct an element, and ignore the tag if we couldn't.\\n        node = createElement(m[1], m[3]);\\n        if (!node) {\\n          continue;\\n        }\\n        // Determine if the tag should be added based on the context of where it\\n        // is placed in the cuetext.\\n        if (!shouldAdd(current, node)) {\\n          continue;\\n        }\\n        // Set the class list (as a list of classes, separated by space).\\n        if (m[2]) {\\n          node.className = m[2].substr(1).replace('.', ' ');\\n        }\\n        // Append the node to the current node, and enter the scope of the new\\n        // node.\\n        tagStack.push(m[1]);\\n        current.appendChild(node);\\n        current = node;\\n        continue;\\n      }\\n\\n      // Text nodes are leaf nodes.\\n      current.appendChild(window.document.createTextNode(unescape(t)));\\n    }\\n\\n    return rootDiv;\\n  }\\n\\n  // This is a list of all the Unicode characters that have a strong\\n  // right-to-left category. What this means is that these characters are\\n  // written right-to-left for sure. It was generated by pulling all the strong\\n  // right-to-left characters out of the Unicode data table. That table can\\n  // found at: http://www.unicode.org/Public/UNIDATA/UnicodeData.txt\\n  var strongRTLChars = [0x05BE, 0x05C0, 0x05C3, 0x05C6, 0x05D0, 0x05D1,\\n      0x05D2, 0x05D3, 0x05D4, 0x05D5, 0x05D6, 0x05D7, 0x05D8, 0x05D9, 0x05DA,\\n      0x05DB, 0x05DC, 0x05DD, 0x05DE, 0x05DF, 0x05E0, 0x05E1, 0x05E2, 0x05E3,\\n      0x05E4, 0x05E5, 0x05E6, 0x05E7, 0x05E8, 0x05E9, 0x05EA, 0x05F0, 0x05F1,\\n      0x05F2, 0x05F3, 0x05F4, 0x0608, 0x060B, 0x060D, 0x061B, 0x061E, 0x061F,\\n      0x0620, 0x0621, 0x0622, 0x0623, 0x0624, 0x0625, 0x0626, 0x0627, 0x0628,\\n      0x0629, 0x062A, 0x062B, 0x062C, 0x062D, 0x062E, 0x062F, 0x0630, 0x0631,\\n      0x0632, 0x0633, 0x0634, 0x0635, 0x0636, 0x0637, 0x0638, 0x0639, 0x063A,\\n      0x063B, 0x063C, 0x063D, 0x063E, 0x063F, 0x0640, 0x0641, 0x0642, 0x0643,\\n      0x0644, 0x0645, 0x0646, 0x0647, 0x0648, 0x0649, 0x064A, 0x066D, 0x066E,\\n      0x066F, 0x0671, 0x0672, 0x0673, 0x0674, 0x0675, 0x0676, 0x0677, 0x0678,\\n      0x0679, 0x067A, 0x067B, 0x067C, 0x067D, 0x067E, 0x067F, 0x0680, 0x0681,\\n      0x0682, 0x0683, 0x0684, 0x0685, 0x0686, 0x0687, 0x0688, 0x0689, 0x068A,\\n      0x068B, 0x068C, 0x068D, 0x068E, 0x068F, 0x0690, 0x0691, 0x0692, 0x0693,\\n      0x0694, 0x0695, 0x0696, 0x0697, 0x0698, 0x0699, 0x069A, 0x069B, 0x069C,\\n      0x069D, 0x069E, 0x069F, 0x06A0, 0x06A1, 0x06A2, 0x06A3, 0x06A4, 0x06A5,\\n      0x06A6, 0x06A7, 0x06A8, 0x06A9, 0x06AA, 0x06AB, 0x06AC, 0x06AD, 0x06AE,\\n      0x06AF, 0x06B0, 0x06B1, 0x06B2, 0x06B3, 0x06B4, 0x06B5, 0x06B6, 0x06B7,\\n      0x06B8, 0x06B9, 0x06BA, 0x06BB, 0x06BC, 0x06BD, 0x06BE, 0x06BF, 0x06C0,\\n      0x06C1, 0x06C2, 0x06C3, 0x06C4, 0x06C5, 0x06C6, 0x06C7, 0x06C8, 0x06C9,\\n      0x06CA, 0x06CB, 0x06CC, 0x06CD, 0x06CE, 0x06CF, 0x06D0, 0x06D1, 0x06D2,\\n      0x06D3, 0x06D4, 0x06D5, 0x06E5, 0x06E6, 0x06EE, 0x06EF, 0x06FA, 0x06FB,\\n      0x06FC, 0x06FD, 0x06FE, 0x06FF, 0x0700, 0x0701, 0x0702, 0x0703, 0x0704,\\n      0x0705, 0x0706, 0x0707, 0x0708, 0x0709, 0x070A, 0x070B, 0x070C, 0x070D,\\n      0x070F, 0x0710, 0x0712, 0x0713, 0x0714, 0x0715, 0x0716, 0x0717, 0x0718,\\n      0x0719, 0x071A, 0x071B, 0x071C, 0x071D, 0x071E, 0x071F, 0x0720, 0x0721,\\n      0x0722, 0x0723, 0x0724, 0x0725, 0x0726, 0x0727, 0x0728, 0x0729, 0x072A,\\n      0x072B, 0x072C, 0x072D, 0x072E, 0x072F, 0x074D, 0x074E, 0x074F, 0x0750,\\n      0x0751, 0x0752, 0x0753, 0x0754, 0x0755, 0x0756, 0x0757, 0x0758, 0x0759,\\n      0x075A, 0x075B, 0x075C, 0x075D, 0x075E, 0x075F, 0x0760, 0x0761, 0x0762,\\n      0x0763, 0x0764, 0x0765, 0x0766, 0x0767, 0x0768, 0x0769, 0x076A, 0x076B,\\n      0x076C, 0x076D, 0x076E, 0x076F, 0x0770, 0x0771, 0x0772, 0x0773, 0x0774,\\n      0x0775, 0x0776, 0x0777, 0x0778, 0x0779, 0x077A, 0x077B, 0x077C, 0x077D,\\n      0x077E, 0x077F, 0x0780, 0x0781, 0x0782, 0x0783, 0x0784, 0x0785, 0x0786,\\n      0x0787, 0x0788, 0x0789, 0x078A, 0x078B, 0x078C, 0x078D, 0x078E, 0x078F,\\n      0x0790, 0x0791, 0x0792, 0x0793, 0x0794, 0x0795, 0x0796, 0x0797, 0x0798,\\n      0x0799, 0x079A, 0x079B, 0x079C, 0x079D, 0x079E, 0x079F, 0x07A0, 0x07A1,\\n      0x07A2, 0x07A3, 0x07A4, 0x07A5, 0x07B1, 0x07C0, 0x07C1, 0x07C2, 0x07C3,\\n      0x07C4, 0x07C5, 0x07C6, 0x07C7, 0x07C8, 0x07C9, 0x07CA, 0x07CB, 0x07CC,\\n      0x07CD, 0x07CE, 0x07CF, 0x07D0, 0x07D1, 0x07D2, 0x07D3, 0x07D4, 0x07D5,\\n      0x07D6, 0x07D7, 0x07D8, 0x07D9, 0x07DA, 0x07DB, 0x07DC, 0x07DD, 0x07DE,\\n      0x07DF, 0x07E0, 0x07E1, 0x07E2, 0x07E3, 0x07E4, 0x07E5, 0x07E6, 0x07E7,\\n      0x07E8, 0x07E9, 0x07EA, 0x07F4, 0x07F5, 0x07FA, 0x0800, 0x0801, 0x0802,\\n      0x0803, 0x0804, 0x0805, 0x0806, 0x0807, 0x0808, 0x0809, 0x080A, 0x080B,\\n      0x080C, 0x080D, 0x080E, 0x080F, 0x0810, 0x0811, 0x0812, 0x0813, 0x0814,\\n      0x0815, 0x081A, 0x0824, 0x0828, 0x0830, 0x0831, 0x0832, 0x0833, 0x0834,\\n      0x0835, 0x0836, 0x0837, 0x0838, 0x0839, 0x083A, 0x083B, 0x083C, 0x083D,\\n      0x083E, 0x0840, 0x0841, 0x0842, 0x0843, 0x0844, 0x0845, 0x0846, 0x0847,\\n      0x0848, 0x0849, 0x084A, 0x084B, 0x084C, 0x084D, 0x084E, 0x084F, 0x0850,\\n      0x0851, 0x0852, 0x0853, 0x0854, 0x0855, 0x0856, 0x0857, 0x0858, 0x085E,\\n      0x08A0, 0x08A2, 0x08A3, 0x08A4, 0x08A5, 0x08A6, 0x08A7, 0x08A8, 0x08A9,\\n      0x08AA, 0x08AB, 0x08AC, 0x200F, 0xFB1D, 0xFB1F, 0xFB20, 0xFB21, 0xFB22,\\n      0xFB23, 0xFB24, 0xFB25, 0xFB26, 0xFB27, 0xFB28, 0xFB2A, 0xFB2B, 0xFB2C,\\n      0xFB2D, 0xFB2E, 0xFB2F, 0xFB30, 0xFB31, 0xFB32, 0xFB33, 0xFB34, 0xFB35,\\n      0xFB36, 0xFB38, 0xFB39, 0xFB3A, 0xFB3B, 0xFB3C, 0xFB3E, 0xFB40, 0xFB41,\\n      0xFB43, 0xFB44, 0xFB46, 0xFB47, 0xFB48, 0xFB49, 0xFB4A, 0xFB4B, 0xFB4C,\\n      0xFB4D, 0xFB4E, 0xFB4F, 0xFB50, 0xFB51, 0xFB52, 0xFB53, 0xFB54, 0xFB55,\\n      0xFB56, 0xFB57, 0xFB58, 0xFB59, 0xFB5A, 0xFB5B, 0xFB5C, 0xFB5D, 0xFB5E,\\n      0xFB5F, 0xFB60, 0xFB61, 0xFB62, 0xFB63, 0xFB64, 0xFB65, 0xFB66, 0xFB67,\\n      0xFB68, 0xFB69, 0xFB6A, 0xFB6B, 0xFB6C, 0xFB6D, 0xFB6E, 0xFB6F, 0xFB70,\\n      0xFB71, 0xFB72, 0xFB73, 0xFB74, 0xFB75, 0xFB76, 0xFB77, 0xFB78, 0xFB79,\\n      0xFB7A, 0xFB7B, 0xFB7C, 0xFB7D, 0xFB7E, 0xFB7F, 0xFB80, 0xFB81, 0xFB82,\\n      0xFB83, 0xFB84, 0xFB85, 0xFB86, 0xFB87, 0xFB88, 0xFB89, 0xFB8A, 0xFB8B,\\n      0xFB8C, 0xFB8D, 0xFB8E, 0xFB8F, 0xFB90, 0xFB91, 0xFB92, 0xFB93, 0xFB94,\\n      0xFB95, 0xFB96, 0xFB97, 0xFB98, 0xFB99, 0xFB9A, 0xFB9B, 0xFB9C, 0xFB9D,\\n      0xFB9E, 0xFB9F, 0xFBA0, 0xFBA1, 0xFBA2, 0xFBA3, 0xFBA4, 0xFBA5, 0xFBA6,\\n      0xFBA7, 0xFBA8, 0xFBA9, 0xFBAA, 0xFBAB, 0xFBAC, 0xFBAD, 0xFBAE, 0xFBAF,\\n      0xFBB0, 0xFBB1, 0xFBB2, 0xFBB3, 0xFBB4, 0xFBB5, 0xFBB6, 0xFBB7, 0xFBB8,\\n      0xFBB9, 0xFBBA, 0xFBBB, 0xFBBC, 0xFBBD, 0xFBBE, 0xFBBF, 0xFBC0, 0xFBC1,\\n      0xFBD3, 0xFBD4, 0xFBD5, 0xFBD6, 0xFBD7, 0xFBD8, 0xFBD9, 0xFBDA, 0xFBDB,\\n      0xFBDC, 0xFBDD, 0xFBDE, 0xFBDF, 0xFBE0, 0xFBE1, 0xFBE2, 0xFBE3, 0xFBE4,\\n      0xFBE5, 0xFBE6, 0xFBE7, 0xFBE8, 0xFBE9, 0xFBEA, 0xFBEB, 0xFBEC, 0xFBED,\\n      0xFBEE, 0xFBEF, 0xFBF0, 0xFBF1, 0xFBF2, 0xFBF3, 0xFBF4, 0xFBF5, 0xFBF6,\\n      0xFBF7, 0xFBF8, 0xFBF9, 0xFBFA, 0xFBFB, 0xFBFC, 0xFBFD, 0xFBFE, 0xFBFF,\\n      0xFC00, 0xFC01, 0xFC02, 0xFC03, 0xFC04, 0xFC05, 0xFC06, 0xFC07, 0xFC08,\\n      0xFC09, 0xFC0A, 0xFC0B, 0xFC0C, 0xFC0D, 0xFC0E, 0xFC0F, 0xFC10, 0xFC11,\\n      0xFC12, 0xFC13, 0xFC14, 0xFC15, 0xFC16, 0xFC17, 0xFC18, 0xFC19, 0xFC1A,\\n      0xFC1B, 0xFC1C, 0xFC1D, 0xFC1E, 0xFC1F, 0xFC20, 0xFC21, 0xFC22, 0xFC23,\\n      0xFC24, 0xFC25, 0xFC26, 0xFC27, 0xFC28, 0xFC29, 0xFC2A, 0xFC2B, 0xFC2C,\\n      0xFC2D, 0xFC2E, 0xFC2F, 0xFC30, 0xFC31, 0xFC32, 0xFC33, 0xFC34, 0xFC35,\\n      0xFC36, 0xFC37, 0xFC38, 0xFC39, 0xFC3A, 0xFC3B, 0xFC3C, 0xFC3D, 0xFC3E,\\n      0xFC3F, 0xFC40, 0xFC41, 0xFC42, 0xFC43, 0xFC44, 0xFC45, 0xFC46, 0xFC47,\\n      0xFC48, 0xFC49, 0xFC4A, 0xFC4B, 0xFC4C, 0xFC4D, 0xFC4E, 0xFC4F, 0xFC50,\\n      0xFC51, 0xFC52, 0xFC53, 0xFC54, 0xFC55, 0xFC56, 0xFC57, 0xFC58, 0xFC59,\\n      0xFC5A, 0xFC5B, 0xFC5C, 0xFC5D, 0xFC5E, 0xFC5F, 0xFC60, 0xFC61, 0xFC62,\\n      0xFC63, 0xFC64, 0xFC65, 0xFC66, 0xFC67, 0xFC68, 0xFC69, 0xFC6A, 0xFC6B,\\n      0xFC6C, 0xFC6D, 0xFC6E, 0xFC6F, 0xFC70, 0xFC71, 0xFC72, 0xFC73, 0xFC74,\\n      0xFC75, 0xFC76, 0xFC77, 0xFC78, 0xFC79, 0xFC7A, 0xFC7B, 0xFC7C, 0xFC7D,\\n      0xFC7E, 0xFC7F, 0xFC80, 0xFC81, 0xFC82, 0xFC83, 0xFC84, 0xFC85, 0xFC86,\\n      0xFC87, 0xFC88, 0xFC89, 0xFC8A, 0xFC8B, 0xFC8C, 0xFC8D, 0xFC8E, 0xFC8F,\\n      0xFC90, 0xFC91, 0xFC92, 0xFC93, 0xFC94, 0xFC95, 0xFC96, 0xFC97, 0xFC98,\\n      0xFC99, 0xFC9A, 0xFC9B, 0xFC9C, 0xFC9D, 0xFC9E, 0xFC9F, 0xFCA0, 0xFCA1,\\n      0xFCA2, 0xFCA3, 0xFCA4, 0xFCA5, 0xFCA6, 0xFCA7, 0xFCA8, 0xFCA9, 0xFCAA,\\n      0xFCAB, 0xFCAC, 0xFCAD, 0xFCAE, 0xFCAF, 0xFCB0, 0xFCB1, 0xFCB2, 0xFCB3,\\n      0xFCB4, 0xFCB5, 0xFCB6, 0xFCB7, 0xFCB8, 0xFCB9, 0xFCBA, 0xFCBB, 0xFCBC,\\n      0xFCBD, 0xFCBE, 0xFCBF, 0xFCC0, 0xFCC1, 0xFCC2, 0xFCC3, 0xFCC4, 0xFCC5,\\n      0xFCC6, 0xFCC7, 0xFCC8, 0xFCC9, 0xFCCA, 0xFCCB, 0xFCCC, 0xFCCD, 0xFCCE,\\n      0xFCCF, 0xFCD0, 0xFCD1, 0xFCD2, 0xFCD3, 0xFCD4, 0xFCD5, 0xFCD6, 0xFCD7,\\n      0xFCD8, 0xFCD9, 0xFCDA, 0xFCDB, 0xFCDC, 0xFCDD, 0xFCDE, 0xFCDF, 0xFCE0,\\n      0xFCE1, 0xFCE2, 0xFCE3, 0xFCE4, 0xFCE5, 0xFCE6, 0xFCE7, 0xFCE8, 0xFCE9,\\n      0xFCEA, 0xFCEB, 0xFCEC, 0xFCED, 0xFCEE, 0xFCEF, 0xFCF0, 0xFCF1, 0xFCF2,\\n      0xFCF3, 0xFCF4, 0xFCF5, 0xFCF6, 0xFCF7, 0xFCF8, 0xFCF9, 0xFCFA, 0xFCFB,\\n      0xFCFC, 0xFCFD, 0xFCFE, 0xFCFF, 0xFD00, 0xFD01, 0xFD02, 0xFD03, 0xFD04,\\n      0xFD05, 0xFD06, 0xFD07, 0xFD08, 0xFD09, 0xFD0A, 0xFD0B, 0xFD0C, 0xFD0D,\\n      0xFD0E, 0xFD0F, 0xFD10, 0xFD11, 0xFD12, 0xFD13, 0xFD14, 0xFD15, 0xFD16,\\n      0xFD17, 0xFD18, 0xFD19, 0xFD1A, 0xFD1B, 0xFD1C, 0xFD1D, 0xFD1E, 0xFD1F,\\n      0xFD20, 0xFD21, 0xFD22, 0xFD23, 0xFD24, 0xFD25, 0xFD26, 0xFD27, 0xFD28,\\n      0xFD29, 0xFD2A, 0xFD2B, 0xFD2C, 0xFD2D, 0xFD2E, 0xFD2F, 0xFD30, 0xFD31,\\n      0xFD32, 0xFD33, 0xFD34, 0xFD35, 0xFD36, 0xFD37, 0xFD38, 0xFD39, 0xFD3A,\\n      0xFD3B, 0xFD3C, 0xFD3D, 0xFD50, 0xFD51, 0xFD52, 0xFD53, 0xFD54, 0xFD55,\\n      0xFD56, 0xFD57, 0xFD58, 0xFD59, 0xFD5A, 0xFD5B, 0xFD5C, 0xFD5D, 0xFD5E,\\n      0xFD5F, 0xFD60, 0xFD61, 0xFD62, 0xFD63, 0xFD64, 0xFD65, 0xFD66, 0xFD67,\\n      0xFD68, 0xFD69, 0xFD6A, 0xFD6B, 0xFD6C, 0xFD6D, 0xFD6E, 0xFD6F, 0xFD70,\\n      0xFD71, 0xFD72, 0xFD73, 0xFD74, 0xFD75, 0xFD76, 0xFD77, 0xFD78, 0xFD79,\\n      0xFD7A, 0xFD7B, 0xFD7C, 0xFD7D, 0xFD7E, 0xFD7F, 0xFD80, 0xFD81, 0xFD82,\\n      0xFD83, 0xFD84, 0xFD85, 0xFD86, 0xFD87, 0xFD88, 0xFD89, 0xFD8A, 0xFD8B,\\n      0xFD8C, 0xFD8D, 0xFD8E, 0xFD8F, 0xFD92, 0xFD93, 0xFD94, 0xFD95, 0xFD96,\\n      0xFD97, 0xFD98, 0xFD99, 0xFD9A, 0xFD9B, 0xFD9C, 0xFD9D, 0xFD9E, 0xFD9F,\\n      0xFDA0, 0xFDA1, 0xFDA2, 0xFDA3, 0xFDA4, 0xFDA5, 0xFDA6, 0xFDA7, 0xFDA8,\\n      0xFDA9, 0xFDAA, 0xFDAB, 0xFDAC, 0xFDAD, 0xFDAE, 0xFDAF, 0xFDB0, 0xFDB1,\\n      0xFDB2, 0xFDB3, 0xFDB4, 0xFDB5, 0xFDB6, 0xFDB7, 0xFDB8, 0xFDB9, 0xFDBA,\\n      0xFDBB, 0xFDBC, 0xFDBD, 0xFDBE, 0xFDBF, 0xFDC0, 0xFDC1, 0xFDC2, 0xFDC3,\\n      0xFDC4, 0xFDC5, 0xFDC6, 0xFDC7, 0xFDF0, 0xFDF1, 0xFDF2, 0xFDF3, 0xFDF4,\\n      0xFDF5, 0xFDF6, 0xFDF7, 0xFDF8, 0xFDF9, 0xFDFA, 0xFDFB, 0xFDFC, 0xFE70,\\n      0xFE71, 0xFE72, 0xFE73, 0xFE74, 0xFE76, 0xFE77, 0xFE78, 0xFE79, 0xFE7A,\\n      0xFE7B, 0xFE7C, 0xFE7D, 0xFE7E, 0xFE7F, 0xFE80, 0xFE81, 0xFE82, 0xFE83,\\n      0xFE84, 0xFE85, 0xFE86, 0xFE87, 0xFE88, 0xFE89, 0xFE8A, 0xFE8B, 0xFE8C,\\n      0xFE8D, 0xFE8E, 0xFE8F, 0xFE90, 0xFE91, 0xFE92, 0xFE93, 0xFE94, 0xFE95,\\n      0xFE96, 0xFE97, 0xFE98, 0xFE99, 0xFE9A, 0xFE9B, 0xFE9C, 0xFE9D, 0xFE9E,\\n      0xFE9F, 0xFEA0, 0xFEA1, 0xFEA2, 0xFEA3, 0xFEA4, 0xFEA5, 0xFEA6, 0xFEA7,\\n      0xFEA8, 0xFEA9, 0xFEAA, 0xFEAB, 0xFEAC, 0xFEAD, 0xFEAE, 0xFEAF, 0xFEB0,\\n      0xFEB1, 0xFEB2, 0xFEB3, 0xFEB4, 0xFEB5, 0xFEB6, 0xFEB7, 0xFEB8, 0xFEB9,\\n      0xFEBA, 0xFEBB, 0xFEBC, 0xFEBD, 0xFEBE, 0xFEBF, 0xFEC0, 0xFEC1, 0xFEC2,\\n      0xFEC3, 0xFEC4, 0xFEC5, 0xFEC6, 0xFEC7, 0xFEC8, 0xFEC9, 0xFECA, 0xFECB,\\n      0xFECC, 0xFECD, 0xFECE, 0xFECF, 0xFED0, 0xFED1, 0xFED2, 0xFED3, 0xFED4,\\n      0xFED5, 0xFED6, 0xFED7, 0xFED8, 0xFED9, 0xFEDA, 0xFEDB, 0xFEDC, 0xFEDD,\\n      0xFEDE, 0xFEDF, 0xFEE0, 0xFEE1, 0xFEE2, 0xFEE3, 0xFEE4, 0xFEE5, 0xFEE6,\\n      0xFEE7, 0xFEE8, 0xFEE9, 0xFEEA, 0xFEEB, 0xFEEC, 0xFEED, 0xFEEE, 0xFEEF,\\n      0xFEF0, 0xFEF1, 0xFEF2, 0xFEF3, 0xFEF4, 0xFEF5, 0xFEF6, 0xFEF7, 0xFEF8,\\n      0xFEF9, 0xFEFA, 0xFEFB, 0xFEFC, 0x10800, 0x10801, 0x10802, 0x10803,\\n      0x10804, 0x10805, 0x10808, 0x1080A, 0x1080B, 0x1080C, 0x1080D, 0x1080E,\\n      0x1080F, 0x10810, 0x10811, 0x10812, 0x10813, 0x10814, 0x10815, 0x10816,\\n      0x10817, 0x10818, 0x10819, 0x1081A, 0x1081B, 0x1081C, 0x1081D, 0x1081E,\\n      0x1081F, 0x10820, 0x10821, 0x10822, 0x10823, 0x10824, 0x10825, 0x10826,\\n      0x10827, 0x10828, 0x10829, 0x1082A, 0x1082B, 0x1082C, 0x1082D, 0x1082E,\\n      0x1082F, 0x10830, 0x10831, 0x10832, 0x10833, 0x10834, 0x10835, 0x10837,\\n      0x10838, 0x1083C, 0x1083F, 0x10840, 0x10841, 0x10842, 0x10843, 0x10844,\\n      0x10845, 0x10846, 0x10847, 0x10848, 0x10849, 0x1084A, 0x1084B, 0x1084C,\\n      0x1084D, 0x1084E, 0x1084F, 0x10850, 0x10851, 0x10852, 0x10853, 0x10854,\\n      0x10855, 0x10857, 0x10858, 0x10859, 0x1085A, 0x1085B, 0x1085C, 0x1085D,\\n      0x1085E, 0x1085F, 0x10900, 0x10901, 0x10902, 0x10903, 0x10904, 0x10905,\\n      0x10906, 0x10907, 0x10908, 0x10909, 0x1090A, 0x1090B, 0x1090C, 0x1090D,\\n      0x1090E, 0x1090F, 0x10910, 0x10911, 0x10912, 0x10913, 0x10914, 0x10915,\\n      0x10916, 0x10917, 0x10918, 0x10919, 0x1091A, 0x1091B, 0x10920, 0x10921,\\n      0x10922, 0x10923, 0x10924, 0x10925, 0x10926, 0x10927, 0x10928, 0x10929,\\n      0x1092A, 0x1092B, 0x1092C, 0x1092D, 0x1092E, 0x1092F, 0x10930, 0x10931,\\n      0x10932, 0x10933, 0x10934, 0x10935, 0x10936, 0x10937, 0x10938, 0x10939,\\n      0x1093F, 0x10980, 0x10981, 0x10982, 0x10983, 0x10984, 0x10985, 0x10986,\\n      0x10987, 0x10988, 0x10989, 0x1098A, 0x1098B, 0x1098C, 0x1098D, 0x1098E,\\n      0x1098F, 0x10990, 0x10991, 0x10992, 0x10993, 0x10994, 0x10995, 0x10996,\\n      0x10997, 0x10998, 0x10999, 0x1099A, 0x1099B, 0x1099C, 0x1099D, 0x1099E,\\n      0x1099F, 0x109A0, 0x109A1, 0x109A2, 0x109A3, 0x109A4, 0x109A5, 0x109A6,\\n      0x109A7, 0x109A8, 0x109A9, 0x109AA, 0x109AB, 0x109AC, 0x109AD, 0x109AE,\\n      0x109AF, 0x109B0, 0x109B1, 0x109B2, 0x109B3, 0x109B4, 0x109B5, 0x109B6,\\n      0x109B7, 0x109BE, 0x109BF, 0x10A00, 0x10A10, 0x10A11, 0x10A12, 0x10A13,\\n      0x10A15, 0x10A16, 0x10A17, 0x10A19, 0x10A1A, 0x10A1B, 0x10A1C, 0x10A1D,\\n      0x10A1E, 0x10A1F, 0x10A20, 0x10A21, 0x10A22, 0x10A23, 0x10A24, 0x10A25,\\n      0x10A26, 0x10A27, 0x10A28, 0x10A29, 0x10A2A, 0x10A2B, 0x10A2C, 0x10A2D,\\n      0x10A2E, 0x10A2F, 0x10A30, 0x10A31, 0x10A32, 0x10A33, 0x10A40, 0x10A41,\\n      0x10A42, 0x10A43, 0x10A44, 0x10A45, 0x10A46, 0x10A47, 0x10A50, 0x10A51,\\n      0x10A52, 0x10A53, 0x10A54, 0x10A55, 0x10A56, 0x10A57, 0x10A58, 0x10A60,\\n      0x10A61, 0x10A62, 0x10A63, 0x10A64, 0x10A65, 0x10A66, 0x10A67, 0x10A68,\\n      0x10A69, 0x10A6A, 0x10A6B, 0x10A6C, 0x10A6D, 0x10A6E, 0x10A6F, 0x10A70,\\n      0x10A71, 0x10A72, 0x10A73, 0x10A74, 0x10A75, 0x10A76, 0x10A77, 0x10A78,\\n      0x10A79, 0x10A7A, 0x10A7B, 0x10A7C, 0x10A7D, 0x10A7E, 0x10A7F, 0x10B00,\\n      0x10B01, 0x10B02, 0x10B03, 0x10B04, 0x10B05, 0x10B06, 0x10B07, 0x10B08,\\n      0x10B09, 0x10B0A, 0x10B0B, 0x10B0C, 0x10B0D, 0x10B0E, 0x10B0F, 0x10B10,\\n      0x10B11, 0x10B12, 0x10B13, 0x10B14, 0x10B15, 0x10B16, 0x10B17, 0x10B18,\\n      0x10B19, 0x10B1A, 0x10B1B, 0x10B1C, 0x10B1D, 0x10B1E, 0x10B1F, 0x10B20,\\n      0x10B21, 0x10B22, 0x10B23, 0x10B24, 0x10B25, 0x10B26, 0x10B27, 0x10B28,\\n      0x10B29, 0x10B2A, 0x10B2B, 0x10B2C, 0x10B2D, 0x10B2E, 0x10B2F, 0x10B30,\\n      0x10B31, 0x10B32, 0x10B33, 0x10B34, 0x10B35, 0x10B40, 0x10B41, 0x10B42,\\n      0x10B43, 0x10B44, 0x10B45, 0x10B46, 0x10B47, 0x10B48, 0x10B49, 0x10B4A,\\n      0x10B4B, 0x10B4C, 0x10B4D, 0x10B4E, 0x10B4F, 0x10B50, 0x10B51, 0x10B52,\\n      0x10B53, 0x10B54, 0x10B55, 0x10B58, 0x10B59, 0x10B5A, 0x10B5B, 0x10B5C,\\n      0x10B5D, 0x10B5E, 0x10B5F, 0x10B60, 0x10B61, 0x10B62, 0x10B63, 0x10B64,\\n      0x10B65, 0x10B66, 0x10B67, 0x10B68, 0x10B69, 0x10B6A, 0x10B6B, 0x10B6C,\\n      0x10B6D, 0x10B6E, 0x10B6F, 0x10B70, 0x10B71, 0x10B72, 0x10B78, 0x10B79,\\n      0x10B7A, 0x10B7B, 0x10B7C, 0x10B7D, 0x10B7E, 0x10B7F, 0x10C00, 0x10C01,\\n      0x10C02, 0x10C03, 0x10C04, 0x10C05, 0x10C06, 0x10C07, 0x10C08, 0x10C09,\\n      0x10C0A, 0x10C0B, 0x10C0C, 0x10C0D, 0x10C0E, 0x10C0F, 0x10C10, 0x10C11,\\n      0x10C12, 0x10C13, 0x10C14, 0x10C15, 0x10C16, 0x10C17, 0x10C18, 0x10C19,\\n      0x10C1A, 0x10C1B, 0x10C1C, 0x10C1D, 0x10C1E, 0x10C1F, 0x10C20, 0x10C21,\\n      0x10C22, 0x10C23, 0x10C24, 0x10C25, 0x10C26, 0x10C27, 0x10C28, 0x10C29,\\n      0x10C2A, 0x10C2B, 0x10C2C, 0x10C2D, 0x10C2E, 0x10C2F, 0x10C30, 0x10C31,\\n      0x10C32, 0x10C33, 0x10C34, 0x10C35, 0x10C36, 0x10C37, 0x10C38, 0x10C39,\\n      0x10C3A, 0x10C3B, 0x10C3C, 0x10C3D, 0x10C3E, 0x10C3F, 0x10C40, 0x10C41,\\n      0x10C42, 0x10C43, 0x10C44, 0x10C45, 0x10C46, 0x10C47, 0x10C48, 0x1EE00,\\n      0x1EE01, 0x1EE02, 0x1EE03, 0x1EE05, 0x1EE06, 0x1EE07, 0x1EE08, 0x1EE09,\\n      0x1EE0A, 0x1EE0B, 0x1EE0C, 0x1EE0D, 0x1EE0E, 0x1EE0F, 0x1EE10, 0x1EE11,\\n      0x1EE12, 0x1EE13, 0x1EE14, 0x1EE15, 0x1EE16, 0x1EE17, 0x1EE18, 0x1EE19,\\n      0x1EE1A, 0x1EE1B, 0x1EE1C, 0x1EE1D, 0x1EE1E, 0x1EE1F, 0x1EE21, 0x1EE22,\\n      0x1EE24, 0x1EE27, 0x1EE29, 0x1EE2A, 0x1EE2B, 0x1EE2C, 0x1EE2D, 0x1EE2E,\\n      0x1EE2F, 0x1EE30, 0x1EE31, 0x1EE32, 0x1EE34, 0x1EE35, 0x1EE36, 0x1EE37,\\n      0x1EE39, 0x1EE3B, 0x1EE42, 0x1EE47, 0x1EE49, 0x1EE4B, 0x1EE4D, 0x1EE4E,\\n      0x1EE4F, 0x1EE51, 0x1EE52, 0x1EE54, 0x1EE57, 0x1EE59, 0x1EE5B, 0x1EE5D,\\n      0x1EE5F, 0x1EE61, 0x1EE62, 0x1EE64, 0x1EE67, 0x1EE68, 0x1EE69, 0x1EE6A,\\n      0x1EE6C, 0x1EE6D, 0x1EE6E, 0x1EE6F, 0x1EE70, 0x1EE71, 0x1EE72, 0x1EE74,\\n      0x1EE75, 0x1EE76, 0x1EE77, 0x1EE79, 0x1EE7A, 0x1EE7B, 0x1EE7C, 0x1EE7E,\\n      0x1EE80, 0x1EE81, 0x1EE82, 0x1EE83, 0x1EE84, 0x1EE85, 0x1EE86, 0x1EE87,\\n      0x1EE88, 0x1EE89, 0x1EE8B, 0x1EE8C, 0x1EE8D, 0x1EE8E, 0x1EE8F, 0x1EE90,\\n      0x1EE91, 0x1EE92, 0x1EE93, 0x1EE94, 0x1EE95, 0x1EE96, 0x1EE97, 0x1EE98,\\n      0x1EE99, 0x1EE9A, 0x1EE9B, 0x1EEA1, 0x1EEA2, 0x1EEA3, 0x1EEA5, 0x1EEA6,\\n      0x1EEA7, 0x1EEA8, 0x1EEA9, 0x1EEAB, 0x1EEAC, 0x1EEAD, 0x1EEAE, 0x1EEAF,\\n      0x1EEB0, 0x1EEB1, 0x1EEB2, 0x1EEB3, 0x1EEB4, 0x1EEB5, 0x1EEB6, 0x1EEB7,\\n      0x1EEB8, 0x1EEB9, 0x1EEBA, 0x1EEBB, 0x10FFFD];\\n\\n  function determineBidi(cueDiv) {\\n    var nodeStack = [],\\n        text = \\\"\\\",\\n        charCode;\\n\\n    if (!cueDiv || !cueDiv.childNodes) {\\n      return \\\"ltr\\\";\\n    }\\n\\n    function pushNodes(nodeStack, node) {\\n      for (var i = node.childNodes.length - 1; i >= 0; i--) {\\n        nodeStack.push(node.childNodes[i]);\\n      }\\n    }\\n\\n    function nextTextNode(nodeStack) {\\n      if (!nodeStack || !nodeStack.length) {\\n        return null;\\n      }\\n\\n      var node = nodeStack.pop(),\\n          text = node.textContent || node.innerText;\\n      if (text) {\\n        // TODO: This should match all unicode type B characters (paragraph\\n        // separator characters). See issue #115.\\n        var m = text.match(/^.*(\\\\n|\\\\r)/);\\n        if (m) {\\n          nodeStack.length = 0;\\n          return m[0];\\n        }\\n        return text;\\n      }\\n      if (node.tagName === \\\"ruby\\\") {\\n        return nextTextNode(nodeStack);\\n      }\\n      if (node.childNodes) {\\n        pushNodes(nodeStack, node);\\n        return nextTextNode(nodeStack);\\n      }\\n    }\\n\\n    pushNodes(nodeStack, cueDiv);\\n    while ((text = nextTextNode(nodeStack))) {\\n      for (var i = 0; i < text.length; i++) {\\n        charCode = text.charCodeAt(i);\\n        for (var j = 0; j < strongRTLChars.length; j++) {\\n          if (strongRTLChars[j] === charCode) {\\n            return \\\"rtl\\\";\\n          }\\n        }\\n      }\\n    }\\n    return \\\"ltr\\\";\\n  }\\n\\n  function computeLinePos(cue) {\\n    if (typeof cue.line === \\\"number\\\" &&\\n        (cue.snapToLines || (cue.line >= 0 && cue.line <= 100))) {\\n      return cue.line;\\n    }\\n    if (!cue.track || !cue.track.textTrackList ||\\n        !cue.track.textTrackList.mediaElement) {\\n      return -1;\\n    }\\n    var track = cue.track,\\n        trackList = track.textTrackList,\\n        count = 0;\\n    for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {\\n      if (trackList[i].mode === \\\"showing\\\") {\\n        count++;\\n      }\\n    }\\n    return ++count * -1;\\n  }\\n\\n  function StyleBox() {\\n  }\\n\\n  // Apply styles to a div. If there is no div passed then it defaults to the\\n  // div on 'this'.\\n  StyleBox.prototype.applyStyles = function(styles, div) {\\n    div = div || this.div;\\n    for (var prop in styles) {\\n      if (styles.hasOwnProperty(prop)) {\\n        div.style[prop] = styles[prop];\\n      }\\n    }\\n  };\\n\\n  StyleBox.prototype.formatStyle = function(val, unit) {\\n    return val === 0 ? 0 : val + unit;\\n  };\\n\\n  // Constructs the computed display state of the cue (a div). Places the div\\n  // into the overlay which should be a block level element (usually a div).\\n  function CueStyleBox(window, cue, styleOptions) {\\n    var isIE8 = (/MSIE\\\\s8\\\\.0/).test(navigator.userAgent);\\n    var color = \\\"rgba(255, 255, 255, 1)\\\";\\n    var backgroundColor = \\\"rgba(0, 0, 0, 0.8)\\\";\\n\\n    if (isIE8) {\\n      color = \\\"rgb(255, 255, 255)\\\";\\n      backgroundColor = \\\"rgb(0, 0, 0)\\\";\\n    }\\n\\n    StyleBox.call(this);\\n    this.cue = cue;\\n\\n    // Parse our cue's text into a DOM tree rooted at 'cueDiv'. This div will\\n    // have inline positioning and will function as the cue background box.\\n    this.cueDiv = parseContent(window, cue.text);\\n    var styles = {\\n      color: color,\\n      backgroundColor: backgroundColor,\\n      position: \\\"relative\\\",\\n      left: 0,\\n      right: 0,\\n      top: 0,\\n      bottom: 0,\\n      display: \\\"inline\\\"\\n    };\\n\\n    if (!isIE8) {\\n      styles.writingMode = cue.vertical === \\\"\\\" ? \\\"horizontal-tb\\\"\\n                                               : cue.vertical === \\\"lr\\\" ? \\\"vertical-lr\\\"\\n                                                                       : \\\"vertical-rl\\\";\\n      styles.unicodeBidi = \\\"plaintext\\\";\\n    }\\n    this.applyStyles(styles, this.cueDiv);\\n\\n    // Create an absolutely positioned div that will be used to position the cue\\n    // div. Note, all WebVTT cue-setting alignments are equivalent to the CSS\\n    // mirrors of them except \\\"middle\\\" which is \\\"center\\\" in CSS.\\n    this.div = window.document.createElement(\\\"div\\\");\\n    styles = {\\n      textAlign: cue.align === \\\"middle\\\" ? \\\"center\\\" : cue.align,\\n      font: styleOptions.font,\\n      whiteSpace: \\\"pre-line\\\",\\n      position: \\\"absolute\\\"\\n    };\\n\\n    if (!isIE8) {\\n      styles.direction = determineBidi(this.cueDiv);\\n      styles.writingMode = cue.vertical === \\\"\\\" ? \\\"horizontal-tb\\\"\\n                                               : cue.vertical === \\\"lr\\\" ? \\\"vertical-lr\\\"\\n                                                                       : \\\"vertical-rl\\\".\\n      stylesunicodeBidi =  \\\"plaintext\\\";\\n    }\\n\\n    this.applyStyles(styles);\\n\\n    this.div.appendChild(this.cueDiv);\\n\\n    // Calculate the distance from the reference edge of the viewport to the text\\n    // position of the cue box. The reference edge will be resolved later when\\n    // the box orientation styles are applied.\\n    var textPos = 0;\\n    switch (cue.positionAlign) {\\n    case \\\"start\\\":\\n      textPos = cue.position;\\n      break;\\n    case \\\"middle\\\":\\n      textPos = cue.position - (cue.size / 2);\\n      break;\\n    case \\\"end\\\":\\n      textPos = cue.position - cue.size;\\n      break;\\n    }\\n\\n    // Horizontal box orientation; textPos is the distance from the left edge of the\\n    // area to the left edge of the box and cue.size is the distance extending to\\n    // the right from there.\\n    if (cue.vertical === \\\"\\\") {\\n      this.applyStyles({\\n        left:  this.formatStyle(textPos, \\\"%\\\"),\\n        width: this.formatStyle(cue.size, \\\"%\\\")\\n      });\\n    // Vertical box orientation; textPos is the distance from the top edge of the\\n    // area to the top edge of the box and cue.size is the height extending\\n    // downwards from there.\\n    } else {\\n      this.applyStyles({\\n        top: this.formatStyle(textPos, \\\"%\\\"),\\n        height: this.formatStyle(cue.size, \\\"%\\\")\\n      });\\n    }\\n\\n    this.move = function(box) {\\n      this.applyStyles({\\n        top: this.formatStyle(box.top, \\\"px\\\"),\\n        bottom: this.formatStyle(box.bottom, \\\"px\\\"),\\n        left: this.formatStyle(box.left, \\\"px\\\"),\\n        right: this.formatStyle(box.right, \\\"px\\\"),\\n        height: this.formatStyle(box.height, \\\"px\\\"),\\n        width: this.formatStyle(box.width, \\\"px\\\")\\n      });\\n    };\\n  }\\n  CueStyleBox.prototype = _objCreate(StyleBox.prototype);\\n  CueStyleBox.prototype.constructor = CueStyleBox;\\n\\n  // Represents the co-ordinates of an Element in a way that we can easily\\n  // compute things with such as if it overlaps or intersects with another Element.\\n  // Can initialize it with either a StyleBox or another BoxPosition.\\n  function BoxPosition(obj) {\\n    var isIE8 = (/MSIE\\\\s8\\\\.0/).test(navigator.userAgent);\\n\\n    // Either a BoxPosition was passed in and we need to copy it, or a StyleBox\\n    // was passed in and we need to copy the results of 'getBoundingClientRect'\\n    // as the object returned is readonly. All co-ordinate values are in reference\\n    // to the viewport origin (top left).\\n    var lh, height, width, top;\\n    if (obj.div) {\\n      height = obj.div.offsetHeight;\\n      width = obj.div.offsetWidth;\\n      top = obj.div.offsetTop;\\n\\n      var rects = (rects = obj.div.childNodes) && (rects = rects[0]) &&\\n                  rects.getClientRects && rects.getClientRects();\\n      obj = obj.div.getBoundingClientRect();\\n      // In certain cases the outter div will be slightly larger then the sum of\\n      // the inner div's lines. This could be due to bold text, etc, on some platforms.\\n      // In this case we should get the average line height and use that. This will\\n      // result in the desired behaviour.\\n      lh = rects ? Math.max((rects[0] && rects[0].height) || 0, obj.height / rects.length)\\n                 : 0;\\n\\n    }\\n    this.left = obj.left;\\n    this.right = obj.right;\\n    this.top = obj.top || top;\\n    this.height = obj.height || height;\\n    this.bottom = obj.bottom || (top + (obj.height || height));\\n    this.width = obj.width || width;\\n    this.lineHeight = lh !== undefined ? lh : obj.lineHeight;\\n\\n    if (isIE8 && !this.lineHeight) {\\n      this.lineHeight = 13;\\n    }\\n  }\\n\\n  // Move the box along a particular axis. Optionally pass in an amount to move\\n  // the box. If no amount is passed then the default is the line height of the\\n  // box.\\n  BoxPosition.prototype.move = function(axis, toMove) {\\n    toMove = toMove !== undefined ? toMove : this.lineHeight;\\n    switch (axis) {\\n    case \\\"+x\\\":\\n      this.left += toMove;\\n      this.right += toMove;\\n      break;\\n    case \\\"-x\\\":\\n      this.left -= toMove;\\n      this.right -= toMove;\\n      break;\\n    case \\\"+y\\\":\\n      this.top += toMove;\\n      this.bottom += toMove;\\n      break;\\n    case \\\"-y\\\":\\n      this.top -= toMove;\\n      this.bottom -= toMove;\\n      break;\\n    }\\n  };\\n\\n  // Check if this box overlaps another box, b2.\\n  BoxPosition.prototype.overlaps = function(b2) {\\n    return this.left < b2.right &&\\n           this.right > b2.left &&\\n           this.top < b2.bottom &&\\n           this.bottom > b2.top;\\n  };\\n\\n  // Check if this box overlaps any other boxes in boxes.\\n  BoxPosition.prototype.overlapsAny = function(boxes) {\\n    for (var i = 0; i < boxes.length; i++) {\\n      if (this.overlaps(boxes[i])) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  };\\n\\n  // Check if this box is within another box.\\n  BoxPosition.prototype.within = function(container) {\\n    return this.top >= container.top &&\\n           this.bottom <= container.bottom &&\\n           this.left >= container.left &&\\n           this.right <= container.right;\\n  };\\n\\n  // Check if this box is entirely within the container or it is overlapping\\n  // on the edge opposite of the axis direction passed. For example, if \\\"+x\\\" is\\n  // passed and the box is overlapping on the left edge of the container, then\\n  // return true.\\n  BoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {\\n    switch (axis) {\\n    case \\\"+x\\\":\\n      return this.left < container.left;\\n    case \\\"-x\\\":\\n      return this.right > container.right;\\n    case \\\"+y\\\":\\n      return this.top < container.top;\\n    case \\\"-y\\\":\\n      return this.bottom > container.bottom;\\n    }\\n  };\\n\\n  // Find the percentage of the area that this box is overlapping with another\\n  // box.\\n  BoxPosition.prototype.intersectPercentage = function(b2) {\\n    var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)),\\n        y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)),\\n        intersectArea = x * y;\\n    return intersectArea / (this.height * this.width);\\n  };\\n\\n  // Convert the positions from this box to CSS compatible positions using\\n  // the reference container's positions. This has to be done because this\\n  // box's positions are in reference to the viewport origin, whereas, CSS\\n  // values are in referecne to their respective edges.\\n  BoxPosition.prototype.toCSSCompatValues = function(reference) {\\n    return {\\n      top: this.top - reference.top,\\n      bottom: reference.bottom - this.bottom,\\n      left: this.left - reference.left,\\n      right: reference.right - this.right,\\n      height: this.height,\\n      width: this.width\\n    };\\n  };\\n\\n  // Get an object that represents the box's position without anything extra.\\n  // Can pass a StyleBox, HTMLElement, or another BoxPositon.\\n  BoxPosition.getSimpleBoxPosition = function(obj) {\\n    var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;\\n    var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;\\n    var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;\\n\\n    obj = obj.div ? obj.div.getBoundingClientRect() :\\n                  obj.tagName ? obj.getBoundingClientRect() : obj;\\n    var ret = {\\n      left: obj.left,\\n      right: obj.right,\\n      top: obj.top || top,\\n      height: obj.height || height,\\n      bottom: obj.bottom || (top + (obj.height || height)),\\n      width: obj.width || width\\n    };\\n    return ret;\\n  };\\n\\n  // Move a StyleBox to its specified, or next best, position. The containerBox\\n  // is the box that contains the StyleBox, such as a div. boxPositions are\\n  // a list of other boxes that the styleBox can't overlap with.\\n  function moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {\\n\\n    // Find the best position for a cue box, b, on the video. The axis parameter\\n    // is a list of axis, the order of which, it will move the box along. For example:\\n    // Passing [\\\"+x\\\", \\\"-x\\\"] will move the box first along the x axis in the positive\\n    // direction. If it doesn't find a good position for it there it will then move\\n    // it along the x axis in the negative direction.\\n    function findBestPosition(b, axis) {\\n      var bestPosition,\\n          specifiedPosition = new BoxPosition(b),\\n          percentage = 1; // Highest possible so the first thing we get is better.\\n\\n      for (var i = 0; i < axis.length; i++) {\\n        while (b.overlapsOppositeAxis(containerBox, axis[i]) ||\\n               (b.within(containerBox) && b.overlapsAny(boxPositions))) {\\n          b.move(axis[i]);\\n        }\\n        // We found a spot where we aren't overlapping anything. This is our\\n        // best position.\\n        if (b.within(containerBox)) {\\n          return b;\\n        }\\n        var p = b.intersectPercentage(containerBox);\\n        // If we're outside the container box less then we were on our last try\\n        // then remember this position as the best position.\\n        if (percentage > p) {\\n          bestPosition = new BoxPosition(b);\\n          percentage = p;\\n        }\\n        // Reset the box position to the specified position.\\n        b = new BoxPosition(specifiedPosition);\\n      }\\n      return bestPosition || specifiedPosition;\\n    }\\n\\n    var boxPosition = new BoxPosition(styleBox),\\n        cue = styleBox.cue,\\n        linePos = computeLinePos(cue),\\n        axis = [];\\n\\n    // If we have a line number to align the cue to.\\n    if (cue.snapToLines) {\\n      var size;\\n      switch (cue.vertical) {\\n      case \\\"\\\":\\n        axis = [ \\\"+y\\\", \\\"-y\\\" ];\\n        size = \\\"height\\\";\\n        break;\\n      case \\\"rl\\\":\\n        axis = [ \\\"+x\\\", \\\"-x\\\" ];\\n        size = \\\"width\\\";\\n        break;\\n      case \\\"lr\\\":\\n        axis = [ \\\"-x\\\", \\\"+x\\\" ];\\n        size = \\\"width\\\";\\n        break;\\n      }\\n\\n      var step = boxPosition.lineHeight,\\n          position = step * Math.round(linePos),\\n          maxPosition = containerBox[size] + step,\\n          initialAxis = axis[0];\\n\\n      // If the specified intial position is greater then the max position then\\n      // clamp the box to the amount of steps it would take for the box to\\n      // reach the max position.\\n      if (Math.abs(position) > maxPosition) {\\n        position = position < 0 ? -1 : 1;\\n        position *= Math.ceil(maxPosition / step) * step;\\n      }\\n\\n      // If computed line position returns negative then line numbers are\\n      // relative to the bottom of the video instead of the top. Therefore, we\\n      // need to increase our initial position by the length or width of the\\n      // video, depending on the writing direction, and reverse our axis directions.\\n      if (linePos < 0) {\\n        position += cue.vertical === \\\"\\\" ? containerBox.height : containerBox.width;\\n        axis = axis.reverse();\\n      }\\n\\n      // Move the box to the specified position. This may not be its best\\n      // position.\\n      boxPosition.move(initialAxis, position);\\n\\n    } else {\\n      // If we have a percentage line value for the cue.\\n      var calculatedPercentage = (boxPosition.lineHeight / containerBox.height) * 100;\\n\\n      switch (cue.lineAlign) {\\n      case \\\"middle\\\":\\n        linePos -= (calculatedPercentage / 2);\\n        break;\\n      case \\\"end\\\":\\n        linePos -= calculatedPercentage;\\n        break;\\n      }\\n\\n      // Apply initial line position to the cue box.\\n      switch (cue.vertical) {\\n      case \\\"\\\":\\n        styleBox.applyStyles({\\n          top: styleBox.formatStyle(linePos, \\\"%\\\")\\n        });\\n        break;\\n      case \\\"rl\\\":\\n        styleBox.applyStyles({\\n          left: styleBox.formatStyle(linePos, \\\"%\\\")\\n        });\\n        break;\\n      case \\\"lr\\\":\\n        styleBox.applyStyles({\\n          right: styleBox.formatStyle(linePos, \\\"%\\\")\\n        });\\n        break;\\n      }\\n\\n      axis = [ \\\"+y\\\", \\\"-x\\\", \\\"+x\\\", \\\"-y\\\" ];\\n\\n      // Get the box position again after we've applied the specified positioning\\n      // to it.\\n      boxPosition = new BoxPosition(styleBox);\\n    }\\n\\n    var bestPosition = findBestPosition(boxPosition, axis);\\n    styleBox.move(bestPosition.toCSSCompatValues(containerBox));\\n  }\\n\\n  function WebVTT() {\\n    // Nothing\\n  }\\n\\n  // Helper to allow strings to be decoded instead of the default binary utf8 data.\\n  WebVTT.StringDecoder = function() {\\n    return {\\n      decode: function(data) {\\n        if (!data) {\\n          return \\\"\\\";\\n        }\\n        if (typeof data !== \\\"string\\\") {\\n          throw new Error(\\\"Error - expected string data.\\\");\\n        }\\n        return decodeURIComponent(encodeURIComponent(data));\\n      }\\n    };\\n  };\\n\\n  WebVTT.convertCueToDOMTree = function(window, cuetext) {\\n    if (!window || !cuetext) {\\n      return null;\\n    }\\n    return parseContent(window, cuetext);\\n  };\\n\\n  var FONT_SIZE_PERCENT = 0.05;\\n  var FONT_STYLE = \\\"sans-serif\\\";\\n  var CUE_BACKGROUND_PADDING = \\\"1.5%\\\";\\n\\n  // Runs the processing model over the cues and regions passed to it.\\n  // @param overlay A block level element (usually a div) that the computed cues\\n  //                and regions will be placed into.\\n  WebVTT.processCues = function(window, cues, overlay) {\\n    if (!window || !cues || !overlay) {\\n      return null;\\n    }\\n\\n    // Remove all previous children.\\n    while (overlay.firstChild) {\\n      overlay.removeChild(overlay.firstChild);\\n    }\\n\\n    var paddedOverlay = window.document.createElement(\\\"div\\\");\\n    paddedOverlay.style.position = \\\"absolute\\\";\\n    paddedOverlay.style.left = \\\"0\\\";\\n    paddedOverlay.style.right = \\\"0\\\";\\n    paddedOverlay.style.top = \\\"0\\\";\\n    paddedOverlay.style.bottom = \\\"0\\\";\\n    paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;\\n    overlay.appendChild(paddedOverlay);\\n\\n    // Determine if we need to compute the display states of the cues. This could\\n    // be the case if a cue's state has been changed since the last computation or\\n    // if it has not been computed yet.\\n    function shouldCompute(cues) {\\n      for (var i = 0; i < cues.length; i++) {\\n        if (cues[i].hasBeenReset || !cues[i].displayState) {\\n          return true;\\n        }\\n      }\\n      return false;\\n    }\\n\\n    // We don't need to recompute the cues' display states. Just reuse them.\\n    if (!shouldCompute(cues)) {\\n      for (var i = 0; i < cues.length; i++) {\\n        paddedOverlay.appendChild(cues[i].displayState);\\n      }\\n      return;\\n    }\\n\\n    var boxPositions = [],\\n        containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay),\\n        fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;\\n    var styleOptions = {\\n      font: fontSize + \\\"px \\\" + FONT_STYLE\\n    };\\n\\n    (function() {\\n      var styleBox, cue;\\n\\n      for (var i = 0; i < cues.length; i++) {\\n        cue = cues[i];\\n\\n        // Compute the intial position and styles of the cue div.\\n        styleBox = new CueStyleBox(window, cue, styleOptions);\\n        paddedOverlay.appendChild(styleBox.div);\\n\\n        // Move the cue div to it's correct line position.\\n        moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);\\n\\n        // Remember the computed div so that we don't have to recompute it later\\n        // if we don't have too.\\n        cue.displayState = styleBox.div;\\n\\n        boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));\\n      }\\n    })();\\n  };\\n\\n  WebVTT.Parser = function(window, vttjs, decoder) {\\n    if (!decoder) {\\n      decoder = vttjs;\\n      vttjs = {};\\n    }\\n    if (!vttjs) {\\n      vttjs = {};\\n    }\\n\\n    this.window = window;\\n    this.vttjs = vttjs;\\n    this.state = \\\"INITIAL\\\";\\n    this.buffer = \\\"\\\";\\n    this.decoder = decoder || new TextDecoder(\\\"utf8\\\");\\n    this.regionList = [];\\n  };\\n\\n  WebVTT.Parser.prototype = {\\n    // If the error is a ParsingError then report it to the consumer if\\n    // possible. If it's not a ParsingError then throw it like normal.\\n    reportOrThrowError: function(e) {\\n      if (e instanceof ParsingError) {\\n        this.onparsingerror && this.onparsingerror(e);\\n      } else {\\n        throw e;\\n      }\\n    },\\n    parse: function (data) {\\n      var self = this;\\n\\n      // If there is no data then we won't decode it, but will just try to parse\\n      // whatever is in buffer already. This may occur in circumstances, for\\n      // example when flush() is called.\\n      if (data) {\\n        // Try to decode the data that we received.\\n        self.buffer += self.decoder.decode(data, {stream: true});\\n      }\\n\\n      function collectNextLine() {\\n        var buffer = self.buffer;\\n        var pos = 0;\\n        while (pos < buffer.length && buffer[pos] !== '\\\\r' && buffer[pos] !== '\\\\n') {\\n          ++pos;\\n        }\\n        var line = buffer.substr(0, pos);\\n        // Advance the buffer early in case we fail below.\\n        if (buffer[pos] === '\\\\r') {\\n          ++pos;\\n        }\\n        if (buffer[pos] === '\\\\n') {\\n          ++pos;\\n        }\\n        self.buffer = buffer.substr(pos);\\n        return line;\\n      }\\n\\n      // 3.4 WebVTT region and WebVTT region settings syntax\\n      function parseRegion(input) {\\n        var settings = new Settings();\\n\\n        parseOptions(input, function (k, v) {\\n          switch (k) {\\n          case \\\"id\\\":\\n            settings.set(k, v);\\n            break;\\n          case \\\"width\\\":\\n            settings.percent(k, v);\\n            break;\\n          case \\\"lines\\\":\\n            settings.integer(k, v);\\n            break;\\n          case \\\"regionanchor\\\":\\n          case \\\"viewportanchor\\\":\\n            var xy = v.split(',');\\n            if (xy.length !== 2) {\\n              break;\\n            }\\n            // We have to make sure both x and y parse, so use a temporary\\n            // settings object here.\\n            var anchor = new Settings();\\n            anchor.percent(\\\"x\\\", xy[0]);\\n            anchor.percent(\\\"y\\\", xy[1]);\\n            if (!anchor.has(\\\"x\\\") || !anchor.has(\\\"y\\\")) {\\n              break;\\n            }\\n            settings.set(k + \\\"X\\\", anchor.get(\\\"x\\\"));\\n            settings.set(k + \\\"Y\\\", anchor.get(\\\"y\\\"));\\n            break;\\n          case \\\"scroll\\\":\\n            settings.alt(k, v, [\\\"up\\\"]);\\n            break;\\n          }\\n        }, /=/, /\\\\s/);\\n\\n        // Create the region, using default values for any values that were not\\n        // specified.\\n        if (settings.has(\\\"id\\\")) {\\n          var region = new (self.vttjs.VTTRegion || self.window.VTTRegion)();\\n          region.width = settings.get(\\\"width\\\", 100);\\n          region.lines = settings.get(\\\"lines\\\", 3);\\n          region.regionAnchorX = settings.get(\\\"regionanchorX\\\", 0);\\n          region.regionAnchorY = settings.get(\\\"regionanchorY\\\", 100);\\n          region.viewportAnchorX = settings.get(\\\"viewportanchorX\\\", 0);\\n          region.viewportAnchorY = settings.get(\\\"viewportanchorY\\\", 100);\\n          region.scroll = settings.get(\\\"scroll\\\", \\\"\\\");\\n          // Register the region.\\n          self.onregion && self.onregion(region);\\n          // Remember the VTTRegion for later in case we parse any VTTCues that\\n          // reference it.\\n          self.regionList.push({\\n            id: settings.get(\\\"id\\\"),\\n            region: region\\n          });\\n        }\\n      }\\n\\n      // 3.2 WebVTT metadata header syntax\\n      function parseHeader(input) {\\n        parseOptions(input, function (k, v) {\\n          switch (k) {\\n          case \\\"Region\\\":\\n            // 3.3 WebVTT region metadata header syntax\\n            parseRegion(v);\\n            break;\\n          }\\n        }, /:/);\\n      }\\n\\n      // 5.1 WebVTT file parsing.\\n      try {\\n        var line;\\n        if (self.state === \\\"INITIAL\\\") {\\n          // We can't start parsing until we have the first line.\\n          if (!/\\\\r\\\\n|\\\\n/.test(self.buffer)) {\\n            return this;\\n          }\\n\\n          line = collectNextLine();\\n\\n          var m = line.match(/^WEBVTT([ \\\\t].*)?$/);\\n          if (!m || !m[0]) {\\n            throw new ParsingError(ParsingError.Errors.BadSignature);\\n          }\\n\\n          self.state = \\\"HEADER\\\";\\n        }\\n\\n        var alreadyCollectedLine = false;\\n        while (self.buffer) {\\n          // We can't parse a line until we have the full line.\\n          if (!/\\\\r\\\\n|\\\\n/.test(self.buffer)) {\\n            return this;\\n          }\\n\\n          if (!alreadyCollectedLine) {\\n            line = collectNextLine();\\n          } else {\\n            alreadyCollectedLine = false;\\n          }\\n\\n          switch (self.state) {\\n          case \\\"HEADER\\\":\\n            // 13-18 - Allow a header (metadata) under the WEBVTT line.\\n            if (/:/.test(line)) {\\n              parseHeader(line);\\n            } else if (!line) {\\n              // An empty line terminates the header and starts the body (cues).\\n              self.state = \\\"ID\\\";\\n            }\\n            continue;\\n          case \\\"NOTE\\\":\\n            // Ignore NOTE blocks.\\n            if (!line) {\\n              self.state = \\\"ID\\\";\\n            }\\n            continue;\\n          case \\\"ID\\\":\\n            // Check for the start of NOTE blocks.\\n            if (/^NOTE($|[ \\\\t])/.test(line)) {\\n              self.state = \\\"NOTE\\\";\\n              break;\\n            }\\n            // 19-29 - Allow any number of line terminators, then initialize new cue values.\\n            if (!line) {\\n              continue;\\n            }\\n            self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, \\\"\\\");\\n            self.state = \\\"CUE\\\";\\n            // 30-39 - Check if self line contains an optional identifier or timing data.\\n            if (line.indexOf(\\\"-->\\\") === -1) {\\n              self.cue.id = line;\\n              continue;\\n            }\\n            // Process line as start of a cue.\\n            /*falls through*/\\n          case \\\"CUE\\\":\\n            // 40 - Collect cue timings and settings.\\n            try {\\n              parseCue(line, self.cue, self.regionList);\\n            } catch (e) {\\n              self.reportOrThrowError(e);\\n              // In case of an error ignore rest of the cue.\\n              self.cue = null;\\n              self.state = \\\"BADCUE\\\";\\n              continue;\\n            }\\n            self.state = \\\"CUETEXT\\\";\\n            continue;\\n          case \\\"CUETEXT\\\":\\n            var hasSubstring = line.indexOf(\\\"-->\\\") !== -1;\\n            // 34 - If we have an empty line then report the cue.\\n            // 35 - If we have the special substring '-->' then report the cue,\\n            // but do not collect the line as we need to process the current\\n            // one as a new cue.\\n            if (!line || hasSubstring && (alreadyCollectedLine = true)) {\\n              // We are done parsing self cue.\\n              self.oncue && self.oncue(self.cue);\\n              self.cue = null;\\n              self.state = \\\"ID\\\";\\n              continue;\\n            }\\n            if (self.cue.text) {\\n              self.cue.text += \\\"\\\\n\\\";\\n            }\\n            self.cue.text += line;\\n            continue;\\n          case \\\"BADCUE\\\": // BADCUE\\n            // 54-62 - Collect and discard the remaining cue.\\n            if (!line) {\\n              self.state = \\\"ID\\\";\\n            }\\n            continue;\\n          }\\n        }\\n      } catch (e) {\\n        self.reportOrThrowError(e);\\n\\n        // If we are currently parsing a cue, report what we have.\\n        if (self.state === \\\"CUETEXT\\\" && self.cue && self.oncue) {\\n          self.oncue(self.cue);\\n        }\\n        self.cue = null;\\n        // Enter BADWEBVTT state if header was not parsed correctly otherwise\\n        // another exception occurred so enter BADCUE state.\\n        self.state = self.state === \\\"INITIAL\\\" ? \\\"BADWEBVTT\\\" : \\\"BADCUE\\\";\\n      }\\n      return this;\\n    },\\n    flush: function () {\\n      var self = this;\\n      try {\\n        // Finish decoding the stream.\\n        self.buffer += self.decoder.decode();\\n        // Synthesize the end of the current cue or region.\\n        if (self.cue || self.state === \\\"HEADER\\\") {\\n          self.buffer += \\\"\\\\n\\\\n\\\";\\n          self.parse();\\n        }\\n        // If we've flushed, parsed, and we're still on the INITIAL state then\\n        // that means we don't have enough of the stream to parse the first\\n        // line.\\n        if (self.state === \\\"INITIAL\\\") {\\n          throw new ParsingError(ParsingError.Errors.BadSignature);\\n        }\\n      } catch(e) {\\n        self.reportOrThrowError(e);\\n      }\\n      self.onflush && self.onflush();\\n      return this;\\n    }\\n  };\\n\\n  global.WebVTT = WebVTT;\\n\\n}(this, (this.vttjs || {})));\\n\"\n\n/***/ },\n\n/***/ 830:\n/***/ function(module, exports) {\n\nmodule.exports = \"/**\\n * videojs-contrib-hls\\n * @version 3.5.3\\n * @copyright 2016 Brightcove, Inc\\n * @license Apache-2.0\\n */\\n(function(f){if(typeof exports===\\\"object\\\"&&typeof module!==\\\"undefined\\\"){module.exports=f()}else if(typeof define===\\\"function\\\"&&define.amd){define([],f)}else{var g;if(typeof window!==\\\"undefined\\\"){g=window}else if(typeof global!==\\\"undefined\\\"){g=global}else if(typeof self!==\\\"undefined\\\"){g=self}else{g=this}g.videojsContribHls = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\\\"function\\\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\\\"Cannot find module '\\\"+o+\\\"'\\\");throw f.code=\\\"MODULE_NOT_FOUND\\\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\\\"function\\\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\\n/**\\n * @file ad-cue-tags.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _globalWindow = require('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\n/**\\n * Searches for an ad cue that overlaps with the given mediaTime\\n */\\nvar findAdCue = function findAdCue(track, mediaTime) {\\n  var cues = track.cues;\\n\\n  for (var i = 0; i < cues.length; i++) {\\n    var cue = cues[i];\\n\\n    if (mediaTime >= cue.adStartTime && mediaTime <= cue.adEndTime) {\\n      return cue;\\n    }\\n  }\\n  return null;\\n};\\n\\nvar updateAdCues = function updateAdCues(media, track) {\\n  var offset = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\\n\\n  if (!media.segments) {\\n    return;\\n  }\\n\\n  var mediaTime = offset;\\n  var cue = undefined;\\n\\n  for (var i = 0; i < media.segments.length; i++) {\\n    var segment = media.segments[i];\\n\\n    if (!cue) {\\n      // Since the cues will span for at least the segment duration, adding a fudge\\n      // factor of half segment duration will prevent duplicate cues from being\\n      // created when timing info is not exact (e.g. cue start time initialized\\n      // at 10.006677, but next call mediaTime is 10.003332 )\\n      cue = findAdCue(track, mediaTime + segment.duration / 2);\\n    }\\n\\n    if (cue) {\\n      if ('cueIn' in segment) {\\n        // Found a CUE-IN so end the cue\\n        cue.endTime = mediaTime;\\n        cue.adEndTime = mediaTime;\\n        mediaTime += segment.duration;\\n        cue = null;\\n        continue;\\n      }\\n\\n      if (mediaTime < cue.endTime) {\\n        // Already processed this mediaTime for this cue\\n        mediaTime += segment.duration;\\n        continue;\\n      }\\n\\n      // otherwise extend cue until a CUE-IN is found\\n      cue.endTime += segment.duration;\\n    } else {\\n      if ('cueOut' in segment) {\\n        cue = new _globalWindow2['default'].VTTCue(mediaTime, mediaTime + segment.duration, segment.cueOut);\\n        cue.adStartTime = mediaTime;\\n        // Assumes tag format to be\\n        // #EXT-X-CUE-OUT:30\\n        cue.adEndTime = mediaTime + parseFloat(segment.cueOut);\\n        track.addCue(cue);\\n      }\\n\\n      if ('cueOutCont' in segment) {\\n        // Entered into the middle of an ad cue\\n        var adOffset = undefined;\\n        var adTotal = undefined;\\n\\n        // Assumes tag formate to be\\n        // #EXT-X-CUE-OUT-CONT:10/30\\n\\n        var _segment$cueOutCont$split$map = segment.cueOutCont.split('/').map(parseFloat);\\n\\n        var _segment$cueOutCont$split$map2 = _slicedToArray(_segment$cueOutCont$split$map, 2);\\n\\n        adOffset = _segment$cueOutCont$split$map2[0];\\n        adTotal = _segment$cueOutCont$split$map2[1];\\n\\n        cue = new _globalWindow2['default'].VTTCue(mediaTime, mediaTime + segment.duration, '');\\n        cue.adStartTime = mediaTime - adOffset;\\n        cue.adEndTime = cue.adStartTime + adTotal;\\n        track.addCue(cue);\\n      }\\n    }\\n    mediaTime += segment.duration;\\n  }\\n};\\n\\nexports['default'] = {\\n  updateAdCues: updateAdCues,\\n  findAdCue: findAdCue\\n};\\nmodule.exports = exports['default'];\\n},{\\\"global/window\\\":26}],2:[function(require,module,exports){\\n/**\\n * @file bin-utils.js\\n */\\n\\n/**\\n * convert a TimeRange to text\\n *\\n * @param {TimeRange} range the timerange to use for conversion\\n * @param {Number} i the iterator on the range to convert\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\nvar textRange = function textRange(range, i) {\\n  return range.start(i) + '-' + range.end(i);\\n};\\n\\n/**\\n * format a number as hex string\\n *\\n * @param {Number} e The number\\n * @param {Number} i the iterator\\n */\\nvar formatHexString = function formatHexString(e, i) {\\n  var value = e.toString(16);\\n\\n  return '00'.substring(0, 2 - value.length) + value + (i % 2 ? ' ' : '');\\n};\\nvar formatAsciiString = function formatAsciiString(e) {\\n  if (e >= 0x20 && e < 0x7e) {\\n    return String.fromCharCode(e);\\n  }\\n  return '.';\\n};\\n\\n/**\\n * utils to help dump binary data to the console\\n */\\nvar utils = {\\n  hexDump: function hexDump(data) {\\n    var bytes = Array.prototype.slice.call(data);\\n    var step = 16;\\n    var result = '';\\n    var hex = undefined;\\n    var ascii = undefined;\\n\\n    for (var j = 0; j < bytes.length / step; j++) {\\n      hex = bytes.slice(j * step, j * step + step).map(formatHexString).join('');\\n      ascii = bytes.slice(j * step, j * step + step).map(formatAsciiString).join('');\\n      result += hex + ' ' + ascii + '\\\\n';\\n    }\\n    return result;\\n  },\\n  tagDump: function tagDump(tag) {\\n    return utils.hexDump(tag.bytes);\\n  },\\n  textRanges: function textRanges(ranges) {\\n    var result = '';\\n    var i = undefined;\\n\\n    for (i = 0; i < ranges.length; i++) {\\n      result += textRange(ranges, i) + ' ';\\n    }\\n    return result;\\n  }\\n};\\n\\nexports['default'] = utils;\\nmodule.exports = exports['default'];\\n},{}],3:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports[\\\"default\\\"] = {\\n  GOAL_BUFFER_LENGTH: 30\\n};\\nmodule.exports = exports[\\\"default\\\"];\\n},{}],4:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file gap-skipper.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nvar _ranges = require('./ranges');\\n\\nvar _ranges2 = _interopRequireDefault(_ranges);\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\n// Set of events that reset the gap-skipper logic and clear the timeout\\nvar timerCancelEvents = ['seeking', 'seeked', 'pause', 'playing', 'error'];\\n\\n/**\\n * The gap skipper object handles all scenarios\\n * where the player runs into the end of a buffered\\n * region and there is a buffered region ahead.\\n *\\n * It then handles the skipping behavior by setting a\\n * timer to the size (in time) of the gap. This gives\\n * the hls segment fetcher time to close the gap and\\n * resume playing before the timer is triggered and\\n * the gap skipper simply seeks over the gap as a\\n * last resort to resume playback.\\n *\\n * @class GapSkipper\\n */\\n\\nvar GapSkipper = (function () {\\n  /**\\n   * Represents a GapSKipper object.\\n   * @constructor\\n   * @param {object} options an object that includes the tech and settings\\n   */\\n\\n  function GapSkipper(options) {\\n    var _this = this;\\n\\n    _classCallCheck(this, GapSkipper);\\n\\n    this.tech_ = options.tech;\\n    this.consecutiveUpdates = 0;\\n    this.lastRecordedTime = null;\\n    this.timer_ = null;\\n\\n    if (options.debug) {\\n      this.logger_ = _videoJs2['default'].log.bind(_videoJs2['default'], 'gap-skipper ->');\\n    }\\n    this.logger_('initialize');\\n\\n    var waitingHandler = function waitingHandler() {\\n      return _this.waiting_();\\n    };\\n    var timeupdateHandler = function timeupdateHandler() {\\n      return _this.timeupdate_();\\n    };\\n    var cancelTimerHandler = function cancelTimerHandler() {\\n      return _this.cancelTimer_();\\n    };\\n\\n    this.tech_.on('waiting', waitingHandler);\\n    this.tech_.on('timeupdate', timeupdateHandler);\\n    this.tech_.on(timerCancelEvents, cancelTimerHandler);\\n\\n    // Define the dispose function to clean up our events\\n    this.dispose = function () {\\n      _this.logger_('dispose');\\n      _this.tech_.off('waiting', waitingHandler);\\n      _this.tech_.off('timeupdate', timeupdateHandler);\\n      _this.tech_.off(timerCancelEvents, cancelTimerHandler);\\n      _this.cancelTimer_();\\n    };\\n  }\\n\\n  /**\\n   * Handler for `waiting` events from the player\\n   *\\n   * @private\\n   */\\n\\n  _createClass(GapSkipper, [{\\n    key: 'waiting_',\\n    value: function waiting_() {\\n      if (!this.tech_.seeking()) {\\n        this.setTimer_();\\n      }\\n    }\\n\\n    /**\\n     * The purpose of this function is to emulate the \\\"waiting\\\" event on\\n     * browsers that do not emit it when they are waiting for more\\n     * data to continue playback\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'timeupdate_',\\n    value: function timeupdate_() {\\n      if (this.tech_.paused() || this.tech_.seeking()) {\\n        return;\\n      }\\n\\n      var currentTime = this.tech_.currentTime();\\n\\n      if (this.consecutiveUpdates === 5 && currentTime === this.lastRecordedTime) {\\n        this.consecutiveUpdates++;\\n        this.waiting_();\\n      } else if (currentTime === this.lastRecordedTime) {\\n        this.consecutiveUpdates++;\\n      } else {\\n        this.consecutiveUpdates = 0;\\n        this.lastRecordedTime = currentTime;\\n      }\\n    }\\n\\n    /**\\n     * Cancels any pending timers and resets the 'timeupdate' mechanism\\n     * designed to detect that we are stalled\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'cancelTimer_',\\n    value: function cancelTimer_() {\\n      this.consecutiveUpdates = 0;\\n\\n      if (this.timer_) {\\n        this.logger_('cancelTimer_');\\n        clearTimeout(this.timer_);\\n      }\\n\\n      this.timer_ = null;\\n    }\\n\\n    /**\\n     * Timer callback. If playback still has not proceeded, then we seek\\n     * to the start of the next buffered region.\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'skipTheGap_',\\n    value: function skipTheGap_(scheduledCurrentTime) {\\n      var buffered = this.tech_.buffered();\\n      var currentTime = this.tech_.currentTime();\\n      var nextRange = _ranges2['default'].findNextRange(buffered, currentTime);\\n\\n      this.consecutiveUpdates = 0;\\n      this.timer_ = null;\\n\\n      if (nextRange.length === 0 || currentTime !== scheduledCurrentTime) {\\n        return;\\n      }\\n\\n      this.logger_('skipTheGap_:', 'currentTime:', currentTime, 'scheduled currentTime:', scheduledCurrentTime, 'nextRange start:', nextRange.start(0));\\n\\n      // only seek if we still have not played\\n      this.tech_.setCurrentTime(nextRange.start(0) + _ranges2['default'].TIME_FUDGE_FACTOR);\\n    }\\n  }, {\\n    key: 'gapFromVideoUnderflow_',\\n    value: function gapFromVideoUnderflow_(buffered, currentTime) {\\n      // At least in Chrome, if there is a gap in the video buffer, the audio will continue\\n      // playing for ~3 seconds after the video gap starts. This is done to account for\\n      // video buffer underflow/underrun (note that this is not done when there is audio\\n      // buffer underflow/underrun -- in that case the video will stop as soon as it\\n      // encounters the gap, as audio stalls are more noticeable/jarring to a user than\\n      // video stalls). The player's time will reflect the playthrough of audio, so the\\n      // time will appear as if we are in a buffered region, even if we are stuck in a\\n      // \\\"gap.\\\"\\n      //\\n      // Example:\\n      // video buffer:   0 => 10.1, 10.2 => 20\\n      // audio buffer:   0 => 20\\n      // overall buffer: 0 => 10.1, 10.2 => 20\\n      // current time: 13\\n      //\\n      // Chrome's video froze at 10 seconds, where the video buffer encountered the gap,\\n      // however, the audio continued playing until it reached ~3 seconds past the gap\\n      // (13 seconds), at which point it stops as well. Since current time is past the\\n      // gap, findNextRange will return no ranges.\\n      //\\n      // To check for this issue, we see if there is a gap that starts somewhere within\\n      // a 3 second range (3 seconds +/- 1 second) back from our current time.\\n      var gaps = _ranges2['default'].findGaps(buffered);\\n\\n      for (var i = 0; i < gaps.length; i++) {\\n        var start = gaps.start(i);\\n        var end = gaps.end(i);\\n\\n        // gap is starts no more than 4 seconds back\\n        if (currentTime - start < 4 && currentTime - start > 2) {\\n          return {\\n            start: start,\\n            end: end\\n          };\\n        }\\n      }\\n\\n      return null;\\n    }\\n\\n    /**\\n     * Set a timer to skip the unbuffered region.\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'setTimer_',\\n    value: function setTimer_() {\\n      var buffered = this.tech_.buffered();\\n      var currentTime = this.tech_.currentTime();\\n      var nextRange = _ranges2['default'].findNextRange(buffered, currentTime);\\n\\n      if (this.timer_ !== null) {\\n        return;\\n      }\\n\\n      if (nextRange.length === 0) {\\n        // Even if there is no available next range, there is still a possibility we are\\n        // stuck in a gap due to video underflow.\\n        var gap = this.gapFromVideoUnderflow_(buffered, currentTime);\\n\\n        if (gap) {\\n          this.logger_('setTimer_:', 'Encountered a gap in video', 'from: ', gap.start, 'to: ', gap.end, 'seeking to current time: ', currentTime);\\n          // Even though the video underflowed and was stuck in a gap, the audio overplayed\\n          // the gap, leading currentTime into a buffered range. Seeking to currentTime\\n          // allows the video to catch up to the audio position without losing any audio\\n          // (only suffering ~3 seconds of frozen video and a pause in audio playback).\\n          this.tech_.setCurrentTime(currentTime);\\n        }\\n        return;\\n      }\\n\\n      var difference = nextRange.start(0) - currentTime;\\n\\n      this.logger_('setTimer_:', 'stopped at:', currentTime, 'setting timer for:', difference, 'seeking to:', nextRange.start(0));\\n\\n      this.timer_ = setTimeout(this.skipTheGap_.bind(this), difference * 1000, currentTime);\\n    }\\n\\n    /**\\n     * A debugging logger noop that is set to console.log only if debugging\\n     * is enabled globally\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'logger_',\\n    value: function logger_() {}\\n  }]);\\n\\n  return GapSkipper;\\n})();\\n\\nexports['default'] = GapSkipper;\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./ranges\\\":9}],5:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file hls-audio-track.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _playlistLoader = require('./playlist-loader');\\n\\nvar _playlistLoader2 = _interopRequireDefault(_playlistLoader);\\n\\n/**\\n * HlsAudioTrack extends video.js audio tracks but adds HLS\\n * specific data storage such as playlist loaders, mediaGroups\\n * and default/autoselect\\n *\\n * @param {Object} options options to create HlsAudioTrack with\\n * @class HlsAudioTrack\\n * @extends AudioTrack\\n */\\n\\nvar HlsAudioTrack = (function (_AudioTrack) {\\n  _inherits(HlsAudioTrack, _AudioTrack);\\n\\n  function HlsAudioTrack(options) {\\n    _classCallCheck(this, HlsAudioTrack);\\n\\n    _get(Object.getPrototypeOf(HlsAudioTrack.prototype), 'constructor', this).call(this, {\\n      kind: options['default'] ? 'main' : 'alternative',\\n      enabled: options['default'] || false,\\n      language: options.language,\\n      label: options.label\\n    });\\n\\n    this.hls = options.hls;\\n    this.autoselect = options.autoselect || false;\\n    this['default'] = options['default'] || false;\\n    this.withCredentials = options.withCredentials || false;\\n    this.mediaGroups_ = [];\\n    this.addLoader(options.mediaGroup, options.resolvedUri);\\n  }\\n\\n  /**\\n   * get a PlaylistLoader from this track given a mediaGroup name\\n   *\\n   * @param {String} mediaGroup the mediaGroup to get the loader for\\n   * @return {PlaylistLoader|Null} the PlaylistLoader or null\\n   */\\n\\n  _createClass(HlsAudioTrack, [{\\n    key: 'getLoader',\\n    value: function getLoader(mediaGroup) {\\n      for (var i = 0; i < this.mediaGroups_.length; i++) {\\n        var mgl = this.mediaGroups_[i];\\n\\n        if (mgl.mediaGroup === mediaGroup) {\\n          return mgl.loader;\\n        }\\n      }\\n    }\\n\\n    /**\\n     * add a PlaylistLoader given a mediaGroup, and a uri. for a combined track\\n     * we store null for the playlistloader\\n     *\\n     * @param {String} mediaGroup the mediaGroup to get the loader for\\n     * @param {String} uri the uri to get the audio track/mediaGroup from\\n     */\\n  }, {\\n    key: 'addLoader',\\n    value: function addLoader(mediaGroup) {\\n      var uri = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\\n\\n      var loader = null;\\n\\n      if (uri) {\\n        // TODO: this should probably happen upstream in Master Playlist\\n        // Controller when we can switch PlaylistLoader sources\\n        // then we can just store the uri here instead\\n        loader = new _playlistLoader2['default'](uri, this.hls, this.withCredentials);\\n      }\\n      this.mediaGroups_.push({ mediaGroup: mediaGroup, loader: loader });\\n    }\\n\\n    /**\\n     * remove a playlist loader from a track given the mediaGroup\\n     *\\n     * @param {String} mediaGroup the mediaGroup to remove\\n     */\\n  }, {\\n    key: 'removeLoader',\\n    value: function removeLoader(mediaGroup) {\\n      for (var i = 0; i < this.mediaGroups_.length; i++) {\\n        var mgl = this.mediaGroups_[i];\\n\\n        if (mgl.mediaGroup === mediaGroup) {\\n          if (mgl.loader) {\\n            mgl.loader.dispose();\\n          }\\n          this.mediaGroups_.splice(i, 1);\\n          return;\\n        }\\n      }\\n    }\\n\\n    /**\\n     * Dispose of this audio track and\\n     * the playlist loader that it holds inside\\n     */\\n  }, {\\n    key: 'dispose',\\n    value: function dispose() {\\n      var i = this.mediaGroups_.length;\\n\\n      while (i--) {\\n        this.removeLoader(this.mediaGroups_[i].mediaGroup);\\n      }\\n    }\\n  }]);\\n\\n  return HlsAudioTrack;\\n})(_videoJs.AudioTrack);\\n\\nexports['default'] = HlsAudioTrack;\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./playlist-loader\\\":7}],6:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file master-playlist-controller.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _playlistLoader = require('./playlist-loader');\\n\\nvar _playlistLoader2 = _interopRequireDefault(_playlistLoader);\\n\\nvar _segmentLoader = require('./segment-loader');\\n\\nvar _segmentLoader2 = _interopRequireDefault(_segmentLoader);\\n\\nvar _ranges = require('./ranges');\\n\\nvar _ranges2 = _interopRequireDefault(_ranges);\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\nvar _hlsAudioTrack = require('./hls-audio-track');\\n\\nvar _hlsAudioTrack2 = _interopRequireDefault(_hlsAudioTrack);\\n\\nvar _adCueTags = require('./ad-cue-tags');\\n\\nvar _adCueTags2 = _interopRequireDefault(_adCueTags);\\n\\n// 5 minute blacklist\\nvar BLACKLIST_DURATION = 5 * 60 * 1000;\\nvar Hls = undefined;\\n\\nvar parseCodecs = function parseCodecs(codecs) {\\n  var result = {\\n    codecCount: 0,\\n    videoCodec: null,\\n    audioProfile: null\\n  };\\n\\n  result.codecCount = codecs.split(',').length;\\n  result.codecCount = result.codecCount || 2;\\n\\n  // parse the video codec but ignore the version\\n  result.videoCodec = /(^|\\\\s|,)+(avc1)[^ ,]*/i.exec(codecs);\\n  result.videoCodec = result.videoCodec && result.videoCodec[2];\\n\\n  // parse the last field of the audio codec\\n  result.audioProfile = /(^|\\\\s|,)+mp4a.\\\\d+\\\\.(\\\\d+)/i.exec(codecs);\\n  result.audioProfile = result.audioProfile && result.audioProfile[2];\\n\\n  return result;\\n};\\n\\n/**\\n * the master playlist controller controller all interactons\\n * between playlists and segmentloaders. At this time this mainly\\n * involves a master playlist and a series of audio playlists\\n * if they are available\\n *\\n * @class MasterPlaylistController\\n * @extends videojs.EventTarget\\n */\\n\\nvar MasterPlaylistController = (function (_videojs$EventTarget) {\\n  _inherits(MasterPlaylistController, _videojs$EventTarget);\\n\\n  function MasterPlaylistController(_ref) {\\n    var _this = this;\\n\\n    var url = _ref.url;\\n    var withCredentials = _ref.withCredentials;\\n    var mode = _ref.mode;\\n    var tech = _ref.tech;\\n    var bandwidth = _ref.bandwidth;\\n    var externHls = _ref.externHls;\\n    var useCueTags = _ref.useCueTags;\\n\\n    _classCallCheck(this, MasterPlaylistController);\\n\\n    _get(Object.getPrototypeOf(MasterPlaylistController.prototype), 'constructor', this).call(this);\\n\\n    Hls = externHls;\\n\\n    this.withCredentials = withCredentials;\\n    this.tech_ = tech;\\n    this.hls_ = tech.hls;\\n    this.mode_ = mode;\\n    this.useCueTags_ = useCueTags;\\n    if (this.useCueTags_) {\\n      this.cueTagsTrack_ = this.tech_.addTextTrack('metadata', 'ad-cues');\\n      this.cueTagsTrack_.inBandMetadataTrackDispatchType = '';\\n      this.tech_.textTracks().addTrack_(this.cueTagsTrack_);\\n    }\\n\\n    this.audioTracks_ = [];\\n    this.requestOptions_ = {\\n      withCredentials: this.withCredentials,\\n      timeout: null\\n    };\\n\\n    this.mediaSource = new _videoJs2['default'].MediaSource({ mode: mode });\\n    this.mediaSource.on('audioinfo', function (e) {\\n      return _this.trigger(e);\\n    });\\n    // load the media source into the player\\n    this.mediaSource.addEventListener('sourceopen', this.handleSourceOpen_.bind(this));\\n\\n    var segmentLoaderOptions = {\\n      hls: this.hls_,\\n      mediaSource: this.mediaSource,\\n      currentTime: this.tech_.currentTime.bind(this.tech_),\\n      seekable: function seekable() {\\n        return _this.seekable();\\n      },\\n      seeking: function seeking() {\\n        return _this.tech_.seeking();\\n      },\\n      setCurrentTime: function setCurrentTime(a) {\\n        return _this.tech_.setCurrentTime(a);\\n      },\\n      hasPlayed: function hasPlayed() {\\n        return _this.tech_.played().length !== 0;\\n      },\\n      bandwidth: bandwidth\\n    };\\n\\n    // combined audio/video or just video when alternate audio track is selected\\n    this.mainSegmentLoader_ = new _segmentLoader2['default'](segmentLoaderOptions);\\n    // alternate audio track\\n    this.audioSegmentLoader_ = new _segmentLoader2['default'](segmentLoaderOptions);\\n\\n    if (!url) {\\n      throw new Error('A non-empty playlist URL is required');\\n    }\\n\\n    this.masterPlaylistLoader_ = new _playlistLoader2['default'](url, this.hls_, this.withCredentials);\\n\\n    this.masterPlaylistLoader_.on('loadedmetadata', function () {\\n      var media = _this.masterPlaylistLoader_.media();\\n      var requestTimeout = _this.masterPlaylistLoader_.targetDuration * 1.5 * 1000;\\n\\n      _this.requestOptions_.timeout = requestTimeout;\\n\\n      // if this isn't a live video and preload permits, start\\n      // downloading segments\\n      if (media.endList && _this.tech_.preload() !== 'none') {\\n        _this.mainSegmentLoader_.playlist(media, _this.requestOptions_);\\n        _this.mainSegmentLoader_.expired(_this.masterPlaylistLoader_.expired_);\\n        _this.mainSegmentLoader_.load();\\n      }\\n\\n      _this.setupSourceBuffer_();\\n      _this.setupFirstPlay();\\n      _this.useAudio();\\n    });\\n\\n    this.masterPlaylistLoader_.on('loadedplaylist', function () {\\n      var updatedPlaylist = _this.masterPlaylistLoader_.media();\\n      var seekable = undefined;\\n\\n      if (!updatedPlaylist) {\\n        // select the initial variant\\n        _this.initialMedia_ = _this.selectPlaylist();\\n        _this.masterPlaylistLoader_.media(_this.initialMedia_);\\n        _this.fillAudioTracks_();\\n\\n        _this.trigger('selectedinitialmedia');\\n        return;\\n      }\\n\\n      if (_this.useCueTags_) {\\n        _this.updateAdCues_(updatedPlaylist, _this.masterPlaylistLoader_.expired_);\\n      }\\n\\n      // TODO: Create a new event on the PlaylistLoader that signals\\n      // that the segments have changed in some way and use that to\\n      // update the SegmentLoader instead of doing it twice here and\\n      // on `mediachange`\\n      _this.mainSegmentLoader_.playlist(updatedPlaylist, _this.requestOptions_);\\n      _this.mainSegmentLoader_.expired(_this.masterPlaylistLoader_.expired_);\\n      _this.updateDuration();\\n\\n      // update seekable\\n      seekable = _this.seekable();\\n      if (!updatedPlaylist.endList && seekable.length !== 0) {\\n        _this.mediaSource.addSeekableRange_(seekable.start(0), seekable.end(0));\\n      }\\n    });\\n\\n    this.masterPlaylistLoader_.on('error', function () {\\n      _this.blacklistCurrentPlaylist(_this.masterPlaylistLoader_.error);\\n    });\\n\\n    this.masterPlaylistLoader_.on('mediachanging', function () {\\n      _this.mainSegmentLoader_.abort();\\n      _this.mainSegmentLoader_.pause();\\n    });\\n\\n    this.masterPlaylistLoader_.on('mediachange', function () {\\n      var media = _this.masterPlaylistLoader_.media();\\n      var requestTimeout = _this.masterPlaylistLoader_.targetDuration * 1.5 * 1000;\\n\\n      // If we don't have any more available playlists, we don't want to\\n      // timeout the request.\\n      if (_this.masterPlaylistLoader_.isLowestEnabledRendition_()) {\\n        _this.requestOptions_.timeout = 0;\\n      } else {\\n        _this.requestOptions_.timeout = requestTimeout;\\n      }\\n\\n      // TODO: Create a new event on the PlaylistLoader that signals\\n      // that the segments have changed in some way and use that to\\n      // update the SegmentLoader instead of doing it twice here and\\n      // on `loadedplaylist`\\n      _this.mainSegmentLoader_.playlist(media, _this.requestOptions_);\\n      _this.mainSegmentLoader_.expired(_this.masterPlaylistLoader_.expired_);\\n      _this.mainSegmentLoader_.load();\\n\\n      _this.tech_.trigger({\\n        type: 'mediachange',\\n        bubbles: true\\n      });\\n    });\\n\\n    this.mainSegmentLoader_.on('progress', function () {\\n      // figure out what stream the next segment should be downloaded from\\n      // with the updated bandwidth information\\n      _this.masterPlaylistLoader_.media(_this.selectPlaylist());\\n\\n      _this.trigger('progress');\\n    });\\n\\n    this.mainSegmentLoader_.on('error', function () {\\n      _this.blacklistCurrentPlaylist(_this.mainSegmentLoader_.error());\\n    });\\n\\n    this.audioSegmentLoader_.on('error', function () {\\n      _videoJs2['default'].log.warn('Problem encountered with the current alternate audio track' + '. Switching back to default.');\\n      _this.audioSegmentLoader_.abort();\\n      _this.audioPlaylistLoader_ = null;\\n      _this.useAudio();\\n    });\\n\\n    this.masterPlaylistLoader_.load();\\n  }\\n\\n  /**\\n   * get the total number of media requests from the `audiosegmentloader_`\\n   * and the `mainSegmentLoader_`\\n   *\\n   * @private\\n   */\\n\\n  _createClass(MasterPlaylistController, [{\\n    key: 'mediaRequests_',\\n    value: function mediaRequests_() {\\n      return this.audioSegmentLoader_.mediaRequests + this.mainSegmentLoader_.mediaRequests;\\n    }\\n\\n    /**\\n     * get the total time that media requests have spent trnasfering\\n     * from the `audiosegmentloader_` and the `mainSegmentLoader_`\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'mediaTransferDuration_',\\n    value: function mediaTransferDuration_() {\\n      return this.audioSegmentLoader_.mediaTransferDuration + this.mainSegmentLoader_.mediaTransferDuration;\\n    }\\n\\n    /**\\n     * get the total number of bytes transfered during media requests\\n     * from the `audiosegmentloader_` and the `mainSegmentLoader_`\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'mediaBytesTransferred_',\\n    value: function mediaBytesTransferred_() {\\n      return this.audioSegmentLoader_.mediaBytesTransferred + this.mainSegmentLoader_.mediaBytesTransferred;\\n    }\\n\\n    /**\\n     * fill our internal list of HlsAudioTracks with data from\\n     * the master playlist or use a default\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'fillAudioTracks_',\\n    value: function fillAudioTracks_() {\\n      var master = this.master();\\n      var mediaGroups = master.mediaGroups || {};\\n\\n      // force a default if we have none or we are not\\n      // in html5 mode (the only mode to support more than one\\n      // audio track)\\n      if (!mediaGroups || !mediaGroups.AUDIO || Object.keys(mediaGroups.AUDIO).length === 0 || this.mode_ !== 'html5') {\\n        // \\\"main\\\" audio group, track name \\\"default\\\"\\n        mediaGroups.AUDIO = { main: { 'default': { 'default': true } } };\\n      }\\n\\n      var tracks = {};\\n\\n      for (var mediaGroup in mediaGroups.AUDIO) {\\n        for (var label in mediaGroups.AUDIO[mediaGroup]) {\\n          var properties = mediaGroups.AUDIO[mediaGroup][label];\\n\\n          // if the track already exists add a new \\\"location\\\"\\n          // since tracks in different mediaGroups are actually the same\\n          // track with different locations to download them from\\n          if (tracks[label]) {\\n            tracks[label].addLoader(mediaGroup, properties.resolvedUri);\\n            continue;\\n          }\\n\\n          var track = new _hlsAudioTrack2['default'](_videoJs2['default'].mergeOptions(properties, {\\n            hls: this.hls_,\\n            withCredentials: this.withCredential,\\n            mediaGroup: mediaGroup,\\n            label: label\\n          }));\\n\\n          tracks[label] = track;\\n          this.audioTracks_.push(track);\\n        }\\n      }\\n    }\\n\\n    /**\\n     * Call load on our SegmentLoaders\\n     */\\n  }, {\\n    key: 'load',\\n    value: function load() {\\n      this.mainSegmentLoader_.load();\\n      if (this.audioPlaylistLoader_) {\\n        this.audioSegmentLoader_.load();\\n      }\\n    }\\n\\n    /**\\n     * Get the current active Media Group for Audio\\n     * given the selected playlist and its attributes\\n     */\\n  }, {\\n    key: 'activeAudioGroup',\\n    value: function activeAudioGroup() {\\n      var media = this.masterPlaylistLoader_.media();\\n      var mediaGroup = 'main';\\n\\n      if (media && media.attributes && media.attributes.AUDIO) {\\n        mediaGroup = media.attributes.AUDIO;\\n      }\\n\\n      return mediaGroup;\\n    }\\n\\n    /**\\n     * Use any audio track that we have, and start to load it\\n     */\\n  }, {\\n    key: 'useAudio',\\n    value: function useAudio() {\\n      var _this2 = this;\\n\\n      var track = undefined;\\n\\n      this.audioTracks_.forEach(function (t) {\\n        if (!track && t.enabled) {\\n          track = t;\\n        }\\n      });\\n\\n      // called too early or no track is enabled\\n      if (!track) {\\n        return;\\n      }\\n\\n      // Pause any alternative audio\\n      if (this.audioPlaylistLoader_) {\\n        this.audioPlaylistLoader_.pause();\\n        this.audioPlaylistLoader_ = null;\\n        this.audioSegmentLoader_.pause();\\n      }\\n\\n      // If the audio track for the active audio group has\\n      // a playlist loader than it is an alterative audio track\\n      // otherwise it is a part of the mainSegmenLoader\\n      var loader = track.getLoader(this.activeAudioGroup());\\n\\n      if (!loader) {\\n        this.mainSegmentLoader_.clearBuffer();\\n        return;\\n      }\\n\\n      // TODO: it may be better to create the playlist loader here\\n      // when we can change an audioPlaylistLoaders src\\n      this.audioPlaylistLoader_ = loader;\\n\\n      if (this.audioPlaylistLoader_.started) {\\n        this.audioPlaylistLoader_.load();\\n        this.audioSegmentLoader_.load();\\n        this.audioSegmentLoader_.clearBuffer();\\n        return;\\n      }\\n\\n      this.audioPlaylistLoader_.on('loadedmetadata', function () {\\n        /* eslint-disable no-shadow */\\n        var media = _this2.audioPlaylistLoader_.media();\\n        /* eslint-enable no-shadow */\\n\\n        _this2.audioSegmentLoader_.playlist(media, _this2.requestOptions_);\\n        _this2.addMimeType_(_this2.audioSegmentLoader_, 'mp4a.40.2', media);\\n\\n        // if the video is already playing, or if this isn't a live video and preload\\n        // permits, start downloading segments\\n        if (!_this2.tech_.paused() || media.endList && _this2.tech_.preload() !== 'none') {\\n          _this2.audioSegmentLoader_.load();\\n        }\\n\\n        if (!media.endList) {\\n          // trigger the playlist loader to start \\\"expired time\\\"-tracking\\n          _this2.audioPlaylistLoader_.trigger('firstplay');\\n        }\\n      });\\n\\n      this.audioPlaylistLoader_.on('loadedplaylist', function () {\\n        var updatedPlaylist = undefined;\\n\\n        if (_this2.audioPlaylistLoader_) {\\n          updatedPlaylist = _this2.audioPlaylistLoader_.media();\\n        }\\n\\n        if (!updatedPlaylist) {\\n          // only one playlist to select\\n          _this2.audioPlaylistLoader_.media(_this2.audioPlaylistLoader_.playlists.master.playlists[0]);\\n          return;\\n        }\\n\\n        _this2.audioSegmentLoader_.playlist(updatedPlaylist, _this2.requestOptions_);\\n      });\\n\\n      this.audioPlaylistLoader_.on('error', function () {\\n        _videoJs2['default'].log.warn('Problem encountered loading the alternate audio track' + '. Switching back to default.');\\n        _this2.audioSegmentLoader_.abort();\\n        _this2.audioPlaylistLoader_ = null;\\n        _this2.useAudio();\\n      });\\n\\n      this.audioSegmentLoader_.clearBuffer();\\n      this.audioPlaylistLoader_.start();\\n    }\\n\\n    /**\\n     * Re-tune playback quality level for the current player\\n     * conditions. This method may perform destructive actions, like\\n     * removing already buffered content, to readjust the currently\\n     * active playlist quickly.\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'fastQualityChange_',\\n    value: function fastQualityChange_() {\\n      var media = this.selectPlaylist();\\n\\n      if (media !== this.masterPlaylistLoader_.media()) {\\n        this.masterPlaylistLoader_.media(media);\\n        this.mainSegmentLoader_.sourceUpdater_.remove(this.tech_.currentTime() + 5, Infinity);\\n      }\\n    }\\n\\n    /**\\n     * Begin playback.\\n     */\\n  }, {\\n    key: 'play',\\n    value: function play() {\\n      if (this.setupFirstPlay()) {\\n        return;\\n      }\\n\\n      if (this.tech_.ended()) {\\n        this.tech_.setCurrentTime(0);\\n      }\\n\\n      this.load();\\n\\n      // if the viewer has paused and we fell out of the live window,\\n      // seek forward to the earliest available position\\n      if (this.tech_.duration() === Infinity) {\\n        if (this.tech_.currentTime() < this.tech_.seekable().start(0)) {\\n          return this.tech_.setCurrentTime(this.tech_.seekable().start(0));\\n        }\\n      }\\n    }\\n\\n    /**\\n     * Seek to the latest media position if this is a live video and the\\n     * player and video are loaded and initialized.\\n     */\\n  }, {\\n    key: 'setupFirstPlay',\\n    value: function setupFirstPlay() {\\n      var seekable = undefined;\\n      var media = this.masterPlaylistLoader_.media();\\n\\n      // check that everything is ready to begin buffering\\n      // 1) the active media playlist is available\\n      if (media &&\\n      // 2) the video is a live stream\\n      !media.endList &&\\n\\n      // 3) the player is not paused\\n      !this.tech_.paused() &&\\n\\n      // 4) the player has not started playing\\n      !this.hasPlayed_) {\\n\\n        this.load();\\n\\n        // trigger the playlist loader to start \\\"expired time\\\"-tracking\\n        this.masterPlaylistLoader_.trigger('firstplay');\\n        this.hasPlayed_ = true;\\n\\n        // seek to the latest media position for live videos\\n        seekable = this.seekable();\\n        if (seekable.length) {\\n          this.tech_.setCurrentTime(seekable.end(0));\\n        }\\n\\n        return true;\\n      }\\n      return false;\\n    }\\n\\n    /**\\n     * handle the sourceopen event on the MediaSource\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'handleSourceOpen_',\\n    value: function handleSourceOpen_() {\\n      // Only attempt to create the source buffer if none already exist.\\n      // handleSourceOpen is also called when we are \\\"re-opening\\\" a source buffer\\n      // after `endOfStream` has been called (in response to a seek for instance)\\n      this.setupSourceBuffer_();\\n\\n      // if autoplay is enabled, begin playback. This is duplicative of\\n      // code in video.js but is required because play() must be invoked\\n      // *after* the media source has opened.\\n      if (this.tech_.autoplay()) {\\n        this.tech_.play();\\n      }\\n\\n      this.trigger('sourceopen');\\n    }\\n\\n    /**\\n     * Blacklists a playlist when an error occurs for a set amount of time\\n     * making it unavailable for selection by the rendition selection algorithm\\n     * and then forces a new playlist (rendition) selection.\\n     *\\n     * @param {Object=} error an optional error that may include the playlist\\n     * to blacklist\\n     */\\n  }, {\\n    key: 'blacklistCurrentPlaylist',\\n    value: function blacklistCurrentPlaylist() {\\n      var error = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\\n\\n      var currentPlaylist = undefined;\\n      var nextPlaylist = undefined;\\n\\n      // If the `error` was generated by the playlist loader, it will contain\\n      // the playlist we were trying to load (but failed) and that should be\\n      // blacklisted instead of the currently selected playlist which is likely\\n      // out-of-date in this scenario\\n      currentPlaylist = error.playlist || this.masterPlaylistLoader_.media();\\n\\n      // If there is no current playlist, then an error occurred while we were\\n      // trying to load the master OR while we were disposing of the tech\\n      if (!currentPlaylist) {\\n        this.error = error;\\n        return this.mediaSource.endOfStream('network');\\n      }\\n\\n      // Blacklist this playlist\\n      currentPlaylist.excludeUntil = Date.now() + BLACKLIST_DURATION;\\n\\n      // Select a new playlist\\n      nextPlaylist = this.selectPlaylist();\\n\\n      if (nextPlaylist) {\\n        _videoJs2['default'].log.warn('Problem encountered with the current ' + 'HLS playlist. Switching to another playlist.');\\n\\n        return this.masterPlaylistLoader_.media(nextPlaylist);\\n      }\\n      _videoJs2['default'].log.warn('Problem encountered with the current ' + 'HLS playlist. No suitable alternatives found.');\\n      // We have no more playlists we can select so we must fail\\n      this.error = error;\\n      return this.mediaSource.endOfStream('network');\\n    }\\n\\n    /**\\n     * Pause all segment loaders\\n     */\\n  }, {\\n    key: 'pauseLoading',\\n    value: function pauseLoading() {\\n      this.mainSegmentLoader_.pause();\\n      if (this.audioPlaylistLoader_) {\\n        this.audioSegmentLoader_.pause();\\n      }\\n    }\\n\\n    /**\\n     * set the current time on all segment loaders\\n     *\\n     * @param {TimeRange} currentTime the current time to set\\n     * @return {TimeRange} the current time\\n     */\\n  }, {\\n    key: 'setCurrentTime',\\n    value: function setCurrentTime(currentTime) {\\n      var buffered = _ranges2['default'].findRange(this.tech_.buffered(), currentTime);\\n\\n      if (!(this.masterPlaylistLoader_ && this.masterPlaylistLoader_.media())) {\\n        // return immediately if the metadata is not ready yet\\n        return 0;\\n      }\\n\\n      // it's clearly an edge-case but don't thrown an error if asked to\\n      // seek within an empty playlist\\n      if (!this.masterPlaylistLoader_.media().segments) {\\n        return 0;\\n      }\\n\\n      // if the seek location is already buffered, continue buffering as\\n      // usual\\n      if (buffered && buffered.length) {\\n        return currentTime;\\n      }\\n\\n      // cancel outstanding requests so we begin buffering at the new\\n      // location\\n      this.mainSegmentLoader_.abort();\\n      if (this.audioPlaylistLoader_) {\\n        this.audioSegmentLoader_.abort();\\n      }\\n\\n      if (!this.tech_.paused()) {\\n        this.mainSegmentLoader_.load();\\n        if (this.audioPlaylistLoader_) {\\n          this.audioSegmentLoader_.load();\\n        }\\n      }\\n    }\\n\\n    /**\\n     * get the current duration\\n     *\\n     * @return {TimeRange} the duration\\n     */\\n  }, {\\n    key: 'duration',\\n    value: function duration() {\\n      if (!this.masterPlaylistLoader_) {\\n        return 0;\\n      }\\n\\n      if (this.mediaSource) {\\n        return this.mediaSource.duration;\\n      }\\n\\n      return Hls.Playlist.duration(this.masterPlaylistLoader_.media());\\n    }\\n\\n    /**\\n     * check the seekable range\\n     *\\n     * @return {TimeRange} the seekable range\\n     */\\n  }, {\\n    key: 'seekable',\\n    value: function seekable() {\\n      var media = undefined;\\n      var mainSeekable = undefined;\\n      var audioSeekable = undefined;\\n\\n      if (!this.masterPlaylistLoader_) {\\n        return _videoJs2['default'].createTimeRanges();\\n      }\\n      media = this.masterPlaylistLoader_.media();\\n      if (!media) {\\n        return _videoJs2['default'].createTimeRanges();\\n      }\\n\\n      mainSeekable = Hls.Playlist.seekable(media, this.masterPlaylistLoader_.expired_);\\n      if (mainSeekable.length === 0) {\\n        return mainSeekable;\\n      }\\n\\n      if (this.audioPlaylistLoader_) {\\n        audioSeekable = Hls.Playlist.seekable(this.audioPlaylistLoader_.media(), this.audioPlaylistLoader_.expired_);\\n        if (audioSeekable.length === 0) {\\n          return audioSeekable;\\n        }\\n      }\\n\\n      if (!audioSeekable) {\\n        // seekable has been calculated based on buffering video data so it\\n        // can be returned directly\\n        return mainSeekable;\\n      }\\n\\n      return _videoJs2['default'].createTimeRanges([[audioSeekable.start(0) > mainSeekable.start(0) ? audioSeekable.start(0) : mainSeekable.start(0), audioSeekable.end(0) < mainSeekable.end(0) ? audioSeekable.end(0) : mainSeekable.end(0)]]);\\n    }\\n\\n    /**\\n     * Update the player duration\\n     */\\n  }, {\\n    key: 'updateDuration',\\n    value: function updateDuration() {\\n      var _this3 = this;\\n\\n      var oldDuration = this.mediaSource.duration;\\n      var newDuration = Hls.Playlist.duration(this.masterPlaylistLoader_.media());\\n      var buffered = this.tech_.buffered();\\n      var setDuration = function setDuration() {\\n        _this3.mediaSource.duration = newDuration;\\n        _this3.tech_.trigger('durationchange');\\n\\n        _this3.mediaSource.removeEventListener('sourceopen', setDuration);\\n      };\\n\\n      if (buffered.length > 0) {\\n        newDuration = Math.max(newDuration, buffered.end(buffered.length - 1));\\n      }\\n\\n      // if the duration has changed, invalidate the cached value\\n      if (oldDuration !== newDuration) {\\n        // update the duration\\n        if (this.mediaSource.readyState !== 'open') {\\n          this.mediaSource.addEventListener('sourceopen', setDuration);\\n        } else {\\n          setDuration();\\n        }\\n      }\\n    }\\n\\n    /**\\n     * dispose of the MasterPlaylistController and everything\\n     * that it controls\\n     */\\n  }, {\\n    key: 'dispose',\\n    value: function dispose() {\\n      this.masterPlaylistLoader_.dispose();\\n      this.audioTracks_.forEach(function (track) {\\n        track.dispose();\\n      });\\n      this.audioTracks_.length = 0;\\n      this.mainSegmentLoader_.dispose();\\n      this.audioSegmentLoader_.dispose();\\n    }\\n\\n    /**\\n     * return the master playlist object if we have one\\n     *\\n     * @return {Object} the master playlist object that we parsed\\n     */\\n  }, {\\n    key: 'master',\\n    value: function master() {\\n      return this.masterPlaylistLoader_.master;\\n    }\\n\\n    /**\\n     * return the currently selected playlist\\n     *\\n     * @return {Object} the currently selected playlist object that we parsed\\n     */\\n  }, {\\n    key: 'media',\\n    value: function media() {\\n      // playlist loader will not return media if it has not been fully loaded\\n      return this.masterPlaylistLoader_.media() || this.initialMedia_;\\n    }\\n\\n    /**\\n     * setup our internal source buffers on our segment Loaders\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'setupSourceBuffer_',\\n    value: function setupSourceBuffer_() {\\n      var media = this.masterPlaylistLoader_.media();\\n\\n      // wait until a media playlist is available and the Media Source is\\n      // attached\\n      if (!media || this.mediaSource.readyState !== 'open') {\\n        return;\\n      }\\n\\n      this.addMimeType_(this.mainSegmentLoader_, 'avc1.4d400d, mp4a.40.2', media);\\n\\n      // exclude any incompatible variant streams from future playlist\\n      // selection\\n      this.excludeIncompatibleVariants_(media);\\n    }\\n\\n    /**\\n     * add a time type to a segmentLoader\\n     *\\n     * @param {SegmentLoader} segmentLoader the segmentloader to work on\\n     * @param {String} codecs to use by default\\n     * @param {Object} the parsed media object\\n     * @private\\n     */\\n  }, {\\n    key: 'addMimeType_',\\n    value: function addMimeType_(segmentLoader, defaultCodecs, media) {\\n      var mimeType = 'video/mp2t';\\n\\n      // if the codecs were explicitly specified, pass them along to the\\n      // source buffer\\n      if (media.attributes && media.attributes.CODECS) {\\n        mimeType += '; codecs=\\\"' + media.attributes.CODECS + '\\\"';\\n      } else {\\n        mimeType += '; codecs=\\\"' + defaultCodecs + '\\\"';\\n      }\\n      segmentLoader.mimeType(mimeType);\\n    }\\n\\n    /**\\n     * Blacklist playlists that are known to be codec or\\n     * stream-incompatible with the SourceBuffer configuration. For\\n     * instance, Media Source Extensions would cause the video element to\\n     * stall waiting for video data if you switched from a variant with\\n     * video and audio to an audio-only one.\\n     *\\n     * @param {Object} media a media playlist compatible with the current\\n     * set of SourceBuffers. Variants in the current master playlist that\\n     * do not appear to have compatible codec or stream configurations\\n     * will be excluded from the default playlist selection algorithm\\n     * indefinitely.\\n     * @private\\n     */\\n  }, {\\n    key: 'excludeIncompatibleVariants_',\\n    value: function excludeIncompatibleVariants_(media) {\\n      var master = this.masterPlaylistLoader_.master;\\n      var codecCount = 2;\\n      var videoCodec = null;\\n      var audioProfile = null;\\n      var codecs = undefined;\\n\\n      if (media.attributes && media.attributes.CODECS) {\\n        codecs = parseCodecs(media.attributes.CODECS);\\n        videoCodec = codecs.videoCodec;\\n        audioProfile = codecs.audioProfile;\\n        codecCount = codecs.codecCount;\\n      }\\n      master.playlists.forEach(function (variant) {\\n        var variantCodecs = {\\n          codecCount: 2,\\n          videoCodec: null,\\n          audioProfile: null\\n        };\\n\\n        if (variant.attributes && variant.attributes.CODECS) {\\n          variantCodecs = parseCodecs(variant.attributes.CODECS);\\n        }\\n\\n        // if the streams differ in the presence or absence of audio or\\n        // video, they are incompatible\\n        if (variantCodecs.codecCount !== codecCount) {\\n          variant.excludeUntil = Infinity;\\n        }\\n\\n        // if h.264 is specified on the current playlist, some flavor of\\n        // it must be specified on all compatible variants\\n        if (variantCodecs.videoCodec !== videoCodec) {\\n          variant.excludeUntil = Infinity;\\n        }\\n        // HE-AAC (\\\"mp4a.40.5\\\") is incompatible with all other versions of\\n        // AAC audio in Chrome 46. Don't mix the two.\\n        if (variantCodecs.audioProfile === '5' && audioProfile !== '5' || audioProfile === '5' && variantCodecs.audioProfile !== '5') {\\n          variant.excludeUntil = Infinity;\\n        }\\n      });\\n    }\\n  }, {\\n    key: 'updateAdCues_',\\n    value: function updateAdCues_(media) {\\n      var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\\n\\n      _adCueTags2['default'].updateAdCues(media, this.cueTagsTrack_, offset);\\n    }\\n  }]);\\n\\n  return MasterPlaylistController;\\n})(_videoJs2['default'].EventTarget);\\n\\nexports['default'] = MasterPlaylistController;\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./ad-cue-tags\\\":1,\\\"./hls-audio-track\\\":5,\\\"./playlist-loader\\\":7,\\\"./ranges\\\":9,\\\"./segment-loader\\\":12}],7:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file playlist-loader.js\\n *\\n * A state machine that manages the loading, caching, and updating of\\n * M3U8 playlists.\\n *\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _resolveUrl = require('./resolve-url');\\n\\nvar _resolveUrl2 = _interopRequireDefault(_resolveUrl);\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _stream = require('./stream');\\n\\nvar _stream2 = _interopRequireDefault(_stream);\\n\\nvar _m3u8Parser = require('m3u8-parser');\\n\\nvar _m3u8Parser2 = _interopRequireDefault(_m3u8Parser);\\n\\nvar _globalWindow = require('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\n/**\\n  * Returns a new array of segments that is the result of merging\\n  * properties from an older list of segments onto an updated\\n  * list. No properties on the updated playlist will be overridden.\\n  *\\n  * @param {Array} original the outdated list of segments\\n  * @param {Array} update the updated list of segments\\n  * @param {Number=} offset the index of the first update\\n  * segment in the original segment list. For non-live playlists,\\n  * this should always be zero and does not need to be\\n  * specified. For live playlists, it should be the difference\\n  * between the media sequence numbers in the original and updated\\n  * playlists.\\n  * @return a list of merged segment objects\\n  */\\nvar updateSegments = function updateSegments(original, update, offset) {\\n  var result = update.slice();\\n  var length = undefined;\\n  var i = undefined;\\n\\n  offset = offset || 0;\\n  length = Math.min(original.length, update.length + offset);\\n\\n  for (i = offset; i < length; i++) {\\n    result[i - offset] = (0, _videoJs.mergeOptions)(original[i], result[i - offset]);\\n  }\\n  return result;\\n};\\n\\n/**\\n  * Returns a new master playlist that is the result of merging an\\n  * updated media playlist into the original version. If the\\n  * updated media playlist does not match any of the playlist\\n  * entries in the original master playlist, null is returned.\\n  *\\n  * @param {Object} master a parsed master M3U8 object\\n  * @param {Object} media a parsed media M3U8 object\\n  * @return {Object} a new object that represents the original\\n  * master playlist with the updated media playlist merged in, or\\n  * null if the merge produced no change.\\n  */\\nvar updateMaster = function updateMaster(master, media) {\\n  var changed = false;\\n  var result = (0, _videoJs.mergeOptions)(master, {});\\n  var i = master.playlists.length;\\n  var playlist = undefined;\\n  var segment = undefined;\\n  var j = undefined;\\n\\n  while (i--) {\\n    playlist = result.playlists[i];\\n    if (playlist.uri === media.uri) {\\n      // consider the playlist unchanged if the number of segments\\n      // are equal and the media sequence number is unchanged\\n      if (playlist.segments && media.segments && playlist.segments.length === media.segments.length && playlist.mediaSequence === media.mediaSequence) {\\n        continue;\\n      }\\n\\n      result.playlists[i] = (0, _videoJs.mergeOptions)(playlist, media);\\n      result.playlists[media.uri] = result.playlists[i];\\n\\n      // if the update could overlap existing segment information,\\n      // merge the two lists\\n      if (playlist.segments) {\\n        result.playlists[i].segments = updateSegments(playlist.segments, media.segments, media.mediaSequence - playlist.mediaSequence);\\n      }\\n      // resolve any missing segment and key URIs\\n      j = 0;\\n      if (result.playlists[i].segments) {\\n        j = result.playlists[i].segments.length;\\n      }\\n      while (j--) {\\n        segment = result.playlists[i].segments[j];\\n        if (!segment.resolvedUri) {\\n          segment.resolvedUri = (0, _resolveUrl2['default'])(playlist.resolvedUri, segment.uri);\\n        }\\n        if (segment.key && !segment.key.resolvedUri) {\\n          segment.key.resolvedUri = (0, _resolveUrl2['default'])(playlist.resolvedUri, segment.key.uri);\\n        }\\n      }\\n      changed = true;\\n    }\\n  }\\n  return changed ? result : null;\\n};\\n\\n/**\\n * Load a playlist from a remote loacation\\n *\\n * @class PlaylistLoader\\n * @extends Stream\\n * @param {String} srcUrl the url to start with\\n * @param {Boolean} withCredentials the withCredentials xhr option\\n * @constructor\\n */\\nvar PlaylistLoader = function PlaylistLoader(srcUrl, hls, withCredentials) {\\n  var _this = this;\\n\\n  /* eslint-disable consistent-this */\\n  var loader = this;\\n  /* eslint-enable consistent-this */\\n  var dispose = undefined;\\n  var mediaUpdateTimeout = undefined;\\n  var request = undefined;\\n  var playlistRequestError = undefined;\\n  var haveMetadata = undefined;\\n\\n  PlaylistLoader.prototype.constructor.call(this);\\n\\n  this.hls_ = hls;\\n\\n  // a flag that disables \\\"expired time\\\"-tracking this setting has\\n  // no effect when not playing a live stream\\n  this.trackExpiredTime_ = false;\\n\\n  if (!srcUrl) {\\n    throw new Error('A non-empty playlist URL is required');\\n  }\\n\\n  playlistRequestError = function (xhr, url, startingState) {\\n    loader.setBandwidth(request || xhr);\\n\\n    // any in-flight request is now finished\\n    request = null;\\n\\n    if (startingState) {\\n      loader.state = startingState;\\n    }\\n\\n    loader.error = {\\n      playlist: loader.master.playlists[url],\\n      status: xhr.status,\\n      message: 'HLS playlist request error at URL: ' + url,\\n      responseText: xhr.responseText,\\n      code: xhr.status >= 500 ? 4 : 2\\n    };\\n\\n    loader.trigger('error');\\n  };\\n\\n  // update the playlist loader's state in response to a new or\\n  // updated playlist.\\n  haveMetadata = function (xhr, url) {\\n    var parser = undefined;\\n    var refreshDelay = undefined;\\n    var update = undefined;\\n\\n    loader.setBandwidth(request || xhr);\\n\\n    // any in-flight request is now finished\\n    request = null;\\n\\n    loader.state = 'HAVE_METADATA';\\n\\n    parser = new _m3u8Parser2['default'].Parser();\\n\\n    parser.push(xhr.responseText);\\n    parser.end();\\n    parser.manifest.uri = url;\\n\\n    // merge this playlist into the master\\n    update = updateMaster(loader.master, parser.manifest);\\n    refreshDelay = (parser.manifest.targetDuration || 10) * 1000;\\n    loader.targetDuration = parser.manifest.targetDuration;\\n    if (update) {\\n      loader.master = update;\\n      loader.updateMediaPlaylist_(parser.manifest);\\n    } else {\\n      // if the playlist is unchanged since the last reload,\\n      // try again after half the target duration\\n      refreshDelay /= 2;\\n    }\\n\\n    // refresh live playlists after a target duration passes\\n    if (!loader.media().endList) {\\n      _globalWindow2['default'].clearTimeout(mediaUpdateTimeout);\\n      mediaUpdateTimeout = _globalWindow2['default'].setTimeout(function () {\\n        loader.trigger('mediaupdatetimeout');\\n      }, refreshDelay);\\n    }\\n\\n    loader.trigger('loadedplaylist');\\n  };\\n\\n  // initialize the loader state\\n  loader.state = 'HAVE_NOTHING';\\n\\n  // track the time that has expired from the live window\\n  // this allows the seekable start range to be calculated even if\\n  // all segments with timing information have expired\\n  this.expired_ = 0;\\n\\n  // capture the prototype dispose function\\n  dispose = this.dispose;\\n\\n  /**\\n   * Abort any outstanding work and clean up.\\n   */\\n  loader.dispose = function () {\\n    loader.stopRequest();\\n    _globalWindow2['default'].clearTimeout(mediaUpdateTimeout);\\n    dispose.call(this);\\n  };\\n\\n  loader.stopRequest = function () {\\n    if (request) {\\n      var oldRequest = request;\\n\\n      request = null;\\n      oldRequest.onreadystatechange = null;\\n      oldRequest.abort();\\n    }\\n  };\\n\\n  /**\\n   * Returns the number of enabled playlists on the master playlist object\\n   *\\n   * @return {Number} number of eneabled playlists\\n   */\\n  loader.enabledPlaylists_ = function () {\\n    return loader.master.playlists.filter(function (element, index, array) {\\n      return !element.excludeUntil || element.excludeUntil <= Date.now();\\n    }).length;\\n  };\\n\\n  /**\\n   * Returns whether the current playlist is the lowest rendition\\n   *\\n   * @return {Boolean} true if on lowest rendition\\n   */\\n  loader.isLowestEnabledRendition_ = function () {\\n    if (!loader.media()) {\\n      return false;\\n    }\\n\\n    var currentPlaylist = loader.media().attributes.BANDWIDTH;\\n\\n    return !(loader.master.playlists.filter(function (element, index, array) {\\n      var enabled = typeof element.excludeUntil === 'undefined' || element.excludeUntil <= Date.now();\\n\\n      if (!enabled) {\\n        return false;\\n      }\\n\\n      var item = element.attributes.BANDWIDTH;\\n\\n      return item <= currentPlaylist;\\n    }).length > 1);\\n  };\\n\\n  /**\\n   * When called without any arguments, returns the currently\\n   * active media playlist. When called with a single argument,\\n   * triggers the playlist loader to asynchronously switch to the\\n   * specified media playlist. Calling this method while the\\n   * loader is in the HAVE_NOTHING causes an error to be emitted\\n   * but otherwise has no effect.\\n   *\\n   * @param {Object=} playlis tthe parsed media playlist\\n   * object to switch to\\n   * @return {Playlist} the current loaded media\\n   */\\n  loader.media = function (playlist) {\\n    var startingState = loader.state;\\n    var mediaChange = undefined;\\n\\n    // getter\\n    if (!playlist) {\\n      return loader.media_;\\n    }\\n\\n    // setter\\n    if (loader.state === 'HAVE_NOTHING') {\\n      throw new Error('Cannot switch media playlist from ' + loader.state);\\n    }\\n\\n    // find the playlist object if the target playlist has been\\n    // specified by URI\\n    if (typeof playlist === 'string') {\\n      if (!loader.master.playlists[playlist]) {\\n        throw new Error('Unknown playlist URI: ' + playlist);\\n      }\\n      playlist = loader.master.playlists[playlist];\\n    }\\n\\n    mediaChange = !loader.media_ || playlist.uri !== loader.media_.uri;\\n\\n    // switch to fully loaded playlists immediately\\n    if (loader.master.playlists[playlist.uri].endList) {\\n      // abort outstanding playlist requests\\n      if (request) {\\n        request.onreadystatechange = null;\\n        request.abort();\\n        request = null;\\n      }\\n      loader.state = 'HAVE_METADATA';\\n      loader.media_ = playlist;\\n\\n      // trigger media change if the active media has been updated\\n      if (mediaChange) {\\n        loader.trigger('mediachanging');\\n        loader.trigger('mediachange');\\n      }\\n      return;\\n    }\\n\\n    // switching to the active playlist is a no-op\\n    if (!mediaChange) {\\n      return;\\n    }\\n\\n    loader.state = 'SWITCHING_MEDIA';\\n\\n    // there is already an outstanding playlist request\\n    if (request) {\\n      if ((0, _resolveUrl2['default'])(loader.master.uri, playlist.uri) === request.url) {\\n        // requesting to switch to the same playlist multiple times\\n        // has no effect after the first\\n        return;\\n      }\\n      request.onreadystatechange = null;\\n      request.abort();\\n      request = null;\\n    }\\n\\n    // request the new playlist\\n    if (this.media_) {\\n      this.trigger('mediachanging');\\n    }\\n    request = this.hls_.xhr({\\n      uri: (0, _resolveUrl2['default'])(loader.master.uri, playlist.uri),\\n      withCredentials: withCredentials\\n    }, function (error, req) {\\n      // disposed\\n      if (!request) {\\n        return;\\n      }\\n\\n      if (error) {\\n        return playlistRequestError(request, playlist.uri, startingState);\\n      }\\n\\n      haveMetadata(req, playlist.uri);\\n\\n      // fire loadedmetadata the first time a media playlist is loaded\\n      if (startingState === 'HAVE_MASTER') {\\n        loader.trigger('loadedmetadata');\\n      } else {\\n        loader.trigger('mediachange');\\n      }\\n    });\\n  };\\n\\n  /**\\n   * set the bandwidth on an xhr to the bandwidth on the playlist\\n   */\\n  loader.setBandwidth = function (xhr) {\\n    loader.bandwidth = xhr.bandwidth;\\n  };\\n\\n  // In a live playlist, don't keep track of the expired time\\n  // until HLS tells us that \\\"first play\\\" has commenced\\n  loader.on('firstplay', function () {\\n    this.trackExpiredTime_ = true;\\n  });\\n\\n  // live playlist staleness timeout\\n  loader.on('mediaupdatetimeout', function () {\\n    if (loader.state !== 'HAVE_METADATA') {\\n      // only refresh the media playlist if no other activity is going on\\n      return;\\n    }\\n\\n    loader.state = 'HAVE_CURRENT_METADATA';\\n    request = this.hls_.xhr({\\n      uri: (0, _resolveUrl2['default'])(loader.master.uri, loader.media().uri),\\n      withCredentials: withCredentials\\n    }, function (error, req) {\\n      // disposed\\n      if (!request) {\\n        return;\\n      }\\n\\n      if (error) {\\n        return playlistRequestError(request, loader.media().uri);\\n      }\\n      haveMetadata(request, loader.media().uri);\\n    });\\n  });\\n\\n  /**\\n   * pause loading of the playlist\\n   */\\n  loader.pause = function () {\\n    loader.stopRequest();\\n    _globalWindow2['default'].clearTimeout(mediaUpdateTimeout);\\n  };\\n\\n  /**\\n   * start loading of the playlist\\n   */\\n  loader.load = function () {\\n    if (loader.started) {\\n      if (!loader.media().endList) {\\n        loader.trigger('mediaupdatetimeout');\\n      } else {\\n        loader.trigger('loadedplaylist');\\n      }\\n    } else {\\n      loader.start();\\n    }\\n  };\\n\\n  /**\\n   * start loading of the playlist\\n   */\\n  loader.start = function () {\\n    loader.started = true;\\n\\n    // request the specified URL\\n    request = _this.hls_.xhr({\\n      uri: srcUrl,\\n      withCredentials: withCredentials\\n    }, function (error, req) {\\n      var parser = undefined;\\n      var playlist = undefined;\\n      var i = undefined;\\n\\n      // disposed\\n      if (!request) {\\n        return;\\n      }\\n\\n      // clear the loader's request reference\\n      request = null;\\n\\n      if (error) {\\n        loader.error = {\\n          status: req.status,\\n          message: 'HLS playlist request error at URL: ' + srcUrl,\\n          responseText: req.responseText,\\n          // MEDIA_ERR_NETWORK\\n          code: 2\\n        };\\n        return loader.trigger('error');\\n      }\\n\\n      parser = new _m3u8Parser2['default'].Parser();\\n      parser.push(req.responseText);\\n      parser.end();\\n\\n      loader.state = 'HAVE_MASTER';\\n\\n      parser.manifest.uri = srcUrl;\\n\\n      // loaded a master playlist\\n      if (parser.manifest.playlists) {\\n        loader.master = parser.manifest;\\n\\n        // setup by-URI lookups and resolve media playlist URIs\\n        i = loader.master.playlists.length;\\n        while (i--) {\\n          playlist = loader.master.playlists[i];\\n          loader.master.playlists[playlist.uri] = playlist;\\n          playlist.resolvedUri = (0, _resolveUrl2['default'])(loader.master.uri, playlist.uri);\\n        }\\n\\n        // resolve any media group URIs\\n        for (var groupKey in loader.master.mediaGroups.AUDIO) {\\n          for (var labelKey in loader.master.mediaGroups.AUDIO[groupKey]) {\\n            var alternateAudio = loader.master.mediaGroups.AUDIO[groupKey][labelKey];\\n\\n            if (alternateAudio.uri) {\\n              alternateAudio.resolvedUri = (0, _resolveUrl2['default'])(loader.master.uri, alternateAudio.uri);\\n            }\\n          }\\n        }\\n\\n        loader.trigger('loadedplaylist');\\n        if (!request) {\\n          // no media playlist was specifically selected so start\\n          // from the first listed one\\n          loader.media(parser.manifest.playlists[0]);\\n        }\\n        return;\\n      }\\n\\n      // loaded a media playlist\\n      // infer a master playlist if none was previously requested\\n      loader.master = {\\n        uri: _globalWindow2['default'].location.href,\\n        playlists: [{\\n          uri: srcUrl\\n        }]\\n      };\\n      loader.master.playlists[srcUrl] = loader.master.playlists[0];\\n      loader.master.playlists[0].resolvedUri = srcUrl;\\n      haveMetadata(req, srcUrl);\\n      return loader.trigger('loadedmetadata');\\n    });\\n  };\\n};\\n\\nPlaylistLoader.prototype = new _stream2['default']();\\n\\n/**\\n * Update the PlaylistLoader state to reflect the changes in an\\n * update to the current media playlist.\\n *\\n * @param {Object} update the updated media playlist object\\n */\\nPlaylistLoader.prototype.updateMediaPlaylist_ = function (update) {\\n  var outdated = undefined;\\n  var i = undefined;\\n  var segment = undefined;\\n\\n  outdated = this.media_;\\n  this.media_ = this.master.playlists[update.uri];\\n\\n  if (!outdated) {\\n    return;\\n  }\\n\\n  // don't track expired time until this flag is truthy\\n  if (!this.trackExpiredTime_) {\\n    return;\\n  }\\n\\n  // if the update was the result of a rendition switch do not\\n  // attempt to calculate expired_ since media-sequences need not\\n  // correlate between renditions/variants\\n  if (update.uri !== outdated.uri) {\\n    return;\\n  }\\n\\n  // try using precise timing from first segment of the updated\\n  // playlist\\n  if (update.segments.length) {\\n    if (typeof update.segments[0].start !== 'undefined') {\\n      this.expired_ = update.segments[0].start;\\n      return;\\n    } else if (typeof update.segments[0].end !== 'undefined') {\\n      this.expired_ = update.segments[0].end - update.segments[0].duration;\\n      return;\\n    }\\n  }\\n\\n  // calculate expired by walking the outdated playlist\\n  i = update.mediaSequence - outdated.mediaSequence - 1;\\n\\n  for (; i >= 0; i--) {\\n    segment = outdated.segments[i];\\n\\n    if (!segment) {\\n      // we missed information on this segment completely between\\n      // playlist updates so we'll have to take an educated guess\\n      // once we begin buffering again, any error we introduce can\\n      // be corrected\\n      this.expired_ += outdated.targetDuration || 10;\\n      continue;\\n    }\\n\\n    if (typeof segment.end !== 'undefined') {\\n      this.expired_ = segment.end;\\n      return;\\n    }\\n    if (typeof segment.start !== 'undefined') {\\n      this.expired_ = segment.start + segment.duration;\\n      return;\\n    }\\n    this.expired_ += segment.duration;\\n  }\\n};\\n\\nexports['default'] = PlaylistLoader;\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./resolve-url\\\":11,\\\"./stream\\\":14,\\\"global/window\\\":26,\\\"m3u8-parser\\\":63}],8:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file playlist.js\\n *\\n * Playlist related utilities.\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _globalWindow = require('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar Playlist = {\\n  /**\\n   * The number of segments that are unsafe to start playback at in\\n   * a live stream. Changing this value can cause playback stalls.\\n   * See HTTP Live Streaming, \\\"Playing the Media Playlist File\\\"\\n   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-18#section-6.3.3\\n   */\\n  UNSAFE_LIVE_SEGMENTS: 3\\n};\\n\\n/**\\n * walk backward until we find a duration we can use\\n * or return a failure\\n *\\n * @param {Playlist} playlist the playlist to walk through\\n * @param {Number} endSequence the mediaSequence to stop walking on\\n */\\n\\nvar backwardDuration = function backwardDuration(playlist, endSequence) {\\n  var result = 0;\\n  var i = endSequence - playlist.mediaSequence;\\n  // if a start time is available for segment immediately following\\n  // the interval, use it\\n  var segment = playlist.segments[i];\\n\\n  // Walk backward until we find the latest segment with timeline\\n  // information that is earlier than endSequence\\n  if (segment) {\\n    if (typeof segment.start !== 'undefined') {\\n      return { result: segment.start, precise: true };\\n    }\\n    if (typeof segment.end !== 'undefined') {\\n      return {\\n        result: segment.end - segment.duration,\\n        precise: true\\n      };\\n    }\\n  }\\n  while (i--) {\\n    segment = playlist.segments[i];\\n    if (typeof segment.end !== 'undefined') {\\n      return { result: result + segment.end, precise: true };\\n    }\\n\\n    result += segment.duration;\\n\\n    if (typeof segment.start !== 'undefined') {\\n      return { result: result + segment.start, precise: true };\\n    }\\n  }\\n  return { result: result, precise: false };\\n};\\n\\n/**\\n * walk forward until we find a duration we can use\\n * or return a failure\\n *\\n * @param {Playlist} playlist the playlist to walk through\\n * @param {Number} endSequence the mediaSequence to stop walking on\\n */\\nvar forwardDuration = function forwardDuration(playlist, endSequence) {\\n  var result = 0;\\n  var segment = undefined;\\n  var i = endSequence - playlist.mediaSequence;\\n  // Walk forward until we find the earliest segment with timeline\\n  // information\\n\\n  for (; i < playlist.segments.length; i++) {\\n    segment = playlist.segments[i];\\n    if (typeof segment.start !== 'undefined') {\\n      return {\\n        result: segment.start - result,\\n        precise: true\\n      };\\n    }\\n\\n    result += segment.duration;\\n\\n    if (typeof segment.end !== 'undefined') {\\n      return {\\n        result: segment.end - result,\\n        precise: true\\n      };\\n    }\\n  }\\n  // indicate we didn't find a useful duration estimate\\n  return { result: -1, precise: false };\\n};\\n\\n/**\\n  * Calculate the media duration from the segments associated with a\\n  * playlist. The duration of a subinterval of the available segments\\n  * may be calculated by specifying an end index.\\n  *\\n  * @param {Object} playlist a media playlist object\\n  * @param {Number=} endSequence an exclusive upper boundary\\n  * for the playlist.  Defaults to playlist length.\\n  * @param {Number} expired the amount of time that has dropped\\n  * off the front of the playlist in a live scenario\\n  * @return {Number} the duration between the first available segment\\n  * and end index.\\n  */\\nvar intervalDuration = function intervalDuration(playlist, endSequence, expired) {\\n  var backward = undefined;\\n  var forward = undefined;\\n\\n  if (typeof endSequence === 'undefined') {\\n    endSequence = playlist.mediaSequence + playlist.segments.length;\\n  }\\n\\n  if (endSequence < playlist.mediaSequence) {\\n    return 0;\\n  }\\n\\n  // do a backward walk to estimate the duration\\n  backward = backwardDuration(playlist, endSequence);\\n  if (backward.precise) {\\n    // if we were able to base our duration estimate on timing\\n    // information provided directly from the Media Source, return\\n    // it\\n    return backward.result;\\n  }\\n\\n  // walk forward to see if a precise duration estimate can be made\\n  // that way\\n  forward = forwardDuration(playlist, endSequence);\\n  if (forward.precise) {\\n    // we found a segment that has been buffered and so it's\\n    // position is known precisely\\n    return forward.result;\\n  }\\n\\n  // return the less-precise, playlist-based duration estimate\\n  return backward.result + expired;\\n};\\n\\n/**\\n  * Calculates the duration of a playlist. If a start and end index\\n  * are specified, the duration will be for the subset of the media\\n  * timeline between those two indices. The total duration for live\\n  * playlists is always Infinity.\\n  *\\n  * @param {Object} playlist a media playlist object\\n  * @param {Number=} endSequence an exclusive upper\\n  * boundary for the playlist. Defaults to the playlist media\\n  * sequence number plus its length.\\n  * @param {Number=} expired the amount of time that has\\n  * dropped off the front of the playlist in a live scenario\\n  * @return {Number} the duration between the start index and end\\n  * index.\\n  */\\nvar duration = function duration(playlist, endSequence, expired) {\\n  if (!playlist) {\\n    return 0;\\n  }\\n\\n  if (typeof expired !== 'number') {\\n    expired = 0;\\n  }\\n\\n  // if a slice of the total duration is not requested, use\\n  // playlist-level duration indicators when they're present\\n  if (typeof endSequence === 'undefined') {\\n    // if present, use the duration specified in the playlist\\n    if (playlist.totalDuration) {\\n      return playlist.totalDuration;\\n    }\\n\\n    // duration should be Infinity for live playlists\\n    if (!playlist.endList) {\\n      return _globalWindow2['default'].Infinity;\\n    }\\n  }\\n\\n  // calculate the total duration based on the segment durations\\n  return intervalDuration(playlist, endSequence, expired);\\n};\\n\\nexports.duration = duration;\\n/**\\n  * Calculates the interval of time that is currently seekable in a\\n  * playlist. The returned time ranges are relative to the earliest\\n  * moment in the specified playlist that is still available. A full\\n  * seekable implementation for live streams would need to offset\\n  * these values by the duration of content that has expired from the\\n  * stream.\\n  *\\n  * @param {Object} playlist a media playlist object\\n  * @param {Number=} expired the amount of time that has\\n  * dropped off the front of the playlist in a live scenario\\n  * @return {TimeRanges} the periods of time that are valid targets\\n  * for seeking\\n  */\\nvar seekable = function seekable(playlist, expired) {\\n  var start = undefined;\\n  var end = undefined;\\n  var endSequence = undefined;\\n\\n  if (typeof expired !== 'number') {\\n    expired = 0;\\n  }\\n\\n  // without segments, there are no seekable ranges\\n  if (!playlist || !playlist.segments) {\\n    return (0, _videoJs.createTimeRange)();\\n  }\\n  // when the playlist is complete, the entire duration is seekable\\n  if (playlist.endList) {\\n    return (0, _videoJs.createTimeRange)(0, duration(playlist));\\n  }\\n\\n  // live playlists should not expose three segment durations worth\\n  // of content from the end of the playlist\\n  // https://tools.ietf.org/html/draft-pantos-http-live-streaming-16#section-6.3.3\\n  start = intervalDuration(playlist, playlist.mediaSequence, expired);\\n  endSequence = Math.max(0, playlist.segments.length - Playlist.UNSAFE_LIVE_SEGMENTS);\\n  end = intervalDuration(playlist, playlist.mediaSequence + endSequence, expired);\\n  return (0, _videoJs.createTimeRange)(start, end);\\n};\\n\\nexports.seekable = seekable;\\n/**\\n * Determine the index of the segment that contains a specified\\n * playback position in a media playlist.\\n *\\n * @param {Object} playlist the media playlist to query\\n * @param {Number} time The number of seconds since the earliest\\n * possible position to determine the containing segment for\\n * @param {Number=} expired the duration of content, in\\n * seconds, that has been removed from this playlist because it\\n * expired\\n * @return {Number} The number of the media segment that contains\\n * that time position.\\n */\\nvar getMediaIndexForTime_ = function getMediaIndexForTime_(playlist, time, expired) {\\n  var i = undefined;\\n  var segment = undefined;\\n  var originalTime = time;\\n  var numSegments = playlist.segments.length;\\n  var lastSegment = numSegments - 1;\\n  var startIndex = undefined;\\n  var endIndex = undefined;\\n  var knownStart = undefined;\\n  var knownEnd = undefined;\\n\\n  if (!playlist) {\\n    return 0;\\n  }\\n\\n  // when the requested position is earlier than the current set of\\n  // segments, return the earliest segment index\\n  if (time < 0) {\\n    return 0;\\n  }\\n\\n  if (time === 0 && !expired) {\\n    return 0;\\n  }\\n\\n  expired = expired || 0;\\n\\n  // find segments with known timing information that bound the\\n  // target time\\n  for (i = 0; i < numSegments; i++) {\\n    segment = playlist.segments[i];\\n    if (segment.end) {\\n      if (segment.end > time) {\\n        knownEnd = segment.end;\\n        endIndex = i;\\n        break;\\n      } else {\\n        knownStart = segment.end;\\n        startIndex = i + 1;\\n      }\\n    }\\n  }\\n\\n  // time was equal to or past the end of the last segment in the playlist\\n  if (startIndex === numSegments) {\\n    return numSegments;\\n  }\\n\\n  // use the bounds we just found and playlist information to\\n  // estimate the segment that contains the time we are looking for\\n  if (typeof startIndex !== 'undefined') {\\n    // We have a known-start point that is before our desired time so\\n    // walk from that point forwards\\n    time = time - knownStart;\\n    for (i = startIndex; i < (endIndex || numSegments); i++) {\\n      segment = playlist.segments[i];\\n      time -= segment.duration;\\n\\n      if (time < 0) {\\n        return i;\\n      }\\n    }\\n\\n    if (i >= endIndex) {\\n      // We haven't found a segment but we did hit a known end point\\n      // so fallback to interpolating between the segment index\\n      // based on the known span of the timeline we are dealing with\\n      // and the number of segments inside that span\\n      return startIndex + Math.floor((originalTime - knownStart) / (knownEnd - knownStart) * (endIndex - startIndex));\\n    }\\n\\n    // We _still_ haven't found a segment so load the last one\\n    return lastSegment;\\n  } else if (typeof endIndex !== 'undefined') {\\n    // We _only_ have a known-end point that is after our desired time so\\n    // walk from that point backwards\\n    time = knownEnd - time;\\n    for (i = endIndex; i >= 0; i--) {\\n      segment = playlist.segments[i];\\n      time -= segment.duration;\\n\\n      if (time < 0) {\\n        return i;\\n      }\\n    }\\n\\n    // We haven't found a segment so load the first one if time is zero\\n    if (time === 0) {\\n      return 0;\\n    }\\n    return -1;\\n  }\\n  // We known nothing so walk from the front of the playlist,\\n  // subtracting durations until we find a segment that contains\\n  // time and return it\\n  time = time - expired;\\n\\n  if (time < 0) {\\n    return -1;\\n  }\\n\\n  for (i = 0; i < numSegments; i++) {\\n    segment = playlist.segments[i];\\n    time -= segment.duration;\\n    if (time < 0) {\\n      return i;\\n    }\\n  }\\n  // We are out of possible candidates so load the last one...\\n  // The last one is the least likely to overlap a buffer and therefore\\n  // the one most likely to tell us something about the timeline\\n  return lastSegment;\\n};\\n\\nexports.getMediaIndexForTime_ = getMediaIndexForTime_;\\nPlaylist.duration = duration;\\nPlaylist.seekable = seekable;\\nPlaylist.getMediaIndexForTime_ = getMediaIndexForTime_;\\n\\n// exports\\nexports['default'] = Playlist;\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"global/window\\\":26}],9:[function(require,module,exports){\\n(function (global){\\n/**\\n * ranges\\n *\\n * Utilities for working with TimeRanges.\\n *\\n */\\n\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\n// Fudge factor to account for TimeRanges rounding\\nvar TIME_FUDGE_FACTOR = 1 / 30;\\n\\n/**\\n * Clamps a value to within a range\\n * @param {Number} num - the value to clamp\\n * @param {Number} start - the start of the range to clamp within, inclusive\\n * @param {Number} end - the end of the range to clamp within, inclusive\\n * @return {Number}\\n */\\nvar clamp = function clamp(num, _ref) {\\n  var _ref2 = _slicedToArray(_ref, 2);\\n\\n  var start = _ref2[0];\\n  var end = _ref2[1];\\n\\n  return Math.min(Math.max(start, num), end);\\n};\\nvar filterRanges = function filterRanges(timeRanges, predicate) {\\n  var results = [];\\n  var i = undefined;\\n\\n  if (timeRanges && timeRanges.length) {\\n    // Search for ranges that match the predicate\\n    for (i = 0; i < timeRanges.length; i++) {\\n      if (predicate(timeRanges.start(i), timeRanges.end(i))) {\\n        results.push([timeRanges.start(i), timeRanges.end(i)]);\\n      }\\n    }\\n  }\\n\\n  return _videoJs2['default'].createTimeRanges(results);\\n};\\n\\n/**\\n * Attempts to find the buffered TimeRange that contains the specified\\n * time.\\n * @param {TimeRanges} buffered - the TimeRanges object to query\\n * @param {number} time  - the time to filter on.\\n * @returns {TimeRanges} a new TimeRanges object\\n */\\nvar findRange = function findRange(buffered, time) {\\n  return filterRanges(buffered, function (start, end) {\\n    return start - TIME_FUDGE_FACTOR <= time && end + TIME_FUDGE_FACTOR >= time;\\n  });\\n};\\n\\n/**\\n * Returns the TimeRanges that begin later than the specified time.\\n * @param {TimeRanges} timeRanges - the TimeRanges object to query\\n * @param {number} time - the time to filter on.\\n * @returns {TimeRanges} a new TimeRanges object.\\n */\\nvar findNextRange = function findNextRange(timeRanges, time) {\\n  return filterRanges(timeRanges, function (start) {\\n    return start - TIME_FUDGE_FACTOR >= time;\\n  });\\n};\\n\\n/**\\n * Returns gaps within a list of TimeRanges\\n * @param {TimeRanges} buffered - the TimeRanges object\\n * @return {TimeRanges} a TimeRanges object of gaps\\n */\\nvar findGaps = function findGaps(buffered) {\\n  if (buffered.length < 2) {\\n    return _videoJs2['default'].createTimeRanges();\\n  }\\n\\n  var ranges = [];\\n\\n  for (var i = 1; i < buffered.length; i++) {\\n    var start = buffered.end(i - 1);\\n    var end = buffered.start(i);\\n\\n    ranges.push([start, end]);\\n  }\\n\\n  return _videoJs2['default'].createTimeRanges(ranges);\\n};\\n\\n/**\\n * Search for a likely end time for the segment that was just appened\\n * based on the state of the `buffered` property before and after the\\n * append. If we fin only one such uncommon end-point return it.\\n * @param {TimeRanges} original - the buffered time ranges before the update\\n * @param {TimeRanges} update - the buffered time ranges after the update\\n * @returns {Number|null} the end time added between `original` and `update`,\\n * or null if one cannot be unambiguously determined.\\n */\\nvar findSoleUncommonTimeRangesEnd = function findSoleUncommonTimeRangesEnd(original, update) {\\n  var i = undefined;\\n  var start = undefined;\\n  var end = undefined;\\n  var result = [];\\n  var edges = [];\\n\\n  // In order to qualify as a possible candidate, the end point must:\\n  //  1) Not have already existed in the `original` ranges\\n  //  2) Not result from the shrinking of a range that already existed\\n  //     in the `original` ranges\\n  //  3) Not be contained inside of a range that existed in `original`\\n  var overlapsCurrentEnd = function overlapsCurrentEnd(span) {\\n    return span[0] <= end && span[1] >= end;\\n  };\\n\\n  if (original) {\\n    // Save all the edges in the `original` TimeRanges object\\n    for (i = 0; i < original.length; i++) {\\n      start = original.start(i);\\n      end = original.end(i);\\n\\n      edges.push([start, end]);\\n    }\\n  }\\n\\n  if (update) {\\n    // Save any end-points in `update` that are not in the `original`\\n    // TimeRanges object\\n    for (i = 0; i < update.length; i++) {\\n      start = update.start(i);\\n      end = update.end(i);\\n\\n      if (edges.some(overlapsCurrentEnd)) {\\n        continue;\\n      }\\n\\n      // at this point it must be a unique non-shrinking end edge\\n      result.push(end);\\n    }\\n  }\\n\\n  // we err on the side of caution and return null if didn't find\\n  // exactly *one* differing end edge in the search above\\n  if (result.length !== 1) {\\n    return null;\\n  }\\n\\n  return result[0];\\n};\\n\\n/**\\n * Calculate the intersection of two TimeRanges\\n * @param {TimeRanges} bufferA\\n * @param {TimeRanges} bufferB\\n * @returns {TimeRanges} The interesection of `bufferA` with `bufferB`\\n */\\nvar bufferIntersection = function bufferIntersection(bufferA, bufferB) {\\n  var start = null;\\n  var end = null;\\n  var arity = 0;\\n  var extents = [];\\n  var ranges = [];\\n\\n  if (!bufferA || !bufferA.length || !bufferB || !bufferB.length) {\\n    return _videoJs2['default'].createTimeRange();\\n  }\\n\\n  // Handle the case where we have both buffers and create an\\n  // intersection of the two\\n  var count = bufferA.length;\\n\\n  // A) Gather up all start and end times\\n  while (count--) {\\n    extents.push({ time: bufferA.start(count), type: 'start' });\\n    extents.push({ time: bufferA.end(count), type: 'end' });\\n  }\\n  count = bufferB.length;\\n  while (count--) {\\n    extents.push({ time: bufferB.start(count), type: 'start' });\\n    extents.push({ time: bufferB.end(count), type: 'end' });\\n  }\\n  // B) Sort them by time\\n  extents.sort(function (a, b) {\\n    return a.time - b.time;\\n  });\\n\\n  // C) Go along one by one incrementing arity for start and decrementing\\n  //    arity for ends\\n  for (count = 0; count < extents.length; count++) {\\n    if (extents[count].type === 'start') {\\n      arity++;\\n\\n      // D) If arity is ever incremented to 2 we are entering an\\n      //    overlapping range\\n      if (arity === 2) {\\n        start = extents[count].time;\\n      }\\n    } else if (extents[count].type === 'end') {\\n      arity--;\\n\\n      // E) If arity is ever decremented to 1 we leaving an\\n      //    overlapping range\\n      if (arity === 1) {\\n        end = extents[count].time;\\n      }\\n    }\\n\\n    // F) Record overlapping ranges\\n    if (start !== null && end !== null) {\\n      ranges.push([start, end]);\\n      start = null;\\n      end = null;\\n    }\\n  }\\n\\n  return _videoJs2['default'].createTimeRanges(ranges);\\n};\\n\\n/**\\n * Calculates the percentage of `segmentRange` that overlaps the\\n * `buffered` time ranges.\\n * @param {TimeRanges} segmentRange - the time range that the segment\\n * covers adjusted according to currentTime\\n * @param {TimeRanges} referenceRange - the original time range that the\\n * segment covers\\n * @param {Number} currentTime - time in seconds where the current playback\\n * is at\\n * @param {TimeRanges} buffered - the currently buffered time ranges\\n * @returns {Number} percent of the segment currently buffered\\n */\\nvar calculateBufferedPercent = function calculateBufferedPercent(adjustedRange, referenceRange, currentTime, buffered) {\\n  var referenceDuration = referenceRange.end(0) - referenceRange.start(0);\\n  var adjustedDuration = adjustedRange.end(0) - adjustedRange.start(0);\\n  var bufferMissingFromAdjusted = referenceDuration - adjustedDuration;\\n  var adjustedIntersection = bufferIntersection(adjustedRange, buffered);\\n  var referenceIntersection = bufferIntersection(referenceRange, buffered);\\n  var adjustedOverlap = 0;\\n  var referenceOverlap = 0;\\n\\n  var count = adjustedIntersection.length;\\n\\n  while (count--) {\\n    adjustedOverlap += adjustedIntersection.end(count) - adjustedIntersection.start(count);\\n\\n    // If the current overlap segment starts at currentTime, then increase the\\n    // overlap duration so that it actually starts at the beginning of referenceRange\\n    // by including the difference between the two Range's durations\\n    // This is a work around for the way Flash has no buffer before currentTime\\n    if (adjustedIntersection.start(count) === currentTime) {\\n      adjustedOverlap += bufferMissingFromAdjusted;\\n    }\\n  }\\n\\n  count = referenceIntersection.length;\\n\\n  while (count--) {\\n    referenceOverlap += referenceIntersection.end(count) - referenceIntersection.start(count);\\n  }\\n\\n  // Use whichever value is larger for the percentage-buffered since that value\\n  // is likely more accurate because the only way\\n  return Math.max(adjustedOverlap, referenceOverlap) / referenceDuration * 100;\\n};\\n\\n/**\\n * Return the amount of a range specified by the startOfSegment and segmentDuration\\n * overlaps the current buffered content.\\n *\\n * @param {Number} startOfSegment - the time where the segment begins\\n * @param {Number} segmentDuration - the duration of the segment in seconds\\n * @param {Number} currentTime - time in seconds where the current playback\\n * is at\\n * @param {TimeRanges} buffered - the state of the buffer\\n * @returns {Number} percentage of the segment's time range that is\\n * already in `buffered`\\n */\\nvar getSegmentBufferedPercent = function getSegmentBufferedPercent(startOfSegment, segmentDuration, currentTime, buffered) {\\n  var endOfSegment = startOfSegment + segmentDuration;\\n\\n  // The entire time range of the segment\\n  var originalSegmentRange = _videoJs2['default'].createTimeRanges([[startOfSegment, endOfSegment]]);\\n\\n  // The adjusted segment time range that is setup such that it starts\\n  // no earlier than currentTime\\n  // Flash has no notion of a back-buffer so adjustedSegmentRange adjusts\\n  // for that and the function will still return 100% if a only half of a\\n  // segment is actually in the buffer as long as the currentTime is also\\n  // half-way through the segment\\n  var adjustedSegmentRange = _videoJs2['default'].createTimeRanges([[clamp(startOfSegment, [currentTime, endOfSegment]), endOfSegment]]);\\n\\n  // This condition happens when the currentTime is beyond the segment's\\n  // end time\\n  if (adjustedSegmentRange.start(0) === adjustedSegmentRange.end(0)) {\\n    return 0;\\n  }\\n\\n  var percent = calculateBufferedPercent(adjustedSegmentRange, originalSegmentRange, currentTime, buffered);\\n\\n  // If the segment is reported as having a zero duration, return 0%\\n  // since it is likely that we will need to fetch the segment\\n  if (isNaN(percent) || percent === Infinity || percent === -Infinity) {\\n    return 0;\\n  }\\n\\n  return percent;\\n};\\n\\nexports['default'] = {\\n  findRange: findRange,\\n  findNextRange: findNextRange,\\n  findGaps: findGaps,\\n  findSoleUncommonTimeRangesEnd: findSoleUncommonTimeRangesEnd,\\n  getSegmentBufferedPercent: getSegmentBufferedPercent,\\n  TIME_FUDGE_FACTOR: TIME_FUDGE_FACTOR\\n};\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{}],10:[function(require,module,exports){\\n/**\\n * Enable/disable playlist function. It is intended to have the first two\\n * arguments partially-applied in order to create the final per-playlist\\n * function.\\n *\\n * @param {PlaylistLoader} playlist - The rendition or media-playlist\\n * @param {Function} changePlaylistFn - A function to be called after a\\n * playlist's enabled-state has been changed. Will NOT be called if a\\n * playlist's enabled-state is unchanged\\n * @param {Boolean=} enable - Value to set the playlist enabled-state to\\n * or if undefined returns the current enabled-state for the playlist\\n * @return {Boolean} The current enabled-state of the playlist\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nvar enableFunction = function enableFunction(playlist, changePlaylistFn, enable) {\\n  var currentlyEnabled = typeof playlist.excludeUntil === 'undefined' || playlist.excludeUntil <= Date.now();\\n\\n  if (typeof enable === 'undefined') {\\n    return currentlyEnabled;\\n  }\\n\\n  if (enable !== currentlyEnabled) {\\n    if (enable) {\\n      delete playlist.excludeUntil;\\n    } else {\\n      playlist.excludeUntil = Infinity;\\n    }\\n\\n    // Ensure the outside world knows about our changes\\n    changePlaylistFn();\\n  }\\n\\n  return enable;\\n};\\n\\n/**\\n * The representation object encapsulates the publicly visible information\\n * in a media playlist along with a setter/getter-type function (enabled)\\n * for changing the enabled-state of a particular playlist entry\\n *\\n * @class Representation\\n */\\n\\nvar Representation = function Representation(hlsHandler, playlist, id) {\\n  _classCallCheck(this, Representation);\\n\\n  // Get a reference to a bound version of fastQualityChange_\\n  var fastChangeFunction = hlsHandler.masterPlaylistController_.fastQualityChange_.bind(hlsHandler.masterPlaylistController_);\\n\\n  // Carefully descend into the playlist's attributes since most\\n  // properties are optional\\n  if (playlist.attributes) {\\n    var attributes = playlist.attributes;\\n\\n    if (attributes.RESOLUTION) {\\n      var resolution = attributes.RESOLUTION;\\n\\n      this.width = resolution.width;\\n      this.height = resolution.height;\\n    }\\n\\n    this.bandwidth = attributes.BANDWIDTH;\\n  }\\n\\n  // The id is simply the ordinality of the media playlist\\n  // within the master playlist\\n  this.id = id;\\n\\n  // Partially-apply the enableFunction to create a playlist-\\n  // specific variant\\n  this.enabled = enableFunction.bind(this, playlist, fastChangeFunction);\\n}\\n\\n/**\\n * A mixin function that adds the `representations` api to an instance\\n * of the HlsHandler class\\n * @param {HlsHandler} hlsHandler - An instance of HlsHandler to add the\\n * representation API into\\n */\\n;\\n\\nvar renditionSelectionMixin = function renditionSelectionMixin(hlsHandler) {\\n  var playlists = hlsHandler.playlists;\\n\\n  // Add a single API-specific function to the HlsHandler instance\\n  hlsHandler.representations = function () {\\n    return playlists.master.playlists.map(function (e, i) {\\n      return new Representation(hlsHandler, e, i);\\n    });\\n  };\\n};\\n\\nexports['default'] = renditionSelectionMixin;\\nmodule.exports = exports['default'];\\n},{}],11:[function(require,module,exports){\\n/**\\n * @file resolve-url.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _globalDocument = require('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\n/**\\n * Constructs a new URI by interpreting a path relative to another\\n * URI.\\n *\\n * @see http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue\\n * @param {String} basePath a relative or absolute URI\\n * @param {String} path a path part to combine with the base\\n * @return {String} a URI that is equivalent to composing `base`\\n * with `path`\\n */\\nvar resolveUrl = function resolveUrl(basePath, path) {\\n  // use the base element to get the browser to handle URI resolution\\n  var oldBase = _globalDocument2['default'].querySelector('base');\\n  var docHead = _globalDocument2['default'].querySelector('head');\\n  var a = _globalDocument2['default'].createElement('a');\\n  var base = oldBase;\\n  var oldHref = undefined;\\n  var result = undefined;\\n\\n  // prep the document\\n  if (oldBase) {\\n    oldHref = oldBase.href;\\n  } else {\\n    base = docHead.appendChild(_globalDocument2['default'].createElement('base'));\\n  }\\n\\n  base.href = basePath;\\n  a.href = path;\\n  result = a.href;\\n\\n  // clean up\\n  if (oldBase) {\\n    oldBase.href = oldHref;\\n  } else {\\n    docHead.removeChild(base);\\n  }\\n  return result;\\n};\\n\\nexports['default'] = resolveUrl;\\nmodule.exports = exports['default'];\\n},{\\\"global/document\\\":25}],12:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file segment-loader.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _ranges = require('./ranges');\\n\\nvar _ranges2 = _interopRequireDefault(_ranges);\\n\\nvar _playlist = require('./playlist');\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\nvar _sourceUpdater = require('./source-updater');\\n\\nvar _sourceUpdater2 = _interopRequireDefault(_sourceUpdater);\\n\\nvar _aesDecrypter = require('aes-decrypter');\\n\\nvar _config = require('./config');\\n\\nvar _config2 = _interopRequireDefault(_config);\\n\\nvar _globalWindow = require('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\n// in ms\\nvar CHECK_BUFFER_DELAY = 500;\\n\\n/**\\n * Updates segment with information about its end-point in time and, optionally,\\n * the segment duration if we have enough information to determine a segment duration\\n * accurately.\\n *\\n * @param {Object} playlist a media playlist object\\n * @param {Number} segmentIndex the index of segment we last appended\\n * @param {Number} segmentEnd the known of the segment referenced by segmentIndex\\n */\\nvar updateSegmentMetadata = function updateSegmentMetadata(playlist, segmentIndex, segmentEnd) {\\n  if (!playlist) {\\n    return false;\\n  }\\n\\n  var segment = playlist.segments[segmentIndex];\\n  var previousSegment = playlist.segments[segmentIndex - 1];\\n\\n  if (segmentEnd && segment) {\\n    segment.end = segmentEnd;\\n\\n    // fix up segment durations based on segment end data\\n    if (!previousSegment) {\\n      // first segment is always has a start time of 0 making its duration\\n      // equal to the segment end\\n      segment.duration = segment.end;\\n    } else if (previousSegment.end) {\\n      segment.duration = segment.end - previousSegment.end;\\n    }\\n    return true;\\n  }\\n  return false;\\n};\\n\\n/**\\n * Determines if we should call endOfStream on the media source based\\n * on the state of the buffer or if appened segment was the final\\n * segment in the playlist.\\n *\\n * @param {Object} playlist a media playlist object\\n * @param {Object} mediaSource the MediaSource object\\n * @param {Number} segmentIndex the index of segment we last appended\\n * @param {Object} currentBuffered buffered region that currentTime resides in\\n * @returns {Boolean} do we need to call endOfStream on the MediaSource\\n */\\nvar detectEndOfStream = function detectEndOfStream(playlist, mediaSource, segmentIndex, currentBuffered) {\\n  if (!playlist) {\\n    return false;\\n  }\\n\\n  var segments = playlist.segments;\\n\\n  // determine a few boolean values to help make the branch below easier\\n  // to read\\n  var appendedLastSegment = segmentIndex === segments.length - 1;\\n  var bufferedToEnd = currentBuffered.length && segments[segments.length - 1].end <= currentBuffered.end(0);\\n\\n  // if we've buffered to the end of the video, we need to call endOfStream\\n  // so that MediaSources can trigger the `ended` event when it runs out of\\n  // buffered data instead of waiting for me\\n  return playlist.endList && mediaSource.readyState === 'open' && (appendedLastSegment || bufferedToEnd);\\n};\\n\\n/**\\n * Turns segment byterange into a string suitable for use in\\n * HTTP Range requests\\n */\\nvar byterangeStr = function byterangeStr(byterange) {\\n  var byterangeStart = undefined;\\n  var byterangeEnd = undefined;\\n\\n  // `byterangeEnd` is one less than `offset + length` because the HTTP range\\n  // header uses inclusive ranges\\n  byterangeEnd = byterange.offset + byterange.length - 1;\\n  byterangeStart = byterange.offset;\\n  return 'bytes=' + byterangeStart + '-' + byterangeEnd;\\n};\\n\\n/**\\n * Defines headers for use in the xhr request for a particular segment.\\n */\\nvar segmentXhrHeaders = function segmentXhrHeaders(segment) {\\n  var headers = {};\\n\\n  if ('byterange' in segment) {\\n    headers.Range = byterangeStr(segment.byterange);\\n  }\\n  return headers;\\n};\\n\\n/**\\n * An object that manages segment loading and appending.\\n *\\n * @class SegmentLoader\\n * @param {Object} options required and optional options\\n * @extends videojs.EventTarget\\n */\\n\\nvar SegmentLoader = (function (_videojs$EventTarget) {\\n  _inherits(SegmentLoader, _videojs$EventTarget);\\n\\n  function SegmentLoader(options) {\\n    _classCallCheck(this, SegmentLoader);\\n\\n    _get(Object.getPrototypeOf(SegmentLoader.prototype), 'constructor', this).call(this);\\n    var settings = undefined;\\n\\n    // check pre-conditions\\n    if (!options) {\\n      throw new TypeError('Initialization options are required');\\n    }\\n    if (typeof options.currentTime !== 'function') {\\n      throw new TypeError('No currentTime getter specified');\\n    }\\n    if (!options.mediaSource) {\\n      throw new TypeError('No MediaSource specified');\\n    }\\n    settings = _videoJs2['default'].mergeOptions(_videoJs2['default'].options.hls, options);\\n\\n    // public properties\\n    this.state = 'INIT';\\n    this.bandwidth = settings.bandwidth;\\n    this.roundTrip = NaN;\\n    this.resetStats_();\\n\\n    // private properties\\n    this.hasPlayed_ = settings.hasPlayed;\\n    this.currentTime_ = settings.currentTime;\\n    this.seekable_ = settings.seekable;\\n    this.seeking_ = settings.seeking;\\n    this.setCurrentTime_ = settings.setCurrentTime;\\n    this.mediaSource_ = settings.mediaSource;\\n    this.checkBufferTimeout_ = null;\\n    this.error_ = void 0;\\n    this.expired_ = 0;\\n    this.timeCorrection_ = 0;\\n    this.currentTimeline_ = -1;\\n    this.xhr_ = null;\\n    this.pendingSegment_ = null;\\n    this.sourceUpdater_ = null;\\n    this.hls_ = settings.hls;\\n    this.xhrOptions_ = null;\\n  }\\n\\n  /**\\n   * reset all of our media stats\\n   *\\n   * @private\\n   */\\n\\n  _createClass(SegmentLoader, [{\\n    key: 'resetStats_',\\n    value: function resetStats_() {\\n      this.mediaBytesTransferred = 0;\\n      this.mediaRequests = 0;\\n      this.mediaTransferDuration = 0;\\n    }\\n\\n    /**\\n     * dispose of the SegmentLoader and reset to the default state\\n     */\\n  }, {\\n    key: 'dispose',\\n    value: function dispose() {\\n      this.state = 'DISPOSED';\\n      this.abort_();\\n      if (this.sourceUpdater_) {\\n        this.sourceUpdater_.dispose();\\n      }\\n      this.resetStats_();\\n    }\\n\\n    /**\\n     * abort anything that is currently doing on with the SegmentLoader\\n     * and reset to a default state\\n     */\\n  }, {\\n    key: 'abort',\\n    value: function abort() {\\n      if (this.state !== 'WAITING') {\\n        return;\\n      }\\n\\n      this.abort_();\\n\\n      // don't wait for buffer check timeouts to begin fetching the\\n      // next segment\\n      if (!this.paused()) {\\n        this.state = 'READY';\\n        this.fillBuffer_();\\n      }\\n    }\\n\\n    /**\\n     * set an error on the segment loader and null out any pending segements\\n     *\\n     * @param {Error} error the error to set on the SegmentLoader\\n     * @return {Error} the error that was set or that is currently set\\n     */\\n  }, {\\n    key: 'error',\\n    value: function error(_error) {\\n      if (typeof _error !== 'undefined') {\\n        this.error_ = _error;\\n      }\\n\\n      this.pendingSegment_ = null;\\n      return this.error_;\\n    }\\n\\n    /**\\n     * load a playlist and start to fill the buffer\\n     */\\n  }, {\\n    key: 'load',\\n    value: function load() {\\n      this.monitorBuffer_();\\n\\n      // if we don't have a playlist yet, keep waiting for one to be\\n      // specified\\n      if (!this.playlist_) {\\n        return;\\n      }\\n\\n      // if we're in the middle of processing a segment already, don't\\n      // kick off an additional segment request\\n      if (!this.sourceUpdater_ || this.state !== 'READY' && this.state !== 'INIT') {\\n        return;\\n      }\\n\\n      this.state = 'READY';\\n      this.fillBuffer_();\\n    }\\n\\n    /**\\n     * set a playlist on the segment loader\\n     *\\n     * @param {PlaylistLoader} media the playlist to set on the segment loader\\n     */\\n  }, {\\n    key: 'playlist',\\n    value: function playlist(media) {\\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n\\n      this.playlist_ = media;\\n      this.xhrOptions_ = options;\\n\\n      // if we were unpaused but waiting for a playlist, start\\n      // buffering now\\n      if (this.sourceUpdater_ && media && this.state === 'INIT' && !this.paused()) {\\n        this.state = 'READY';\\n        return this.fillBuffer_();\\n      }\\n    }\\n\\n    /**\\n     * Prevent the loader from fetching additional segments. If there\\n     * is a segment request outstanding, it will finish processing\\n     * before the loader halts. A segment loader can be unpaused by\\n     * calling load().\\n     */\\n  }, {\\n    key: 'pause',\\n    value: function pause() {\\n      if (this.checkBufferTimeout_) {\\n        _globalWindow2['default'].clearTimeout(this.checkBufferTimeout_);\\n\\n        this.checkBufferTimeout_ = null;\\n      }\\n    }\\n\\n    /**\\n     * Returns whether the segment loader is fetching additional\\n     * segments when given the opportunity. This property can be\\n     * modified through calls to pause() and load().\\n     */\\n  }, {\\n    key: 'paused',\\n    value: function paused() {\\n      return this.checkBufferTimeout_ === null;\\n    }\\n\\n    /**\\n     * setter for expired time on the SegmentLoader\\n     *\\n     * @param {Number} expired the exired time to set\\n     */\\n  }, {\\n    key: 'expired',\\n    value: function expired(_expired) {\\n      this.expired_ = _expired;\\n    }\\n\\n    /**\\n     * create/set the following mimetype on the SourceBuffer through a\\n     * SourceUpdater\\n     *\\n     * @param {String} mimeType the mime type string to use\\n     */\\n  }, {\\n    key: 'mimeType',\\n    value: function mimeType(_mimeType) {\\n      // TODO Allow source buffers to be re-created with different mime-types\\n      if (!this.sourceUpdater_) {\\n        this.sourceUpdater_ = new _sourceUpdater2['default'](this.mediaSource_, _mimeType);\\n        this.clearBuffer();\\n\\n        // if we were unpaused but waiting for a sourceUpdater, start\\n        // buffering now\\n        if (this.playlist_ && this.state === 'INIT' && !this.paused()) {\\n          this.state = 'READY';\\n          return this.fillBuffer_();\\n        }\\n      }\\n    }\\n\\n    /**\\n     * asynchronously/recursively monitor the buffer\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'monitorBuffer_',\\n    value: function monitorBuffer_() {\\n      if (this.state === 'READY') {\\n        this.fillBuffer_();\\n      }\\n\\n      if (this.checkBufferTimeout_) {\\n        _globalWindow2['default'].clearTimeout(this.checkBufferTimeout_);\\n      }\\n\\n      this.checkBufferTimeout_ = _globalWindow2['default'].setTimeout(this.monitorBuffer_.bind(this), CHECK_BUFFER_DELAY);\\n    }\\n\\n    /**\\n     * Determines what segment request should be made, given current\\n     * playback state.\\n     *\\n     * @param {TimeRanges} buffered - the state of the buffer\\n     * @param {Object} playlist - the playlist object to fetch segments from\\n     * @param {Number} currentTime - the playback position in seconds\\n     * @returns {Object} a segment info object that describes the\\n     * request that should be made or null if no request is necessary\\n     */\\n  }, {\\n    key: 'checkBuffer_',\\n    value: function checkBuffer_(buffered, playlist, currentTime) {\\n      var currentBuffered = _ranges2['default'].findRange(buffered, currentTime);\\n\\n      // There are times when MSE reports the first segment as starting a\\n      // little after 0-time so add a fudge factor to try and fix those cases\\n      // or we end up fetching the same first segment over and over\\n      if (currentBuffered.length === 0 && currentTime === 0) {\\n        currentBuffered = _ranges2['default'].findRange(buffered, currentTime + _ranges2['default'].TIME_FUDGE_FACTOR);\\n      }\\n\\n      var bufferedTime = undefined;\\n      var currentBufferedEnd = undefined;\\n      var timestampOffset = this.sourceUpdater_.timestampOffset();\\n      var segment = undefined;\\n      var mediaIndex = undefined;\\n\\n      if (!playlist.segments.length) {\\n        return;\\n      }\\n\\n      if (currentBuffered.length === 0) {\\n        // find the segment containing currentTime\\n        mediaIndex = (0, _playlist.getMediaIndexForTime_)(playlist, currentTime + this.timeCorrection_, this.expired_);\\n      } else {\\n        // find the segment adjacent to the end of the current\\n        // buffered region\\n        currentBufferedEnd = currentBuffered.end(0);\\n        bufferedTime = Math.max(0, currentBufferedEnd - currentTime);\\n\\n        // if the video has not yet played only, and we already have\\n        // one segment downloaded do nothing\\n        if (!this.hasPlayed_() && bufferedTime >= 1) {\\n          return null;\\n        }\\n\\n        // if there is plenty of content buffered, and the video has\\n        // been played before relax for awhile\\n        if (this.hasPlayed_() && bufferedTime >= _config2['default'].GOAL_BUFFER_LENGTH) {\\n          return null;\\n        }\\n        mediaIndex = (0, _playlist.getMediaIndexForTime_)(playlist, currentBufferedEnd + this.timeCorrection_, this.expired_);\\n      }\\n\\n      if (mediaIndex < 0 || mediaIndex === playlist.segments.length) {\\n        return null;\\n      }\\n\\n      segment = playlist.segments[mediaIndex];\\n      var startOfSegment = (0, _playlist.duration)(playlist, playlist.mediaSequence + mediaIndex, this.expired_);\\n\\n      // We will need to change timestampOffset of the sourceBuffer if either of\\n      // the following conditions are true:\\n      // - The segment.timeline !== this.currentTimeline\\n      //   (we are crossing a discontinuity somehow)\\n      // - The \\\"timestampOffset\\\" for the start of this segment is less than\\n      //   the currently set timestampOffset\\n      if (segment.timeline !== this.currentTimeline_ || startOfSegment < this.sourceUpdater_.timestampOffset()) {\\n        timestampOffset = startOfSegment;\\n      }\\n\\n      return {\\n        // resolve the segment URL relative to the playlist\\n        uri: segment.resolvedUri,\\n        // the segment's mediaIndex at the time it was requested\\n        mediaIndex: mediaIndex,\\n        // the segment's playlist\\n        playlist: playlist,\\n        // unencrypted bytes of the segment\\n        bytes: null,\\n        // when a key is defined for this segment, the encrypted bytes\\n        encryptedBytes: null,\\n        // the state of the buffer before a segment is appended will be\\n        // stored here so that the actual segment duration can be\\n        // determined after it has been appended\\n        buffered: null,\\n        // The target timestampOffset for this segment when we append it\\n        // to the source buffer\\n        timestampOffset: timestampOffset,\\n        // The timeline that the segment is in\\n        timeline: segment.timeline,\\n        // The expected duration of the segment in seconds\\n        duration: segment.duration\\n      };\\n    }\\n\\n    /**\\n     * abort all pending xhr requests and null any pending segements\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'abort_',\\n    value: function abort_() {\\n      if (this.xhr_) {\\n        this.xhr_.abort();\\n      }\\n\\n      // clear out the segment being processed\\n      this.pendingSegment_ = null;\\n    }\\n\\n    /**\\n     * fill the buffer with segements unless the\\n     * sourceBuffers are currently updating\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'fillBuffer_',\\n    value: function fillBuffer_() {\\n      if (this.sourceUpdater_.updating()) {\\n        return;\\n      }\\n\\n      // see if we need to begin loading immediately\\n      var request = this.checkBuffer_(this.sourceUpdater_.buffered(), this.playlist_, this.currentTime_(), this.timestampOffset_);\\n\\n      if (!request) {\\n        return;\\n      }\\n\\n      if (request.mediaIndex === this.playlist_.segments.length - 1 && this.mediaSource_.readyState === 'ended' && !this.seeking_()) {\\n        return;\\n      }\\n\\n      var segment = this.playlist_.segments[request.mediaIndex];\\n      var startOfSegment = (0, _playlist.duration)(this.playlist_, this.playlist_.mediaSequence + request.mediaIndex, this.expired_);\\n\\n      // Sanity check the segment-index determining logic by calcuating the\\n      // percentage of the chosen segment that is buffered. If more than 90%\\n      // of the segment is buffered then fetching it will likely not help in\\n      // any way\\n      var percentBuffered = _ranges2['default'].getSegmentBufferedPercent(startOfSegment, segment.duration, this.currentTime_(), this.sourceUpdater_.buffered());\\n\\n      if (percentBuffered >= 90) {\\n        // Increment the timeCorrection_ variable to push the fetcher forward\\n        // in time and hopefully skip any gaps or flaws in our understanding\\n        // of the media\\n        var correctionApplied = this.incrementTimeCorrection_(this.playlist_.targetDuration / 2, 1);\\n\\n        if (correctionApplied && !this.paused()) {\\n          this.fillBuffer_();\\n        }\\n\\n        return;\\n      }\\n\\n      this.loadSegment_(request);\\n    }\\n\\n    /**\\n     * trim the back buffer so we only remove content\\n     * on segment boundaries\\n     *\\n     * @private\\n     *\\n     * @param {Object} segmentInfo - the current segment\\n     * @returns {Number} removeToTime - the end point in time, in seconds\\n     * that the the buffer should be trimmed.\\n     */\\n  }, {\\n    key: 'trimBuffer_',\\n    value: function trimBuffer_(segmentInfo) {\\n      var seekable = this.seekable_();\\n      var currentTime = this.currentTime_();\\n      var removeToTime = 0;\\n\\n      // Chrome has a hard limit of 150mb of\\n      // buffer and a very conservative \\\"garbage collector\\\"\\n      // We manually clear out the old buffer to ensure\\n      // we don't trigger the QuotaExceeded error\\n      // on the source buffer during subsequent appends\\n\\n      // If we have a seekable range use that as the limit for what can be removed safely\\n      // otherwise remove anything older than 1 minute before the current play head\\n      if (seekable.length && seekable.start(0) > 0 && seekable.start(0) < currentTime) {\\n        removeToTime = seekable.start(0);\\n      } else {\\n        removeToTime = currentTime - 60;\\n      }\\n\\n      // If we are going to remove time from the front of the buffer, make\\n      // sure we aren't discarding a partial segment to avoid throwing\\n      // PLAYER_ERR_TIMEOUT while trying to read a partially discarded segment\\n      for (var i = 0; i <= segmentInfo.playlist.segments.length; i++) {\\n        // Loop through the segments and calculate the duration to compare\\n        // against the removeToTime\\n        var removeDuration = (0, _playlist.duration)(segmentInfo.playlist, segmentInfo.playlist.mediaSequence + i, this.expired_);\\n\\n        // If we are close to next segment begining, remove to end of previous\\n        // segment instead\\n        var previousDuration = (0, _playlist.duration)(segmentInfo.playlist, segmentInfo.playlist.mediaSequence + (i - 1), this.expired_);\\n\\n        if (removeDuration >= removeToTime) {\\n          removeToTime = previousDuration;\\n          break;\\n        }\\n      }\\n      return removeToTime;\\n    }\\n\\n    /**\\n     * load a specific segment from a request into the buffer\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'loadSegment_',\\n    value: function loadSegment_(segmentInfo) {\\n      var segment = undefined;\\n      var keyXhr = undefined;\\n      var segmentXhr = undefined;\\n      var removeToTime = 0;\\n\\n      removeToTime = this.trimBuffer_(segmentInfo);\\n\\n      if (removeToTime > 0) {\\n        this.sourceUpdater_.remove(0, removeToTime);\\n      }\\n\\n      segment = segmentInfo.playlist.segments[segmentInfo.mediaIndex];\\n\\n      if (segment.key) {\\n        var keyRequestOptions = _videoJs2['default'].mergeOptions(this.xhrOptions_, {\\n          uri: segment.key.resolvedUri,\\n          responseType: 'arraybuffer'\\n        });\\n\\n        keyXhr = this.hls_.xhr(keyRequestOptions, this.handleResponse_.bind(this));\\n      }\\n\\n      this.pendingSegment_ = segmentInfo;\\n\\n      var segmentRequestOptions = _videoJs2['default'].mergeOptions(this.xhrOptions_, {\\n        uri: segmentInfo.uri,\\n        responseType: 'arraybuffer',\\n        headers: segmentXhrHeaders(segment)\\n      });\\n\\n      segmentXhr = this.hls_.xhr(segmentRequestOptions, this.handleResponse_.bind(this));\\n\\n      this.xhr_ = {\\n        keyXhr: keyXhr,\\n        segmentXhr: segmentXhr,\\n        abort: function abort() {\\n          if (this.segmentXhr) {\\n            // Prevent error handler from running.\\n            this.segmentXhr.onreadystatechange = null;\\n            this.segmentXhr.abort();\\n            this.segmentXhr = null;\\n          }\\n          if (this.keyXhr) {\\n            // Prevent error handler from running.\\n            this.keyXhr.onreadystatechange = null;\\n            this.keyXhr.abort();\\n            this.keyXhr = null;\\n          }\\n        }\\n      };\\n\\n      this.state = 'WAITING';\\n    }\\n\\n    /**\\n     * triggered when a segment response is received\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'handleResponse_',\\n    value: function handleResponse_(error, request) {\\n      var segmentInfo = undefined;\\n      var segment = undefined;\\n      var keyXhrRequest = undefined;\\n      var view = undefined;\\n\\n      // timeout of previously aborted request\\n      if (!this.xhr_ || request !== this.xhr_.segmentXhr && request !== this.xhr_.keyXhr) {\\n        return;\\n      }\\n\\n      segmentInfo = this.pendingSegment_;\\n      segment = segmentInfo.playlist.segments[segmentInfo.mediaIndex];\\n\\n      // if a request times out, reset bandwidth tracking\\n      if (request.timedout) {\\n        this.abort_();\\n        this.bandwidth = 1;\\n        this.roundTrip = NaN;\\n        this.state = 'READY';\\n        return this.trigger('progress');\\n      }\\n\\n      // trigger an event for other errors\\n      if (!request.aborted && error) {\\n        // abort will clear xhr_\\n        keyXhrRequest = this.xhr_.keyXhr;\\n        this.abort_();\\n        this.error({\\n          status: request.status,\\n          message: request === keyXhrRequest ? 'HLS key request error at URL: ' + segment.key.uri : 'HLS segment request error at URL: ' + segmentInfo.uri,\\n          code: 2,\\n          xhr: request\\n        });\\n        this.state = 'READY';\\n        this.pause();\\n        return this.trigger('error');\\n      }\\n\\n      // stop processing if the request was aborted\\n      if (!request.response) {\\n        this.abort_();\\n        return;\\n      }\\n\\n      if (request === this.xhr_.segmentXhr) {\\n        // the segment request is no longer outstanding\\n        this.xhr_.segmentXhr = null;\\n\\n        // calculate the download bandwidth based on segment request\\n        this.roundTrip = request.roundTripTime;\\n        this.bandwidth = request.bandwidth;\\n        this.mediaBytesTransferred += request.bytesReceived || 0;\\n        this.mediaRequests += 1;\\n        this.mediaTransferDuration += request.roundTripTime || 0;\\n\\n        if (segment.key) {\\n          segmentInfo.encryptedBytes = new Uint8Array(request.response);\\n        } else {\\n          segmentInfo.bytes = new Uint8Array(request.response);\\n        }\\n      }\\n\\n      if (request === this.xhr_.keyXhr) {\\n        keyXhrRequest = this.xhr_.segmentXhr;\\n        // the key request is no longer outstanding\\n        this.xhr_.keyXhr = null;\\n\\n        if (request.response.byteLength !== 16) {\\n          this.abort_();\\n          this.error({\\n            status: request.status,\\n            message: 'Invalid HLS key at URL: ' + segment.key.uri,\\n            code: 2,\\n            xhr: request\\n          });\\n          this.state = 'READY';\\n          this.pause();\\n          return this.trigger('error');\\n        }\\n\\n        view = new DataView(request.response);\\n        segment.key.bytes = new Uint32Array([view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12)]);\\n\\n        // if the media sequence is greater than 2^32, the IV will be incorrect\\n        // assuming 10s segments, that would be about 1300 years\\n        segment.key.iv = segment.key.iv || new Uint32Array([0, 0, 0, segmentInfo.mediaIndex + segmentInfo.playlist.mediaSequence]);\\n      }\\n\\n      if (!this.xhr_.segmentXhr && !this.xhr_.keyXhr) {\\n        this.xhr_ = null;\\n        this.processResponse_();\\n      }\\n    }\\n\\n    /**\\n     * clear anything that is currently in the buffer and throw it away\\n     */\\n  }, {\\n    key: 'clearBuffer',\\n    value: function clearBuffer() {\\n      if (this.sourceUpdater_ && this.sourceUpdater_.buffered().length) {\\n        this.sourceUpdater_.remove(0, Infinity);\\n      }\\n    }\\n\\n    /**\\n     * Decrypt the segment that is being loaded if necessary\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'processResponse_',\\n    value: function processResponse_() {\\n      var segmentInfo = undefined;\\n      var segment = undefined;\\n\\n      this.state = 'DECRYPTING';\\n\\n      segmentInfo = this.pendingSegment_;\\n      segment = segmentInfo.playlist.segments[segmentInfo.mediaIndex];\\n\\n      if (segment.key) {\\n        // this is an encrypted segment\\n        // incrementally decrypt the segment\\n        /* eslint-disable no-new, handle-callback-err */\\n        new _aesDecrypter.Decrypter(segmentInfo.encryptedBytes, segment.key.bytes, segment.key.iv, (function (err, bytes) {\\n          // err always null\\n          segmentInfo.bytes = bytes;\\n          this.handleSegment_();\\n        }).bind(this));\\n        /* eslint-enable */\\n      } else {\\n          this.handleSegment_();\\n        }\\n    }\\n\\n    /**\\n     * append a decrypted segement to the SourceBuffer through a SourceUpdater\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'handleSegment_',\\n    value: function handleSegment_() {\\n      var segmentInfo = undefined;\\n\\n      this.state = 'APPENDING';\\n      segmentInfo = this.pendingSegment_;\\n      segmentInfo.buffered = this.sourceUpdater_.buffered();\\n      this.currentTimeline_ = segmentInfo.timeline;\\n\\n      if (segmentInfo.timestampOffset !== this.sourceUpdater_.timestampOffset()) {\\n        this.sourceUpdater_.timestampOffset(segmentInfo.timestampOffset);\\n      }\\n\\n      this.sourceUpdater_.appendBuffer(segmentInfo.bytes, this.handleUpdateEnd_.bind(this));\\n    }\\n\\n    /**\\n     * callback to run when appendBuffer is finished. detects if we are\\n     * in a good state to do things with the data we got, or if we need\\n     * to wait for more\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'handleUpdateEnd_',\\n    value: function handleUpdateEnd_() {\\n      var segmentInfo = this.pendingSegment_;\\n      var currentTime = this.currentTime_();\\n\\n      this.pendingSegment_ = null;\\n\\n      // add segment metadata if it we have gained information during the\\n      // last append\\n      var timelineUpdated = this.updateTimeline_(segmentInfo);\\n\\n      this.trigger('progress');\\n\\n      var currentMediaIndex = segmentInfo.mediaIndex;\\n\\n      currentMediaIndex += segmentInfo.playlist.mediaSequence - this.playlist_.mediaSequence;\\n\\n      var currentBuffered = _ranges2['default'].findRange(this.sourceUpdater_.buffered(), currentTime);\\n\\n      // any time an update finishes and the last segment is in the\\n      // buffer, end the stream. this ensures the \\\"ended\\\" event will\\n      // fire if playback reaches that point.\\n      var isEndOfStream = detectEndOfStream(segmentInfo.playlist, this.mediaSource_, currentMediaIndex, currentBuffered);\\n\\n      if (isEndOfStream) {\\n        this.mediaSource_.endOfStream();\\n      }\\n\\n      // when seeking to the beginning of the seekable range, it's\\n      // possible that imprecise timing information may cause the seek to\\n      // end up earlier than the start of the range\\n      // in that case, seek again\\n      var seekable = this.seekable_();\\n      var next = _ranges2['default'].findNextRange(this.sourceUpdater_.buffered(), currentTime);\\n\\n      if (this.seeking_() && currentBuffered.length === 0) {\\n        if (seekable.length && currentTime < seekable.start(0)) {\\n\\n          if (next.length) {\\n            _videoJs2['default'].log('tried seeking to', currentTime, 'but that was too early, retrying at', next.start(0));\\n            this.setCurrentTime_(next.start(0) + _ranges2['default'].TIME_FUDGE_FACTOR);\\n          }\\n        }\\n      }\\n\\n      this.state = 'READY';\\n\\n      if (timelineUpdated) {\\n        this.timeCorrection_ = 0;\\n        if (!this.paused()) {\\n          this.fillBuffer_();\\n        }\\n        return;\\n      }\\n\\n      // the last segment append must have been entirely in the\\n      // already buffered time ranges. adjust the timeCorrection\\n      // offset to fetch forward until we find a segment that adds\\n      // to the buffered time ranges and improves subsequent media\\n      // index calculations.\\n      var correctionApplied = this.incrementTimeCorrection_(segmentInfo.duration, 4);\\n\\n      if (correctionApplied && !this.paused()) {\\n        this.fillBuffer_();\\n      }\\n    }\\n\\n    /**\\n     * annotate the segment with any start and end time information\\n     * added by the media processing\\n     *\\n     * @private\\n     * @param {Object} segmentInfo annotate a segment with time info\\n     */\\n  }, {\\n    key: 'updateTimeline_',\\n    value: function updateTimeline_(segmentInfo) {\\n      var segment = undefined;\\n      var segmentEnd = undefined;\\n      var timelineUpdated = false;\\n      var playlist = segmentInfo.playlist;\\n      var currentMediaIndex = segmentInfo.mediaIndex;\\n\\n      currentMediaIndex += playlist.mediaSequence - this.playlist_.mediaSequence;\\n      segment = playlist.segments[currentMediaIndex];\\n\\n      // Update segment meta-data (duration and end-point) based on timeline\\n      if (segment && segmentInfo && segmentInfo.playlist.uri === this.playlist_.uri) {\\n        segmentEnd = _ranges2['default'].findSoleUncommonTimeRangesEnd(segmentInfo.buffered, this.sourceUpdater_.buffered());\\n        timelineUpdated = updateSegmentMetadata(playlist, currentMediaIndex, segmentEnd);\\n      }\\n\\n      return timelineUpdated;\\n    }\\n\\n    /**\\n     * add a number of seconds to the currentTime when determining which\\n     * segment to fetch in order to force the fetcher to advance in cases\\n     * where it may get stuck on the same segment due to buffer gaps or\\n     * missing segment annotation after a rendition switch (especially\\n     * during a live stream)\\n     *\\n     * @private\\n     * @param {Number} secondsToIncrement number of seconds to add to the\\n     * timeCorrection_ variable\\n     * @param {Number} maxSegmentsToWalk maximum number of times we allow this\\n     * function to walk forward\\n     */\\n  }, {\\n    key: 'incrementTimeCorrection_',\\n    value: function incrementTimeCorrection_(secondsToIncrement, maxSegmentsToWalk) {\\n      // If we have already incremented timeCorrection_ beyond the limit,\\n      // stop searching for a segment and reset timeCorrection_\\n      if (this.timeCorrection_ >= this.playlist_.targetDuration * maxSegmentsToWalk) {\\n        this.timeCorrection_ = 0;\\n        return false;\\n      }\\n\\n      this.timeCorrection_ += secondsToIncrement;\\n      return true;\\n    }\\n  }]);\\n\\n  return SegmentLoader;\\n})(_videoJs2['default'].EventTarget);\\n\\nexports['default'] = SegmentLoader;\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./config\\\":3,\\\"./playlist\\\":8,\\\"./ranges\\\":9,\\\"./source-updater\\\":13,\\\"aes-decrypter\\\":19,\\\"global/window\\\":26}],13:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file source-updater.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\n/**\\n * A queue of callbacks to be serialized and applied when a\\n * MediaSource and its associated SourceBuffers are not in the\\n * updating state. It is used by the segment loader to update the\\n * underlying SourceBuffers when new data is loaded, for instance.\\n *\\n * @class SourceUpdater\\n * @param {MediaSource} mediaSource the MediaSource to create the\\n * SourceBuffer from\\n * @param {String} mimeType the desired MIME type of the underlying\\n * SourceBuffer\\n */\\n\\nvar SourceUpdater = (function () {\\n  function SourceUpdater(mediaSource, mimeType) {\\n    var _this = this;\\n\\n    _classCallCheck(this, SourceUpdater);\\n\\n    var createSourceBuffer = function createSourceBuffer() {\\n      _this.sourceBuffer_ = mediaSource.addSourceBuffer(mimeType);\\n\\n      // run completion handlers and process callbacks as updateend\\n      // events fire\\n      _this.onUpdateendCallback_ = function () {\\n        var pendingCallback = _this.pendingCallback_;\\n\\n        _this.pendingCallback_ = null;\\n\\n        if (pendingCallback) {\\n          pendingCallback();\\n        }\\n\\n        _this.runCallback_();\\n      };\\n\\n      _this.sourceBuffer_.addEventListener('updateend', _this.onUpdateendCallback_);\\n\\n      _this.runCallback_();\\n    };\\n\\n    this.callbacks_ = [];\\n    this.pendingCallback_ = null;\\n    this.timestampOffset_ = 0;\\n    this.mediaSource = mediaSource;\\n\\n    if (mediaSource.readyState === 'closed') {\\n      mediaSource.addEventListener('sourceopen', createSourceBuffer);\\n    } else {\\n      createSourceBuffer();\\n    }\\n  }\\n\\n  /**\\n   * Aborts the current segment and resets the segment parser.\\n   *\\n   * @param {Function} done function to call when done\\n   * @see http://w3c.github.io/media-source/#widl-SourceBuffer-abort-void\\n   */\\n\\n  _createClass(SourceUpdater, [{\\n    key: 'abort',\\n    value: function abort(done) {\\n      var _this2 = this;\\n\\n      this.queueCallback_(function () {\\n        _this2.sourceBuffer_.abort();\\n      }, done);\\n    }\\n\\n    /**\\n     * Queue an update to append an ArrayBuffer.\\n     *\\n     * @param {ArrayBuffer} bytes\\n     * @param {Function} done the function to call when done\\n     * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-appendBuffer-void-ArrayBuffer-data\\n     */\\n  }, {\\n    key: 'appendBuffer',\\n    value: function appendBuffer(bytes, done) {\\n      var _this3 = this;\\n\\n      this.queueCallback_(function () {\\n        _this3.sourceBuffer_.appendBuffer(bytes);\\n      }, done);\\n    }\\n\\n    /**\\n     * Indicates what TimeRanges are buffered in the managed SourceBuffer.\\n     *\\n     * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-buffered\\n     */\\n  }, {\\n    key: 'buffered',\\n    value: function buffered() {\\n      if (!this.sourceBuffer_) {\\n        return _videoJs2['default'].createTimeRanges();\\n      }\\n      return this.sourceBuffer_.buffered;\\n    }\\n\\n    /**\\n     * Queue an update to set the duration.\\n     *\\n     * @param {Double} duration what to set the duration to\\n     * @see http://www.w3.org/TR/media-source/#widl-MediaSource-duration\\n     */\\n  }, {\\n    key: 'duration',\\n    value: function duration(_duration) {\\n      var _this4 = this;\\n\\n      this.queueCallback_(function () {\\n        _this4.sourceBuffer_.duration = _duration;\\n      });\\n    }\\n\\n    /**\\n     * Queue an update to remove a time range from the buffer.\\n     *\\n     * @param {Number} start where to start the removal\\n     * @param {Number} end where to end the removal\\n     * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-remove-void-double-start-unrestricted-double-end\\n     */\\n  }, {\\n    key: 'remove',\\n    value: function remove(start, end) {\\n      var _this5 = this;\\n\\n      this.queueCallback_(function () {\\n        _this5.sourceBuffer_.remove(start, end);\\n      });\\n    }\\n\\n    /**\\n     * wether the underlying sourceBuffer is updating or not\\n     *\\n     * @return {Boolean} the updating status of the SourceBuffer\\n     */\\n  }, {\\n    key: 'updating',\\n    value: function updating() {\\n      return !this.sourceBuffer_ || this.sourceBuffer_.updating;\\n    }\\n\\n    /**\\n     * Set/get the timestampoffset on the SourceBuffer\\n     *\\n     * @return {Number} the timestamp offset\\n     */\\n  }, {\\n    key: 'timestampOffset',\\n    value: function timestampOffset(offset) {\\n      var _this6 = this;\\n\\n      if (typeof offset !== 'undefined') {\\n        this.queueCallback_(function () {\\n          _this6.sourceBuffer_.timestampOffset = offset;\\n        });\\n        this.timestampOffset_ = offset;\\n      }\\n      return this.timestampOffset_;\\n    }\\n\\n    /**\\n     * que a callback to run\\n     */\\n  }, {\\n    key: 'queueCallback_',\\n    value: function queueCallback_(callback, done) {\\n      this.callbacks_.push([callback.bind(this), done]);\\n      this.runCallback_();\\n    }\\n\\n    /**\\n     * run a queued callback\\n     */\\n  }, {\\n    key: 'runCallback_',\\n    value: function runCallback_() {\\n      var callbacks = undefined;\\n\\n      if (this.sourceBuffer_ && !this.sourceBuffer_.updating && this.callbacks_.length) {\\n        callbacks = this.callbacks_.shift();\\n        this.pendingCallback_ = callbacks[1];\\n        callbacks[0]();\\n      }\\n    }\\n\\n    /**\\n     * dispose of the source updater and the underlying sourceBuffer\\n     */\\n  }, {\\n    key: 'dispose',\\n    value: function dispose() {\\n      this.sourceBuffer_.removeEventListener('updateend', this.onUpdateendCallback_);\\n      if (this.sourceBuffer_ && this.mediaSource.readyState === 'open') {\\n        this.sourceBuffer_.abort();\\n      }\\n    }\\n  }]);\\n\\n  return SourceUpdater;\\n})();\\n\\nexports['default'] = SourceUpdater;\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{}],14:[function(require,module,exports){\\n/**\\n * @file stream.js\\n */\\n/**\\n * A lightweight readable stream implemention that handles event dispatching.\\n *\\n * @class Stream\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nvar Stream = (function () {\\n  function Stream() {\\n    _classCallCheck(this, Stream);\\n\\n    this.listeners = {};\\n  }\\n\\n  /**\\n   * Add a listener for a specified event type.\\n   *\\n   * @param {String} type the event name\\n   * @param {Function} listener the callback to be invoked when an event of\\n   * the specified type occurs\\n   */\\n\\n  _createClass(Stream, [{\\n    key: 'on',\\n    value: function on(type, listener) {\\n      if (!this.listeners[type]) {\\n        this.listeners[type] = [];\\n      }\\n      this.listeners[type].push(listener);\\n    }\\n\\n    /**\\n     * Remove a listener for a specified event type.\\n     *\\n     * @param {String} type the event name\\n     * @param {Function} listener  a function previously registered for this\\n     * type of event through `on`\\n     * @return {Boolean} if we could turn it off or not\\n     */\\n  }, {\\n    key: 'off',\\n    value: function off(type, listener) {\\n      var index = undefined;\\n\\n      if (!this.listeners[type]) {\\n        return false;\\n      }\\n      index = this.listeners[type].indexOf(listener);\\n      this.listeners[type].splice(index, 1);\\n      return index > -1;\\n    }\\n\\n    /**\\n     * Trigger an event of the specified type on this stream. Any additional\\n     * arguments to this function are passed as parameters to event listeners.\\n     *\\n     * @param {String} type the event name\\n     */\\n  }, {\\n    key: 'trigger',\\n    value: function trigger(type) {\\n      var callbacks = undefined;\\n      var i = undefined;\\n      var length = undefined;\\n      var args = undefined;\\n\\n      callbacks = this.listeners[type];\\n      if (!callbacks) {\\n        return;\\n      }\\n      // Slicing the arguments on every invocation of this method\\n      // can add a significant amount of overhead. Avoid the\\n      // intermediate object creation for the common case of a\\n      // single callback argument\\n      if (arguments.length === 2) {\\n        length = callbacks.length;\\n        for (i = 0; i < length; ++i) {\\n          callbacks[i].call(this, arguments[1]);\\n        }\\n      } else {\\n        args = Array.prototype.slice.call(arguments, 1);\\n        length = callbacks.length;\\n        for (i = 0; i < length; ++i) {\\n          callbacks[i].apply(this, args);\\n        }\\n      }\\n    }\\n\\n    /**\\n     * Destroys the stream and cleans up.\\n     */\\n  }, {\\n    key: 'dispose',\\n    value: function dispose() {\\n      this.listeners = {};\\n    }\\n\\n    /**\\n     * Forwards all `data` events on this stream to the destination stream. The\\n     * destination stream should provide a method `push` to receive the data\\n     * events as they arrive.\\n     *\\n     * @param {Stream} destination the stream that will receive all `data` events\\n     * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\\n     */\\n  }, {\\n    key: 'pipe',\\n    value: function pipe(destination) {\\n      this.on('data', function (data) {\\n        destination.push(data);\\n      });\\n    }\\n  }]);\\n\\n  return Stream;\\n})();\\n\\nexports['default'] = Stream;\\nmodule.exports = exports['default'];\\n},{}],15:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file xhr.js\\n */\\n\\n/**\\n * A wrapper for videojs.xhr that tracks bandwidth.\\n *\\n * @param {Object} options options for the XHR\\n * @param {Function} callback the callback to call when done\\n * @return {Request} the xhr request that is going to be made\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar xhrFactory = function xhrFactory() {\\n  var xhr = function XhrFunction(options, callback) {\\n    // Add a default timeout for all hls requests\\n    options = (0, _videoJs.mergeOptions)({\\n      timeout: 45e3\\n    }, options);\\n\\n    // Allow an optional user-specified function to modify the option\\n    // object before we construct the xhr request\\n    if (XhrFunction.beforeRequest && typeof XhrFunction.beforeRequest === 'function') {\\n      var newOptions = XhrFunction.beforeRequest(options);\\n\\n      if (newOptions) {\\n        options = newOptions;\\n      }\\n    }\\n\\n    var request = (0, _videoJs.xhr)(options, function (error, response) {\\n      if (!error && request.response) {\\n        request.responseTime = new Date().getTime();\\n        request.roundTripTime = request.responseTime - request.requestTime;\\n        request.bytesReceived = request.response.byteLength || request.response.length;\\n        if (!request.bandwidth) {\\n          request.bandwidth = Math.floor(request.bytesReceived / request.roundTripTime * 8 * 1000);\\n        }\\n      }\\n\\n      // videojs.xhr now uses a specific code\\n      // on the error object to signal that a request has\\n      // timed out errors of setting a boolean on the request object\\n      if (error || request.timedout) {\\n        request.timedout = request.timedout || error.code === 'ETIMEDOUT';\\n      } else {\\n        request.timedout = false;\\n      }\\n\\n      // videojs.xhr no longer considers status codes outside of 200 and 0\\n      // (for file uris) to be errors, but the old XHR did, so emulate that\\n      // behavior. Status 206 may be used in response to byterange requests.\\n      if (!error && response.statusCode !== 200 && response.statusCode !== 206 && response.statusCode !== 0) {\\n        error = new Error('XHR Failed with a response of: ' + (request && (request.response || request.responseText)));\\n      }\\n\\n      callback(error, request);\\n    });\\n\\n    request.requestTime = new Date().getTime();\\n    return request;\\n  };\\n\\n  return xhr;\\n};\\n\\nexports['default'] = xhrFactory;\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{}],16:[function(require,module,exports){\\n/**\\n * @file aes.js\\n *\\n * This file contains an adaptation of the AES decryption algorithm\\n * from the Standford Javascript Cryptography Library. That work is\\n * covered by the following copyright and permissions notice:\\n *\\n * Copyright 2009-2010 Emily Stark, Mike Hamburg, Dan Boneh.\\n * All rights reserved.\\n *\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are\\n * met:\\n *\\n * 1. Redistributions of source code must retain the above copyright\\n *    notice, this list of conditions and the following disclaimer.\\n *\\n * 2. Redistributions in binary form must reproduce the above\\n *    copyright notice, this list of conditions and the following\\n *    disclaimer in the documentation and/or other materials provided\\n *    with the distribution.\\n *\\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR\\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR CONTRIBUTORS BE\\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n *\\n * The views and conclusions contained in the software and documentation\\n * are those of the authors and should not be interpreted as representing\\n * official policies, either expressed or implied, of the authors.\\n */\\n\\n/**\\n * Expand the S-box tables.\\n *\\n * @private\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nvar precompute = function precompute() {\\n  var tables = [[[], [], [], [], []], [[], [], [], [], []]];\\n  var encTable = tables[0];\\n  var decTable = tables[1];\\n  var sbox = encTable[4];\\n  var sboxInv = decTable[4];\\n  var i = undefined;\\n  var x = undefined;\\n  var xInv = undefined;\\n  var d = [];\\n  var th = [];\\n  var x2 = undefined;\\n  var x4 = undefined;\\n  var x8 = undefined;\\n  var s = undefined;\\n  var tEnc = undefined;\\n  var tDec = undefined;\\n\\n  // Compute double and third tables\\n  for (i = 0; i < 256; i++) {\\n    th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;\\n  }\\n\\n  for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {\\n    // Compute sbox\\n    s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;\\n    s = s >> 8 ^ s & 255 ^ 99;\\n    sbox[x] = s;\\n    sboxInv[s] = x;\\n\\n    // Compute MixColumns\\n    x8 = d[x4 = d[x2 = d[x]]];\\n    tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\\n    tEnc = d[s] * 0x101 ^ s * 0x1010100;\\n\\n    for (i = 0; i < 4; i++) {\\n      encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\\n      decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;\\n    }\\n  }\\n\\n  // Compactify. Considerable speedup on Firefox.\\n  for (i = 0; i < 5; i++) {\\n    encTable[i] = encTable[i].slice(0);\\n    decTable[i] = decTable[i].slice(0);\\n  }\\n  return tables;\\n};\\nvar aesTables = null;\\n\\n/**\\n * Schedule out an AES key for both encryption and decryption. This\\n * is a low-level class. Use a cipher mode to do bulk encryption.\\n *\\n * @class AES\\n * @param key {Array} The key as an array of 4, 6 or 8 words.\\n */\\n\\nvar AES = (function () {\\n  function AES(key) {\\n    _classCallCheck(this, AES);\\n\\n    /**\\n     * The expanded S-box and inverse S-box tables. These will be computed\\n     * on the client so that we don't have to send them down the wire.\\n     *\\n     * There are two tables, _tables[0] is for encryption and\\n     * _tables[1] is for decryption.\\n     *\\n     * The first 4 sub-tables are the expanded S-box with MixColumns. The\\n     * last (_tables[01][4]) is the S-box itself.\\n     *\\n     * @private\\n     */\\n    // if we have yet to precompute the S-box tables\\n    // do so now\\n    if (!aesTables) {\\n      aesTables = precompute();\\n    }\\n    // then make a copy of that object for use\\n    this._tables = [[aesTables[0][0].slice(), aesTables[0][1].slice(), aesTables[0][2].slice(), aesTables[0][3].slice(), aesTables[0][4].slice()], [aesTables[1][0].slice(), aesTables[1][1].slice(), aesTables[1][2].slice(), aesTables[1][3].slice(), aesTables[1][4].slice()]];\\n    var i = undefined;\\n    var j = undefined;\\n    var tmp = undefined;\\n    var encKey = undefined;\\n    var decKey = undefined;\\n    var sbox = this._tables[0][4];\\n    var decTable = this._tables[1];\\n    var keyLen = key.length;\\n    var rcon = 1;\\n\\n    if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {\\n      throw new Error('Invalid aes key size');\\n    }\\n\\n    encKey = key.slice(0);\\n    decKey = [];\\n    this._key = [encKey, decKey];\\n\\n    // schedule encryption keys\\n    for (i = keyLen; i < 4 * keyLen + 28; i++) {\\n      tmp = encKey[i - 1];\\n\\n      // apply sbox\\n      if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {\\n        tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];\\n\\n        // shift rows and add rcon\\n        if (i % keyLen === 0) {\\n          tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;\\n          rcon = rcon << 1 ^ (rcon >> 7) * 283;\\n        }\\n      }\\n\\n      encKey[i] = encKey[i - keyLen] ^ tmp;\\n    }\\n\\n    // schedule decryption keys\\n    for (j = 0; i; j++, i--) {\\n      tmp = encKey[j & 3 ? i : i - 4];\\n      if (i <= 4 || j < 4) {\\n        decKey[j] = tmp;\\n      } else {\\n        decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Decrypt 16 bytes, specified as four 32-bit words.\\n   *\\n   * @param {Number} encrypted0 the first word to decrypt\\n   * @param {Number} encrypted1 the second word to decrypt\\n   * @param {Number} encrypted2 the third word to decrypt\\n   * @param {Number} encrypted3 the fourth word to decrypt\\n   * @param {Int32Array} out the array to write the decrypted words\\n   * into\\n   * @param {Number} offset the offset into the output array to start\\n   * writing results\\n   * @return {Array} The plaintext.\\n   */\\n\\n  _createClass(AES, [{\\n    key: 'decrypt',\\n    value: function decrypt(encrypted0, encrypted1, encrypted2, encrypted3, out, offset) {\\n      var key = this._key[1];\\n      // state variables a,b,c,d are loaded with pre-whitened data\\n      var a = encrypted0 ^ key[0];\\n      var b = encrypted3 ^ key[1];\\n      var c = encrypted2 ^ key[2];\\n      var d = encrypted1 ^ key[3];\\n      var a2 = undefined;\\n      var b2 = undefined;\\n      var c2 = undefined;\\n\\n      // key.length === 2 ?\\n      var nInnerRounds = key.length / 4 - 2;\\n      var i = undefined;\\n      var kIndex = 4;\\n      var table = this._tables[1];\\n\\n      // load up the tables\\n      var table0 = table[0];\\n      var table1 = table[1];\\n      var table2 = table[2];\\n      var table3 = table[3];\\n      var sbox = table[4];\\n\\n      // Inner rounds. Cribbed from OpenSSL.\\n      for (i = 0; i < nInnerRounds; i++) {\\n        a2 = table0[a >>> 24] ^ table1[b >> 16 & 255] ^ table2[c >> 8 & 255] ^ table3[d & 255] ^ key[kIndex];\\n        b2 = table0[b >>> 24] ^ table1[c >> 16 & 255] ^ table2[d >> 8 & 255] ^ table3[a & 255] ^ key[kIndex + 1];\\n        c2 = table0[c >>> 24] ^ table1[d >> 16 & 255] ^ table2[a >> 8 & 255] ^ table3[b & 255] ^ key[kIndex + 2];\\n        d = table0[d >>> 24] ^ table1[a >> 16 & 255] ^ table2[b >> 8 & 255] ^ table3[c & 255] ^ key[kIndex + 3];\\n        kIndex += 4;\\n        a = a2;b = b2;c = c2;\\n      }\\n\\n      // Last round.\\n      for (i = 0; i < 4; i++) {\\n        out[(3 & -i) + offset] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];\\n        a2 = a;a = b;b = c;c = d;d = a2;\\n      }\\n    }\\n  }]);\\n\\n  return AES;\\n})();\\n\\nexports['default'] = AES;\\nmodule.exports = exports['default'];\\n},{}],17:[function(require,module,exports){\\n/**\\n * @file async-stream.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _stream = require('./stream');\\n\\nvar _stream2 = _interopRequireDefault(_stream);\\n\\n/**\\n * A wrapper around the Stream class to use setTiemout\\n * and run stream \\\"jobs\\\" Asynchronously\\n *\\n * @class AsyncStream\\n * @extends Stream\\n */\\n\\nvar AsyncStream = (function (_Stream) {\\n  _inherits(AsyncStream, _Stream);\\n\\n  function AsyncStream() {\\n    _classCallCheck(this, AsyncStream);\\n\\n    _get(Object.getPrototypeOf(AsyncStream.prototype), 'constructor', this).call(this, _stream2['default']);\\n    this.jobs = [];\\n    this.delay = 1;\\n    this.timeout_ = null;\\n  }\\n\\n  /**\\n   * process an async job\\n   *\\n   * @private\\n   */\\n\\n  _createClass(AsyncStream, [{\\n    key: 'processJob_',\\n    value: function processJob_() {\\n      this.jobs.shift()();\\n      if (this.jobs.length) {\\n        this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);\\n      } else {\\n        this.timeout_ = null;\\n      }\\n    }\\n\\n    /**\\n     * push a job into the stream\\n     *\\n     * @param {Function} job the job to push into the stream\\n     */\\n  }, {\\n    key: 'push',\\n    value: function push(job) {\\n      this.jobs.push(job);\\n      if (!this.timeout_) {\\n        this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);\\n      }\\n    }\\n  }]);\\n\\n  return AsyncStream;\\n})(_stream2['default']);\\n\\nexports['default'] = AsyncStream;\\nmodule.exports = exports['default'];\\n},{\\\"./stream\\\":20}],18:[function(require,module,exports){\\n/**\\n * @file decrypter.js\\n *\\n * An asynchronous implementation of AES-128 CBC decryption with\\n * PKCS#7 padding.\\n */\\n\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nvar _aes = require('./aes');\\n\\nvar _aes2 = _interopRequireDefault(_aes);\\n\\nvar _asyncStream = require('./async-stream');\\n\\nvar _asyncStream2 = _interopRequireDefault(_asyncStream);\\n\\nvar _pkcs7 = require('pkcs7');\\n\\n/**\\n * Convert network-order (big-endian) bytes into their little-endian\\n * representation.\\n */\\nvar ntoh = function ntoh(word) {\\n  return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\\n};\\n\\n/**\\n * Decrypt bytes using AES-128 with CBC and PKCS#7 padding.\\n *\\n * @param {Uint8Array} encrypted the encrypted bytes\\n * @param {Uint32Array} key the bytes of the decryption key\\n * @param {Uint32Array} initVector the initialization vector (IV) to\\n * use for the first round of CBC.\\n * @return {Uint8Array} the decrypted bytes\\n *\\n * @see http://en.wikipedia.org/wiki/Advanced_Encryption_Standard\\n * @see http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_.28CBC.29\\n * @see https://tools.ietf.org/html/rfc2315\\n */\\nvar decrypt = function decrypt(encrypted, key, initVector) {\\n  // word-level access to the encrypted bytes\\n  var encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2);\\n\\n  var decipher = new _aes2['default'](Array.prototype.slice.call(key));\\n\\n  // byte and word-level access for the decrypted output\\n  var decrypted = new Uint8Array(encrypted.byteLength);\\n  var decrypted32 = new Int32Array(decrypted.buffer);\\n\\n  // temporary variables for working with the IV, encrypted, and\\n  // decrypted data\\n  var init0 = undefined;\\n  var init1 = undefined;\\n  var init2 = undefined;\\n  var init3 = undefined;\\n  var encrypted0 = undefined;\\n  var encrypted1 = undefined;\\n  var encrypted2 = undefined;\\n  var encrypted3 = undefined;\\n\\n  // iteration variable\\n  var wordIx = undefined;\\n\\n  // pull out the words of the IV to ensure we don't modify the\\n  // passed-in reference and easier access\\n  init0 = initVector[0];\\n  init1 = initVector[1];\\n  init2 = initVector[2];\\n  init3 = initVector[3];\\n\\n  // decrypt four word sequences, applying cipher-block chaining (CBC)\\n  // to each decrypted block\\n  for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {\\n    // convert big-endian (network order) words into little-endian\\n    // (javascript order)\\n    encrypted0 = ntoh(encrypted32[wordIx]);\\n    encrypted1 = ntoh(encrypted32[wordIx + 1]);\\n    encrypted2 = ntoh(encrypted32[wordIx + 2]);\\n    encrypted3 = ntoh(encrypted32[wordIx + 3]);\\n\\n    // decrypt the block\\n    decipher.decrypt(encrypted0, encrypted1, encrypted2, encrypted3, decrypted32, wordIx);\\n\\n    // XOR with the IV, and restore network byte-order to obtain the\\n    // plaintext\\n    decrypted32[wordIx] = ntoh(decrypted32[wordIx] ^ init0);\\n    decrypted32[wordIx + 1] = ntoh(decrypted32[wordIx + 1] ^ init1);\\n    decrypted32[wordIx + 2] = ntoh(decrypted32[wordIx + 2] ^ init2);\\n    decrypted32[wordIx + 3] = ntoh(decrypted32[wordIx + 3] ^ init3);\\n\\n    // setup the IV for the next round\\n    init0 = encrypted0;\\n    init1 = encrypted1;\\n    init2 = encrypted2;\\n    init3 = encrypted3;\\n  }\\n\\n  return decrypted;\\n};\\n\\nexports.decrypt = decrypt;\\n/**\\n * The `Decrypter` class that manages decryption of AES\\n * data through `AsyncStream` objects and the `decrypt`\\n * function\\n *\\n * @param {Uint8Array} encrypted the encrypted bytes\\n * @param {Uint32Array} key the bytes of the decryption key\\n * @param {Uint32Array} initVector the initialization vector (IV) to\\n * @param {Function} done the function to run when done\\n * @class Decrypter\\n */\\n\\nvar Decrypter = (function () {\\n  function Decrypter(encrypted, key, initVector, done) {\\n    _classCallCheck(this, Decrypter);\\n\\n    var step = Decrypter.STEP;\\n    var encrypted32 = new Int32Array(encrypted.buffer);\\n    var decrypted = new Uint8Array(encrypted.byteLength);\\n    var i = 0;\\n\\n    this.asyncStream_ = new _asyncStream2['default']();\\n\\n    // split up the encryption job and do the individual chunks asynchronously\\n    this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));\\n    for (i = step; i < encrypted32.length; i += step) {\\n      initVector = new Uint32Array([ntoh(encrypted32[i - 4]), ntoh(encrypted32[i - 3]), ntoh(encrypted32[i - 2]), ntoh(encrypted32[i - 1])]);\\n      this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));\\n    }\\n    // invoke the done() callback when everything is finished\\n    this.asyncStream_.push(function () {\\n      // remove pkcs#7 padding from the decrypted bytes\\n      done(null, (0, _pkcs7.unpad)(decrypted));\\n    });\\n  }\\n\\n  /**\\n   * a getter for step the maximum number of bytes to process at one time\\n   *\\n   * @return {Number} the value of step 32000\\n   */\\n\\n  _createClass(Decrypter, [{\\n    key: 'decryptChunk_',\\n\\n    /**\\n     * @private\\n     */\\n    value: function decryptChunk_(encrypted, key, initVector, decrypted) {\\n      return function () {\\n        var bytes = decrypt(encrypted, key, initVector);\\n\\n        decrypted.set(bytes, encrypted.byteOffset);\\n      };\\n    }\\n  }], [{\\n    key: 'STEP',\\n    get: function get() {\\n      // 4 * 8000;\\n      return 32000;\\n    }\\n  }]);\\n\\n  return Decrypter;\\n})();\\n\\nexports.Decrypter = Decrypter;\\nexports['default'] = {\\n  Decrypter: Decrypter,\\n  decrypt: decrypt\\n};\\n},{\\\"./aes\\\":16,\\\"./async-stream\\\":17,\\\"pkcs7\\\":22}],19:[function(require,module,exports){\\n/**\\n * @file index.js\\n *\\n * Index module to easily import the primary components of AES-128\\n * decryption. Like this:\\n *\\n * ```js\\n * import {Decrypter, decrypt, AsyncStream} from 'aes-decrypter';\\n * ```\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _decrypter = require('./decrypter');\\n\\nvar _asyncStream = require('./async-stream');\\n\\nvar _asyncStream2 = _interopRequireDefault(_asyncStream);\\n\\nexports['default'] = {\\n  decrypt: _decrypter.decrypt,\\n  Decrypter: _decrypter.Decrypter,\\n  AsyncStream: _asyncStream2['default']\\n};\\nmodule.exports = exports['default'];\\n},{\\\"./async-stream\\\":17,\\\"./decrypter\\\":18}],20:[function(require,module,exports){\\narguments[4][14][0].apply(exports,arguments)\\n},{\\\"dup\\\":14}],21:[function(require,module,exports){\\n/*\\n * pkcs7.pad\\n * https://github.com/brightcove/pkcs7\\n *\\n * Copyright (c) 2014 Brightcove\\n * Licensed under the apache2 license.\\n */\\n\\n'use strict';\\n\\nvar PADDING;\\n\\n/**\\n * Returns a new Uint8Array that is padded with PKCS#7 padding.\\n * @param plaintext {Uint8Array} the input bytes before encryption\\n * @return {Uint8Array} the padded bytes\\n * @see http://tools.ietf.org/html/rfc5652\\n */\\nmodule.exports = function pad(plaintext) {\\n  var padding = PADDING[(plaintext.byteLength % 16) || 0],\\n      result = new Uint8Array(plaintext.byteLength + padding.length);\\n  result.set(plaintext);\\n  result.set(padding, plaintext.byteLength);\\n  return result;\\n};\\n\\n// pre-define the padding values\\nPADDING = [\\n  [16, 16, 16, 16,\\n   16, 16, 16, 16,\\n   16, 16, 16, 16,\\n   16, 16, 16, 16],\\n\\n  [15, 15, 15, 15,\\n   15, 15, 15, 15,\\n   15, 15, 15, 15,\\n   15, 15, 15],\\n\\n  [14, 14, 14, 14,\\n   14, 14, 14, 14,\\n   14, 14, 14, 14,\\n   14, 14],\\n\\n  [13, 13, 13, 13,\\n   13, 13, 13, 13,\\n   13, 13, 13, 13,\\n   13],\\n\\n  [12, 12, 12, 12,\\n   12, 12, 12, 12,\\n   12, 12, 12, 12],\\n\\n  [11, 11, 11, 11,\\n   11, 11, 11, 11,\\n   11, 11, 11],\\n\\n  [10, 10, 10, 10,\\n   10, 10, 10, 10,\\n   10, 10],\\n\\n  [9, 9, 9, 9,\\n   9, 9, 9, 9,\\n   9],\\n\\n  [8, 8, 8, 8,\\n   8, 8, 8, 8],\\n\\n  [7, 7, 7, 7,\\n   7, 7, 7],\\n\\n  [6, 6, 6, 6,\\n   6, 6],\\n\\n  [5, 5, 5, 5,\\n   5],\\n\\n  [4, 4, 4, 4],\\n\\n  [3, 3, 3],\\n\\n  [2, 2],\\n\\n  [1]\\n];\\n\\n},{}],22:[function(require,module,exports){\\n/*\\n * pkcs7\\n * https://github.com/brightcove/pkcs7\\n *\\n * Copyright (c) 2014 Brightcove\\n * Licensed under the apache2 license.\\n */\\n\\n'use strict';\\n\\nexports.pad = require('./pad.js');\\nexports.unpad = require('./unpad.js');\\n\\n},{\\\"./pad.js\\\":21,\\\"./unpad.js\\\":23}],23:[function(require,module,exports){\\n/*\\n * pkcs7.unpad\\n * https://github.com/brightcove/pkcs7\\n *\\n * Copyright (c) 2014 Brightcove\\n * Licensed under the apache2 license.\\n */\\n\\n'use strict';\\n\\n/**\\n * Returns the subarray of a Uint8Array without PKCS#7 padding.\\n * @param padded {Uint8Array} unencrypted bytes that have been padded\\n * @return {Uint8Array} the unpadded bytes\\n * @see http://tools.ietf.org/html/rfc5652\\n */\\nmodule.exports = function unpad(padded) {\\n  return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);\\n};\\n\\n},{}],24:[function(require,module,exports){\\n\\n},{}],25:[function(require,module,exports){\\n(function (global){\\nvar topLevel = typeof global !== 'undefined' ? global :\\n    typeof window !== 'undefined' ? window : {}\\nvar minDoc = require('min-document');\\n\\nif (typeof document !== 'undefined') {\\n    module.exports = document;\\n} else {\\n    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\\n\\n    if (!doccy) {\\n        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\\n    }\\n\\n    module.exports = doccy;\\n}\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"min-document\\\":24}],26:[function(require,module,exports){\\n(function (global){\\nif (typeof window !== \\\"undefined\\\") {\\n    module.exports = window;\\n} else if (typeof global !== \\\"undefined\\\") {\\n    module.exports = global;\\n} else if (typeof self !== \\\"undefined\\\"){\\n    module.exports = self;\\n} else {\\n    module.exports = {};\\n}\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{}],27:[function(require,module,exports){\\n/** Used as the `TypeError` message for \\\"Functions\\\" methods. */\\nvar FUNC_ERROR_TEXT = 'Expected a function';\\n\\n/* Native method references for those with the same name as other `lodash` methods. */\\nvar nativeMax = Math.max;\\n\\n/**\\n * Creates a function that invokes `func` with the `this` binding of the\\n * created function and arguments from `start` and beyond provided as an array.\\n *\\n * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/Web/JavaScript/Reference/Functions/rest_parameters).\\n *\\n * @static\\n * @memberOf _\\n * @category Function\\n * @param {Function} func The function to apply a rest parameter to.\\n * @param {number} [start=func.length-1] The start position of the rest parameter.\\n * @returns {Function} Returns the new function.\\n * @example\\n *\\n * var say = _.restParam(function(what, names) {\\n *   return what + ' ' + _.initial(names).join(', ') +\\n *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\\n * });\\n *\\n * say('hello', 'fred', 'barney', 'pebbles');\\n * // => 'hello fred, barney, & pebbles'\\n */\\nfunction restParam(func, start) {\\n  if (typeof func != 'function') {\\n    throw new TypeError(FUNC_ERROR_TEXT);\\n  }\\n  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);\\n  return function() {\\n    var args = arguments,\\n        index = -1,\\n        length = nativeMax(args.length - start, 0),\\n        rest = Array(length);\\n\\n    while (++index < length) {\\n      rest[index] = args[start + index];\\n    }\\n    switch (start) {\\n      case 0: return func.call(this, rest);\\n      case 1: return func.call(this, args[0], rest);\\n      case 2: return func.call(this, args[0], args[1], rest);\\n    }\\n    var otherArgs = Array(start + 1);\\n    index = -1;\\n    while (++index < start) {\\n      otherArgs[index] = args[index];\\n    }\\n    otherArgs[start] = rest;\\n    return func.apply(this, otherArgs);\\n  };\\n}\\n\\nmodule.exports = restParam;\\n\\n},{}],28:[function(require,module,exports){\\n/**\\n * Copies the values of `source` to `array`.\\n *\\n * @private\\n * @param {Array} source The array to copy values from.\\n * @param {Array} [array=[]] The array to copy values to.\\n * @returns {Array} Returns `array`.\\n */\\nfunction arrayCopy(source, array) {\\n  var index = -1,\\n      length = source.length;\\n\\n  array || (array = Array(length));\\n  while (++index < length) {\\n    array[index] = source[index];\\n  }\\n  return array;\\n}\\n\\nmodule.exports = arrayCopy;\\n\\n},{}],29:[function(require,module,exports){\\n/**\\n * A specialized version of `_.forEach` for arrays without support for callback\\n * shorthands and `this` binding.\\n *\\n * @private\\n * @param {Array} array The array to iterate over.\\n * @param {Function} iteratee The function invoked per iteration.\\n * @returns {Array} Returns `array`.\\n */\\nfunction arrayEach(array, iteratee) {\\n  var index = -1,\\n      length = array.length;\\n\\n  while (++index < length) {\\n    if (iteratee(array[index], index, array) === false) {\\n      break;\\n    }\\n  }\\n  return array;\\n}\\n\\nmodule.exports = arrayEach;\\n\\n},{}],30:[function(require,module,exports){\\n/**\\n * Copies properties of `source` to `object`.\\n *\\n * @private\\n * @param {Object} source The object to copy properties from.\\n * @param {Array} props The property names to copy.\\n * @param {Object} [object={}] The object to copy properties to.\\n * @returns {Object} Returns `object`.\\n */\\nfunction baseCopy(source, props, object) {\\n  object || (object = {});\\n\\n  var index = -1,\\n      length = props.length;\\n\\n  while (++index < length) {\\n    var key = props[index];\\n    object[key] = source[key];\\n  }\\n  return object;\\n}\\n\\nmodule.exports = baseCopy;\\n\\n},{}],31:[function(require,module,exports){\\nvar createBaseFor = require('./createBaseFor');\\n\\n/**\\n * The base implementation of `baseForIn` and `baseForOwn` which iterates\\n * over `object` properties returned by `keysFunc` invoking `iteratee` for\\n * each property. Iteratee functions may exit iteration early by explicitly\\n * returning `false`.\\n *\\n * @private\\n * @param {Object} object The object to iterate over.\\n * @param {Function} iteratee The function invoked per iteration.\\n * @param {Function} keysFunc The function to get the keys of `object`.\\n * @returns {Object} Returns `object`.\\n */\\nvar baseFor = createBaseFor();\\n\\nmodule.exports = baseFor;\\n\\n},{\\\"./createBaseFor\\\":38}],32:[function(require,module,exports){\\nvar baseFor = require('./baseFor'),\\n    keysIn = require('../object/keysIn');\\n\\n/**\\n * The base implementation of `_.forIn` without support for callback\\n * shorthands and `this` binding.\\n *\\n * @private\\n * @param {Object} object The object to iterate over.\\n * @param {Function} iteratee The function invoked per iteration.\\n * @returns {Object} Returns `object`.\\n */\\nfunction baseForIn(object, iteratee) {\\n  return baseFor(object, iteratee, keysIn);\\n}\\n\\nmodule.exports = baseForIn;\\n\\n},{\\\"../object/keysIn\\\":59,\\\"./baseFor\\\":31}],33:[function(require,module,exports){\\nvar arrayEach = require('./arrayEach'),\\n    baseMergeDeep = require('./baseMergeDeep'),\\n    isArray = require('../lang/isArray'),\\n    isArrayLike = require('./isArrayLike'),\\n    isObject = require('../lang/isObject'),\\n    isObjectLike = require('./isObjectLike'),\\n    isTypedArray = require('../lang/isTypedArray'),\\n    keys = require('../object/keys');\\n\\n/**\\n * The base implementation of `_.merge` without support for argument juggling,\\n * multiple sources, and `this` binding `customizer` functions.\\n *\\n * @private\\n * @param {Object} object The destination object.\\n * @param {Object} source The source object.\\n * @param {Function} [customizer] The function to customize merged values.\\n * @param {Array} [stackA=[]] Tracks traversed source objects.\\n * @param {Array} [stackB=[]] Associates values with source counterparts.\\n * @returns {Object} Returns `object`.\\n */\\nfunction baseMerge(object, source, customizer, stackA, stackB) {\\n  if (!isObject(object)) {\\n    return object;\\n  }\\n  var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),\\n      props = isSrcArr ? undefined : keys(source);\\n\\n  arrayEach(props || source, function(srcValue, key) {\\n    if (props) {\\n      key = srcValue;\\n      srcValue = source[key];\\n    }\\n    if (isObjectLike(srcValue)) {\\n      stackA || (stackA = []);\\n      stackB || (stackB = []);\\n      baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);\\n    }\\n    else {\\n      var value = object[key],\\n          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\\n          isCommon = result === undefined;\\n\\n      if (isCommon) {\\n        result = srcValue;\\n      }\\n      if ((result !== undefined || (isSrcArr && !(key in object))) &&\\n          (isCommon || (result === result ? (result !== value) : (value === value)))) {\\n        object[key] = result;\\n      }\\n    }\\n  });\\n  return object;\\n}\\n\\nmodule.exports = baseMerge;\\n\\n},{\\\"../lang/isArray\\\":50,\\\"../lang/isObject\\\":53,\\\"../lang/isTypedArray\\\":56,\\\"../object/keys\\\":58,\\\"./arrayEach\\\":29,\\\"./baseMergeDeep\\\":34,\\\"./isArrayLike\\\":41,\\\"./isObjectLike\\\":46}],34:[function(require,module,exports){\\nvar arrayCopy = require('./arrayCopy'),\\n    isArguments = require('../lang/isArguments'),\\n    isArray = require('../lang/isArray'),\\n    isArrayLike = require('./isArrayLike'),\\n    isPlainObject = require('../lang/isPlainObject'),\\n    isTypedArray = require('../lang/isTypedArray'),\\n    toPlainObject = require('../lang/toPlainObject');\\n\\n/**\\n * A specialized version of `baseMerge` for arrays and objects which performs\\n * deep merges and tracks traversed objects enabling objects with circular\\n * references to be merged.\\n *\\n * @private\\n * @param {Object} object The destination object.\\n * @param {Object} source The source object.\\n * @param {string} key The key of the value to merge.\\n * @param {Function} mergeFunc The function to merge values.\\n * @param {Function} [customizer] The function to customize merged values.\\n * @param {Array} [stackA=[]] Tracks traversed source objects.\\n * @param {Array} [stackB=[]] Associates values with source counterparts.\\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\\n */\\nfunction baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {\\n  var length = stackA.length,\\n      srcValue = source[key];\\n\\n  while (length--) {\\n    if (stackA[length] == srcValue) {\\n      object[key] = stackB[length];\\n      return;\\n    }\\n  }\\n  var value = object[key],\\n      result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\\n      isCommon = result === undefined;\\n\\n  if (isCommon) {\\n    result = srcValue;\\n    if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {\\n      result = isArray(value)\\n        ? value\\n        : (isArrayLike(value) ? arrayCopy(value) : []);\\n    }\\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\\n      result = isArguments(value)\\n        ? toPlainObject(value)\\n        : (isPlainObject(value) ? value : {});\\n    }\\n    else {\\n      isCommon = false;\\n    }\\n  }\\n  // Add the source value to the stack of traversed objects and associate\\n  // it with its merged value.\\n  stackA.push(srcValue);\\n  stackB.push(result);\\n\\n  if (isCommon) {\\n    // Recursively merge objects and arrays (susceptible to call stack limits).\\n    object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);\\n  } else if (result === result ? (result !== value) : (value === value)) {\\n    object[key] = result;\\n  }\\n}\\n\\nmodule.exports = baseMergeDeep;\\n\\n},{\\\"../lang/isArguments\\\":49,\\\"../lang/isArray\\\":50,\\\"../lang/isPlainObject\\\":54,\\\"../lang/isTypedArray\\\":56,\\\"../lang/toPlainObject\\\":57,\\\"./arrayCopy\\\":28,\\\"./isArrayLike\\\":41}],35:[function(require,module,exports){\\nvar toObject = require('./toObject');\\n\\n/**\\n * The base implementation of `_.property` without support for deep paths.\\n *\\n * @private\\n * @param {string} key The key of the property to get.\\n * @returns {Function} Returns the new function.\\n */\\nfunction baseProperty(key) {\\n  return function(object) {\\n    return object == null ? undefined : toObject(object)[key];\\n  };\\n}\\n\\nmodule.exports = baseProperty;\\n\\n},{\\\"./toObject\\\":48}],36:[function(require,module,exports){\\nvar identity = require('../utility/identity');\\n\\n/**\\n * A specialized version of `baseCallback` which only supports `this` binding\\n * and specifying the number of arguments to provide to `func`.\\n *\\n * @private\\n * @param {Function} func The function to bind.\\n * @param {*} thisArg The `this` binding of `func`.\\n * @param {number} [argCount] The number of arguments to provide to `func`.\\n * @returns {Function} Returns the callback.\\n */\\nfunction bindCallback(func, thisArg, argCount) {\\n  if (typeof func != 'function') {\\n    return identity;\\n  }\\n  if (thisArg === undefined) {\\n    return func;\\n  }\\n  switch (argCount) {\\n    case 1: return function(value) {\\n      return func.call(thisArg, value);\\n    };\\n    case 3: return function(value, index, collection) {\\n      return func.call(thisArg, value, index, collection);\\n    };\\n    case 4: return function(accumulator, value, index, collection) {\\n      return func.call(thisArg, accumulator, value, index, collection);\\n    };\\n    case 5: return function(value, other, key, object, source) {\\n      return func.call(thisArg, value, other, key, object, source);\\n    };\\n  }\\n  return function() {\\n    return func.apply(thisArg, arguments);\\n  };\\n}\\n\\nmodule.exports = bindCallback;\\n\\n},{\\\"../utility/identity\\\":62}],37:[function(require,module,exports){\\nvar bindCallback = require('./bindCallback'),\\n    isIterateeCall = require('./isIterateeCall'),\\n    restParam = require('../function/restParam');\\n\\n/**\\n * Creates a `_.assign`, `_.defaults`, or `_.merge` function.\\n *\\n * @private\\n * @param {Function} assigner The function to assign values.\\n * @returns {Function} Returns the new assigner function.\\n */\\nfunction createAssigner(assigner) {\\n  return restParam(function(object, sources) {\\n    var index = -1,\\n        length = object == null ? 0 : sources.length,\\n        customizer = length > 2 ? sources[length - 2] : undefined,\\n        guard = length > 2 ? sources[2] : undefined,\\n        thisArg = length > 1 ? sources[length - 1] : undefined;\\n\\n    if (typeof customizer == 'function') {\\n      customizer = bindCallback(customizer, thisArg, 5);\\n      length -= 2;\\n    } else {\\n      customizer = typeof thisArg == 'function' ? thisArg : undefined;\\n      length -= (customizer ? 1 : 0);\\n    }\\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\\n      customizer = length < 3 ? undefined : customizer;\\n      length = 1;\\n    }\\n    while (++index < length) {\\n      var source = sources[index];\\n      if (source) {\\n        assigner(object, source, customizer);\\n      }\\n    }\\n    return object;\\n  });\\n}\\n\\nmodule.exports = createAssigner;\\n\\n},{\\\"../function/restParam\\\":27,\\\"./bindCallback\\\":36,\\\"./isIterateeCall\\\":44}],38:[function(require,module,exports){\\nvar toObject = require('./toObject');\\n\\n/**\\n * Creates a base function for `_.forIn` or `_.forInRight`.\\n *\\n * @private\\n * @param {boolean} [fromRight] Specify iterating from right to left.\\n * @returns {Function} Returns the new base function.\\n */\\nfunction createBaseFor(fromRight) {\\n  return function(object, iteratee, keysFunc) {\\n    var iterable = toObject(object),\\n        props = keysFunc(object),\\n        length = props.length,\\n        index = fromRight ? length : -1;\\n\\n    while ((fromRight ? index-- : ++index < length)) {\\n      var key = props[index];\\n      if (iteratee(iterable[key], key, iterable) === false) {\\n        break;\\n      }\\n    }\\n    return object;\\n  };\\n}\\n\\nmodule.exports = createBaseFor;\\n\\n},{\\\"./toObject\\\":48}],39:[function(require,module,exports){\\nvar baseProperty = require('./baseProperty');\\n\\n/**\\n * Gets the \\\"length\\\" property value of `object`.\\n *\\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\\n * that affects Safari on at least iOS 8.1-8.3 ARM64.\\n *\\n * @private\\n * @param {Object} object The object to query.\\n * @returns {*} Returns the \\\"length\\\" value.\\n */\\nvar getLength = baseProperty('length');\\n\\nmodule.exports = getLength;\\n\\n},{\\\"./baseProperty\\\":35}],40:[function(require,module,exports){\\nvar isNative = require('../lang/isNative');\\n\\n/**\\n * Gets the native function at `key` of `object`.\\n *\\n * @private\\n * @param {Object} object The object to query.\\n * @param {string} key The key of the method to get.\\n * @returns {*} Returns the function if it's native, else `undefined`.\\n */\\nfunction getNative(object, key) {\\n  var value = object == null ? undefined : object[key];\\n  return isNative(value) ? value : undefined;\\n}\\n\\nmodule.exports = getNative;\\n\\n},{\\\"../lang/isNative\\\":52}],41:[function(require,module,exports){\\nvar getLength = require('./getLength'),\\n    isLength = require('./isLength');\\n\\n/**\\n * Checks if `value` is array-like.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\\n */\\nfunction isArrayLike(value) {\\n  return value != null && isLength(getLength(value));\\n}\\n\\nmodule.exports = isArrayLike;\\n\\n},{\\\"./getLength\\\":39,\\\"./isLength\\\":45}],42:[function(require,module,exports){\\n/**\\n * Checks if `value` is a host object in IE < 9.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\\n */\\nvar isHostObject = (function() {\\n  try {\\n    Object({ 'toString': 0 } + '');\\n  } catch(e) {\\n    return function() { return false; };\\n  }\\n  return function(value) {\\n    // IE < 9 presents many host objects as `Object` objects that can coerce\\n    // to strings despite having improperly defined `toString` methods.\\n    return typeof value.toString != 'function' && typeof (value + '') == 'string';\\n  };\\n}());\\n\\nmodule.exports = isHostObject;\\n\\n},{}],43:[function(require,module,exports){\\n/** Used to detect unsigned integer values. */\\nvar reIsUint = /^\\\\d+$/;\\n\\n/**\\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\\n * of an array-like value.\\n */\\nvar MAX_SAFE_INTEGER = 9007199254740991;\\n\\n/**\\n * Checks if `value` is a valid array-like index.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\\n */\\nfunction isIndex(value, length) {\\n  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\\n  length = length == null ? MAX_SAFE_INTEGER : length;\\n  return value > -1 && value % 1 == 0 && value < length;\\n}\\n\\nmodule.exports = isIndex;\\n\\n},{}],44:[function(require,module,exports){\\nvar isArrayLike = require('./isArrayLike'),\\n    isIndex = require('./isIndex'),\\n    isObject = require('../lang/isObject');\\n\\n/**\\n * Checks if the provided arguments are from an iteratee call.\\n *\\n * @private\\n * @param {*} value The potential iteratee value argument.\\n * @param {*} index The potential iteratee index or key argument.\\n * @param {*} object The potential iteratee object argument.\\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\\n */\\nfunction isIterateeCall(value, index, object) {\\n  if (!isObject(object)) {\\n    return false;\\n  }\\n  var type = typeof index;\\n  if (type == 'number'\\n      ? (isArrayLike(object) && isIndex(index, object.length))\\n      : (type == 'string' && index in object)) {\\n    var other = object[index];\\n    return value === value ? (value === other) : (other !== other);\\n  }\\n  return false;\\n}\\n\\nmodule.exports = isIterateeCall;\\n\\n},{\\\"../lang/isObject\\\":53,\\\"./isArrayLike\\\":41,\\\"./isIndex\\\":43}],45:[function(require,module,exports){\\n/**\\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\\n * of an array-like value.\\n */\\nvar MAX_SAFE_INTEGER = 9007199254740991;\\n\\n/**\\n * Checks if `value` is a valid array-like length.\\n *\\n * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\\n */\\nfunction isLength(value) {\\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\\n}\\n\\nmodule.exports = isLength;\\n\\n},{}],46:[function(require,module,exports){\\n/**\\n * Checks if `value` is object-like.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\\n */\\nfunction isObjectLike(value) {\\n  return !!value && typeof value == 'object';\\n}\\n\\nmodule.exports = isObjectLike;\\n\\n},{}],47:[function(require,module,exports){\\nvar isArguments = require('../lang/isArguments'),\\n    isArray = require('../lang/isArray'),\\n    isIndex = require('./isIndex'),\\n    isLength = require('./isLength'),\\n    isString = require('../lang/isString'),\\n    keysIn = require('../object/keysIn');\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/** Used to check objects for own properties. */\\nvar hasOwnProperty = objectProto.hasOwnProperty;\\n\\n/**\\n * A fallback implementation of `Object.keys` which creates an array of the\\n * own enumerable property names of `object`.\\n *\\n * @private\\n * @param {Object} object The object to query.\\n * @returns {Array} Returns the array of property names.\\n */\\nfunction shimKeys(object) {\\n  var props = keysIn(object),\\n      propsLength = props.length,\\n      length = propsLength && object.length;\\n\\n  var allowIndexes = !!length && isLength(length) &&\\n    (isArray(object) || isArguments(object) || isString(object));\\n\\n  var index = -1,\\n      result = [];\\n\\n  while (++index < propsLength) {\\n    var key = props[index];\\n    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\\n      result.push(key);\\n    }\\n  }\\n  return result;\\n}\\n\\nmodule.exports = shimKeys;\\n\\n},{\\\"../lang/isArguments\\\":49,\\\"../lang/isArray\\\":50,\\\"../lang/isString\\\":55,\\\"../object/keysIn\\\":59,\\\"./isIndex\\\":43,\\\"./isLength\\\":45}],48:[function(require,module,exports){\\nvar isObject = require('../lang/isObject'),\\n    isString = require('../lang/isString'),\\n    support = require('../support');\\n\\n/**\\n * Converts `value` to an object if it's not one.\\n *\\n * @private\\n * @param {*} value The value to process.\\n * @returns {Object} Returns the object.\\n */\\nfunction toObject(value) {\\n  if (support.unindexedChars && isString(value)) {\\n    var index = -1,\\n        length = value.length,\\n        result = Object(value);\\n\\n    while (++index < length) {\\n      result[index] = value.charAt(index);\\n    }\\n    return result;\\n  }\\n  return isObject(value) ? value : Object(value);\\n}\\n\\nmodule.exports = toObject;\\n\\n},{\\\"../lang/isObject\\\":53,\\\"../lang/isString\\\":55,\\\"../support\\\":61}],49:[function(require,module,exports){\\nvar isArrayLike = require('../internal/isArrayLike'),\\n    isObjectLike = require('../internal/isObjectLike');\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/** Used to check objects for own properties. */\\nvar hasOwnProperty = objectProto.hasOwnProperty;\\n\\n/** Native method references. */\\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\\n\\n/**\\n * Checks if `value` is classified as an `arguments` object.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\\n * @example\\n *\\n * _.isArguments(function() { return arguments; }());\\n * // => true\\n *\\n * _.isArguments([1, 2, 3]);\\n * // => false\\n */\\nfunction isArguments(value) {\\n  return isObjectLike(value) && isArrayLike(value) &&\\n    hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\\n}\\n\\nmodule.exports = isArguments;\\n\\n},{\\\"../internal/isArrayLike\\\":41,\\\"../internal/isObjectLike\\\":46}],50:[function(require,module,exports){\\nvar getNative = require('../internal/getNative'),\\n    isLength = require('../internal/isLength'),\\n    isObjectLike = require('../internal/isObjectLike');\\n\\n/** `Object#toString` result references. */\\nvar arrayTag = '[object Array]';\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/* Native method references for those with the same name as other `lodash` methods. */\\nvar nativeIsArray = getNative(Array, 'isArray');\\n\\n/**\\n * Checks if `value` is classified as an `Array` object.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\\n * @example\\n *\\n * _.isArray([1, 2, 3]);\\n * // => true\\n *\\n * _.isArray(function() { return arguments; }());\\n * // => false\\n */\\nvar isArray = nativeIsArray || function(value) {\\n  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\\n};\\n\\nmodule.exports = isArray;\\n\\n},{\\\"../internal/getNative\\\":40,\\\"../internal/isLength\\\":45,\\\"../internal/isObjectLike\\\":46}],51:[function(require,module,exports){\\nvar isObject = require('./isObject');\\n\\n/** `Object#toString` result references. */\\nvar funcTag = '[object Function]';\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/**\\n * Checks if `value` is classified as a `Function` object.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\\n * @example\\n *\\n * _.isFunction(_);\\n * // => true\\n *\\n * _.isFunction(/abc/);\\n * // => false\\n */\\nfunction isFunction(value) {\\n  // The use of `Object#toString` avoids issues with the `typeof` operator\\n  // in older versions of Chrome and Safari which return 'function' for regexes\\n  // and Safari 8 which returns 'object' for typed array constructors.\\n  return isObject(value) && objToString.call(value) == funcTag;\\n}\\n\\nmodule.exports = isFunction;\\n\\n},{\\\"./isObject\\\":53}],52:[function(require,module,exports){\\nvar isFunction = require('./isFunction'),\\n    isHostObject = require('../internal/isHostObject'),\\n    isObjectLike = require('../internal/isObjectLike');\\n\\n/** Used to detect host constructors (Safari > 5). */\\nvar reIsHostCtor = /^\\\\[object .+?Constructor\\\\]$/;\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/** Used to resolve the decompiled source of functions. */\\nvar fnToString = Function.prototype.toString;\\n\\n/** Used to check objects for own properties. */\\nvar hasOwnProperty = objectProto.hasOwnProperty;\\n\\n/** Used to detect if a method is native. */\\nvar reIsNative = RegExp('^' +\\n  fnToString.call(hasOwnProperty).replace(/[\\\\\\\\^$.*+?()[\\\\]{}|]/g, '\\\\\\\\$&')\\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\\\\\\\()| for .+?(?=\\\\\\\\\\\\])/g, '$1.*?') + '$'\\n);\\n\\n/**\\n * Checks if `value` is a native function.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\\n * @example\\n *\\n * _.isNative(Array.prototype.push);\\n * // => true\\n *\\n * _.isNative(_);\\n * // => false\\n */\\nfunction isNative(value) {\\n  if (value == null) {\\n    return false;\\n  }\\n  if (isFunction(value)) {\\n    return reIsNative.test(fnToString.call(value));\\n  }\\n  return isObjectLike(value) && (isHostObject(value) ? reIsNative : reIsHostCtor).test(value);\\n}\\n\\nmodule.exports = isNative;\\n\\n},{\\\"../internal/isHostObject\\\":42,\\\"../internal/isObjectLike\\\":46,\\\"./isFunction\\\":51}],53:[function(require,module,exports){\\n/**\\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\\n * @example\\n *\\n * _.isObject({});\\n * // => true\\n *\\n * _.isObject([1, 2, 3]);\\n * // => true\\n *\\n * _.isObject(1);\\n * // => false\\n */\\nfunction isObject(value) {\\n  // Avoid a V8 JIT bug in Chrome 19-20.\\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\\n  var type = typeof value;\\n  return !!value && (type == 'object' || type == 'function');\\n}\\n\\nmodule.exports = isObject;\\n\\n},{}],54:[function(require,module,exports){\\nvar baseForIn = require('../internal/baseForIn'),\\n    isArguments = require('./isArguments'),\\n    isHostObject = require('../internal/isHostObject'),\\n    isObjectLike = require('../internal/isObjectLike'),\\n    support = require('../support');\\n\\n/** `Object#toString` result references. */\\nvar objectTag = '[object Object]';\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/** Used to check objects for own properties. */\\nvar hasOwnProperty = objectProto.hasOwnProperty;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/**\\n * Checks if `value` is a plain object, that is, an object created by the\\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\\n *\\n * **Note:** This method assumes objects created by the `Object` constructor\\n * have no inherited enumerable properties.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\\n * @example\\n *\\n * function Foo() {\\n *   this.a = 1;\\n * }\\n *\\n * _.isPlainObject(new Foo);\\n * // => false\\n *\\n * _.isPlainObject([1, 2, 3]);\\n * // => false\\n *\\n * _.isPlainObject({ 'x': 0, 'y': 0 });\\n * // => true\\n *\\n * _.isPlainObject(Object.create(null));\\n * // => true\\n */\\nfunction isPlainObject(value) {\\n  var Ctor;\\n\\n  // Exit early for non `Object` objects.\\n  if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isHostObject(value) && !isArguments(value)) ||\\n      (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {\\n    return false;\\n  }\\n  // IE < 9 iterates inherited properties before own properties. If the first\\n  // iterated property is an object's own property then there are no inherited\\n  // enumerable properties.\\n  var result;\\n  if (support.ownLast) {\\n    baseForIn(value, function(subValue, key, object) {\\n      result = hasOwnProperty.call(object, key);\\n      return false;\\n    });\\n    return result !== false;\\n  }\\n  // In most environments an object's own properties are iterated before\\n  // its inherited properties. If the last iterated property is an object's\\n  // own property then there are no inherited enumerable properties.\\n  baseForIn(value, function(subValue, key) {\\n    result = key;\\n  });\\n  return result === undefined || hasOwnProperty.call(value, result);\\n}\\n\\nmodule.exports = isPlainObject;\\n\\n},{\\\"../internal/baseForIn\\\":32,\\\"../internal/isHostObject\\\":42,\\\"../internal/isObjectLike\\\":46,\\\"../support\\\":61,\\\"./isArguments\\\":49}],55:[function(require,module,exports){\\nvar isObjectLike = require('../internal/isObjectLike');\\n\\n/** `Object#toString` result references. */\\nvar stringTag = '[object String]';\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/**\\n * Checks if `value` is classified as a `String` primitive or object.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\\n * @example\\n *\\n * _.isString('abc');\\n * // => true\\n *\\n * _.isString(1);\\n * // => false\\n */\\nfunction isString(value) {\\n  return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);\\n}\\n\\nmodule.exports = isString;\\n\\n},{\\\"../internal/isObjectLike\\\":46}],56:[function(require,module,exports){\\nvar isLength = require('../internal/isLength'),\\n    isObjectLike = require('../internal/isObjectLike');\\n\\n/** `Object#toString` result references. */\\nvar argsTag = '[object Arguments]',\\n    arrayTag = '[object Array]',\\n    boolTag = '[object Boolean]',\\n    dateTag = '[object Date]',\\n    errorTag = '[object Error]',\\n    funcTag = '[object Function]',\\n    mapTag = '[object Map]',\\n    numberTag = '[object Number]',\\n    objectTag = '[object Object]',\\n    regexpTag = '[object RegExp]',\\n    setTag = '[object Set]',\\n    stringTag = '[object String]',\\n    weakMapTag = '[object WeakMap]';\\n\\nvar arrayBufferTag = '[object ArrayBuffer]',\\n    float32Tag = '[object Float32Array]',\\n    float64Tag = '[object Float64Array]',\\n    int8Tag = '[object Int8Array]',\\n    int16Tag = '[object Int16Array]',\\n    int32Tag = '[object Int32Array]',\\n    uint8Tag = '[object Uint8Array]',\\n    uint8ClampedTag = '[object Uint8ClampedArray]',\\n    uint16Tag = '[object Uint16Array]',\\n    uint32Tag = '[object Uint32Array]';\\n\\n/** Used to identify `toStringTag` values of typed arrays. */\\nvar typedArrayTags = {};\\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\\ntypedArrayTags[uint32Tag] = true;\\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\\ntypedArrayTags[dateTag] = typedArrayTags[errorTag] =\\ntypedArrayTags[funcTag] = typedArrayTags[mapTag] =\\ntypedArrayTags[numberTag] = typedArrayTags[objectTag] =\\ntypedArrayTags[regexpTag] = typedArrayTags[setTag] =\\ntypedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/**\\n * Checks if `value` is classified as a typed array.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\\n * @example\\n *\\n * _.isTypedArray(new Uint8Array);\\n * // => true\\n *\\n * _.isTypedArray([]);\\n * // => false\\n */\\nfunction isTypedArray(value) {\\n  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];\\n}\\n\\nmodule.exports = isTypedArray;\\n\\n},{\\\"../internal/isLength\\\":45,\\\"../internal/isObjectLike\\\":46}],57:[function(require,module,exports){\\nvar baseCopy = require('../internal/baseCopy'),\\n    keysIn = require('../object/keysIn');\\n\\n/**\\n * Converts `value` to a plain object flattening inherited enumerable\\n * properties of `value` to own properties of the plain object.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to convert.\\n * @returns {Object} Returns the converted plain object.\\n * @example\\n *\\n * function Foo() {\\n *   this.b = 2;\\n * }\\n *\\n * Foo.prototype.c = 3;\\n *\\n * _.assign({ 'a': 1 }, new Foo);\\n * // => { 'a': 1, 'b': 2 }\\n *\\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\\n * // => { 'a': 1, 'b': 2, 'c': 3 }\\n */\\nfunction toPlainObject(value) {\\n  return baseCopy(value, keysIn(value));\\n}\\n\\nmodule.exports = toPlainObject;\\n\\n},{\\\"../internal/baseCopy\\\":30,\\\"../object/keysIn\\\":59}],58:[function(require,module,exports){\\nvar getNative = require('../internal/getNative'),\\n    isArrayLike = require('../internal/isArrayLike'),\\n    isObject = require('../lang/isObject'),\\n    shimKeys = require('../internal/shimKeys'),\\n    support = require('../support');\\n\\n/* Native method references for those with the same name as other `lodash` methods. */\\nvar nativeKeys = getNative(Object, 'keys');\\n\\n/**\\n * Creates an array of the own enumerable property names of `object`.\\n *\\n * **Note:** Non-object values are coerced to objects. See the\\n * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\\n * for more details.\\n *\\n * @static\\n * @memberOf _\\n * @category Object\\n * @param {Object} object The object to query.\\n * @returns {Array} Returns the array of property names.\\n * @example\\n *\\n * function Foo() {\\n *   this.a = 1;\\n *   this.b = 2;\\n * }\\n *\\n * Foo.prototype.c = 3;\\n *\\n * _.keys(new Foo);\\n * // => ['a', 'b'] (iteration order is not guaranteed)\\n *\\n * _.keys('hi');\\n * // => ['0', '1']\\n */\\nvar keys = !nativeKeys ? shimKeys : function(object) {\\n  var Ctor = object == null ? undefined : object.constructor;\\n  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\\n      (typeof object == 'function' ? support.enumPrototypes : isArrayLike(object))) {\\n    return shimKeys(object);\\n  }\\n  return isObject(object) ? nativeKeys(object) : [];\\n};\\n\\nmodule.exports = keys;\\n\\n},{\\\"../internal/getNative\\\":40,\\\"../internal/isArrayLike\\\":41,\\\"../internal/shimKeys\\\":47,\\\"../lang/isObject\\\":53,\\\"../support\\\":61}],59:[function(require,module,exports){\\nvar arrayEach = require('../internal/arrayEach'),\\n    isArguments = require('../lang/isArguments'),\\n    isArray = require('../lang/isArray'),\\n    isFunction = require('../lang/isFunction'),\\n    isIndex = require('../internal/isIndex'),\\n    isLength = require('../internal/isLength'),\\n    isObject = require('../lang/isObject'),\\n    isString = require('../lang/isString'),\\n    support = require('../support');\\n\\n/** `Object#toString` result references. */\\nvar arrayTag = '[object Array]',\\n    boolTag = '[object Boolean]',\\n    dateTag = '[object Date]',\\n    errorTag = '[object Error]',\\n    funcTag = '[object Function]',\\n    numberTag = '[object Number]',\\n    objectTag = '[object Object]',\\n    regexpTag = '[object RegExp]',\\n    stringTag = '[object String]';\\n\\n/** Used to fix the JScript `[[DontEnum]]` bug. */\\nvar shadowProps = [\\n  'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',\\n  'toLocaleString', 'toString', 'valueOf'\\n];\\n\\n/** Used for native method references. */\\nvar errorProto = Error.prototype,\\n    objectProto = Object.prototype,\\n    stringProto = String.prototype;\\n\\n/** Used to check objects for own properties. */\\nvar hasOwnProperty = objectProto.hasOwnProperty;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/** Used to avoid iterating over non-enumerable properties in IE < 9. */\\nvar nonEnumProps = {};\\nnonEnumProps[arrayTag] = nonEnumProps[dateTag] = nonEnumProps[numberTag] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };\\nnonEnumProps[boolTag] = nonEnumProps[stringTag] = { 'constructor': true, 'toString': true, 'valueOf': true };\\nnonEnumProps[errorTag] = nonEnumProps[funcTag] = nonEnumProps[regexpTag] = { 'constructor': true, 'toString': true };\\nnonEnumProps[objectTag] = { 'constructor': true };\\n\\narrayEach(shadowProps, function(key) {\\n  for (var tag in nonEnumProps) {\\n    if (hasOwnProperty.call(nonEnumProps, tag)) {\\n      var props = nonEnumProps[tag];\\n      props[key] = hasOwnProperty.call(props, key);\\n    }\\n  }\\n});\\n\\n/**\\n * Creates an array of the own and inherited enumerable property names of `object`.\\n *\\n * **Note:** Non-object values are coerced to objects.\\n *\\n * @static\\n * @memberOf _\\n * @category Object\\n * @param {Object} object The object to query.\\n * @returns {Array} Returns the array of property names.\\n * @example\\n *\\n * function Foo() {\\n *   this.a = 1;\\n *   this.b = 2;\\n * }\\n *\\n * Foo.prototype.c = 3;\\n *\\n * _.keysIn(new Foo);\\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\\n */\\nfunction keysIn(object) {\\n  if (object == null) {\\n    return [];\\n  }\\n  if (!isObject(object)) {\\n    object = Object(object);\\n  }\\n  var length = object.length;\\n\\n  length = (length && isLength(length) &&\\n    (isArray(object) || isArguments(object) || isString(object)) && length) || 0;\\n\\n  var Ctor = object.constructor,\\n      index = -1,\\n      proto = (isFunction(Ctor) && Ctor.prototype) || objectProto,\\n      isProto = proto === object,\\n      result = Array(length),\\n      skipIndexes = length > 0,\\n      skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error),\\n      skipProto = support.enumPrototypes && isFunction(object);\\n\\n  while (++index < length) {\\n    result[index] = (index + '');\\n  }\\n  // lodash skips the `constructor` property when it infers it's iterating\\n  // over a `prototype` object because IE < 9 can't set the `[[Enumerable]]`\\n  // attribute of an existing property and the `constructor` property of a\\n  // prototype defaults to non-enumerable.\\n  for (var key in object) {\\n    if (!(skipProto && key == 'prototype') &&\\n        !(skipErrorProps && (key == 'message' || key == 'name')) &&\\n        !(skipIndexes && isIndex(key, length)) &&\\n        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\\n      result.push(key);\\n    }\\n  }\\n  if (support.nonEnumShadows && object !== objectProto) {\\n    var tag = object === stringProto ? stringTag : (object === errorProto ? errorTag : objToString.call(object)),\\n        nonEnums = nonEnumProps[tag] || nonEnumProps[objectTag];\\n\\n    if (tag == objectTag) {\\n      proto = objectProto;\\n    }\\n    length = shadowProps.length;\\n    while (length--) {\\n      key = shadowProps[length];\\n      var nonEnum = nonEnums[key];\\n      if (!(isProto && nonEnum) &&\\n          (nonEnum ? hasOwnProperty.call(object, key) : object[key] !== proto[key])) {\\n        result.push(key);\\n      }\\n    }\\n  }\\n  return result;\\n}\\n\\nmodule.exports = keysIn;\\n\\n},{\\\"../internal/arrayEach\\\":29,\\\"../internal/isIndex\\\":43,\\\"../internal/isLength\\\":45,\\\"../lang/isArguments\\\":49,\\\"../lang/isArray\\\":50,\\\"../lang/isFunction\\\":51,\\\"../lang/isObject\\\":53,\\\"../lang/isString\\\":55,\\\"../support\\\":61}],60:[function(require,module,exports){\\nvar baseMerge = require('../internal/baseMerge'),\\n    createAssigner = require('../internal/createAssigner');\\n\\n/**\\n * Recursively merges own enumerable properties of the source object(s), that\\n * don't resolve to `undefined` into the destination object. Subsequent sources\\n * overwrite property assignments of previous sources. If `customizer` is\\n * provided it's invoked to produce the merged values of the destination and\\n * source properties. If `customizer` returns `undefined` merging is handled\\n * by the method instead. The `customizer` is bound to `thisArg` and invoked\\n * with five arguments: (objectValue, sourceValue, key, object, source).\\n *\\n * @static\\n * @memberOf _\\n * @category Object\\n * @param {Object} object The destination object.\\n * @param {...Object} [sources] The source objects.\\n * @param {Function} [customizer] The function to customize assigned values.\\n * @param {*} [thisArg] The `this` binding of `customizer`.\\n * @returns {Object} Returns `object`.\\n * @example\\n *\\n * var users = {\\n *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]\\n * };\\n *\\n * var ages = {\\n *   'data': [{ 'age': 36 }, { 'age': 40 }]\\n * };\\n *\\n * _.merge(users, ages);\\n * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }\\n *\\n * // using a customizer callback\\n * var object = {\\n *   'fruits': ['apple'],\\n *   'vegetables': ['beet']\\n * };\\n *\\n * var other = {\\n *   'fruits': ['banana'],\\n *   'vegetables': ['carrot']\\n * };\\n *\\n * _.merge(object, other, function(a, b) {\\n *   if (_.isArray(a)) {\\n *     return a.concat(b);\\n *   }\\n * });\\n * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }\\n */\\nvar merge = createAssigner(baseMerge);\\n\\nmodule.exports = merge;\\n\\n},{\\\"../internal/baseMerge\\\":33,\\\"../internal/createAssigner\\\":37}],61:[function(require,module,exports){\\n/** Used for native method references. */\\nvar arrayProto = Array.prototype,\\n    errorProto = Error.prototype,\\n    objectProto = Object.prototype;\\n\\n/** Native method references. */\\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable,\\n    splice = arrayProto.splice;\\n\\n/**\\n * An object environment feature flags.\\n *\\n * @static\\n * @memberOf _\\n * @type Object\\n */\\nvar support = {};\\n\\n(function(x) {\\n  var Ctor = function() { this.x = x; },\\n      object = { '0': x, 'length': x },\\n      props = [];\\n\\n  Ctor.prototype = { 'valueOf': x, 'y': x };\\n  for (var key in new Ctor) { props.push(key); }\\n\\n  /**\\n   * Detect if `name` or `message` properties of `Error.prototype` are\\n   * enumerable by default (IE < 9, Safari < 5.1).\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') ||\\n    propertyIsEnumerable.call(errorProto, 'name');\\n\\n  /**\\n   * Detect if `prototype` properties are enumerable by default.\\n   *\\n   * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1\\n   * (if the prototype or a property on the prototype has been set)\\n   * incorrectly set the `[[Enumerable]]` value of a function's `prototype`\\n   * property to `true`.\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.enumPrototypes = propertyIsEnumerable.call(Ctor, 'prototype');\\n\\n  /**\\n   * Detect if properties shadowing those on `Object.prototype` are non-enumerable.\\n   *\\n   * In IE < 9 an object's own properties, shadowing non-enumerable ones,\\n   * are made non-enumerable as well (a.k.a the JScript `[[DontEnum]]` bug).\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.nonEnumShadows = !/valueOf/.test(props);\\n\\n  /**\\n   * Detect if own properties are iterated after inherited properties (IE < 9).\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.ownLast = props[0] != 'x';\\n\\n  /**\\n   * Detect if `Array#shift` and `Array#splice` augment array-like objects\\n   * correctly.\\n   *\\n   * Firefox < 10, compatibility modes of IE 8, and IE < 9 have buggy Array\\n   * `shift()` and `splice()` functions that fail to remove the last element,\\n   * `value[0]`, of array-like objects even though the \\\"length\\\" property is\\n   * set to `0`. The `shift()` method is buggy in compatibility modes of IE 8,\\n   * while `splice()` is buggy regardless of mode in IE < 9.\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.spliceObjects = (splice.call(object, 0, 1), !object[0]);\\n\\n  /**\\n   * Detect lack of support for accessing string characters by index.\\n   *\\n   * IE < 8 can't access characters by index. IE 8 can only access characters\\n   * by index on string literals, not string objects.\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.unindexedChars = ('x'[0] + Object('x')[0]) != 'xx';\\n}(1, 0));\\n\\nmodule.exports = support;\\n\\n},{}],62:[function(require,module,exports){\\n/**\\n * This method returns the first argument provided to it.\\n *\\n * @static\\n * @memberOf _\\n * @category Utility\\n * @param {*} value Any value.\\n * @returns {*} Returns `value`.\\n * @example\\n *\\n * var object = { 'user': 'fred' };\\n *\\n * _.identity(object) === object;\\n * // => true\\n */\\nfunction identity(value) {\\n  return value;\\n}\\n\\nmodule.exports = identity;\\n\\n},{}],63:[function(require,module,exports){\\n/**\\n * @file m3u8/index.js\\n *\\n * Utilities for parsing M3U8 files. If the entire manifest is available,\\n * `Parser` will create an object representation with enough detail for managing\\n * playback. `ParseStream` and `LineStream` are lower-level parsing primitives\\n * that do not assume the entirety of the manifest is ready and expose a\\n * ReadableStream-like interface.\\n */\\n\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _lineStream = require('./line-stream');\\n\\nvar _lineStream2 = _interopRequireDefault(_lineStream);\\n\\nvar _parseStream = require('./parse-stream');\\n\\nvar _parseStream2 = _interopRequireDefault(_parseStream);\\n\\nvar _parser = require('./parser');\\n\\nvar _parser2 = _interopRequireDefault(_parser);\\n\\nexports['default'] = {\\n  LineStream: _lineStream2['default'],\\n  ParseStream: _parseStream2['default'],\\n  Parser: _parser2['default']\\n};\\nmodule.exports = exports['default'];\\n},{\\\"./line-stream\\\":64,\\\"./parse-stream\\\":65,\\\"./parser\\\":66}],64:[function(require,module,exports){\\n/**\\n * @file m3u8/line-stream.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _stream = require('./stream');\\n\\nvar _stream2 = _interopRequireDefault(_stream);\\n\\n/**\\n * A stream that buffers string input and generates a `data` event for each\\n * line.\\n *\\n * @class LineStream\\n * @extends Stream\\n */\\n\\nvar LineStream = (function (_Stream) {\\n  _inherits(LineStream, _Stream);\\n\\n  function LineStream() {\\n    _classCallCheck(this, LineStream);\\n\\n    _get(Object.getPrototypeOf(LineStream.prototype), 'constructor', this).call(this);\\n    this.buffer = '';\\n  }\\n\\n  /**\\n   * Add new data to be parsed.\\n   *\\n   * @param {String} data the text to process\\n   */\\n\\n  _createClass(LineStream, [{\\n    key: 'push',\\n    value: function push(data) {\\n      var nextNewline = undefined;\\n\\n      this.buffer += data;\\n      nextNewline = this.buffer.indexOf('\\\\n');\\n\\n      for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\\\\n')) {\\n        this.trigger('data', this.buffer.substring(0, nextNewline));\\n        this.buffer = this.buffer.substring(nextNewline + 1);\\n      }\\n    }\\n  }]);\\n\\n  return LineStream;\\n})(_stream2['default']);\\n\\nexports['default'] = LineStream;\\nmodule.exports = exports['default'];\\n},{\\\"./stream\\\":67}],65:[function(require,module,exports){\\n/**\\n * @file m3u8/parse-stream.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _stream = require('./stream');\\n\\nvar _stream2 = _interopRequireDefault(_stream);\\n\\n/**\\n * \\\"forgiving\\\" attribute list psuedo-grammar:\\n * attributes -> keyvalue (',' keyvalue)*\\n * keyvalue   -> key '=' value\\n * key        -> [^=]*\\n * value      -> '\\\"' [^\\\"]* '\\\"' | [^,]*\\n */\\nvar attributeSeparator = function attributeSeparator() {\\n  var key = '[^=]*';\\n  var value = '\\\"[^\\\"]*\\\"|[^,]*';\\n  var keyvalue = '(?:' + key + ')=(?:' + value + ')';\\n\\n  return new RegExp('(?:^|,)(' + keyvalue + ')');\\n};\\n\\n/**\\n * Parse attributes from a line given the seperator\\n *\\n * @param {String} attributes the attibute line to parse\\n */\\nvar parseAttributes = function parseAttributes(attributes) {\\n  // split the string using attributes as the separator\\n  var attrs = attributes.split(attributeSeparator());\\n  var i = attrs.length;\\n  var result = {};\\n  var attr = undefined;\\n\\n  while (i--) {\\n    // filter out unmatched portions of the string\\n    if (attrs[i] === '') {\\n      continue;\\n    }\\n\\n    // split the key and value\\n    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1);\\n    // trim whitespace and remove optional quotes around the value\\n    attr[0] = attr[0].replace(/^\\\\s+|\\\\s+$/g, '');\\n    attr[1] = attr[1].replace(/^\\\\s+|\\\\s+$/g, '');\\n    attr[1] = attr[1].replace(/^['\\\"](.*)['\\\"]$/g, '$1');\\n    result[attr[0]] = attr[1];\\n  }\\n  return result;\\n};\\n\\n/**\\n * A line-level M3U8 parser event stream. It expects to receive input one\\n * line at a time and performs a context-free parse of its contents. A stream\\n * interpretation of a manifest can be useful if the manifest is expected to\\n * be too large to fit comfortably into memory or the entirety of the input\\n * is not immediately available. Otherwise, it's probably much easier to work\\n * with a regular `Parser` object.\\n *\\n * Produces `data` events with an object that captures the parser's\\n * interpretation of the input. That object has a property `tag` that is one\\n * of `uri`, `comment`, or `tag`. URIs only have a single additional\\n * property, `line`, which captures the entirety of the input without\\n * interpretation. Comments similarly have a single additional property\\n * `text` which is the input without the leading `#`.\\n *\\n * Tags always have a property `tagType` which is the lower-cased version of\\n * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\\n * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\\n * tags are given the tag type `unknown` and a single additional property\\n * `data` with the remainder of the input.\\n *\\n * @class ParseStream\\n * @extends Stream\\n */\\n\\nvar ParseStream = (function (_Stream) {\\n  _inherits(ParseStream, _Stream);\\n\\n  function ParseStream() {\\n    _classCallCheck(this, ParseStream);\\n\\n    _get(Object.getPrototypeOf(ParseStream.prototype), 'constructor', this).call(this);\\n  }\\n\\n  /**\\n   * Parses an additional line of input.\\n   *\\n   * @param {String} line a single line of an M3U8 file to parse\\n   */\\n\\n  _createClass(ParseStream, [{\\n    key: 'push',\\n    value: function push(line) {\\n      var match = undefined;\\n      var event = undefined;\\n\\n      // strip whitespace\\n      line = line.replace(/^[\\\\u0000\\\\s]+|[\\\\u0000\\\\s]+$/g, '');\\n      if (line.length === 0) {\\n        // ignore empty lines\\n        return;\\n      }\\n\\n      // URIs\\n      if (line[0] !== '#') {\\n        this.trigger('data', {\\n          type: 'uri',\\n          uri: line\\n        });\\n        return;\\n      }\\n\\n      // Comments\\n      if (line.indexOf('#EXT') !== 0) {\\n        this.trigger('data', {\\n          type: 'comment',\\n          text: line.slice(1)\\n        });\\n        return;\\n      }\\n\\n      // strip off any carriage returns here so the regex matching\\n      // doesn't have to account for them.\\n      line = line.replace('\\\\r', '');\\n\\n      // Tags\\n      match = /^#EXTM3U/.exec(line);\\n      if (match) {\\n        this.trigger('data', {\\n          type: 'tag',\\n          tagType: 'm3u'\\n        });\\n        return;\\n      }\\n      match = /^#EXTINF:?([0-9\\\\.]*)?,?(.*)?$/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'inf'\\n        };\\n        if (match[1]) {\\n          event.duration = parseFloat(match[1]);\\n        }\\n        if (match[2]) {\\n          event.title = match[2];\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'targetduration'\\n        };\\n        if (match[1]) {\\n          event.duration = parseInt(match[1], 10);\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#ZEN-TOTAL-DURATION:?([0-9.]*)?/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'totalduration'\\n        };\\n        if (match[1]) {\\n          event.duration = parseInt(match[1], 10);\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'version'\\n        };\\n        if (match[1]) {\\n          event.version = parseInt(match[1], 10);\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-MEDIA-SEQUENCE:?(\\\\-?[0-9.]*)?/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'media-sequence'\\n        };\\n        if (match[1]) {\\n          event.number = parseInt(match[1], 10);\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\\\\-?[0-9.]*)?/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'discontinuity-sequence'\\n        };\\n        if (match[1]) {\\n          event.number = parseInt(match[1], 10);\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'playlist-type'\\n        };\\n        if (match[1]) {\\n          event.playlistType = match[1];\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-BYTERANGE:?([0-9.]*)?@?([0-9.]*)?/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'byterange'\\n        };\\n        if (match[1]) {\\n          event.length = parseInt(match[1], 10);\\n        }\\n        if (match[2]) {\\n          event.offset = parseInt(match[2], 10);\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'allow-cache'\\n        };\\n        if (match[1]) {\\n          event.allowed = !/NO/.test(match[1]);\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-MAP:?(.*)$/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'map'\\n        };\\n\\n        if (match[1]) {\\n          var attributes = parseAttributes(match[1]);\\n\\n          if (attributes.URI) {\\n            event.uri = attributes.URI;\\n          }\\n          if (attributes.BYTERANGE) {\\n            var _attributes$BYTERANGE$split = attributes.BYTERANGE.split('@');\\n\\n            var _attributes$BYTERANGE$split2 = _slicedToArray(_attributes$BYTERANGE$split, 2);\\n\\n            var _length = _attributes$BYTERANGE$split2[0];\\n            var offset = _attributes$BYTERANGE$split2[1];\\n\\n            event.byterange = {};\\n            if (_length) {\\n              event.byterange.length = parseInt(_length, 10);\\n            }\\n            if (offset) {\\n              event.byterange.offset = parseInt(offset, 10);\\n            }\\n          }\\n        }\\n\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-STREAM-INF:?(.*)$/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'stream-inf'\\n        };\\n        if (match[1]) {\\n          event.attributes = parseAttributes(match[1]);\\n\\n          if (event.attributes.RESOLUTION) {\\n            var split = event.attributes.RESOLUTION.split('x');\\n            var resolution = {};\\n\\n            if (split[0]) {\\n              resolution.width = parseInt(split[0], 10);\\n            }\\n            if (split[1]) {\\n              resolution.height = parseInt(split[1], 10);\\n            }\\n            event.attributes.RESOLUTION = resolution;\\n          }\\n          if (event.attributes.BANDWIDTH) {\\n            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\\n          }\\n          if (event.attributes['PROGRAM-ID']) {\\n            event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);\\n          }\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-MEDIA:?(.*)$/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'media'\\n        };\\n        if (match[1]) {\\n          event.attributes = parseAttributes(match[1]);\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-ENDLIST/.exec(line);\\n      if (match) {\\n        this.trigger('data', {\\n          type: 'tag',\\n          tagType: 'endlist'\\n        });\\n        return;\\n      }\\n      match = /^#EXT-X-DISCONTINUITY/.exec(line);\\n      if (match) {\\n        this.trigger('data', {\\n          type: 'tag',\\n          tagType: 'discontinuity'\\n        });\\n        return;\\n      }\\n      match = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'program-date-time'\\n        };\\n        if (match[1]) {\\n          event.dateTimeString = match[1];\\n          event.dateTimeObject = new Date(match[1]);\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-KEY:?(.*)$/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'key'\\n        };\\n        if (match[1]) {\\n          event.attributes = parseAttributes(match[1]);\\n          // parse the IV string into a Uint32Array\\n          if (event.attributes.IV) {\\n            if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {\\n              event.attributes.IV = event.attributes.IV.substring(2);\\n            }\\n\\n            event.attributes.IV = event.attributes.IV.match(/.{8}/g);\\n            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\\n            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\\n            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\\n            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\\n            event.attributes.IV = new Uint32Array(event.attributes.IV);\\n          }\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'cue-out-cont'\\n        };\\n        if (match[1]) {\\n          event.data = match[1];\\n        } else {\\n          event.data = '';\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'cue-out'\\n        };\\n        if (match[1]) {\\n          event.data = match[1];\\n        } else {\\n          event.data = '';\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'cue-in'\\n        };\\n        if (match[1]) {\\n          event.data = match[1];\\n        } else {\\n          event.data = '';\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n\\n      // unknown tag type\\n      this.trigger('data', {\\n        type: 'tag',\\n        data: line.slice(4)\\n      });\\n    }\\n  }]);\\n\\n  return ParseStream;\\n})(_stream2['default']);\\n\\nexports['default'] = ParseStream;\\nmodule.exports = exports['default'];\\n},{\\\"./stream\\\":67}],66:[function(require,module,exports){\\n/**\\n * @file m3u8/parser.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _stream = require('./stream');\\n\\nvar _stream2 = _interopRequireDefault(_stream);\\n\\nvar _lineStream = require('./line-stream');\\n\\nvar _lineStream2 = _interopRequireDefault(_lineStream);\\n\\nvar _parseStream = require('./parse-stream');\\n\\nvar _parseStream2 = _interopRequireDefault(_parseStream);\\n\\nvar _lodashCompatObjectMerge = require('lodash-compat/object/merge');\\n\\nvar _lodashCompatObjectMerge2 = _interopRequireDefault(_lodashCompatObjectMerge);\\n\\n/**\\n * A parser for M3U8 files. The current interpretation of the input is\\n * exposed as a property `manifest` on parser objects. It's just two lines to\\n * create and parse a manifest once you have the contents available as a string:\\n *\\n * ```js\\n * var parser = new m3u8.Parser();\\n * parser.push(xhr.responseText);\\n * ```\\n *\\n * New input can later be applied to update the manifest object by calling\\n * `push` again.\\n *\\n * The parser attempts to create a usable manifest object even if the\\n * underlying input is somewhat nonsensical. It emits `info` and `warning`\\n * events during the parse if it encounters input that seems invalid or\\n * requires some property of the manifest object to be defaulted.\\n *\\n * @class Parser\\n * @extends Stream\\n */\\n\\nvar Parser = (function (_Stream) {\\n  _inherits(Parser, _Stream);\\n\\n  function Parser() {\\n    _classCallCheck(this, Parser);\\n\\n    _get(Object.getPrototypeOf(Parser.prototype), 'constructor', this).call(this);\\n    this.lineStream = new _lineStream2['default']();\\n    this.parseStream = new _parseStream2['default']();\\n    this.lineStream.pipe(this.parseStream);\\n    /* eslint-disable consistent-this */\\n    var self = this;\\n    /* eslint-enable consistent-this */\\n    var uris = [];\\n    var currentUri = {};\\n    // if specified, the active EXT-X-MAP definition\\n    var currentMap = undefined;\\n    // if specified, the active decryption key\\n    var _key = undefined;\\n    var noop = function noop() {};\\n    var defaultMediaGroups = {\\n      'AUDIO': {},\\n      'VIDEO': {},\\n      'CLOSED-CAPTIONS': {},\\n      'SUBTITLES': {}\\n    };\\n    // group segments into numbered timelines delineated by discontinuities\\n    var currentTimeline = 0;\\n\\n    // the manifest is empty until the parse stream begins delivering data\\n    this.manifest = {\\n      allowCache: true,\\n      discontinuityStarts: []\\n    };\\n\\n    // update the manifest with the m3u8 entry from the parse stream\\n    this.parseStream.on('data', function (entry) {\\n      var mediaGroup = undefined;\\n      var rendition = undefined;\\n\\n      ({\\n        tag: function tag() {\\n          // switch based on the tag type\\n          (({\\n            'allow-cache': function allowCache() {\\n              this.manifest.allowCache = entry.allowed;\\n              if (!('allowed' in entry)) {\\n                this.trigger('info', {\\n                  message: 'defaulting allowCache to YES'\\n                });\\n                this.manifest.allowCache = true;\\n              }\\n            },\\n            byterange: function byterange() {\\n              var byterange = {};\\n\\n              if ('length' in entry) {\\n                currentUri.byterange = byterange;\\n                byterange.length = entry.length;\\n\\n                if (!('offset' in entry)) {\\n                  this.trigger('info', {\\n                    message: 'defaulting offset to zero'\\n                  });\\n                  entry.offset = 0;\\n                }\\n              }\\n              if ('offset' in entry) {\\n                currentUri.byterange = byterange;\\n                byterange.offset = entry.offset;\\n              }\\n            },\\n            endlist: function endlist() {\\n              this.manifest.endList = true;\\n            },\\n            inf: function inf() {\\n              if (!('mediaSequence' in this.manifest)) {\\n                this.manifest.mediaSequence = 0;\\n                this.trigger('info', {\\n                  message: 'defaulting media sequence to zero'\\n                });\\n              }\\n              if (!('discontinuitySequence' in this.manifest)) {\\n                this.manifest.discontinuitySequence = 0;\\n                this.trigger('info', {\\n                  message: 'defaulting discontinuity sequence to zero'\\n                });\\n              }\\n              if (entry.duration > 0) {\\n                currentUri.duration = entry.duration;\\n              }\\n\\n              if (entry.duration === 0) {\\n                currentUri.duration = 0.01;\\n                this.trigger('info', {\\n                  message: 'updating zero segment duration to a small value'\\n                });\\n              }\\n\\n              this.manifest.segments = uris;\\n            },\\n            key: function key() {\\n              if (!entry.attributes) {\\n                this.trigger('warn', {\\n                  message: 'ignoring key declaration without attribute list'\\n                });\\n                return;\\n              }\\n              // clear the active encryption key\\n              if (entry.attributes.METHOD === 'NONE') {\\n                _key = null;\\n                return;\\n              }\\n              if (!entry.attributes.URI) {\\n                this.trigger('warn', {\\n                  message: 'ignoring key declaration without URI'\\n                });\\n                return;\\n              }\\n              if (!entry.attributes.METHOD) {\\n                this.trigger('warn', {\\n                  message: 'defaulting key method to AES-128'\\n                });\\n              }\\n\\n              // setup an encryption key for upcoming segments\\n              _key = {\\n                method: entry.attributes.METHOD || 'AES-128',\\n                uri: entry.attributes.URI\\n              };\\n\\n              if (typeof entry.attributes.IV !== 'undefined') {\\n                _key.iv = entry.attributes.IV;\\n              }\\n            },\\n            'media-sequence': function mediaSequence() {\\n              if (!isFinite(entry.number)) {\\n                this.trigger('warn', {\\n                  message: 'ignoring invalid media sequence: ' + entry.number\\n                });\\n                return;\\n              }\\n              this.manifest.mediaSequence = entry.number;\\n            },\\n            'discontinuity-sequence': function discontinuitySequence() {\\n              if (!isFinite(entry.number)) {\\n                this.trigger('warn', {\\n                  message: 'ignoring invalid discontinuity sequence: ' + entry.number\\n                });\\n                return;\\n              }\\n              this.manifest.discontinuitySequence = entry.number;\\n              currentTimeline = entry.number;\\n            },\\n            'playlist-type': function playlistType() {\\n              if (!/VOD|EVENT/.test(entry.playlistType)) {\\n                this.trigger('warn', {\\n                  message: 'ignoring unknown playlist type: ' + entry.playlist\\n                });\\n                return;\\n              }\\n              this.manifest.playlistType = entry.playlistType;\\n            },\\n            map: function map() {\\n              currentMap = {};\\n              if (entry.uri) {\\n                currentMap.uri = entry.uri;\\n              }\\n              if (entry.byterange) {\\n                currentMap.byterange = entry.byterange;\\n              }\\n            },\\n            'stream-inf': function streamInf() {\\n              this.manifest.playlists = uris;\\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\\n\\n              if (!entry.attributes) {\\n                this.trigger('warn', {\\n                  message: 'ignoring empty stream-inf attributes'\\n                });\\n                return;\\n              }\\n\\n              if (!currentUri.attributes) {\\n                currentUri.attributes = {};\\n              }\\n              currentUri.attributes = (0, _lodashCompatObjectMerge2['default'])(currentUri.attributes, entry.attributes);\\n            },\\n            media: function media() {\\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\\n\\n              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {\\n                this.trigger('warn', {\\n                  message: 'ignoring incomplete or missing media group'\\n                });\\n                return;\\n              }\\n\\n              // find the media group, creating defaults as necessary\\n              var mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\\n\\n              mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};\\n              mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']];\\n\\n              // collect the rendition metadata\\n              rendition = {\\n                'default': /yes/i.test(entry.attributes.DEFAULT)\\n              };\\n              if (rendition['default']) {\\n                rendition.autoselect = true;\\n              } else {\\n                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\\n              }\\n              if (entry.attributes.LANGUAGE) {\\n                rendition.language = entry.attributes.LANGUAGE;\\n              }\\n              if (entry.attributes.URI) {\\n                rendition.uri = entry.attributes.URI;\\n              }\\n              if (entry.attributes['INSTREAM-ID']) {\\n                rendition.instreamId = entry.attributes['INSTREAM-ID'];\\n              }\\n\\n              // insert the new rendition\\n              mediaGroup[entry.attributes.NAME] = rendition;\\n            },\\n            discontinuity: function discontinuity() {\\n              currentTimeline += 1;\\n              currentUri.discontinuity = true;\\n              this.manifest.discontinuityStarts.push(uris.length);\\n            },\\n            'program-date-time': function programDateTime() {\\n              this.manifest.dateTimeString = entry.dateTimeString;\\n              this.manifest.dateTimeObject = entry.dateTimeObject;\\n            },\\n            targetduration: function targetduration() {\\n              if (!isFinite(entry.duration) || entry.duration < 0) {\\n                this.trigger('warn', {\\n                  message: 'ignoring invalid target duration: ' + entry.duration\\n                });\\n                return;\\n              }\\n              this.manifest.targetDuration = entry.duration;\\n            },\\n            totalduration: function totalduration() {\\n              if (!isFinite(entry.duration) || entry.duration < 0) {\\n                this.trigger('warn', {\\n                  message: 'ignoring invalid total duration: ' + entry.duration\\n                });\\n                return;\\n              }\\n              this.manifest.totalDuration = entry.duration;\\n            },\\n            'cue-out': function cueOut() {\\n              currentUri.cueOut = entry.data;\\n            },\\n            'cue-out-cont': function cueOutCont() {\\n              currentUri.cueOutCont = entry.data;\\n            },\\n            'cue-in': function cueIn() {\\n              currentUri.cueIn = entry.data;\\n            }\\n          })[entry.tagType] || noop).call(self);\\n        },\\n        uri: function uri() {\\n          currentUri.uri = entry.uri;\\n          uris.push(currentUri);\\n\\n          // if no explicit duration was declared, use the target duration\\n          if (this.manifest.targetDuration && !('duration' in currentUri)) {\\n            this.trigger('warn', {\\n              message: 'defaulting segment duration to the target duration'\\n            });\\n            currentUri.duration = this.manifest.targetDuration;\\n          }\\n          // annotate with encryption information, if necessary\\n          if (_key) {\\n            currentUri.key = _key;\\n          }\\n          currentUri.timeline = currentTimeline;\\n          // annotate with initialization segment information, if necessary\\n          if (currentMap) {\\n            currentUri.map = currentMap;\\n          }\\n\\n          // prepare for the next URI\\n          currentUri = {};\\n        },\\n        comment: function comment() {\\n          // comments are not important for playback\\n        }\\n      })[entry.type].call(self);\\n    });\\n  }\\n\\n  /**\\n   * Parse the input string and update the manifest object.\\n   *\\n   * @param {String} chunk a potentially incomplete portion of the manifest\\n   */\\n\\n  _createClass(Parser, [{\\n    key: 'push',\\n    value: function push(chunk) {\\n      this.lineStream.push(chunk);\\n    }\\n\\n    /**\\n     * Flush any remaining input. This can be handy if the last line of an M3U8\\n     * manifest did not contain a trailing newline but the file has been\\n     * completely received.\\n     */\\n  }, {\\n    key: 'end',\\n    value: function end() {\\n      // flush any buffered input\\n      this.lineStream.push('\\\\n');\\n    }\\n  }]);\\n\\n  return Parser;\\n})(_stream2['default']);\\n\\nexports['default'] = Parser;\\nmodule.exports = exports['default'];\\n},{\\\"./line-stream\\\":64,\\\"./parse-stream\\\":65,\\\"./stream\\\":67,\\\"lodash-compat/object/merge\\\":60}],67:[function(require,module,exports){\\narguments[4][14][0].apply(exports,arguments)\\n},{\\\"dup\\\":14}],68:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file add-text-track-data.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _globalWindow = require('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\n/**\\n * Define properties on a cue for backwards compatability,\\n * but warn the user that the way that they are using it\\n * is depricated and will be removed at a later date.\\n *\\n * @param {Cue} cue the cue to add the properties on\\n * @private\\n */\\nvar deprecateOldCue = function deprecateOldCue(cue) {\\n  Object.defineProperties(cue.frame, {\\n    id: {\\n      get: function get() {\\n        _videoJs2['default'].log.warn('cue.frame.id is deprecated. Use cue.value.key instead.');\\n        return cue.value.key;\\n      }\\n    },\\n    value: {\\n      get: function get() {\\n        _videoJs2['default'].log.warn('cue.frame.value is deprecated. Use cue.value.data instead.');\\n        return cue.value.data;\\n      }\\n    },\\n    privateData: {\\n      get: function get() {\\n        _videoJs2['default'].log.warn('cue.frame.privateData is deprecated. Use cue.value.data instead.');\\n        return cue.value.data;\\n      }\\n    }\\n  });\\n};\\n\\n/**\\n * Add text track data to a source handler given the captions and\\n * metadata from the buffer.\\n *\\n * @param {Object} sourceHandler the flash or virtual source buffer\\n * @param {Array} captionArray an array of caption data\\n * @param {Array} cue an array of meta data\\n * @private\\n */\\nvar addTextTrackData = function addTextTrackData(sourceHandler, captionArray, metadataArray) {\\n  var Cue = _globalWindow2['default'].WebKitDataCue || _globalWindow2['default'].VTTCue;\\n\\n  if (captionArray) {\\n    captionArray.forEach(function (caption) {\\n      this.inbandTextTrack_.addCue(new Cue(caption.startTime + this.timestampOffset, caption.endTime + this.timestampOffset, caption.text));\\n    }, sourceHandler);\\n  }\\n\\n  if (metadataArray) {\\n    metadataArray.forEach(function (metadata) {\\n      var time = metadata.cueTime + this.timestampOffset;\\n\\n      metadata.frames.forEach(function (frame) {\\n        var cue = new Cue(time, time, frame.value || frame.url || frame.data || '');\\n\\n        cue.frame = frame;\\n        cue.value = frame;\\n        deprecateOldCue(cue);\\n        this.metadataTrack_.addCue(cue);\\n      }, this);\\n    }, sourceHandler);\\n  }\\n};\\n\\nexports['default'] = addTextTrackData;\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"global/window\\\":26}],69:[function(require,module,exports){\\n/**\\n * @file codec-utils.js\\n */\\n\\n/**\\n * Check if a codec string refers to an audio codec.\\n *\\n * @param {String} codec codec string to check\\n * @return {Boolean} if this is an audio codec\\n * @private\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\nvar isAudioCodec = function isAudioCodec(codec) {\\n  return (/mp4a\\\\.\\\\d+.\\\\d+/i.test(codec)\\n  );\\n};\\n\\n/**\\n * Check if a codec string refers to a video codec.\\n *\\n * @param {String} codec codec string to check\\n * @return {Boolean} if this is a video codec\\n * @private\\n */\\nvar isVideoCodec = function isVideoCodec(codec) {\\n  return (/avc1\\\\.[\\\\da-f]+/i.test(codec)\\n  );\\n};\\n\\n/**\\n * Parse a content type header into a type and parameters\\n * object\\n *\\n * @param {String} type the content type header\\n * @return {Object} the parsed content-type\\n * @private\\n */\\nvar parseContentType = function parseContentType(type) {\\n  var object = { type: '', parameters: {} };\\n  var parameters = type.trim().split(';');\\n\\n  // first parameter should always be content-type\\n  object.type = parameters.shift().trim();\\n  parameters.forEach(function (parameter) {\\n    var pair = parameter.trim().split('=');\\n\\n    if (pair.length > 1) {\\n      var _name = pair[0].replace(/\\\"/g, '').trim();\\n      var value = pair[1].replace(/\\\"/g, '').trim();\\n\\n      object.parameters[_name] = value;\\n    }\\n  });\\n\\n  return object;\\n};\\n\\nexports['default'] = {\\n  isAudioCodec: isAudioCodec,\\n  parseContentType: parseContentType,\\n  isVideoCodec: isVideoCodec\\n};\\nmodule.exports = exports['default'];\\n},{}],70:[function(require,module,exports){\\n/**\\n * @file create-text-tracks-if-necessary.js\\n */\\n\\n/**\\n * Create text tracks on video.js if they exist on a segment.\\n *\\n * @param {Object} sourceBuffer the VSB or FSB\\n * @param {Object} mediaSource the HTML or Flash media source\\n * @param {Object} segment the segment that may contain the text track\\n * @private\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\nvar createTextTracksIfNecessary = function createTextTracksIfNecessary(sourceBuffer, mediaSource, segment) {\\n  // create an in-band caption track if one is present in the segment\\n  if (segment.captions && segment.captions.length && !sourceBuffer.inbandTextTrack_) {\\n    sourceBuffer.inbandTextTrack_ = mediaSource.player_.addTextTrack('captions', 'cc1');\\n  }\\n\\n  if (segment.metadata && segment.metadata.length && !sourceBuffer.metadataTrack_) {\\n    sourceBuffer.metadataTrack_ = mediaSource.player_.addTextTrack('metadata', 'Timed Metadata');\\n    sourceBuffer.metadataTrack_.inBandMetadataTrackDispatchType = segment.metadata.dispatchType;\\n  }\\n};\\n\\nexports['default'] = createTextTracksIfNecessary;\\nmodule.exports = exports['default'];\\n},{}],71:[function(require,module,exports){\\n/**\\n * @file flash-constants.js\\n */\\n/**\\n * The maximum size in bytes for append operations to the video.js\\n * SWF. Calling through to Flash blocks and can be expensive so\\n * tuning this parameter may improve playback on slower\\n * systems. There are two factors to consider:\\n * - Each interaction with the SWF must be quick or you risk dropping\\n * video frames. To maintain 60fps for the rest of the page, each append\\n * must not  take longer than 16ms. Given the likelihood that the page\\n * will be executing more javascript than just playback, you probably\\n * want to aim for less than 8ms. We aim for just 4ms.\\n * - Bigger appends significantly increase throughput. The total number of\\n * bytes over time delivered to the SWF must exceed the video bitrate or\\n * playback will stall.\\n *\\n * We adaptively tune the size of appends to give the best throughput\\n * possible given the performance of the system. To do that we try to append\\n * as much as possible in TIME_PER_TICK and while tuning the size of appends\\n * dynamically so that we only append about 4-times in that 4ms span.\\n *\\n * The reason we try to keep the number of appends around four is due to\\n * externalities such as Flash load and garbage collection that are highly\\n * variable and having 4 iterations allows us to exit the loop early if\\n * an iteration takes longer than expected.\\n *\\n * @private\\n */\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nvar flashConstants = {\\n  TIME_BETWEEN_TICKS: Math.floor(1000 / 500),\\n  TIME_PER_TICK: Math.floor(1000 / 100),\\n  // 1kb\\n  BYTES_PER_CHUNK: 4 * 1024,\\n  MIN_CHUNK: 4096,\\n  MAX_CHUNK: 4 * 1024 * 1024\\n};\\n\\nexports[\\\"default\\\"] = flashConstants;\\nmodule.exports = exports[\\\"default\\\"];\\n},{}],72:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file flash-media-source.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _globalDocument = require('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\nvar _flashSourceBuffer = require('./flash-source-buffer');\\n\\nvar _flashSourceBuffer2 = _interopRequireDefault(_flashSourceBuffer);\\n\\nvar _flashConstants = require('./flash-constants');\\n\\nvar _flashConstants2 = _interopRequireDefault(_flashConstants);\\n\\nvar _codecUtils = require('./codec-utils');\\n\\n/**\\n * A flash implmentation of HTML MediaSources and a polyfill\\n * for browsers that don't support native or HTML MediaSources..\\n *\\n * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource\\n * @class FlashMediaSource\\n * @extends videojs.EventTarget\\n */\\n\\nvar FlashMediaSource = (function (_videojs$EventTarget) {\\n  _inherits(FlashMediaSource, _videojs$EventTarget);\\n\\n  function FlashMediaSource() {\\n    var _this = this;\\n\\n    _classCallCheck(this, FlashMediaSource);\\n\\n    _get(Object.getPrototypeOf(FlashMediaSource.prototype), 'constructor', this).call(this);\\n    this.sourceBuffers = [];\\n    this.readyState = 'closed';\\n\\n    this.on(['sourceopen', 'webkitsourceopen'], function (event) {\\n      // find the swf where we will push media data\\n      _this.swfObj = _globalDocument2['default'].getElementById(event.swfId);\\n      _this.player_ = (0, _videoJs2['default'])(_this.swfObj.parentNode);\\n      _this.tech_ = _this.swfObj.tech;\\n      _this.readyState = 'open';\\n\\n      _this.tech_.on('seeking', function () {\\n        var i = _this.sourceBuffers.length;\\n\\n        while (i--) {\\n          _this.sourceBuffers[i].abort();\\n        }\\n      });\\n\\n      // trigger load events\\n      if (_this.swfObj) {\\n        _this.swfObj.vjs_load();\\n      }\\n    });\\n  }\\n\\n  /**\\n    * Set or return the presentation duration.\\n    *\\n    * @param {Double} value the duration of the media in seconds\\n    * @param {Double} the current presentation duration\\n    * @link http://www.w3.org/TR/media-source/#widl-MediaSource-duration\\n    */\\n\\n  /**\\n   * We have this function so that the html and flash interfaces\\n   * are the same.\\n   *\\n   * @private\\n   */\\n\\n  _createClass(FlashMediaSource, [{\\n    key: 'addSeekableRange_',\\n    value: function addSeekableRange_() {}\\n    // intentional no-op\\n\\n    /**\\n     * Create a new flash source buffer and add it to our flash media source.\\n     *\\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/addSourceBuffer\\n     * @param {String} type the content-type of the source\\n     * @return {Object} the flash source buffer\\n     */\\n\\n  }, {\\n    key: 'addSourceBuffer',\\n    value: function addSourceBuffer(type) {\\n      var parsedType = (0, _codecUtils.parseContentType)(type);\\n      var sourceBuffer = undefined;\\n\\n      // if this is an FLV type, we'll push data to flash\\n      if (parsedType.type === 'video/mp2t') {\\n        // Flash source buffers\\n        sourceBuffer = new _flashSourceBuffer2['default'](this);\\n      } else {\\n        throw new Error('NotSupportedError (Video.js)');\\n      }\\n\\n      this.sourceBuffers.push(sourceBuffer);\\n      return sourceBuffer;\\n    }\\n\\n    /**\\n     * Signals the end of the stream.\\n     *\\n     * @link https://w3c.github.io/media-source/#widl-MediaSource-endOfStream-void-EndOfStreamError-error\\n     * @param {String=} error Signals that a playback error\\n     * has occurred. If specified, it must be either \\\"network\\\" or\\n     * \\\"decode\\\".\\n     */\\n  }, {\\n    key: 'endOfStream',\\n    value: function endOfStream(error) {\\n      if (error === 'network') {\\n        // MEDIA_ERR_NETWORK\\n        this.tech_.error(2);\\n      } else if (error === 'decode') {\\n        // MEDIA_ERR_DECODE\\n        this.tech_.error(3);\\n      }\\n      if (this.readyState !== 'ended') {\\n        this.readyState = 'ended';\\n        this.swfObj.vjs_endOfStream();\\n      }\\n    }\\n  }]);\\n\\n  return FlashMediaSource;\\n})(_videoJs2['default'].EventTarget);\\n\\nexports['default'] = FlashMediaSource;\\ntry {\\n  Object.defineProperty(FlashMediaSource.prototype, 'duration', {\\n    /**\\n     * Return the presentation duration.\\n     *\\n     * @return {Double} the duration of the media in seconds\\n     * @link http://www.w3.org/TR/media-source/#widl-MediaSource-duration\\n     */\\n    get: function get() {\\n      if (!this.swfObj) {\\n        return NaN;\\n      }\\n      // get the current duration from the SWF\\n      return this.swfObj.vjs_getProperty('duration');\\n    },\\n    /**\\n     * Set the presentation duration.\\n     *\\n     * @param {Double} value the duration of the media in seconds\\n     * @return {Double} the duration of the media in seconds\\n     * @link http://www.w3.org/TR/media-source/#widl-MediaSource-duration\\n     */\\n    set: function set(value) {\\n      var i = undefined;\\n      var oldDuration = this.swfObj.vjs_getProperty('duration');\\n\\n      this.swfObj.vjs_setProperty('duration', value);\\n\\n      if (value < oldDuration) {\\n        // In MSE, this triggers the range removal algorithm which causes\\n        // an update to occur\\n        for (i = 0; i < this.sourceBuffers.length; i++) {\\n          this.sourceBuffers[i].remove(value, oldDuration);\\n        }\\n      }\\n\\n      return value;\\n    }\\n  });\\n} catch (e) {\\n  // IE8 throws if defineProperty is called on a non-DOM node. We\\n  // don't support IE8 but we shouldn't throw an error if loaded\\n  // there.\\n  FlashMediaSource.prototype.duration = NaN;\\n}\\n\\nfor (var property in _flashConstants2['default']) {\\n  FlashMediaSource[property] = _flashConstants2['default'][property];\\n}\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./codec-utils\\\":69,\\\"./flash-constants\\\":71,\\\"./flash-source-buffer\\\":73,\\\"global/document\\\":25}],73:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file flash-source-buffer.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _globalWindow = require('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\nvar _muxJsLibFlv = require('mux.js/lib/flv');\\n\\nvar _muxJsLibFlv2 = _interopRequireDefault(_muxJsLibFlv);\\n\\nvar _removeCuesFromTrack = require('./remove-cues-from-track');\\n\\nvar _removeCuesFromTrack2 = _interopRequireDefault(_removeCuesFromTrack);\\n\\nvar _createTextTracksIfNecessary = require('./create-text-tracks-if-necessary');\\n\\nvar _createTextTracksIfNecessary2 = _interopRequireDefault(_createTextTracksIfNecessary);\\n\\nvar _addTextTrackData = require('./add-text-track-data');\\n\\nvar _addTextTrackData2 = _interopRequireDefault(_addTextTrackData);\\n\\nvar _flashConstants = require('./flash-constants');\\n\\nvar _flashConstants2 = _interopRequireDefault(_flashConstants);\\n\\n/**\\n * A wrapper around the setTimeout function that uses\\n * the flash constant time between ticks value.\\n *\\n * @param {Function} func the function callback to run\\n * @private\\n */\\nvar scheduleTick = function scheduleTick(func) {\\n  // Chrome doesn't invoke requestAnimationFrame callbacks\\n  // in background tabs, so use setTimeout.\\n  _globalWindow2['default'].setTimeout(func, _flashConstants2['default'].TIME_BETWEEN_TICKS);\\n};\\n\\n/**\\n * Round a number to a specified number of places much like\\n * toFixed but return a number instead of a string representation.\\n *\\n * @param {Number} num A number\\n * @param {Number} places The number of decimal places which to\\n * round\\n * @private\\n */\\nvar toDecimalPlaces = function toDecimalPlaces(num, places) {\\n  if (typeof places !== 'number' || places < 0) {\\n    places = 0;\\n  }\\n\\n  var scale = Math.pow(10, places);\\n\\n  return Math.round(num * scale) / scale;\\n};\\n\\n/**\\n * A SourceBuffer implementation for Flash rather than HTML.\\n *\\n * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource\\n * @param {Object} mediaSource the flash media source\\n * @class FlashSourceBuffer\\n * @extends videojs.EventTarget\\n */\\n\\nvar FlashSourceBuffer = (function (_videojs$EventTarget) {\\n  _inherits(FlashSourceBuffer, _videojs$EventTarget);\\n\\n  function FlashSourceBuffer(mediaSource) {\\n    var _this = this;\\n\\n    _classCallCheck(this, FlashSourceBuffer);\\n\\n    _get(Object.getPrototypeOf(FlashSourceBuffer.prototype), 'constructor', this).call(this);\\n    var encodedHeader = undefined;\\n\\n    // Start off using the globally defined value but refine\\n    // as we append data into flash\\n    this.chunkSize_ = _flashConstants2['default'].BYTES_PER_CHUNK;\\n\\n    // byte arrays queued to be appended\\n    this.buffer_ = [];\\n\\n    // the total number of queued bytes\\n    this.bufferSize_ = 0;\\n\\n    // to be able to determine the correct position to seek to, we\\n    // need to retain information about the mapping between the\\n    // media timeline and PTS values\\n    this.basePtsOffset_ = NaN;\\n\\n    this.mediaSource = mediaSource;\\n\\n    // indicates whether the asynchronous continuation of an operation\\n    // is still being processed\\n    // see https://w3c.github.io/media-source/#widl-SourceBuffer-updating\\n    this.updating = false;\\n    this.timestampOffset_ = 0;\\n\\n    // TS to FLV transmuxer\\n    this.segmentParser_ = new _muxJsLibFlv2['default'].Transmuxer();\\n    this.segmentParser_.on('data', this.receiveBuffer_.bind(this));\\n    encodedHeader = _globalWindow2['default'].btoa(String.fromCharCode.apply(null, Array.prototype.slice.call(this.segmentParser_.getFlvHeader())));\\n    this.mediaSource.swfObj.vjs_appendBuffer(encodedHeader);\\n\\n    this.one('updateend', function () {\\n      _this.mediaSource.tech_.trigger('loadedmetadata');\\n    });\\n\\n    Object.defineProperty(this, 'timestampOffset', {\\n      get: function get() {\\n        return this.timestampOffset_;\\n      },\\n      set: function set(val) {\\n        if (typeof val === 'number' && val >= 0) {\\n          this.timestampOffset_ = val;\\n          this.segmentParser_ = new _muxJsLibFlv2['default'].Transmuxer();\\n          this.segmentParser_.on('data', this.receiveBuffer_.bind(this));\\n          // We have to tell flash to expect a discontinuity\\n          this.mediaSource.swfObj.vjs_discontinuity();\\n          // the media <-> PTS mapping must be re-established after\\n          // the discontinuity\\n          this.basePtsOffset_ = NaN;\\n        }\\n      }\\n    });\\n\\n    Object.defineProperty(this, 'buffered', {\\n      get: function get() {\\n        if (!this.mediaSource || !this.mediaSource.swfObj || !('vjs_getProperty' in this.mediaSource.swfObj)) {\\n          return _videoJs2['default'].createTimeRange();\\n        }\\n\\n        var buffered = this.mediaSource.swfObj.vjs_getProperty('buffered');\\n\\n        if (buffered && buffered.length) {\\n          buffered[0][0] = toDecimalPlaces(buffered[0][0], 3);\\n          buffered[0][1] = toDecimalPlaces(buffered[0][1], 3);\\n        }\\n        return _videoJs2['default'].createTimeRanges(buffered);\\n      }\\n    });\\n\\n    // On a seek we remove all text track data since flash has no concept\\n    // of a buffered-range and everything else is reset on seek\\n    this.mediaSource.player_.on('seeked', function () {\\n      (0, _removeCuesFromTrack2['default'])(0, Infinity, _this.metadataTrack_);\\n      (0, _removeCuesFromTrack2['default'])(0, Infinity, _this.inbandTextTrack_);\\n    });\\n  }\\n\\n  /**\\n   * Append bytes to the sourcebuffers buffer, in this case we\\n   * have to append it to swf object.\\n   *\\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/appendBuffer\\n   * @param {Array} bytes\\n   */\\n\\n  _createClass(FlashSourceBuffer, [{\\n    key: 'appendBuffer',\\n    value: function appendBuffer(bytes) {\\n      var _this2 = this;\\n\\n      var error = undefined;\\n      var chunk = 512 * 1024;\\n      var i = 0;\\n\\n      if (this.updating) {\\n        error = new Error('SourceBuffer.append() cannot be called ' + 'while an update is in progress');\\n        error.name = 'InvalidStateError';\\n        error.code = 11;\\n        throw error;\\n      }\\n\\n      this.updating = true;\\n      this.mediaSource.readyState = 'open';\\n      this.trigger({ type: 'update' });\\n\\n      // this is here to use recursion\\n      var chunkInData = function chunkInData() {\\n        _this2.segmentParser_.push(bytes.subarray(i, i + chunk));\\n        i += chunk;\\n        if (i < bytes.byteLength) {\\n          scheduleTick(chunkInData);\\n        } else {\\n          scheduleTick(_this2.segmentParser_.flush.bind(_this2.segmentParser_));\\n        }\\n      };\\n\\n      chunkInData();\\n    }\\n\\n    /**\\n     * Reset the parser and remove any data queued to be sent to the SWF.\\n     *\\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/abort\\n     */\\n  }, {\\n    key: 'abort',\\n    value: function abort() {\\n      this.buffer_ = [];\\n      this.bufferSize_ = 0;\\n      this.mediaSource.swfObj.vjs_abort();\\n\\n      // report any outstanding updates have ended\\n      if (this.updating) {\\n        this.updating = false;\\n        this.trigger({ type: 'updateend' });\\n      }\\n    }\\n\\n    /**\\n     * Flash cannot remove ranges already buffered in the NetStream\\n     * but seeking clears the buffer entirely. For most purposes,\\n     * having this operation act as a no-op is acceptable.\\n     *\\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/remove\\n     * @param {Double} start start of the section to remove\\n     * @param {Double} end end of the section to remove\\n     */\\n  }, {\\n    key: 'remove',\\n    value: function remove(start, end) {\\n      (0, _removeCuesFromTrack2['default'])(start, end, this.metadataTrack_);\\n      (0, _removeCuesFromTrack2['default'])(start, end, this.inbandTextTrack_);\\n      this.trigger({ type: 'update' });\\n      this.trigger({ type: 'updateend' });\\n    }\\n\\n    /**\\n     * Receive a buffer from the flv.\\n     *\\n     * @param {Object} segment\\n     * @private\\n     */\\n  }, {\\n    key: 'receiveBuffer_',\\n    value: function receiveBuffer_(segment) {\\n      var _this3 = this;\\n\\n      // create an in-band caption track if one is present in the segment\\n      (0, _createTextTracksIfNecessary2['default'])(this, this.mediaSource, segment);\\n      (0, _addTextTrackData2['default'])(this, segment.captions, segment.metadata);\\n\\n      // Do this asynchronously since convertTagsToData_ can be time consuming\\n      scheduleTick(function () {\\n        var flvBytes = _this3.convertTagsToData_(segment);\\n\\n        if (_this3.buffer_.length === 0) {\\n          scheduleTick(_this3.processBuffer_.bind(_this3));\\n        }\\n\\n        if (flvBytes) {\\n          _this3.buffer_.push(flvBytes);\\n          _this3.bufferSize_ += flvBytes.byteLength;\\n        }\\n      });\\n    }\\n\\n    /**\\n     * Append a portion of the current buffer to the SWF.\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'processBuffer_',\\n    value: function processBuffer_() {\\n      var chunk = undefined;\\n      var i = undefined;\\n      var length = undefined;\\n      var binary = undefined;\\n      var b64str = undefined;\\n      var startByte = 0;\\n      var appendIterations = 0;\\n      var startTime = +new Date();\\n      var appendTime = undefined;\\n\\n      if (!this.buffer_.length) {\\n        if (this.updating !== false) {\\n          this.updating = false;\\n          this.trigger({ type: 'updateend' });\\n        }\\n        // do nothing if the buffer is empty\\n        return;\\n      }\\n\\n      do {\\n        appendIterations++;\\n        // concatenate appends up to the max append size\\n        chunk = this.buffer_[0].subarray(startByte, startByte + this.chunkSize_);\\n\\n        // requeue any bytes that won't make it this round\\n        if (chunk.byteLength < this.chunkSize_ || this.buffer_[0].byteLength === startByte + this.chunkSize_) {\\n          startByte = 0;\\n          this.buffer_.shift();\\n        } else {\\n          startByte += this.chunkSize_;\\n        }\\n\\n        this.bufferSize_ -= chunk.byteLength;\\n\\n        // base64 encode the bytes\\n        binary = '';\\n        length = chunk.byteLength;\\n        for (i = 0; i < length; i++) {\\n          binary += String.fromCharCode(chunk[i]);\\n        }\\n        b64str = _globalWindow2['default'].btoa(binary);\\n\\n        // bypass normal ExternalInterface calls and pass xml directly\\n        // IE can be slow by default\\n        this.mediaSource.swfObj.CallFunction('<invoke name=\\\"vjs_appendBuffer\\\"' + 'returntype=\\\"javascript\\\"><arguments><string>' + b64str + '</string></arguments></invoke>');\\n        appendTime = new Date() - startTime;\\n      } while (this.buffer_.length && appendTime < _flashConstants2['default'].TIME_PER_TICK);\\n\\n      if (this.buffer_.length && startByte) {\\n        this.buffer_[0] = this.buffer_[0].subarray(startByte);\\n      }\\n\\n      if (appendTime >= _flashConstants2['default'].TIME_PER_TICK) {\\n        // We want to target 4 iterations per time-slot so that gives us\\n        // room to adjust to changes in Flash load and other externalities\\n        // such as garbage collection while still maximizing throughput\\n        this.chunkSize_ = Math.floor(this.chunkSize_ * (appendIterations / 4));\\n      }\\n\\n      // We also make sure that the chunk-size doesn't drop below 1KB or\\n      // go above 1MB as a sanity check\\n      this.chunkSize_ = Math.max(_flashConstants2['default'].MIN_CHUNK, Math.min(this.chunkSize_, _flashConstants2['default'].MAX_CHUNK));\\n\\n      // schedule another append if necessary\\n      if (this.bufferSize_ !== 0) {\\n        scheduleTick(this.processBuffer_.bind(this));\\n      } else {\\n        this.updating = false;\\n        this.trigger({ type: 'updateend' });\\n      }\\n    }\\n\\n    /**\\n     * Turns an array of flv tags into a Uint8Array representing the\\n     * flv data. Also removes any tags that are before the current\\n     * time so that playback begins at or slightly after the right\\n     * place on a seek\\n     *\\n     * @private\\n     * @param {Object} segmentData object of segment data\\n     */\\n  }, {\\n    key: 'convertTagsToData_',\\n    value: function convertTagsToData_(segmentData) {\\n      var segmentByteLength = 0;\\n      var tech = this.mediaSource.tech_;\\n      var targetPts = 0;\\n      var i = undefined;\\n      var j = undefined;\\n      var segment = undefined;\\n      var filteredTags = [];\\n      var tags = this.getOrderedTags_(segmentData);\\n\\n      // Establish the media timeline to PTS translation if we don't\\n      // have one already\\n      if (isNaN(this.basePtsOffset_) && tags.length) {\\n        this.basePtsOffset_ = tags[0].pts;\\n      }\\n\\n      // Trim any tags that are before the end of the end of\\n      // the current buffer\\n      if (tech.buffered().length) {\\n        targetPts = tech.buffered().end(0) - this.timestampOffset;\\n      }\\n      // Trim to currentTime if it's ahead of buffered or buffered doesn't exist\\n      targetPts = Math.max(targetPts, tech.currentTime() - this.timestampOffset);\\n\\n      // PTS values are represented in milliseconds\\n      targetPts *= 1e3;\\n      targetPts += this.basePtsOffset_;\\n\\n      // skip tags with a presentation time less than the seek target\\n      for (i = 0; i < tags.length; i++) {\\n        if (tags[i].pts >= targetPts) {\\n          filteredTags.push(tags[i]);\\n        }\\n      }\\n\\n      if (filteredTags.length === 0) {\\n        return;\\n      }\\n\\n      // concatenate the bytes into a single segment\\n      for (i = 0; i < filteredTags.length; i++) {\\n        segmentByteLength += filteredTags[i].bytes.byteLength;\\n      }\\n      segment = new Uint8Array(segmentByteLength);\\n      for (i = 0, j = 0; i < filteredTags.length; i++) {\\n        segment.set(filteredTags[i].bytes, j);\\n        j += filteredTags[i].bytes.byteLength;\\n      }\\n\\n      return segment;\\n    }\\n\\n    /**\\n     * Assemble the FLV tags in decoder order.\\n     *\\n     * @private\\n     * @param {Object} segmentData object of segment data\\n     */\\n  }, {\\n    key: 'getOrderedTags_',\\n    value: function getOrderedTags_(segmentData) {\\n      var videoTags = segmentData.tags.videoTags;\\n      var audioTags = segmentData.tags.audioTags;\\n      var tag = undefined;\\n      var tags = [];\\n\\n      while (videoTags.length || audioTags.length) {\\n        if (!videoTags.length) {\\n          // only audio tags remain\\n          tag = audioTags.shift();\\n        } else if (!audioTags.length) {\\n          // only video tags remain\\n          tag = videoTags.shift();\\n        } else if (audioTags[0].dts < videoTags[0].dts) {\\n          // audio should be decoded next\\n          tag = audioTags.shift();\\n        } else {\\n          // video should be decoded next\\n          tag = videoTags.shift();\\n        }\\n\\n        tags.push(tag.finalize());\\n      }\\n\\n      return tags;\\n    }\\n  }]);\\n\\n  return FlashSourceBuffer;\\n})(_videoJs2['default'].EventTarget);\\n\\nexports['default'] = FlashSourceBuffer;\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./add-text-track-data\\\":68,\\\"./create-text-tracks-if-necessary\\\":70,\\\"./flash-constants\\\":71,\\\"./remove-cues-from-track\\\":75,\\\"global/window\\\":26,\\\"mux.js/lib/flv\\\":83}],74:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file html-media-source.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _globalWindow = require('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _globalDocument = require('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\nvar _virtualSourceBuffer = require('./virtual-source-buffer');\\n\\nvar _virtualSourceBuffer2 = _interopRequireDefault(_virtualSourceBuffer);\\n\\nvar _codecUtils = require('./codec-utils');\\n\\n/**\\n * Replace the old apple-style `avc1.<dd>.<dd>` codec string with the standard\\n * `avc1.<hhhhhh>`\\n *\\n * @param {Array} codecs an array of codec strings to fix\\n * @return {Array} the translated codec array\\n * @private\\n */\\nvar translateLegacyCodecs = function translateLegacyCodecs(codecs) {\\n  return codecs.map(function (codec) {\\n    return codec.replace(/avc1\\\\.(\\\\d+)\\\\.(\\\\d+)/i, function (orig, profile, avcLevel) {\\n      var profileHex = ('00' + Number(profile).toString(16)).slice(-2);\\n      var avcLevelHex = ('00' + Number(avcLevel).toString(16)).slice(-2);\\n\\n      return 'avc1.' + profileHex + '00' + avcLevelHex;\\n    });\\n  });\\n};\\n\\n/**\\n * Our MediaSource implementation in HTML, mimics native\\n * MediaSource where/if possible.\\n *\\n * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource\\n * @class HtmlMediaSource\\n * @extends videojs.EventTarget\\n */\\n\\nvar HtmlMediaSource = (function (_videojs$EventTarget) {\\n  _inherits(HtmlMediaSource, _videojs$EventTarget);\\n\\n  function HtmlMediaSource() {\\n    var _this = this;\\n\\n    _classCallCheck(this, HtmlMediaSource);\\n\\n    _get(Object.getPrototypeOf(HtmlMediaSource.prototype), 'constructor', this).call(this);\\n    var property = undefined;\\n\\n    this.nativeMediaSource_ = new _globalWindow2['default'].MediaSource();\\n    // delegate to the native MediaSource's methods by default\\n    for (property in this.nativeMediaSource_) {\\n      if (!(property in HtmlMediaSource.prototype) && typeof this.nativeMediaSource_[property] === 'function') {\\n        this[property] = this.nativeMediaSource_[property].bind(this.nativeMediaSource_);\\n      }\\n    }\\n\\n    // emulate `duration` and `seekable` until seeking can be\\n    // handled uniformly for live streams\\n    // see https://github.com/w3c/media-source/issues/5\\n    this.duration_ = NaN;\\n    Object.defineProperty(this, 'duration', {\\n      get: function get() {\\n        if (this.duration_ === Infinity) {\\n          return this.duration_;\\n        }\\n        return this.nativeMediaSource_.duration;\\n      },\\n      set: function set(duration) {\\n        this.duration_ = duration;\\n        if (duration !== Infinity) {\\n          this.nativeMediaSource_.duration = duration;\\n          return;\\n        }\\n      }\\n    });\\n    Object.defineProperty(this, 'seekable', {\\n      get: function get() {\\n        if (this.duration_ === Infinity) {\\n          return _videoJs2['default'].createTimeRanges([[0, this.nativeMediaSource_.duration]]);\\n        }\\n        return this.nativeMediaSource_.seekable;\\n      }\\n    });\\n\\n    Object.defineProperty(this, 'readyState', {\\n      get: function get() {\\n        return this.nativeMediaSource_.readyState;\\n      }\\n    });\\n\\n    Object.defineProperty(this, 'activeSourceBuffers', {\\n      get: function get() {\\n        return this.activeSourceBuffers_;\\n      }\\n    });\\n\\n    // the list of virtual and native SourceBuffers created by this\\n    // MediaSource\\n    this.sourceBuffers = [];\\n\\n    this.activeSourceBuffers_ = [];\\n\\n    /**\\n     * update the list of active source buffers based upon various\\n     * imformation from HLS and video.js\\n     *\\n     * @private\\n     */\\n    this.updateActiveSourceBuffers_ = function () {\\n      // Retain the reference but empty the array\\n      _this.activeSourceBuffers_.length = 0;\\n\\n      // By default, the audio in the combined virtual source buffer is enabled\\n      // and the audio-only source buffer (if it exists) is disabled.\\n      var combined = false;\\n      var audioOnly = true;\\n\\n      // TODO: maybe we can store the sourcebuffers on the track objects?\\n      // safari may do something like this\\n      for (var i = 0; i < _this.player_.audioTracks().length; i++) {\\n        var track = _this.player_.audioTracks()[i];\\n\\n        if (track.enabled && track.kind !== 'main') {\\n          // The enabled track is an alternate audio track so disable the audio in\\n          // the combined source buffer and enable the audio-only source buffer.\\n          combined = true;\\n          audioOnly = false;\\n          break;\\n        }\\n      }\\n\\n      // Since we currently support a max of two source buffers, add all of the source\\n      // buffers (in order).\\n      _this.sourceBuffers.forEach(function (sourceBuffer) {\\n        /* eslinst-disable */\\n        // TODO once codecs are required, we can switch to using the codecs to determine\\n        //      what stream is the video stream, rather than relying on videoTracks\\n        /* eslinst-enable */\\n\\n        if (sourceBuffer.videoCodec_ && sourceBuffer.audioCodec_) {\\n          // combined\\n          sourceBuffer.audioDisabled_ = combined;\\n        } else if (sourceBuffer.videoCodec_ && !sourceBuffer.audioCodec_) {\\n          // If the \\\"combined\\\" source buffer is video only, then we do not want\\n          // disable the audio-only source buffer (this is mostly for demuxed\\n          // audio and video hls)\\n          sourceBuffer.audioDisabled_ = true;\\n          audioOnly = false;\\n        } else if (!sourceBuffer.videoCodec_ && sourceBuffer.audioCodec_) {\\n          // audio only\\n          sourceBuffer.audioDisabled_ = audioOnly;\\n          if (audioOnly) {\\n            return;\\n          }\\n        }\\n\\n        _this.activeSourceBuffers_.push(sourceBuffer);\\n      });\\n    };\\n\\n    // Re-emit MediaSource events on the polyfill\\n    ['sourceopen', 'sourceclose', 'sourceended'].forEach(function (eventName) {\\n      this.nativeMediaSource_.addEventListener(eventName, this.trigger.bind(this));\\n    }, this);\\n\\n    // capture the associated player when the MediaSource is\\n    // successfully attached\\n    this.on('sourceopen', function (event) {\\n      // Get the player this MediaSource is attached to\\n      var video = _globalDocument2['default'].querySelector('[src=\\\"' + _this.url_ + '\\\"]');\\n\\n      if (!video) {\\n        return;\\n      }\\n\\n      _this.player_ = (0, _videoJs2['default'])(video.parentNode);\\n\\n      if (_this.player_.audioTracks && _this.player_.audioTracks()) {\\n        _this.player_.audioTracks().on('change', _this.updateActiveSourceBuffers_);\\n        _this.player_.audioTracks().on('addtrack', _this.updateActiveSourceBuffers_);\\n        _this.player_.audioTracks().on('removetrack', _this.updateActiveSourceBuffers_);\\n      }\\n    });\\n\\n    // explicitly terminate any WebWorkers that were created\\n    // by SourceHandlers\\n    this.on('sourceclose', function (event) {\\n      this.sourceBuffers.forEach(function (sourceBuffer) {\\n        if (sourceBuffer.transmuxer_) {\\n          sourceBuffer.transmuxer_.terminate();\\n        }\\n      });\\n      this.sourceBuffers.length = 0;\\n      if (!this.player_) {\\n        return;\\n      }\\n\\n      if (this.player_.audioTracks && this.player_.audioTracks()) {\\n        this.player_.audioTracks().off('change', this.updateActiveSourceBuffers_);\\n        this.player_.audioTracks().off('addtrack', this.updateActiveSourceBuffers_);\\n        this.player_.audioTracks().off('removetrack', this.updateActiveSourceBuffers_);\\n      }\\n    });\\n  }\\n\\n  /**\\n   * Add a range that that can now be seeked to.\\n   *\\n   * @param {Double} start where to start the addition\\n   * @param {Double} end where to end the addition\\n   * @private\\n   */\\n\\n  _createClass(HtmlMediaSource, [{\\n    key: 'addSeekableRange_',\\n    value: function addSeekableRange_(start, end) {\\n      var error = undefined;\\n\\n      if (this.duration !== Infinity) {\\n        error = new Error('MediaSource.addSeekableRange() can only be invoked ' + 'when the duration is Infinity');\\n        error.name = 'InvalidStateError';\\n        error.code = 11;\\n        throw error;\\n      }\\n\\n      if (end > this.nativeMediaSource_.duration || isNaN(this.nativeMediaSource_.duration)) {\\n        this.nativeMediaSource_.duration = end;\\n      }\\n    }\\n\\n    /**\\n     * Add a source buffer to the media source.\\n     *\\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/addSourceBuffer\\n     * @param {String} type the content-type of the content\\n     * @return {Object} the created source buffer\\n     */\\n  }, {\\n    key: 'addSourceBuffer',\\n    value: function addSourceBuffer(type) {\\n      var buffer = undefined;\\n      var parsedType = (0, _codecUtils.parseContentType)(type);\\n\\n      // Create a VirtualSourceBuffer to transmux MPEG-2 transport\\n      // stream segments into fragmented MP4s\\n      if (parsedType.type === 'video/mp2t') {\\n        var codecs = [];\\n\\n        if (parsedType.parameters && parsedType.parameters.codecs) {\\n          codecs = parsedType.parameters.codecs.split(',');\\n          codecs = translateLegacyCodecs(codecs);\\n          codecs = codecs.filter(function (codec) {\\n            return (0, _codecUtils.isAudioCodec)(codec) || (0, _codecUtils.isVideoCodec)(codec);\\n          });\\n        }\\n\\n        if (codecs.length === 0) {\\n          codecs = ['avc1.4d400d', 'mp4a.40.2'];\\n        }\\n\\n        buffer = new _virtualSourceBuffer2['default'](this, codecs);\\n\\n        if (this.sourceBuffers.length !== 0) {\\n          // If another VirtualSourceBuffer already exists, then we are creating a\\n          // SourceBuffer for an alternate audio track and therefore we know that\\n          // the source has both an audio and video track.\\n          // That means we should trigger the manual creation of the real\\n          // SourceBuffers instead of waiting for the transmuxer to return data\\n          this.sourceBuffers[0].createRealSourceBuffers_();\\n          buffer.createRealSourceBuffers_();\\n\\n          // Automatically disable the audio on the first source buffer if\\n          // a second source buffer is ever created\\n          this.sourceBuffers[0].audioDisabled_ = true;\\n        }\\n      } else {\\n        // delegate to the native implementation\\n        buffer = this.nativeMediaSource_.addSourceBuffer(type);\\n      }\\n\\n      this.sourceBuffers.push(buffer);\\n      return buffer;\\n    }\\n  }]);\\n\\n  return HtmlMediaSource;\\n})(_videoJs2['default'].EventTarget);\\n\\nexports['default'] = HtmlMediaSource;\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./codec-utils\\\":69,\\\"./virtual-source-buffer\\\":78,\\\"global/document\\\":25,\\\"global/window\\\":26}],75:[function(require,module,exports){\\n/**\\n * @file remove-cues-from-track.js\\n */\\n\\n/**\\n * Remove cues from a track on video.js.\\n *\\n * @param {Double} start start of where we should remove the cue\\n * @param {Double} end end of where the we should remove the cue\\n * @param {Object} track the text track to remove the cues from\\n * @private\\n */\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nvar removeCuesFromTrack = function removeCuesFromTrack(start, end, track) {\\n  var i = undefined;\\n  var cue = undefined;\\n\\n  if (!track) {\\n    return;\\n  }\\n\\n  i = track.cues.length;\\n\\n  while (i--) {\\n    cue = track.cues[i];\\n\\n    // Remove any overlapping cue\\n    if (cue.startTime <= end && cue.endTime >= start) {\\n      track.removeCue(cue);\\n    }\\n  }\\n};\\n\\nexports[\\\"default\\\"] = removeCuesFromTrack;\\nmodule.exports = exports[\\\"default\\\"];\\n},{}],76:[function(require,module,exports){\\n/**\\n * @file transmuxer-worker.js\\n */\\n\\n/**\\n * videojs-contrib-media-sources\\n *\\n * Copyright (c) 2015 Brightcove\\n * All rights reserved.\\n *\\n * Handles communication between the browser-world and the mux.js\\n * transmuxer running inside of a WebWorker by exposing a simple\\n * message-based interface to a Transmuxer object.\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nvar _globalWindow = require('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _muxJsLibMp4 = require('mux.js/lib/mp4');\\n\\nvar _muxJsLibMp42 = _interopRequireDefault(_muxJsLibMp4);\\n\\n/**\\n * Re-emits tranmsuxer events by converting them into messages to the\\n * world outside the worker.\\n *\\n * @param {Object} transmuxer the transmuxer to wire events on\\n * @private\\n */\\nvar wireTransmuxerEvents = function wireTransmuxerEvents(transmuxer) {\\n  transmuxer.on('data', function (segment) {\\n    // transfer ownership of the underlying ArrayBuffer\\n    // instead of doing a copy to save memory\\n    // ArrayBuffers are transferable but generic TypedArrays are not\\n    // @link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers#Passing_data_by_transferring_ownership_(transferable_objects)\\n    var typedArray = segment.data;\\n\\n    segment.data = typedArray.buffer;\\n    _globalWindow2['default'].postMessage({\\n      action: 'data',\\n      segment: segment,\\n      byteOffset: typedArray.byteOffset,\\n      byteLength: typedArray.byteLength\\n    }, [segment.data]);\\n  });\\n\\n  if (transmuxer.captionStream) {\\n    transmuxer.captionStream.on('data', function (caption) {\\n      _globalWindow2['default'].postMessage({\\n        action: 'caption',\\n        data: caption\\n      });\\n    });\\n  }\\n\\n  transmuxer.on('done', function (data) {\\n    _globalWindow2['default'].postMessage({ action: 'done' });\\n  });\\n};\\n\\n/**\\n * All incoming messages route through this hash. If no function exists\\n * to handle an incoming message, then we ignore the message.\\n *\\n * @class MessageHandlers\\n * @param {Object} options the options to initialize with\\n */\\n\\nvar MessageHandlers = (function () {\\n  function MessageHandlers(options) {\\n    _classCallCheck(this, MessageHandlers);\\n\\n    this.options = options || {};\\n    this.init();\\n  }\\n\\n  /**\\n   * Our web wroker interface so that things can talk to mux.js\\n   * that will be running in a web worker. the scope is passed to this by\\n   * webworkify.\\n   *\\n   * @param {Object} self the scope for the web worker\\n   */\\n\\n  /**\\n   * initialize our web worker and wire all the events.\\n   */\\n\\n  _createClass(MessageHandlers, [{\\n    key: 'init',\\n    value: function init() {\\n      if (this.transmuxer) {\\n        this.transmuxer.dispose();\\n      }\\n      this.transmuxer = new _muxJsLibMp42['default'].Transmuxer(this.options);\\n      wireTransmuxerEvents(this.transmuxer);\\n    }\\n\\n    /**\\n     * Adds data (a ts segment) to the start of the transmuxer pipeline for\\n     * processing.\\n     *\\n     * @param {ArrayBuffer} data data to push into the muxer\\n     */\\n  }, {\\n    key: 'push',\\n    value: function push(data) {\\n      // Cast array buffer to correct type for transmuxer\\n      var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);\\n\\n      this.transmuxer.push(segment);\\n    }\\n\\n    /**\\n     * Recreate the transmuxer so that the next segment added via `push`\\n     * start with a fresh transmuxer.\\n     */\\n  }, {\\n    key: 'reset',\\n    value: function reset() {\\n      this.init();\\n    }\\n\\n    /**\\n     * Set the value that will be used as the `baseMediaDecodeTime` time for the\\n     * next segment pushed in. Subsequent segments will have their `baseMediaDecodeTime`\\n     * set relative to the first based on the PTS values.\\n     *\\n     * @param {Object} data used to set the timestamp offset in the muxer\\n     */\\n  }, {\\n    key: 'setTimestampOffset',\\n    value: function setTimestampOffset(data) {\\n      var timestampOffset = data.timestampOffset || 0;\\n\\n      this.transmuxer.setBaseMediaDecodeTime(Math.round(timestampOffset * 90000));\\n    }\\n\\n    /**\\n     * Forces the pipeline to finish processing the last segment and emit it's\\n     * results.\\n     *\\n     * @param {Object} data event data, not really used\\n     */\\n  }, {\\n    key: 'flush',\\n    value: function flush(data) {\\n      this.transmuxer.flush();\\n    }\\n  }]);\\n\\n  return MessageHandlers;\\n})();\\n\\nvar Worker = function Worker(self) {\\n  self.onmessage = function (event) {\\n    if (event.data.action === 'init' && event.data.options) {\\n      this.messageHandlers = new MessageHandlers(event.data.options);\\n      return;\\n    }\\n\\n    if (!this.messageHandlers) {\\n      this.messageHandlers = new MessageHandlers();\\n    }\\n\\n    if (event.data && event.data.action && event.data.action !== 'init') {\\n      if (this.messageHandlers[event.data.action]) {\\n        this.messageHandlers[event.data.action](event.data);\\n      }\\n    }\\n  };\\n};\\n\\nexports['default'] = function (self) {\\n  return new Worker(self);\\n};\\n\\nmodule.exports = exports['default'];\\n},{\\\"global/window\\\":26,\\\"mux.js/lib/mp4\\\":90}],77:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file videojs-contrib-media-sources.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _globalWindow = require('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _flashMediaSource = require('./flash-media-source');\\n\\nvar _flashMediaSource2 = _interopRequireDefault(_flashMediaSource);\\n\\nvar _htmlMediaSource = require('./html-media-source');\\n\\nvar _htmlMediaSource2 = _interopRequireDefault(_htmlMediaSource);\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\nvar urlCount = 0;\\n\\n// ------------\\n// Media Source\\n// ------------\\n\\nvar defaults = {\\n  // how to determine the MediaSource implementation to use. There\\n  // are three available modes:\\n  // - auto: use native MediaSources where available and Flash\\n  //   everywhere else\\n  // - html5: always use native MediaSources\\n  // - flash: always use the Flash MediaSource polyfill\\n  mode: 'auto'\\n};\\n\\n// lolomo references to the media sources so they can be connected\\n// to a video element (a swf object)\\n// TODO: can we lolomo this somewhere local to this module?\\n_videoJs2['default'].mediaSources = {};\\n\\n/**\\n * Provide a method for a swf object to notify JS that a\\n * media source is now open.\\n *\\n * @param {String} msObjectURL string referencing the MSE Object URL\\n * @param {String} swfId the swf id\\n */\\nvar open = function open(msObjectURL, swfId) {\\n  var mediaSource = _videoJs2['default'].mediaSources[msObjectURL];\\n\\n  if (mediaSource) {\\n    mediaSource.trigger({ type: 'sourceopen', swfId: swfId });\\n  } else {\\n    throw new Error('Media Source not found (Video.js)');\\n  }\\n};\\n\\n/**\\n * Check to see if the native MediaSource object exists and supports\\n * an MP4 container with both H.264 video and AAC-LC audio.\\n *\\n * @return {Boolean} if  native media sources are supported\\n */\\nvar supportsNativeMediaSources = function supportsNativeMediaSources() {\\n  return !!_globalWindow2['default'].MediaSource && !!_globalWindow2['default'].MediaSource.isTypeSupported && _globalWindow2['default'].MediaSource.isTypeSupported('video/mp4;codecs=\\\"avc1.4d400d,mp4a.40.2\\\"');\\n};\\n\\n/**\\n * An emulation of the MediaSource API so that we can support\\n * native and non-native functionality such as flash and\\n * video/mp2t videos. returns an instance of HtmlMediaSource or\\n * FlashMediaSource depending on what is supported and what options\\n * are passed in.\\n *\\n * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/MediaSource\\n * @param {Object} options options to use during setup.\\n */\\nvar MediaSource = function MediaSource(options) {\\n  var settings = _videoJs2['default'].mergeOptions(defaults, options);\\n\\n  this.MediaSource = {\\n    open: open,\\n    supportsNativeMediaSources: supportsNativeMediaSources\\n  };\\n\\n  // determine whether HTML MediaSources should be used\\n  if (settings.mode === 'html5' || settings.mode === 'auto' && supportsNativeMediaSources()) {\\n    return new _htmlMediaSource2['default']();\\n  }\\n\\n  // otherwise, emulate them through the SWF\\n  return new _flashMediaSource2['default']();\\n};\\n\\nexports.MediaSource = MediaSource;\\nMediaSource.open = open;\\nMediaSource.supportsNativeMediaSources = supportsNativeMediaSources;\\n\\n/**\\n * A wrapper around the native URL for our MSE object\\n * implementation, this object is exposed under videojs.URL\\n *\\n * @link https://developer.mozilla.org/en-US/docs/Web/API/URL/URL\\n */\\nvar URL = {\\n  /**\\n   * A wrapper around the native createObjectURL for our objects.\\n   * This function maps a native or emulated mediaSource to a blob\\n   * url so that it can be loaded into video.js\\n   *\\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\\n   * @param {MediaSource} object the object to create a blob url to\\n   */\\n  createObjectURL: function createObjectURL(object) {\\n    var objectUrlPrefix = 'blob:vjs-media-source/';\\n    var url = undefined;\\n\\n    // use the native MediaSource to generate an object URL\\n    if (object instanceof _htmlMediaSource2['default']) {\\n      url = _globalWindow2['default'].URL.createObjectURL(object.nativeMediaSource_);\\n      object.url_ = url;\\n      return url;\\n    }\\n    // if the object isn't an emulated MediaSource, delegate to the\\n    // native implementation\\n    if (!(object instanceof _flashMediaSource2['default'])) {\\n      url = _globalWindow2['default'].URL.createObjectURL(object);\\n      object.url_ = url;\\n      return url;\\n    }\\n\\n    // build a URL that can be used to map back to the emulated\\n    // MediaSource\\n    url = objectUrlPrefix + urlCount;\\n\\n    urlCount++;\\n\\n    // setup the mapping back to object\\n    _videoJs2['default'].mediaSources[url] = object;\\n\\n    return url;\\n  }\\n};\\n\\nexports.URL = URL;\\n_videoJs2['default'].MediaSource = MediaSource;\\n_videoJs2['default'].URL = URL;\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./flash-media-source\\\":72,\\\"./html-media-source\\\":74,\\\"global/window\\\":26}],78:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file virtual-source-buffer.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\nvar _createTextTracksIfNecessary = require('./create-text-tracks-if-necessary');\\n\\nvar _createTextTracksIfNecessary2 = _interopRequireDefault(_createTextTracksIfNecessary);\\n\\nvar _removeCuesFromTrack = require('./remove-cues-from-track');\\n\\nvar _removeCuesFromTrack2 = _interopRequireDefault(_removeCuesFromTrack);\\n\\nvar _addTextTrackData = require('./add-text-track-data');\\n\\nvar _addTextTrackData2 = _interopRequireDefault(_addTextTrackData);\\n\\nvar _webworkify = require('webworkify');\\n\\nvar _webworkify2 = _interopRequireDefault(_webworkify);\\n\\nvar _transmuxerWorker = require('./transmuxer-worker');\\n\\nvar _transmuxerWorker2 = _interopRequireDefault(_transmuxerWorker);\\n\\nvar _codecUtils = require('./codec-utils');\\n\\n/**\\n * VirtualSourceBuffers exist so that we can transmux non native formats\\n * into a native format, but keep the same api as a native source buffer.\\n * It creates a transmuxer, that works in its own thread (a web worker) and\\n * that transmuxer muxes the data into a native format. VirtualSourceBuffer will\\n * then send all of that data to the naive sourcebuffer so that it is\\n * indestinguishable from a natively supported format.\\n *\\n * @param {HtmlMediaSource} mediaSource the parent mediaSource\\n * @param {Array} codecs array of codecs that we will be dealing with\\n * @class VirtualSourceBuffer\\n * @extends video.js.EventTarget\\n */\\n\\nvar VirtualSourceBuffer = (function (_videojs$EventTarget) {\\n  _inherits(VirtualSourceBuffer, _videojs$EventTarget);\\n\\n  function VirtualSourceBuffer(mediaSource, codecs) {\\n    var _this = this;\\n\\n    _classCallCheck(this, VirtualSourceBuffer);\\n\\n    _get(Object.getPrototypeOf(VirtualSourceBuffer.prototype), 'constructor', this).call(this, _videoJs2['default'].EventTarget);\\n    this.timestampOffset_ = 0;\\n    this.pendingBuffers_ = [];\\n    this.bufferUpdating_ = false;\\n    this.mediaSource_ = mediaSource;\\n    this.codecs_ = codecs;\\n    this.audioCodec_ = null;\\n    this.videoCodec_ = null;\\n    this.audioDisabled_ = false;\\n\\n    var options = {\\n      remux: false\\n    };\\n\\n    this.codecs_.forEach(function (codec) {\\n      if ((0, _codecUtils.isAudioCodec)(codec)) {\\n        _this.audioCodec_ = codec;\\n      } else if ((0, _codecUtils.isVideoCodec)(codec)) {\\n        _this.videoCodec_ = codec;\\n      }\\n    });\\n\\n    // append muxed segments to their respective native buffers as\\n    // soon as they are available\\n    this.transmuxer_ = (0, _webworkify2['default'])(_transmuxerWorker2['default']);\\n    this.transmuxer_.postMessage({ action: 'init', options: options });\\n\\n    this.transmuxer_.onmessage = function (event) {\\n      if (event.data.action === 'data') {\\n        return _this.data_(event);\\n      }\\n\\n      if (event.data.action === 'done') {\\n        return _this.done_(event);\\n      }\\n    };\\n\\n    // this timestampOffset is a property with the side-effect of resetting\\n    // baseMediaDecodeTime in the transmuxer on the setter\\n    Object.defineProperty(this, 'timestampOffset', {\\n      get: function get() {\\n        return this.timestampOffset_;\\n      },\\n      set: function set(val) {\\n        if (typeof val === 'number' && val >= 0) {\\n          this.timestampOffset_ = val;\\n\\n          // We have to tell the transmuxer to set the baseMediaDecodeTime to\\n          // the desired timestampOffset for the next segment\\n          this.transmuxer_.postMessage({\\n            action: 'setTimestampOffset',\\n            timestampOffset: val\\n          });\\n        }\\n      }\\n    });\\n\\n    // setting the append window affects both source buffers\\n    Object.defineProperty(this, 'appendWindowStart', {\\n      get: function get() {\\n        return (this.videoBuffer_ || this.audioBuffer_).appendWindowStart;\\n      },\\n      set: function set(start) {\\n        if (this.videoBuffer_) {\\n          this.videoBuffer_.appendWindowStart = start;\\n        }\\n        if (this.audioBuffer_) {\\n          this.audioBuffer_.appendWindowStart = start;\\n        }\\n      }\\n    });\\n\\n    // this buffer is \\\"updating\\\" if either of its native buffers are\\n    Object.defineProperty(this, 'updating', {\\n      get: function get() {\\n        return !!(this.bufferUpdating_ || !this.audioDisabled_ && this.audioBuffer_ && this.audioBuffer_.updating || this.videoBuffer_ && this.videoBuffer_.updating);\\n      }\\n    });\\n\\n    // the buffered property is the intersection of the buffered\\n    // ranges of the native source buffers\\n    Object.defineProperty(this, 'buffered', {\\n      get: function get() {\\n        var start = null;\\n        var end = null;\\n        var arity = 0;\\n        var extents = [];\\n        var ranges = [];\\n\\n        if (!this.videoBuffer_ && (this.audioDisabled_ || !this.audioBuffer_)) {\\n          return _videoJs2['default'].createTimeRange();\\n        }\\n\\n        // Handle the case where we only have one buffer\\n        if (!this.videoBuffer_) {\\n          return this.audioBuffer_.buffered;\\n        } else if (this.audioDisabled_ || !this.audioBuffer_) {\\n          return this.videoBuffer_.buffered;\\n        }\\n\\n        // Handle the case where there is no buffer data\\n        if ((!this.videoBuffer_ || this.videoBuffer_.buffered.length === 0) && (!this.audioBuffer_ || this.audioBuffer_.buffered.length === 0)) {\\n          return _videoJs2['default'].createTimeRange();\\n        }\\n\\n        // Handle the case where we have both buffers and create an\\n        // intersection of the two\\n        var videoBuffered = this.videoBuffer_.buffered;\\n        var audioBuffered = this.audioBuffer_.buffered;\\n        var count = videoBuffered.length;\\n\\n        // A) Gather up all start and end times\\n        while (count--) {\\n          extents.push({ time: videoBuffered.start(count), type: 'start' });\\n          extents.push({ time: videoBuffered.end(count), type: 'end' });\\n        }\\n        count = audioBuffered.length;\\n        while (count--) {\\n          extents.push({ time: audioBuffered.start(count), type: 'start' });\\n          extents.push({ time: audioBuffered.end(count), type: 'end' });\\n        }\\n        // B) Sort them by time\\n        extents.sort(function (a, b) {\\n          return a.time - b.time;\\n        });\\n\\n        // C) Go along one by one incrementing arity for start and decrementing\\n        //    arity for ends\\n        for (count = 0; count < extents.length; count++) {\\n          if (extents[count].type === 'start') {\\n            arity++;\\n\\n            // D) If arity is ever incremented to 2 we are entering an\\n            //    overlapping range\\n            if (arity === 2) {\\n              start = extents[count].time;\\n            }\\n          } else if (extents[count].type === 'end') {\\n            arity--;\\n\\n            // E) If arity is ever decremented to 1 we leaving an\\n            //    overlapping range\\n            if (arity === 1) {\\n              end = extents[count].time;\\n            }\\n          }\\n\\n          // F) Record overlapping ranges\\n          if (start !== null && end !== null) {\\n            ranges.push([start, end]);\\n            start = null;\\n            end = null;\\n          }\\n        }\\n\\n        return _videoJs2['default'].createTimeRanges(ranges);\\n      }\\n    });\\n  }\\n\\n  /**\\n   * When we get a data event from the transmuxer\\n   * we call this function and handle the data that\\n   * was sent to us\\n   *\\n   * @private\\n   * @param {Event} event the data event from the transmuxer\\n   */\\n\\n  _createClass(VirtualSourceBuffer, [{\\n    key: 'data_',\\n    value: function data_(event) {\\n      var segment = event.data.segment;\\n\\n      // Cast ArrayBuffer to TypedArray\\n      segment.data = new Uint8Array(segment.data, event.data.byteOffset, event.data.byteLength);\\n\\n      (0, _createTextTracksIfNecessary2['default'])(this, this.mediaSource_, segment);\\n\\n      // Add the segments to the pendingBuffers array\\n      this.pendingBuffers_.push(segment);\\n      return;\\n    }\\n\\n    /**\\n     * When we get a done event from the transmuxer\\n     * we call this function and we process all\\n     * of the pending data that we have been saving in the\\n     * data_ function\\n     *\\n     * @private\\n     * @param {Event} event the done event from the transmuxer\\n     */\\n  }, {\\n    key: 'done_',\\n    value: function done_(event) {\\n      // All buffers should have been flushed from the muxer\\n      // start processing anything we have received\\n      this.processPendingSegments_();\\n      return;\\n    }\\n\\n    /**\\n     * Create our internal native audio/video source buffers and add\\n     * event handlers to them with the following conditions:\\n     * 1. they do not already exist on the mediaSource\\n     * 2. this VSB has a codec for them\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'createRealSourceBuffers_',\\n    value: function createRealSourceBuffers_() {\\n      var _this2 = this;\\n\\n      var types = ['audio', 'video'];\\n      // XA Default codecs\\n      var defaultCodecs = {\\\"audio\\\": \\\"mp4a.40.2\\\", \\\"video\\\":\\\"avc1.4d400d\\\"};\\n\\n      types.forEach(function (type) {\\n        // Don't create a SourceBuffer of this type if we don't have a\\n        // codec for it\\n        if (!_this2[type + 'Codec_']) {\\n          return;\\n        }\\n\\n        // Do nothing if a SourceBuffer of this type already exists\\n        if (_this2[type + 'Buffer_']) {\\n          return;\\n        }\\n\\n        var buffer = null;\\n\\n        // If the mediasource already has a SourceBuffer for the codec\\n        // use that\\n        if (_this2.mediaSource_[type + 'Buffer_']) {\\n          buffer = _this2.mediaSource_[type + 'Buffer_'];\\n        } else {\\n          try {\\n            buffer = _this2.mediaSource_.nativeMediaSource_.addSourceBuffer(type + '/mp4;codecs=\\\"' + _this2[type + 'Codec_'] + '\\\"');\\n          } catch (e) {\\n            // XA The codec is not supported by the browser\\n            // Replace it by a default codec\\n            var defaultCodec = defaultCodecs[type];\\n            if (defaultCodec != undefined) {\\n              buffer = _this2.mediaSource_.nativeMediaSource_.addSourceBuffer(type + '/mp4;codecs=\\\"' + defaultCodec + '\\\"');\\n              console.log(\\\"Replace unsupported CODEC \\\" +_this2[type + 'Codec_'] +\\\" of type \\\"+ type + \\\" by default CODEC \\\" + defaultCodec);\\n            }\\n          }\\n          _this2.mediaSource_[type + 'Buffer_'] = buffer;\\n        }\\n\\n        _this2[type + 'Buffer_'] = buffer;\\n\\n        // Wire up the events to the SourceBuffer\\n        ['update', 'updatestart', 'updateend'].forEach(function (event) {\\n          buffer.addEventListener(event, function () {\\n            // if audio is disabled\\n            if (type === 'audio' && _this2.audioDisabled_) {\\n              return;\\n            }\\n\\n            var shouldTrigger = types.every(function (t) {\\n              // skip checking audio's updating status if audio\\n              // is not enabled\\n              if (t === 'audio' && _this2.audioDisabled_) {\\n                return true;\\n              }\\n              // if the other type if updating we don't trigger\\n              if (type !== t && _this2[t + 'Buffer_'] && _this2[t + 'Buffer_'].updating) {\\n                return false;\\n              }\\n              return true;\\n            });\\n\\n            if (shouldTrigger) {\\n              return _this2.trigger(event);\\n            }\\n          });\\n        });\\n      });\\n    }\\n\\n    /**\\n     * Emulate the native mediasource function, but our function will\\n     * send all of the proposed segments to the transmuxer so that we\\n     * can transmux them before we append them to our internal\\n     * native source buffers in the correct format.\\n     *\\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/appendBuffer\\n     * @param {Uint8Array} segment the segment to append to the buffer\\n     */\\n  }, {\\n    key: 'appendBuffer',\\n    value: function appendBuffer(segment) {\\n      // Start the internal \\\"updating\\\" state\\n      this.bufferUpdating_ = true;\\n\\n      this.transmuxer_.postMessage({\\n        action: 'push',\\n        // Send the typed-array of data as an ArrayBuffer so that\\n        // it can be sent as a \\\"Transferable\\\" and avoid the costly\\n        // memory copy\\n        data: segment.buffer,\\n\\n        // To recreate the original typed-array, we need information\\n        // about what portion of the ArrayBuffer it was a view into\\n        byteOffset: segment.byteOffset,\\n        byteLength: segment.byteLength\\n      }, [segment.buffer]);\\n      this.transmuxer_.postMessage({ action: 'flush' });\\n    }\\n\\n    /**\\n     * Emulate the native mediasource function and remove parts\\n     * of the buffer from any of our internal buffers that exist\\n     *\\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/remove\\n     * @param {Double} start position to start the remove at\\n     * @param {Double} end position to end the remove at\\n     */\\n  }, {\\n    key: 'remove',\\n    value: function remove(start, end) {\\n      if (this.videoBuffer_) {\\n        this.videoBuffer_.remove(start, end);\\n      }\\n      if (!this.audioDisabled_ && this.audioBuffer_) {\\n        this.audioBuffer_.remove(start, end);\\n      }\\n\\n      // Remove Metadata Cues (id3)\\n      (0, _removeCuesFromTrack2['default'])(start, end, this.metadataTrack_);\\n\\n      // Remove Any Captions\\n      (0, _removeCuesFromTrack2['default'])(start, end, this.inbandTextTrack_);\\n    }\\n\\n    /**\\n     * Process any segments that the muxer has output\\n     * Concatenate segments together based on type and append them into\\n     * their respective sourceBuffers\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'processPendingSegments_',\\n    value: function processPendingSegments_() {\\n      var sortedSegments = {\\n        video: {\\n          segments: [],\\n          bytes: 0\\n        },\\n        audio: {\\n          segments: [],\\n          bytes: 0\\n        },\\n        captions: [],\\n        metadata: []\\n      };\\n\\n      // Sort segments into separate video/audio arrays and\\n      // keep track of their total byte lengths\\n      sortedSegments = this.pendingBuffers_.reduce(function (segmentObj, segment) {\\n        var type = segment.type;\\n        var data = segment.data;\\n\\n        segmentObj[type].segments.push(data);\\n        segmentObj[type].bytes += data.byteLength;\\n\\n        // Gather any captions into a single array\\n        if (segment.captions) {\\n          segmentObj.captions = segmentObj.captions.concat(segment.captions);\\n        }\\n\\n        if (segment.info) {\\n          segmentObj[type].info = segment.info;\\n        }\\n\\n        // Gather any metadata into a single array\\n        if (segment.metadata) {\\n          segmentObj.metadata = segmentObj.metadata.concat(segment.metadata);\\n        }\\n\\n        return segmentObj;\\n      }, sortedSegments);\\n\\n      // Create the real source buffers if they don't exist by now since we\\n      // finally are sure what tracks are contained in the source\\n      if (!this.videoBuffer_ && !this.audioBuffer_) {\\n        // Remove any codecs that may have been specified by default but\\n        // are no longer applicable now\\n        if (sortedSegments.video.bytes === 0) {\\n          this.videoCodec_ = null;\\n        }\\n        if (sortedSegments.audio.bytes === 0) {\\n          this.audioCodec_ = null;\\n        }\\n\\n        this.createRealSourceBuffers_();\\n      }\\n\\n      if (sortedSegments.audio.info) {\\n        this.mediaSource_.trigger({ type: 'audioinfo', info: sortedSegments.audio.info });\\n      }\\n      if (sortedSegments.video.info) {\\n        this.mediaSource_.trigger({ type: 'videoinfo', info: sortedSegments.video.info });\\n      }\\n\\n      // Merge multiple video and audio segments into one and append\\n      if (this.videoBuffer_) {\\n        this.concatAndAppendSegments_(sortedSegments.video, this.videoBuffer_);\\n        // TODO: are video tracks the only ones with text tracks?\\n        (0, _addTextTrackData2['default'])(this, sortedSegments.captions, sortedSegments.metadata);\\n      }\\n      if (!this.audioDisabled_ && this.audioBuffer_) {\\n        this.concatAndAppendSegments_(sortedSegments.audio, this.audioBuffer_);\\n      }\\n\\n      this.pendingBuffers_.length = 0;\\n\\n      // We are no longer in the internal \\\"updating\\\" state\\n      this.bufferUpdating_ = false;\\n    }\\n\\n    /**\\n     * Combine all segments into a single Uint8Array and then append them\\n     * to the destination buffer\\n     *\\n     * @param {Object} segmentObj\\n     * @param {SourceBuffer} destinationBuffer native source buffer to append data to\\n     * @private\\n     */\\n  }, {\\n    key: 'concatAndAppendSegments_',\\n    value: function concatAndAppendSegments_(segmentObj, destinationBuffer) {\\n      var offset = 0;\\n      var tempBuffer = undefined;\\n\\n      if (segmentObj.bytes) {\\n        tempBuffer = new Uint8Array(segmentObj.bytes);\\n\\n        // Combine the individual segments into one large typed-array\\n        segmentObj.segments.forEach(function (segment) {\\n          tempBuffer.set(segment, offset);\\n          offset += segment.byteLength;\\n        });\\n\\n        destinationBuffer.appendBuffer(tempBuffer);\\n      }\\n    }\\n\\n    /**\\n     * Emulate the native mediasource function. abort any soureBuffer\\n     * actions and throw out any un-appended data.\\n     *\\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/abort\\n     */\\n  }, {\\n    key: 'abort',\\n    value: function abort() {\\n      if (this.videoBuffer_) {\\n        this.videoBuffer_.abort();\\n      }\\n      if (this.audioBuffer_) {\\n        this.audioBuffer_.abort();\\n      }\\n      if (this.transmuxer_) {\\n        this.transmuxer_.postMessage({ action: 'reset' });\\n      }\\n      this.pendingBuffers_.length = 0;\\n      this.bufferUpdating_ = false;\\n    }\\n  }]);\\n\\n  return VirtualSourceBuffer;\\n})(_videoJs2['default'].EventTarget);\\n\\nexports['default'] = VirtualSourceBuffer;\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./add-text-track-data\\\":68,\\\"./codec-utils\\\":69,\\\"./create-text-tracks-if-necessary\\\":70,\\\"./remove-cues-from-track\\\":75,\\\"./transmuxer-worker\\\":76,\\\"webworkify\\\":95}],79:[function(require,module,exports){\\n/**\\n * mux.js\\n *\\n * Copyright (c) 2016 Brightcove\\n * All rights reserved.\\n *\\n * A stream-based aac to mp4 converter. This utility can be used to\\n * deliver mp4s to a SourceBuffer on platforms that support native\\n * Media Source Extensions.\\n */\\n'use strict';\\nvar Stream = require('../utils/stream.js');\\n\\n// Constants\\nvar AacStream;\\n\\n/**\\n * Splits an incoming stream of binary data into ADTS and ID3 Frames.\\n */\\n\\nAacStream = function() {\\n  var\\n    everything = new Uint8Array(),\\n    timeStamp = 0;\\n\\n  AacStream.prototype.init.call(this);\\n\\n  this.setTimestamp = function(timestamp) {\\n    timeStamp = timestamp;\\n  };\\n\\n  this.parseId3TagSize = function(header, byteIndex) {\\n    var\\n      returnSize = (header[byteIndex + 6] << 21) |\\n                   (header[byteIndex + 7] << 14) |\\n                   (header[byteIndex + 8] << 7) |\\n                   (header[byteIndex + 9]),\\n      flags = header[byteIndex + 5],\\n      footerPresent = (flags & 16) >> 4;\\n\\n    if (footerPresent) {\\n      return returnSize + 20;\\n    }\\n    return returnSize + 10;\\n  };\\n\\n  this.parseAdtsSize = function(header, byteIndex) {\\n    var\\n      lowThree = (header[byteIndex + 5] & 0xE0) >> 5,\\n      middle = header[byteIndex + 4] << 3,\\n      highTwo = header[byteIndex + 3] & 0x3 << 11;\\n\\n    return (highTwo | middle) | lowThree;\\n  };\\n\\n  this.push = function(bytes) {\\n    var\\n      frameSize = 0,\\n      byteIndex = 0,\\n      bytesLeft,\\n      chunk,\\n      packet,\\n      tempLength;\\n\\n    // If there are bytes remaining from the last segment, prepend them to the\\n    // bytes that were pushed in\\n    if (everything.length) {\\n      tempLength = everything.length;\\n      everything = new Uint8Array(bytes.byteLength + tempLength);\\n      everything.set(everything.subarray(0, tempLength));\\n      everything.set(bytes, tempLength);\\n    } else {\\n      everything = bytes;\\n    }\\n\\n    while (everything.length - byteIndex >= 3) {\\n      if ((everything[byteIndex] === 'I'.charCodeAt(0)) &&\\n          (everything[byteIndex + 1] === 'D'.charCodeAt(0)) &&\\n          (everything[byteIndex + 2] === '3'.charCodeAt(0))) {\\n\\n        // Exit early because we don't have enough to parse\\n        // the ID3 tag header\\n        if (everything.length - byteIndex < 10) {\\n          break;\\n        }\\n\\n        // check framesize\\n        frameSize = this.parseId3TagSize(everything, byteIndex);\\n\\n        // Exit early if we don't have enough in the buffer\\n        // to emit a full packet\\n        if (frameSize > everything.length) {\\n          break;\\n        }\\n        chunk = {\\n          type: 'timed-metadata',\\n          data: everything.subarray(byteIndex, byteIndex + frameSize)\\n        };\\n        this.trigger('data', chunk);\\n        byteIndex += frameSize;\\n        continue;\\n      } else if ((everything[byteIndex] & 0xff === 0xff) &&\\n                 ((everything[byteIndex + 1] & 0xf0) === 0xf0)) {\\n\\n        // Exit early because we don't have enough to parse\\n        // the ADTS frame header\\n        if (everything.length - byteIndex < 7) {\\n          break;\\n        }\\n\\n        frameSize = this.parseAdtsSize(everything, byteIndex);\\n\\n        // Exit early if we don't have enough in the buffer\\n        // to emit a full packet\\n        if (frameSize > everything.length) {\\n          break;\\n        }\\n\\n        packet = {\\n          type: 'audio',\\n          data: everything.subarray(byteIndex, byteIndex + frameSize),\\n          pts: timeStamp,\\n          dts: timeStamp\\n        };\\n        this.trigger('data', packet);\\n        byteIndex += frameSize;\\n        continue;\\n      }\\n      byteIndex++;\\n    }\\n    bytesLeft = everything.length - byteIndex;\\n\\n    if (bytesLeft > 0) {\\n      everything = everything.subarray(byteIndex);\\n    } else {\\n      everything = new Uint8Array();\\n    }\\n  };\\n};\\n\\nAacStream.prototype = new Stream();\\n\\nmodule.exports = AacStream;\\n\\n},{\\\"../utils/stream.js\\\":94}],80:[function(require,module,exports){\\n'use strict';\\n\\nvar Stream = require('../utils/stream.js');\\n\\nvar AdtsStream;\\n\\nvar\\n  ADTS_SAMPLING_FREQUENCIES = [\\n    96000,\\n    88200,\\n    64000,\\n    48000,\\n    44100,\\n    32000,\\n    24000,\\n    22050,\\n    16000,\\n    12000,\\n    11025,\\n    8000,\\n    7350\\n  ];\\n\\n/*\\n * Accepts a ElementaryStream and emits data events with parsed\\n * AAC Audio Frames of the individual packets. Input audio in ADTS\\n * format is unpacked and re-emitted as AAC frames.\\n *\\n * @see http://wiki.multimedia.cx/index.php?title=ADTS\\n * @see http://wiki.multimedia.cx/?title=Understanding_AAC\\n */\\nAdtsStream = function() {\\n  var buffer;\\n\\n  AdtsStream.prototype.init.call(this);\\n\\n  this.push = function(packet) {\\n    var\\n      i = 0,\\n      frameNum = 0,\\n      frameLength,\\n      protectionSkipBytes,\\n      frameEnd,\\n      oldBuffer,\\n      sampleCount,\\n      adtsFrameDuration;\\n\\n    if (packet.type !== 'audio') {\\n      // ignore non-audio data\\n      return;\\n    }\\n\\n    // Prepend any data in the buffer to the input data so that we can parse\\n    // aac frames the cross a PES packet boundary\\n    if (buffer) {\\n      oldBuffer = buffer;\\n      buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);\\n      buffer.set(oldBuffer);\\n      buffer.set(packet.data, oldBuffer.byteLength);\\n    } else {\\n      buffer = packet.data;\\n    }\\n\\n    // unpack any ADTS frames which have been fully received\\n    // for details on the ADTS header, see http://wiki.multimedia.cx/index.php?title=ADTS\\n    while (i + 5 < buffer.length) {\\n\\n      // Loook for the start of an ADTS header..\\n      if (buffer[i] !== 0xFF || (buffer[i + 1] & 0xF6) !== 0xF0) {\\n        // If a valid header was not found,  jump one forward and attempt to\\n        // find a valid ADTS header starting at the next byte\\n        i++;\\n        continue;\\n      }\\n\\n      // The protection skip bit tells us if we have 2 bytes of CRC data at the\\n      // end of the ADTS header\\n      protectionSkipBytes = (~buffer[i + 1] & 0x01) * 2;\\n\\n      // Frame length is a 13 bit integer starting 16 bits from the\\n      // end of the sync sequence\\n      frameLength = ((buffer[i + 3] & 0x03) << 11) |\\n        (buffer[i + 4] << 3) |\\n        ((buffer[i + 5] & 0xe0) >> 5);\\n\\n      sampleCount = ((buffer[i + 6] & 0x03) + 1) * 1024;\\n      adtsFrameDuration = (sampleCount * 90000) /\\n        ADTS_SAMPLING_FREQUENCIES[(buffer[i + 2] & 0x3c) >>> 2];\\n\\n      frameEnd = i + frameLength;\\n\\n      // If we don't have enough data to actually finish this ADTS frame, return\\n      // and wait for more data\\n      if (buffer.byteLength < frameEnd) {\\n        return;\\n      }\\n\\n      // Otherwise, deliver the complete AAC frame\\n      this.trigger('data', {\\n        pts: packet.pts + (frameNum * adtsFrameDuration),\\n        dts: packet.dts + (frameNum * adtsFrameDuration),\\n        sampleCount: sampleCount,\\n        audioobjecttype: ((buffer[i + 2] >>> 6) & 0x03) + 1,\\n        channelcount: ((buffer[i + 2] & 1) << 2) |\\n          ((buffer[i + 3] & 0xc0) >>> 6),\\n        samplerate: ADTS_SAMPLING_FREQUENCIES[(buffer[i + 2] & 0x3c) >>> 2],\\n        samplingfrequencyindex: (buffer[i + 2] & 0x3c) >>> 2,\\n        // assume ISO/IEC 14496-12 AudioSampleEntry default of 16\\n        samplesize: 16,\\n        data: buffer.subarray(i + 7 + protectionSkipBytes, frameEnd)\\n      });\\n\\n      // If the buffer is empty, clear it and return\\n      if (buffer.byteLength === frameEnd) {\\n        buffer = undefined;\\n        return;\\n      }\\n\\n      frameNum++;\\n\\n      // Remove the finished frame from the buffer and start the process again\\n      buffer = buffer.subarray(frameEnd);\\n    }\\n  };\\n  this.flush = function() {\\n    this.trigger('done');\\n  };\\n};\\n\\nAdtsStream.prototype = new Stream();\\n\\nmodule.exports = AdtsStream;\\n\\n},{\\\"../utils/stream.js\\\":94}],81:[function(require,module,exports){\\n'use strict';\\n\\nvar Stream = require('../utils/stream.js');\\nvar ExpGolomb = require('../utils/exp-golomb.js');\\n\\nvar H264Stream, NalByteStream;\\nvar PROFILES_WITH_OPTIONAL_SPS_DATA;\\n\\n/**\\n * Accepts a NAL unit byte stream and unpacks the embedded NAL units.\\n */\\nNalByteStream = function() {\\n  var\\n    syncPoint = 0,\\n    i,\\n    buffer;\\n  NalByteStream.prototype.init.call(this);\\n\\n  this.push = function(data) {\\n    var swapBuffer;\\n\\n    if (!buffer) {\\n      buffer = data.data;\\n    } else {\\n      swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);\\n      swapBuffer.set(buffer);\\n      swapBuffer.set(data.data, buffer.byteLength);\\n      buffer = swapBuffer;\\n    }\\n\\n    // Rec. ITU-T H.264, Annex B\\n    // scan for NAL unit boundaries\\n\\n    // a match looks like this:\\n    // 0 0 1 .. NAL .. 0 0 1\\n    // ^ sync point        ^ i\\n    // or this:\\n    // 0 0 1 .. NAL .. 0 0 0\\n    // ^ sync point        ^ i\\n\\n    // advance the sync point to a NAL start, if necessary\\n    for (; syncPoint < buffer.byteLength - 3; syncPoint++) {\\n      if (buffer[syncPoint + 2] === 1) {\\n        // the sync point is properly aligned\\n        i = syncPoint + 5;\\n        break;\\n      }\\n    }\\n\\n    while (i < buffer.byteLength) {\\n      // look at the current byte to determine if we've hit the end of\\n      // a NAL unit boundary\\n      switch (buffer[i]) {\\n      case 0:\\n        // skip past non-sync sequences\\n        if (buffer[i - 1] !== 0) {\\n          i += 2;\\n          break;\\n        } else if (buffer[i - 2] !== 0) {\\n          i++;\\n          break;\\n        }\\n\\n        // deliver the NAL unit if it isn't empty\\n        if (syncPoint + 3 !== i - 2) {\\n          this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\\n        }\\n\\n        // drop trailing zeroes\\n        do {\\n          i++;\\n        } while (buffer[i] !== 1 && i < buffer.length);\\n        syncPoint = i - 2;\\n        i += 3;\\n        break;\\n      case 1:\\n        // skip past non-sync sequences\\n        if (buffer[i - 1] !== 0 ||\\n            buffer[i - 2] !== 0) {\\n          i += 3;\\n          break;\\n        }\\n\\n        // deliver the NAL unit\\n        this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\\n        syncPoint = i - 2;\\n        i += 3;\\n        break;\\n      default:\\n        // the current byte isn't a one or zero, so it cannot be part\\n        // of a sync sequence\\n        i += 3;\\n        break;\\n      }\\n    }\\n    // filter out the NAL units that were delivered\\n    buffer = buffer.subarray(syncPoint);\\n    i -= syncPoint;\\n    syncPoint = 0;\\n  };\\n\\n  this.flush = function() {\\n    // deliver the last buffered NAL unit\\n    if (buffer && buffer.byteLength > 3) {\\n      this.trigger('data', buffer.subarray(syncPoint + 3));\\n    }\\n    // reset the stream state\\n    buffer = null;\\n    syncPoint = 0;\\n    this.trigger('done');\\n  };\\n};\\nNalByteStream.prototype = new Stream();\\n\\n// values of profile_idc that indicate additional fields are included in the SPS\\n// see Recommendation ITU-T H.264 (4/2013),\\n// 7.3.2.1.1 Sequence parameter set data syntax\\nPROFILES_WITH_OPTIONAL_SPS_DATA = {\\n  100: true,\\n  110: true,\\n  122: true,\\n  244: true,\\n  44: true,\\n  83: true,\\n  86: true,\\n  118: true,\\n  128: true,\\n  138: true,\\n  139: true,\\n  134: true\\n};\\n\\n/**\\n * Accepts input from a ElementaryStream and produces H.264 NAL unit data\\n * events.\\n */\\nH264Stream = function() {\\n  var\\n    nalByteStream = new NalByteStream(),\\n    self,\\n    trackId,\\n    currentPts,\\n    currentDts,\\n\\n    discardEmulationPreventionBytes,\\n    readSequenceParameterSet,\\n    skipScalingList;\\n\\n  H264Stream.prototype.init.call(this);\\n  self = this;\\n\\n  this.push = function(packet) {\\n    if (packet.type !== 'video') {\\n      return;\\n    }\\n    trackId = packet.trackId;\\n    currentPts = packet.pts;\\n    currentDts = packet.dts;\\n\\n    nalByteStream.push(packet);\\n  };\\n\\n  nalByteStream.on('data', function(data) {\\n    var\\n      event = {\\n        trackId: trackId,\\n        pts: currentPts,\\n        dts: currentDts,\\n        data: data\\n      };\\n\\n    switch (data[0] & 0x1f) {\\n    case 0x05:\\n      event.nalUnitType = 'slice_layer_without_partitioning_rbsp_idr';\\n      break;\\n    case 0x06:\\n      event.nalUnitType = 'sei_rbsp';\\n      event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\\n      break;\\n    case 0x07:\\n      event.nalUnitType = 'seq_parameter_set_rbsp';\\n      event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\\n      event.config = readSequenceParameterSet(event.escapedRBSP);\\n      break;\\n    case 0x08:\\n      event.nalUnitType = 'pic_parameter_set_rbsp';\\n      break;\\n    case 0x09:\\n      event.nalUnitType = 'access_unit_delimiter_rbsp';\\n      break;\\n\\n    default:\\n      break;\\n    }\\n    self.trigger('data', event);\\n  });\\n  nalByteStream.on('done', function() {\\n    self.trigger('done');\\n  });\\n\\n  this.flush = function() {\\n    nalByteStream.flush();\\n  };\\n\\n  /**\\n   * Advance the ExpGolomb decoder past a scaling list. The scaling\\n   * list is optionally transmitted as part of a sequence parameter\\n   * set and is not relevant to transmuxing.\\n   * @param count {number} the number of entries in this scaling list\\n   * @param expGolombDecoder {object} an ExpGolomb pointed to the\\n   * start of a scaling list\\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\\n   */\\n  skipScalingList = function(count, expGolombDecoder) {\\n    var\\n      lastScale = 8,\\n      nextScale = 8,\\n      j,\\n      deltaScale;\\n\\n    for (j = 0; j < count; j++) {\\n      if (nextScale !== 0) {\\n        deltaScale = expGolombDecoder.readExpGolomb();\\n        nextScale = (lastScale + deltaScale + 256) % 256;\\n      }\\n\\n      lastScale = (nextScale === 0) ? lastScale : nextScale;\\n    }\\n  };\\n\\n  /**\\n   * Expunge any \\\"Emulation Prevention\\\" bytes from a \\\"Raw Byte\\n   * Sequence Payload\\\"\\n   * @param data {Uint8Array} the bytes of a RBSP from a NAL\\n   * unit\\n   * @return {Uint8Array} the RBSP without any Emulation\\n   * Prevention Bytes\\n   */\\n  discardEmulationPreventionBytes = function(data) {\\n    var\\n      length = data.byteLength,\\n      emulationPreventionBytesPositions = [],\\n      i = 1,\\n      newLength, newData;\\n\\n    // Find all `Emulation Prevention Bytes`\\n    while (i < length - 2) {\\n      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\\n        emulationPreventionBytesPositions.push(i + 2);\\n        i += 2;\\n      } else {\\n        i++;\\n      }\\n    }\\n\\n    // If no Emulation Prevention Bytes were found just return the original\\n    // array\\n    if (emulationPreventionBytesPositions.length === 0) {\\n      return data;\\n    }\\n\\n    // Create a new array to hold the NAL unit data\\n    newLength = length - emulationPreventionBytesPositions.length;\\n    newData = new Uint8Array(newLength);\\n    var sourceIndex = 0;\\n\\n    for (i = 0; i < newLength; sourceIndex++, i++) {\\n      if (sourceIndex === emulationPreventionBytesPositions[0]) {\\n        // Skip this byte\\n        sourceIndex++;\\n        // Remove this position index\\n        emulationPreventionBytesPositions.shift();\\n      }\\n      newData[i] = data[sourceIndex];\\n    }\\n\\n    return newData;\\n  };\\n\\n  /**\\n   * Read a sequence parameter set and return some interesting video\\n   * properties. A sequence parameter set is the H264 metadata that\\n   * describes the properties of upcoming video frames.\\n   * @param data {Uint8Array} the bytes of a sequence parameter set\\n   * @return {object} an object with configuration parsed from the\\n   * sequence parameter set, including the dimensions of the\\n   * associated video frames.\\n   */\\n  readSequenceParameterSet = function(data) {\\n    var\\n      frameCropLeftOffset = 0,\\n      frameCropRightOffset = 0,\\n      frameCropTopOffset = 0,\\n      frameCropBottomOffset = 0,\\n      sarScale = 1,\\n      expGolombDecoder, profileIdc, levelIdc, profileCompatibility,\\n      chromaFormatIdc, picOrderCntType,\\n      numRefFramesInPicOrderCntCycle, picWidthInMbsMinus1,\\n      picHeightInMapUnitsMinus1,\\n      frameMbsOnlyFlag,\\n      scalingListCount,\\n      sarRatio,\\n      aspectRatioIdc,\\n      i;\\n\\n    expGolombDecoder = new ExpGolomb(data);\\n    profileIdc = expGolombDecoder.readUnsignedByte(); // profile_idc\\n    profileCompatibility = expGolombDecoder.readUnsignedByte(); // constraint_set[0-5]_flag\\n    levelIdc = expGolombDecoder.readUnsignedByte(); // level_idc u(8)\\n    expGolombDecoder.skipUnsignedExpGolomb(); // seq_parameter_set_id\\n\\n    // some profiles have more optional data we don't need\\n    if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {\\n      chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();\\n      if (chromaFormatIdc === 3) {\\n        expGolombDecoder.skipBits(1); // separate_colour_plane_flag\\n      }\\n      expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_luma_minus8\\n      expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_chroma_minus8\\n      expGolombDecoder.skipBits(1); // qpprime_y_zero_transform_bypass_flag\\n      if (expGolombDecoder.readBoolean()) { // seq_scaling_matrix_present_flag\\n        scalingListCount = (chromaFormatIdc !== 3) ? 8 : 12;\\n        for (i = 0; i < scalingListCount; i++) {\\n          if (expGolombDecoder.readBoolean()) { // seq_scaling_list_present_flag[ i ]\\n            if (i < 6) {\\n              skipScalingList(16, expGolombDecoder);\\n            } else {\\n              skipScalingList(64, expGolombDecoder);\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    expGolombDecoder.skipUnsignedExpGolomb(); // log2_max_frame_num_minus4\\n    picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();\\n\\n    if (picOrderCntType === 0) {\\n      expGolombDecoder.readUnsignedExpGolomb(); // log2_max_pic_order_cnt_lsb_minus4\\n    } else if (picOrderCntType === 1) {\\n      expGolombDecoder.skipBits(1); // delta_pic_order_always_zero_flag\\n      expGolombDecoder.skipExpGolomb(); // offset_for_non_ref_pic\\n      expGolombDecoder.skipExpGolomb(); // offset_for_top_to_bottom_field\\n      numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();\\n      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\\n        expGolombDecoder.skipExpGolomb(); // offset_for_ref_frame[ i ]\\n      }\\n    }\\n\\n    expGolombDecoder.skipUnsignedExpGolomb(); // max_num_ref_frames\\n    expGolombDecoder.skipBits(1); // gaps_in_frame_num_value_allowed_flag\\n\\n    picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\\n    picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\\n\\n    frameMbsOnlyFlag = expGolombDecoder.readBits(1);\\n    if (frameMbsOnlyFlag === 0) {\\n      expGolombDecoder.skipBits(1); // mb_adaptive_frame_field_flag\\n    }\\n\\n    expGolombDecoder.skipBits(1); // direct_8x8_inference_flag\\n    if (expGolombDecoder.readBoolean()) { // frame_cropping_flag\\n      frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();\\n      frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();\\n      frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();\\n      frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();\\n    }\\n    if (expGolombDecoder.readBoolean()) {\\n      // vui_parameters_present_flag\\n      if (expGolombDecoder.readBoolean()) {\\n        // aspect_ratio_info_present_flag\\n        aspectRatioIdc = expGolombDecoder.readUnsignedByte();\\n        switch (aspectRatioIdc) {\\n          case 1: sarRatio = [1, 1]; break;\\n          case 2: sarRatio = [12, 11]; break;\\n          case 3: sarRatio = [10, 11]; break;\\n          case 4: sarRatio = [16, 11]; break;\\n          case 5: sarRatio = [40, 33]; break;\\n          case 6: sarRatio = [24, 11]; break;\\n          case 7: sarRatio = [20, 11]; break;\\n          case 8: sarRatio = [32, 11]; break;\\n          case 9: sarRatio = [80, 33]; break;\\n          case 10: sarRatio = [18, 11]; break;\\n          case 11: sarRatio = [15, 11]; break;\\n          case 12: sarRatio = [64, 33]; break;\\n          case 13: sarRatio = [160, 99]; break;\\n          case 14: sarRatio = [4, 3]; break;\\n          case 15: sarRatio = [3, 2]; break;\\n          case 16: sarRatio = [2, 1]; break;\\n          case 255: {\\n            sarRatio = [expGolombDecoder.readUnsignedByte() << 8 |\\n                        expGolombDecoder.readUnsignedByte(),\\n                        expGolombDecoder.readUnsignedByte() << 8 |\\n                        expGolombDecoder.readUnsignedByte() ];\\n            break;\\n          }\\n        }\\n        if (sarRatio) {\\n          sarScale = sarRatio[0] / sarRatio[1];\\n        }\\n      }\\n    }\\n    return {\\n      profileIdc: profileIdc,\\n      levelIdc: levelIdc,\\n      profileCompatibility: profileCompatibility,\\n      width: Math.ceil((((picWidthInMbsMinus1 + 1) * 16) - frameCropLeftOffset * 2 - frameCropRightOffset * 2) * sarScale),\\n      height: ((2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16) - (frameCropTopOffset * 2) - (frameCropBottomOffset * 2)\\n    };\\n  };\\n\\n};\\nH264Stream.prototype = new Stream();\\n\\nmodule.exports = {\\n  H264Stream: H264Stream,\\n  NalByteStream: NalByteStream\\n};\\n\\n},{\\\"../utils/exp-golomb.js\\\":93,\\\"../utils/stream.js\\\":94}],82:[function(require,module,exports){\\n/**\\n * An object that stores the bytes of an FLV tag and methods for\\n * querying and manipulating that data.\\n * @see http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf\\n */\\n'use strict';\\n\\nvar FlvTag;\\n\\n// (type:uint, extraData:Boolean = false) extends ByteArray\\nFlvTag = function(type, extraData) {\\n  var\\n    // Counter if this is a metadata tag, nal start marker if this is a video\\n    // tag. unused if this is an audio tag\\n    adHoc = 0, // :uint\\n\\n    // The default size is 16kb but this is not enough to hold iframe\\n    // data and the resizing algorithm costs a bit so we create a larger\\n    // starting buffer for video tags\\n    bufferStartSize = 16384,\\n\\n    // checks whether the FLV tag has enough capacity to accept the proposed\\n    // write and re-allocates the internal buffers if necessary\\n    prepareWrite = function(flv, count) {\\n      var\\n        bytes,\\n        minLength = flv.position + count;\\n      if (minLength < flv.bytes.byteLength) {\\n        // there's enough capacity so do nothing\\n        return;\\n      }\\n\\n      // allocate a new buffer and copy over the data that will not be modified\\n      bytes = new Uint8Array(minLength * 2);\\n      bytes.set(flv.bytes.subarray(0, flv.position), 0);\\n      flv.bytes = bytes;\\n      flv.view = new DataView(flv.bytes.buffer);\\n    },\\n\\n    // commonly used metadata properties\\n    widthBytes = FlvTag.widthBytes || new Uint8Array('width'.length),\\n    heightBytes = FlvTag.heightBytes || new Uint8Array('height'.length),\\n    videocodecidBytes = FlvTag.videocodecidBytes || new Uint8Array('videocodecid'.length),\\n    i;\\n\\n  if (!FlvTag.widthBytes) {\\n    // calculating the bytes of common metadata names ahead of time makes the\\n    // corresponding writes faster because we don't have to loop over the\\n    // characters\\n    // re-test with test/perf.html if you're planning on changing this\\n    for (i = 0; i < 'width'.length; i++) {\\n      widthBytes[i] = 'width'.charCodeAt(i);\\n    }\\n    for (i = 0; i < 'height'.length; i++) {\\n      heightBytes[i] = 'height'.charCodeAt(i);\\n    }\\n    for (i = 0; i < 'videocodecid'.length; i++) {\\n      videocodecidBytes[i] = 'videocodecid'.charCodeAt(i);\\n    }\\n\\n    FlvTag.widthBytes = widthBytes;\\n    FlvTag.heightBytes = heightBytes;\\n    FlvTag.videocodecidBytes = videocodecidBytes;\\n  }\\n\\n  this.keyFrame = false; // :Boolean\\n\\n  switch (type) {\\n  case FlvTag.VIDEO_TAG:\\n    this.length = 16;\\n    // Start the buffer at 256k\\n    bufferStartSize *= 6;\\n    break;\\n  case FlvTag.AUDIO_TAG:\\n    this.length = 13;\\n    this.keyFrame = true;\\n    break;\\n  case FlvTag.METADATA_TAG:\\n    this.length = 29;\\n    this.keyFrame = true;\\n    break;\\n  default:\\n    throw new Error('Unknown FLV tag type');\\n  }\\n\\n  this.bytes = new Uint8Array(bufferStartSize);\\n  this.view = new DataView(this.bytes.buffer);\\n  this.bytes[0] = type;\\n  this.position = this.length;\\n  this.keyFrame = extraData; // Defaults to false\\n\\n  // presentation timestamp\\n  this.pts = 0;\\n  // decoder timestamp\\n  this.dts = 0;\\n\\n  // ByteArray#writeBytes(bytes:ByteArray, offset:uint = 0, length:uint = 0)\\n  this.writeBytes = function(bytes, offset, length) {\\n    var\\n      start = offset || 0,\\n      end;\\n    length = length || bytes.byteLength;\\n    end = start + length;\\n\\n    prepareWrite(this, length);\\n    this.bytes.set(bytes.subarray(start, end), this.position);\\n\\n    this.position += length;\\n    this.length = Math.max(this.length, this.position);\\n  };\\n\\n  // ByteArray#writeByte(value:int):void\\n  this.writeByte = function(byte) {\\n    prepareWrite(this, 1);\\n    this.bytes[this.position] = byte;\\n    this.position++;\\n    this.length = Math.max(this.length, this.position);\\n  };\\n\\n  // ByteArray#writeShort(value:int):void\\n  this.writeShort = function(short) {\\n    prepareWrite(this, 2);\\n    this.view.setUint16(this.position, short);\\n    this.position += 2;\\n    this.length = Math.max(this.length, this.position);\\n  };\\n\\n  // Negative index into array\\n  // (pos:uint):int\\n  this.negIndex = function(pos) {\\n    return this.bytes[this.length - pos];\\n  };\\n\\n  // The functions below ONLY work when this[0] == VIDEO_TAG.\\n  // We are not going to check for that because we dont want the overhead\\n  // (nal:ByteArray = null):int\\n  this.nalUnitSize = function() {\\n    if (adHoc === 0) {\\n      return 0;\\n    }\\n\\n    return this.length - (adHoc + 4);\\n  };\\n\\n  this.startNalUnit = function() {\\n    // remember position and add 4 bytes\\n    if (adHoc > 0) {\\n      throw new Error('Attempted to create new NAL wihout closing the old one');\\n    }\\n\\n    // reserve 4 bytes for nal unit size\\n    adHoc = this.length;\\n    this.length += 4;\\n    this.position = this.length;\\n  };\\n\\n  // (nal:ByteArray = null):void\\n  this.endNalUnit = function(nalContainer) {\\n    var\\n      nalStart, // :uint\\n      nalLength; // :uint\\n\\n    // Rewind to the marker and write the size\\n    if (this.length === adHoc + 4) {\\n      // we started a nal unit, but didnt write one, so roll back the 4 byte size value\\n      this.length -= 4;\\n    } else if (adHoc > 0) {\\n      nalStart = adHoc + 4;\\n      nalLength = this.length - nalStart;\\n\\n      this.position = adHoc;\\n      this.view.setUint32(this.position, nalLength);\\n      this.position = this.length;\\n\\n      if (nalContainer) {\\n        // Add the tag to the NAL unit\\n        nalContainer.push(this.bytes.subarray(nalStart, nalStart + nalLength));\\n      }\\n    }\\n\\n    adHoc = 0;\\n  };\\n\\n  /**\\n   * Write out a 64-bit floating point valued metadata property. This method is\\n   * called frequently during a typical parse and needs to be fast.\\n   */\\n  // (key:String, val:Number):void\\n  this.writeMetaDataDouble = function(key, val) {\\n    var i;\\n    prepareWrite(this, 2 + key.length + 9);\\n\\n    // write size of property name\\n    this.view.setUint16(this.position, key.length);\\n    this.position += 2;\\n\\n    // this next part looks terrible but it improves parser throughput by\\n    // 10kB/s in my testing\\n\\n    // write property name\\n    if (key === 'width') {\\n      this.bytes.set(widthBytes, this.position);\\n      this.position += 5;\\n    } else if (key === 'height') {\\n      this.bytes.set(heightBytes, this.position);\\n      this.position += 6;\\n    } else if (key === 'videocodecid') {\\n      this.bytes.set(videocodecidBytes, this.position);\\n      this.position += 12;\\n    } else {\\n      for (i = 0; i < key.length; i++) {\\n        this.bytes[this.position] = key.charCodeAt(i);\\n        this.position++;\\n      }\\n    }\\n\\n    // skip null byte\\n    this.position++;\\n\\n    // write property value\\n    this.view.setFloat64(this.position, val);\\n    this.position += 8;\\n\\n    // update flv tag length\\n    this.length = Math.max(this.length, this.position);\\n    ++adHoc;\\n  };\\n\\n  // (key:String, val:Boolean):void\\n  this.writeMetaDataBoolean = function(key, val) {\\n    var i;\\n    prepareWrite(this, 2);\\n    this.view.setUint16(this.position, key.length);\\n    this.position += 2;\\n    for (i = 0; i < key.length; i++) {\\n      // if key.charCodeAt(i) >= 255, handle error\\n      prepareWrite(this, 1);\\n      this.bytes[this.position] = key.charCodeAt(i);\\n      this.position++;\\n    }\\n    prepareWrite(this, 2);\\n    this.view.setUint8(this.position, 0x01);\\n    this.position++;\\n    this.view.setUint8(this.position, val ? 0x01 : 0x00);\\n    this.position++;\\n    this.length = Math.max(this.length, this.position);\\n    ++adHoc;\\n  };\\n\\n  // ():ByteArray\\n  this.finalize = function() {\\n    var\\n      dtsDelta, // :int\\n      len; // :int\\n\\n    switch (this.bytes[0]) {\\n      // Video Data\\n    case FlvTag.VIDEO_TAG:\\n       // We only support AVC, 1 = key frame (for AVC, a seekable\\n       // frame), 2 = inter frame (for AVC, a non-seekable frame)\\n      this.bytes[11] = ((this.keyFrame || extraData) ? 0x10 : 0x20) | 0x07;\\n      this.bytes[12] = extraData ?  0x00 : 0x01;\\n\\n      dtsDelta = this.pts - this.dts;\\n      this.bytes[13] = (dtsDelta & 0x00FF0000) >>> 16;\\n      this.bytes[14] = (dtsDelta & 0x0000FF00) >>>  8;\\n      this.bytes[15] = (dtsDelta & 0x000000FF) >>>  0;\\n      break;\\n\\n    case FlvTag.AUDIO_TAG:\\n      this.bytes[11] = 0xAF; // 44 kHz, 16-bit stereo\\n      this.bytes[12] = extraData ? 0x00 : 0x01;\\n      break;\\n\\n    case FlvTag.METADATA_TAG:\\n      this.position = 11;\\n      this.view.setUint8(this.position, 0x02); // String type\\n      this.position++;\\n      this.view.setUint16(this.position, 0x0A); // 10 Bytes\\n      this.position += 2;\\n      // set \\\"onMetaData\\\"\\n      this.bytes.set([0x6f, 0x6e, 0x4d, 0x65,\\n                      0x74, 0x61, 0x44, 0x61,\\n                      0x74, 0x61], this.position);\\n      this.position += 10;\\n      this.bytes[this.position] = 0x08; // Array type\\n      this.position++;\\n      this.view.setUint32(this.position, adHoc);\\n      this.position = this.length;\\n      this.bytes.set([0, 0, 9], this.position);\\n      this.position += 3; // End Data Tag\\n      this.length = this.position;\\n      break;\\n    }\\n\\n    len = this.length - 11;\\n\\n    // write the DataSize field\\n    this.bytes[ 1] = (len & 0x00FF0000) >>> 16;\\n    this.bytes[ 2] = (len & 0x0000FF00) >>>  8;\\n    this.bytes[ 3] = (len & 0x000000FF) >>>  0;\\n    // write the Timestamp\\n    this.bytes[ 4] = (this.dts & 0x00FF0000) >>> 16;\\n    this.bytes[ 5] = (this.dts & 0x0000FF00) >>>  8;\\n    this.bytes[ 6] = (this.dts & 0x000000FF) >>>  0;\\n    this.bytes[ 7] = (this.dts & 0xFF000000) >>> 24;\\n    // write the StreamID\\n    this.bytes[ 8] = 0;\\n    this.bytes[ 9] = 0;\\n    this.bytes[10] = 0;\\n\\n    // Sometimes we're at the end of the view and have one slot to write a\\n    // uint32, so, prepareWrite of count 4, since, view is uint8\\n    prepareWrite(this, 4);\\n    this.view.setUint32(this.length, this.length);\\n    this.length += 4;\\n    this.position += 4;\\n\\n    // trim down the byte buffer to what is actually being used\\n    this.bytes = this.bytes.subarray(0, this.length);\\n    this.frameTime = FlvTag.frameTime(this.bytes);\\n    // if bytes.bytelength isn't equal to this.length, handle error\\n    return this;\\n  };\\n};\\n\\nFlvTag.AUDIO_TAG = 0x08; // == 8, :uint\\nFlvTag.VIDEO_TAG = 0x09; // == 9, :uint\\nFlvTag.METADATA_TAG = 0x12; // == 18, :uint\\n\\n// (tag:ByteArray):Boolean {\\nFlvTag.isAudioFrame = function(tag) {\\n  return FlvTag.AUDIO_TAG === tag[0];\\n};\\n\\n// (tag:ByteArray):Boolean {\\nFlvTag.isVideoFrame = function(tag) {\\n  return FlvTag.VIDEO_TAG === tag[0];\\n};\\n\\n// (tag:ByteArray):Boolean {\\nFlvTag.isMetaData = function(tag) {\\n  return FlvTag.METADATA_TAG === tag[0];\\n};\\n\\n// (tag:ByteArray):Boolean {\\nFlvTag.isKeyFrame = function(tag) {\\n  if (FlvTag.isVideoFrame(tag)) {\\n    return tag[11] === 0x17;\\n  }\\n\\n  if (FlvTag.isAudioFrame(tag)) {\\n    return true;\\n  }\\n\\n  if (FlvTag.isMetaData(tag)) {\\n    return true;\\n  }\\n\\n  return false;\\n};\\n\\n// (tag:ByteArray):uint {\\nFlvTag.frameTime = function(tag) {\\n  var pts = tag[ 4] << 16; // :uint\\n  pts |= tag[ 5] <<  8;\\n  pts |= tag[ 6] <<  0;\\n  pts |= tag[ 7] << 24;\\n  return pts;\\n};\\n\\nmodule.exports = FlvTag;\\n\\n},{}],83:[function(require,module,exports){\\nmodule.exports = {\\n  tag: require('./flv-tag'),\\n  Transmuxer: require('./transmuxer')\\n};\\n\\n},{\\\"./flv-tag\\\":82,\\\"./transmuxer\\\":84}],84:[function(require,module,exports){\\n'use strict';\\n\\nvar Stream = require('../utils/stream.js');\\nvar FlvTag = require('./flv-tag.js');\\nvar m2ts = require('../m2ts/m2ts.js');\\nvar AdtsStream = require('../codecs/adts.js');\\nvar H264Stream = require('../codecs/h264').H264Stream;\\n\\nvar\\n  Transmuxer,\\n  VideoSegmentStream,\\n  AudioSegmentStream,\\n  CoalesceStream,\\n  collectTimelineInfo,\\n  metaDataTag,\\n  extraDataTag;\\n\\n/**\\n * Store information about the start and end of the tracka and the\\n * duration for each frame/sample we process in order to calculate\\n * the baseMediaDecodeTime\\n */\\ncollectTimelineInfo = function(track, data) {\\n  if (typeof data.pts === 'number') {\\n    if (track.timelineStartInfo.pts === undefined) {\\n      track.timelineStartInfo.pts = data.pts;\\n    } else {\\n      track.timelineStartInfo.pts =\\n        Math.min(track.timelineStartInfo.pts, data.pts);\\n    }\\n  }\\n\\n  if (typeof data.dts === 'number') {\\n    if (track.timelineStartInfo.dts === undefined) {\\n      track.timelineStartInfo.dts = data.dts;\\n    } else {\\n      track.timelineStartInfo.dts =\\n        Math.min(track.timelineStartInfo.dts, data.dts);\\n    }\\n  }\\n};\\n\\nmetaDataTag = function(track, pts) {\\n  var\\n    tag = new FlvTag(FlvTag.METADATA_TAG); // :FlvTag\\n\\n  tag.dts = pts;\\n  tag.pts = pts;\\n\\n  tag.writeMetaDataDouble('videocodecid', 7);\\n  tag.writeMetaDataDouble('width', track.width);\\n  tag.writeMetaDataDouble('height', track.height);\\n\\n  return tag;\\n};\\n\\nextraDataTag = function(track, pts) {\\n  var\\n    i,\\n    tag = new FlvTag(FlvTag.VIDEO_TAG, true);\\n\\n  tag.dts = pts;\\n  tag.pts = pts;\\n\\n  tag.writeByte(0x01);// version\\n  tag.writeByte(track.profileIdc);// profile\\n  tag.writeByte(track.profileCompatibility);// compatibility\\n  tag.writeByte(track.levelIdc);// level\\n  tag.writeByte(0xFC | 0x03); // reserved (6 bits), NULA length size - 1 (2 bits)\\n  tag.writeByte(0xE0 | 0x01); // reserved (3 bits), num of SPS (5 bits)\\n  tag.writeShort(track.sps[0].length); // data of SPS\\n  tag.writeBytes(track.sps[0]); // SPS\\n\\n  tag.writeByte(track.pps.length); // num of PPS (will there ever be more that 1 PPS?)\\n  for (i = 0; i < track.pps.length; ++i) {\\n    tag.writeShort(track.pps[i].length); // 2 bytes for length of PPS\\n    tag.writeBytes(track.pps[i]); // data of PPS\\n  }\\n\\n  return tag;\\n};\\n\\n/**\\n * Constructs a single-track, media segment from AAC data\\n * events. The output of this stream can be fed to flash.\\n */\\nAudioSegmentStream = function(track) {\\n  var\\n    adtsFrames = [],\\n    oldExtraData;\\n\\n  AudioSegmentStream.prototype.init.call(this);\\n\\n  this.push = function(data) {\\n    collectTimelineInfo(track, data);\\n\\n    if (track && track.channelcount === undefined) {\\n      track.audioobjecttype = data.audioobjecttype;\\n      track.channelcount = data.channelcount;\\n      track.samplerate = data.samplerate;\\n      track.samplingfrequencyindex = data.samplingfrequencyindex;\\n      track.samplesize = data.samplesize;\\n      track.extraData = (track.audioobjecttype << 11) |\\n                        (track.samplingfrequencyindex << 7) |\\n                        (track.channelcount << 3);\\n    }\\n\\n    data.pts = Math.round(data.pts / 90);\\n    data.dts = Math.round(data.dts / 90);\\n\\n    // buffer audio data until end() is called\\n    adtsFrames.push(data);\\n  };\\n\\n  this.flush = function() {\\n    var currentFrame, adtsFrame, lastMetaPts, tags = [];\\n    // return early if no audio data has been observed\\n    if (adtsFrames.length === 0) {\\n      this.trigger('done');\\n      return;\\n    }\\n\\n    lastMetaPts = -Infinity;\\n\\n    while (adtsFrames.length) {\\n      currentFrame = adtsFrames.shift();\\n\\n      // write out metadata tags every 1 second so that the decoder\\n      // is re-initialized quickly after seeking into a different\\n      // audio configuration\\n      if (track.extraData !== oldExtraData || currentFrame.pts - lastMetaPts >= 1000) {\\n       adtsFrame = new FlvTag(FlvTag.METADATA_TAG);\\n        adtsFrame.pts = currentFrame.pts;\\n        adtsFrame.dts = currentFrame.dts;\\n\\n        // AAC is always 10\\n        adtsFrame.writeMetaDataDouble('audiocodecid', 10);\\n        adtsFrame.writeMetaDataBoolean('stereo', track.channelcount === 2);\\n        adtsFrame.writeMetaDataDouble('audiosamplerate', track.samplerate);\\n        // Is AAC always 16 bit?\\n        adtsFrame.writeMetaDataDouble('audiosamplesize', 16);\\n\\n        tags.push(adtsFrame);\\n\\n        oldExtraData = track.extraData;\\n\\n        adtsFrame = new FlvTag(FlvTag.AUDIO_TAG, true);\\n        // For audio, DTS is always the same as PTS. We want to set the DTS\\n        // however so we can compare with video DTS to determine approximate\\n        // packet order\\n        adtsFrame.pts = currentFrame.pts;\\n        adtsFrame.dts = currentFrame.dts;\\n\\n        adtsFrame.view.setUint16(adtsFrame.position, track.extraData);\\n        adtsFrame.position += 2;\\n        adtsFrame.length = Math.max(adtsFrame.length, adtsFrame.position);\\n\\n        tags.push(adtsFrame);\\n\\n        lastMetaPts = currentFrame.pts;\\n      }\\n      adtsFrame = new FlvTag(FlvTag.AUDIO_TAG);\\n      adtsFrame.pts = currentFrame.pts;\\n      adtsFrame.dts = currentFrame.dts;\\n\\n      adtsFrame.writeBytes(currentFrame.data);\\n\\n      tags.push(adtsFrame);\\n    }\\n\\n    oldExtraData = null;\\n    this.trigger('data', {track: track, tags: tags});\\n\\n    this.trigger('done');\\n  };\\n};\\nAudioSegmentStream.prototype = new Stream();\\n\\n/**\\n * Store FlvTags for the h264 stream\\n * @param track {object} track metadata configuration\\n */\\nVideoSegmentStream = function(track) {\\n  var\\n    nalUnits = [],\\n    config,\\n    h264Frame;\\n  VideoSegmentStream.prototype.init.call(this);\\n\\n  this.finishFrame = function(tags, frame) {\\n    if (!frame) {\\n      return;\\n    }\\n    // Check if keyframe and the length of tags.\\n    // This makes sure we write metadata on the first frame of a segment.\\n    if (config && track && track.newMetadata &&\\n        (frame.keyFrame || tags.length === 0)) {\\n      // Push extra data on every IDR frame in case we did a stream change + seek\\n      tags.push(metaDataTag(config, frame.pts));\\n      tags.push(extraDataTag(track, frame.pts));\\n      track.newMetadata = false;\\n    }\\n\\n    frame.endNalUnit();\\n    tags.push(frame);\\n  };\\n\\n  this.push = function(data) {\\n    collectTimelineInfo(track, data);\\n\\n    data.pts = Math.round(data.pts / 90);\\n    data.dts = Math.round(data.dts / 90);\\n\\n    // buffer video until flush() is called\\n    nalUnits.push(data);\\n  };\\n\\n  this.flush = function() {\\n    var\\n      currentNal,\\n      tags = [];\\n\\n    // Throw away nalUnits at the start of the byte stream until we find\\n    // the first AUD\\n    while (nalUnits.length) {\\n      if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\\n        break;\\n      }\\n      nalUnits.shift();\\n    }\\n\\n    // return early if no video data has been observed\\n    if (nalUnits.length === 0) {\\n      this.trigger('done');\\n      return;\\n    }\\n\\n    while (nalUnits.length) {\\n      currentNal = nalUnits.shift();\\n\\n      // record the track config\\n      if (currentNal.nalUnitType === 'seq_parameter_set_rbsp') {\\n        track.newMetadata = true;\\n        config = currentNal.config;\\n        track.width = config.width;\\n        track.height = config.height;\\n        track.sps = [currentNal.data];\\n        track.profileIdc = config.profileIdc;\\n        track.levelIdc = config.levelIdc;\\n        track.profileCompatibility = config.profileCompatibility;\\n        h264Frame.endNalUnit();\\n      } else if (currentNal.nalUnitType === 'pic_parameter_set_rbsp') {\\n        track.newMetadata = true;\\n        track.pps = [currentNal.data];\\n        h264Frame.endNalUnit();\\n      } else if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\\n        if (h264Frame) {\\n          this.finishFrame(tags, h264Frame);\\n        }\\n        h264Frame = new FlvTag(FlvTag.VIDEO_TAG);\\n        h264Frame.pts = currentNal.pts;\\n        h264Frame.dts = currentNal.dts;\\n      } else {\\n        if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\\n          // the current sample is a key frame\\n          h264Frame.keyFrame = true;\\n        }\\n        h264Frame.endNalUnit();\\n      }\\n      h264Frame.startNalUnit();\\n      h264Frame.writeBytes(currentNal.data);\\n    }\\n    if (h264Frame) {\\n      this.finishFrame(tags, h264Frame);\\n    }\\n\\n    this.trigger('data', {track: track, tags: tags});\\n\\n    // Continue with the flush process now\\n    this.trigger('done');\\n  };\\n};\\n\\nVideoSegmentStream.prototype = new Stream();\\n\\n/**\\n * The final stage of the transmuxer that emits the flv tags\\n * for audio, video, and metadata. Also tranlates in time and\\n * outputs caption data and id3 cues.\\n */\\nCoalesceStream = function(options) {\\n  // Number of Tracks per output segment\\n  // If greater than 1, we combine multiple\\n  // tracks into a single segment\\n  this.numberOfTracks = 0;\\n  this.metadataStream = options.metadataStream;\\n\\n  this.videoTags = [];\\n  this.audioTags = [];\\n  this.videoTrack = null;\\n  this.audioTrack = null;\\n  this.pendingCaptions = [];\\n  this.pendingMetadata = [];\\n  this.pendingTracks = 0;\\n\\n  CoalesceStream.prototype.init.call(this);\\n\\n  // Take output from multiple\\n  this.push = function(output) {\\n    // buffer incoming captions until the associated video segment\\n    // finishes\\n    if (output.text) {\\n      return this.pendingCaptions.push(output);\\n    }\\n    // buffer incoming id3 tags until the final flush\\n    if (output.frames) {\\n      return this.pendingMetadata.push(output);\\n    }\\n\\n    if (output.track.type === 'video') {\\n      this.videoTrack = output.track;\\n      this.videoTags = output.tags;\\n      this.pendingTracks++;\\n    }\\n    if (output.track.type === 'audio') {\\n      this.audioTrack = output.track;\\n      this.audioTags = output.tags;\\n      this.pendingTracks++;\\n    }\\n  };\\n};\\n\\nCoalesceStream.prototype = new Stream();\\nCoalesceStream.prototype.flush = function() {\\n  var\\n    id3,\\n    caption,\\n    i,\\n    timelineStartPts,\\n    event = {\\n      tags: {},\\n      captions: [],\\n      metadata: []\\n    };\\n\\n  if (this.pendingTracks < this.numberOfTracks) {\\n    return;\\n  }\\n\\n  if (this.videoTrack) {\\n    timelineStartPts = this.videoTrack.timelineStartInfo.pts;\\n  } else if (this.audioTrack) {\\n    timelineStartPts = this.audioTrack.timelineStartInfo.pts;\\n  }\\n\\n  event.tags.videoTags = this.videoTags;\\n  event.tags.audioTags = this.audioTags;\\n\\n  // Translate caption PTS times into second offsets into the\\n  // video timeline for the segment\\n  for (i = 0; i < this.pendingCaptions.length; i++) {\\n    caption = this.pendingCaptions[i];\\n    caption.startTime = caption.startPts - timelineStartPts;\\n    caption.startTime /= 90e3;\\n    caption.endTime = caption.endPts - timelineStartPts;\\n    caption.endTime /= 90e3;\\n    event.captions.push(caption);\\n  }\\n\\n  // Translate ID3 frame PTS times into second offsets into the\\n  // video timeline for the segment\\n  for (i = 0; i < this.pendingMetadata.length; i++) {\\n    id3 = this.pendingMetadata[i];\\n    id3.cueTime = id3.pts - timelineStartPts;\\n    id3.cueTime /= 90e3;\\n    event.metadata.push(id3);\\n  }\\n  // We add this to every single emitted segment even though we only need\\n  // it for the first\\n  event.metadata.dispatchType = this.metadataStream.dispatchType;\\n\\n  // Reset stream state\\n  this.videoTrack = null;\\n  this.audioTrack = null;\\n  this.videoTags = [];\\n  this.audioTags = [];\\n  this.pendingCaptions.length = 0;\\n  this.pendingMetadata.length = 0;\\n  this.pendingTracks = 0;\\n\\n  // Emit the final segment\\n  this.trigger('data', event);\\n\\n  this.trigger('done');\\n};\\n\\n/**\\n * An object that incrementally transmuxes MPEG2 Trasport Stream\\n * chunks into an FLV.\\n */\\nTransmuxer = function(options) {\\n  var\\n    self = this,\\n\\n    packetStream, parseStream, elementaryStream,\\n    videoTimestampRolloverStream, audioTimestampRolloverStream,\\n    timedMetadataTimestampRolloverStream,\\n    adtsStream, h264Stream,\\n    videoSegmentStream, audioSegmentStream, captionStream,\\n    coalesceStream;\\n\\n  Transmuxer.prototype.init.call(this);\\n\\n  options = options || {};\\n\\n  // expose the metadata stream\\n  this.metadataStream = new m2ts.MetadataStream();\\n\\n  options.metadataStream = this.metadataStream;\\n\\n  // set up the parsing pipeline\\n  packetStream = new m2ts.TransportPacketStream();\\n  parseStream = new m2ts.TransportParseStream();\\n  elementaryStream = new m2ts.ElementaryStream();\\n  videoTimestampRolloverStream = new m2ts.TimestampRolloverStream('video');\\n  audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\\n  timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\\n\\n  adtsStream = new AdtsStream();\\n  h264Stream = new H264Stream();\\n  coalesceStream = new CoalesceStream(options);\\n\\n  // disassemble MPEG2-TS packets into elementary streams\\n  packetStream\\n    .pipe(parseStream)\\n    .pipe(elementaryStream);\\n\\n  // !!THIS ORDER IS IMPORTANT!!\\n  // demux the streams\\n  elementaryStream\\n    .pipe(videoTimestampRolloverStream)\\n    .pipe(h264Stream);\\n  elementaryStream\\n    .pipe(audioTimestampRolloverStream)\\n    .pipe(adtsStream);\\n\\n  elementaryStream\\n    .pipe(timedMetadataTimestampRolloverStream)\\n    .pipe(this.metadataStream)\\n    .pipe(coalesceStream);\\n  // if CEA-708 parsing is available, hook up a caption stream\\n  captionStream = new m2ts.CaptionStream();\\n  h264Stream.pipe(captionStream)\\n    .pipe(coalesceStream);\\n\\n  // hook up the segment streams once track metadata is delivered\\n  elementaryStream.on('data', function(data) {\\n    var i, videoTrack, audioTrack;\\n\\n    if (data.type === 'metadata') {\\n      i = data.tracks.length;\\n\\n      // scan the tracks listed in the metadata\\n      while (i--) {\\n        if (data.tracks[i].type === 'video') {\\n          videoTrack = data.tracks[i];\\n        } else if (data.tracks[i].type === 'audio') {\\n          audioTrack = data.tracks[i];\\n        }\\n      }\\n\\n      // hook up the video segment stream to the first track with h264 data\\n      if (videoTrack && !videoSegmentStream) {\\n        coalesceStream.numberOfTracks++;\\n        videoSegmentStream = new VideoSegmentStream(videoTrack);\\n\\n        // Set up the final part of the video pipeline\\n        h264Stream\\n          .pipe(videoSegmentStream)\\n          .pipe(coalesceStream);\\n      }\\n\\n      if (audioTrack && !audioSegmentStream) {\\n        // hook up the audio segment stream to the first track with aac data\\n        coalesceStream.numberOfTracks++;\\n        audioSegmentStream = new AudioSegmentStream(audioTrack);\\n\\n        // Set up the final part of the audio pipeline\\n        adtsStream\\n          .pipe(audioSegmentStream)\\n          .pipe(coalesceStream);\\n      }\\n    }\\n  });\\n\\n  // feed incoming data to the front of the parsing pipeline\\n  this.push = function(data) {\\n    packetStream.push(data);\\n  };\\n\\n  // flush any buffered data\\n  this.flush = function() {\\n    // Start at the top of the pipeline and flush all pending work\\n    packetStream.flush();\\n  };\\n\\n  // Re-emit any data coming from the coalesce stream to the outside world\\n  coalesceStream.on('data', function(event) {\\n    self.trigger('data', event);\\n  });\\n\\n  // Let the consumer know we have finished flushing the entire pipeline\\n  coalesceStream.on('done', function() {\\n    self.trigger('done');\\n  });\\n\\n  // For information on the FLV format, see\\n  // http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf.\\n  // Technically, this function returns the header and a metadata FLV tag\\n  // if duration is greater than zero\\n  // duration in seconds\\n  // @return {object} the bytes of the FLV header as a Uint8Array\\n  this.getFlvHeader = function(duration, audio, video) { // :ByteArray {\\n    var\\n      headBytes = new Uint8Array(3 + 1 + 1 + 4),\\n      head = new DataView(headBytes.buffer),\\n      metadata,\\n      result,\\n      metadataLength;\\n\\n    // default arguments\\n    duration = duration || 0;\\n    audio = audio === undefined ? true : audio;\\n    video = video === undefined ? true : video;\\n\\n    // signature\\n    head.setUint8(0, 0x46); // 'F'\\n    head.setUint8(1, 0x4c); // 'L'\\n    head.setUint8(2, 0x56); // 'V'\\n\\n    // version\\n    head.setUint8(3, 0x01);\\n\\n    // flags\\n    head.setUint8(4, (audio ? 0x04 : 0x00) | (video ? 0x01 : 0x00));\\n\\n    // data offset, should be 9 for FLV v1\\n    head.setUint32(5, headBytes.byteLength);\\n\\n    // init the first FLV tag\\n    if (duration <= 0) {\\n      // no duration available so just write the first field of the first\\n      // FLV tag\\n      result = new Uint8Array(headBytes.byteLength + 4);\\n      result.set(headBytes);\\n      result.set([0, 0, 0, 0], headBytes.byteLength);\\n      return result;\\n    }\\n\\n    // write out the duration metadata tag\\n    metadata = new FlvTag(FlvTag.METADATA_TAG);\\n    metadata.pts = metadata.dts = 0;\\n    metadata.writeMetaDataDouble('duration', duration);\\n    metadataLength = metadata.finalize().length;\\n    result = new Uint8Array(headBytes.byteLength + metadataLength);\\n    result.set(headBytes);\\n    result.set(head.byteLength, metadataLength);\\n\\n    return result;\\n  };\\n};\\nTransmuxer.prototype = new Stream();\\n\\n// forward compatibility\\nmodule.exports = Transmuxer;\\n\\n},{\\\"../codecs/adts.js\\\":80,\\\"../codecs/h264\\\":81,\\\"../m2ts/m2ts.js\\\":86,\\\"../utils/stream.js\\\":94,\\\"./flv-tag.js\\\":82}],85:[function(require,module,exports){\\n/**\\n * mux.js\\n *\\n * Copyright (c) 2015 Brightcove\\n * All rights reserved.\\n *\\n * Reads in-band caption information from a video elementary\\n * stream. Captions must follow the CEA-708 standard for injection\\n * into an MPEG-2 transport streams.\\n * @see https://en.wikipedia.org/wiki/CEA-708\\n */\\n\\n'use strict';\\n\\n// -----------------\\n// Link To Transport\\n// -----------------\\n\\n// Supplemental enhancement information (SEI) NAL units have a\\n// payload type field to indicate how they are to be\\n// interpreted. CEAS-708 caption content is always transmitted with\\n// payload type 0x04.\\nvar USER_DATA_REGISTERED_ITU_T_T35 = 4,\\n    RBSP_TRAILING_BITS = 128,\\n    Stream = require('../utils/stream');\\n\\n/**\\n  * Parse a supplemental enhancement information (SEI) NAL unit.\\n  * Stops parsing once a message of type ITU T T35 has been found.\\n  *\\n  * @param bytes {Uint8Array} the bytes of a SEI NAL unit\\n  * @return {object} the parsed SEI payload\\n  * @see Rec. ITU-T H.264, 7.3.2.3.1\\n  */\\nvar parseSei = function(bytes) {\\n  var\\n    i = 0,\\n    result = {\\n      payloadType: -1,\\n      payloadSize: 0\\n    },\\n    payloadType = 0,\\n    payloadSize = 0;\\n\\n  // go through the sei_rbsp parsing each each individual sei_message\\n  while (i < bytes.byteLength) {\\n    // stop once we have hit the end of the sei_rbsp\\n    if (bytes[i] === RBSP_TRAILING_BITS) {\\n      break;\\n    }\\n\\n    // Parse payload type\\n    while (bytes[i] === 0xFF) {\\n      payloadType += 255;\\n      i++;\\n    }\\n    payloadType += bytes[i++];\\n\\n    // Parse payload size\\n    while (bytes[i] === 0xFF) {\\n      payloadSize += 255;\\n      i++;\\n    }\\n    payloadSize += bytes[i++];\\n\\n    // this sei_message is a 608/708 caption so save it and break\\n    // there can only ever be one caption message in a frame's sei\\n    if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {\\n      result.payloadType = payloadType;\\n      result.payloadSize = payloadSize;\\n      result.payload = bytes.subarray(i, i + payloadSize);\\n      break;\\n    }\\n\\n    // skip the payload and parse the next message\\n    i += payloadSize;\\n    payloadType = 0;\\n    payloadSize = 0;\\n  }\\n\\n  return result;\\n};\\n\\n// see ANSI/SCTE 128-1 (2013), section 8.1\\nvar parseUserData = function(sei) {\\n  // itu_t_t35_contry_code must be 181 (United States) for\\n  // captions\\n  if (sei.payload[0] !== 181) {\\n    return null;\\n  }\\n\\n  // itu_t_t35_provider_code should be 49 (ATSC) for captions\\n  if (((sei.payload[1] << 8) | sei.payload[2]) !== 49) {\\n    return null;\\n  }\\n\\n  // the user_identifier should be \\\"GA94\\\" to indicate ATSC1 data\\n  if (String.fromCharCode(sei.payload[3],\\n                          sei.payload[4],\\n                          sei.payload[5],\\n                          sei.payload[6]) !== 'GA94') {\\n    return null;\\n  }\\n\\n  // finally, user_data_type_code should be 0x03 for caption data\\n  if (sei.payload[7] !== 0x03) {\\n    return null;\\n  }\\n\\n  // return the user_data_type_structure and strip the trailing\\n  // marker bits\\n  return sei.payload.subarray(8, sei.payload.length - 1);\\n};\\n\\n// see CEA-708-D, section 4.4\\nvar parseCaptionPackets = function(pts, userData) {\\n  var results = [], i, count, offset, data;\\n\\n  // if this is just filler, return immediately\\n  if (!(userData[0] & 0x40)) {\\n    return results;\\n  }\\n\\n  // parse out the cc_data_1 and cc_data_2 fields\\n  count = userData[0] & 0x1f;\\n  for (i = 0; i < count; i++) {\\n    offset = i * 3;\\n    data = {\\n      type: userData[offset + 2] & 0x03,\\n      pts: pts\\n    };\\n\\n    // capture cc data when cc_valid is 1\\n    if (userData[offset + 2] & 0x04) {\\n      data.ccData = (userData[offset + 3] << 8) | userData[offset + 4];\\n      results.push(data);\\n    }\\n  }\\n  return results;\\n};\\n\\nvar CaptionStream = function() {\\n  CaptionStream.prototype.init.call(this);\\n\\n  this.captionPackets_ = [];\\n\\n  this.field1_ = new Cea608Stream(); // eslint-disable-line no-use-before-define\\n\\n  // forward data and done events from field1_ to this CaptionStream\\n  this.field1_.on('data', this.trigger.bind(this, 'data'));\\n  this.field1_.on('done', this.trigger.bind(this, 'done'));\\n};\\nCaptionStream.prototype = new Stream();\\nCaptionStream.prototype.push = function(event) {\\n  var sei, userData;\\n\\n  // only examine SEI NALs\\n  if (event.nalUnitType !== 'sei_rbsp') {\\n    return;\\n  }\\n\\n  // parse the sei\\n  sei = parseSei(event.escapedRBSP);\\n\\n  // ignore everything but user_data_registered_itu_t_t35\\n  if (sei.payloadType !== USER_DATA_REGISTERED_ITU_T_T35) {\\n    return;\\n  }\\n\\n  // parse out the user data payload\\n  userData = parseUserData(sei);\\n\\n  // ignore unrecognized userData\\n  if (!userData) {\\n    return;\\n  }\\n\\n  // parse out CC data packets and save them for later\\n  this.captionPackets_ = this.captionPackets_.concat(parseCaptionPackets(event.pts, userData));\\n};\\n\\nCaptionStream.prototype.flush = function() {\\n  // make sure we actually parsed captions before proceeding\\n  if (!this.captionPackets_.length) {\\n    this.field1_.flush();\\n    return;\\n  }\\n\\n  // In Chrome, the Array#sort function is not stable so add a\\n  // presortIndex that we can use to ensure we get a stable-sort\\n  this.captionPackets_.forEach(function(elem, idx) {\\n    elem.presortIndex = idx;\\n  });\\n\\n  // sort caption byte-pairs based on their PTS values\\n  this.captionPackets_.sort(function(a, b) {\\n    if (a.pts === b.pts) {\\n      return a.presortIndex - b.presortIndex;\\n    }\\n    return a.pts - b.pts;\\n  });\\n\\n  // Push each caption into Cea608Stream\\n  this.captionPackets_.forEach(this.field1_.push, this.field1_);\\n\\n  this.captionPackets_.length = 0;\\n  this.field1_.flush();\\n  return;\\n};\\n// ----------------------\\n// Session to Application\\n// ----------------------\\n\\nvar BASIC_CHARACTER_TRANSLATION = {\\n  0x2a: 0xe1,\\n  0x5c: 0xe9,\\n  0x5e: 0xed,\\n  0x5f: 0xf3,\\n  0x60: 0xfa,\\n  0x7b: 0xe7,\\n  0x7c: 0xf7,\\n  0x7d: 0xd1,\\n  0x7e: 0xf1,\\n  0x7f: 0x2588\\n};\\n\\nvar getCharFromCode = function(code) {\\n  if (code === null) {\\n    return '';\\n  }\\n  code = BASIC_CHARACTER_TRANSLATION[code] || code;\\n  return String.fromCharCode(code);\\n};\\n\\n// Constants for the byte codes recognized by Cea608Stream. This\\n// list is not exhaustive. For a more comprehensive listing and\\n// semantics see\\n// http://www.gpo.gov/fdsys/pkg/CFR-2010-title47-vol1/pdf/CFR-2010-title47-vol1-sec15-119.pdf\\nvar PADDING                    = 0x0000,\\n\\n    // Pop-on Mode\\n    RESUME_CAPTION_LOADING     = 0x1420,\\n    END_OF_CAPTION             = 0x142f,\\n\\n    // Roll-up Mode\\n    ROLL_UP_2_ROWS             = 0x1425,\\n    ROLL_UP_3_ROWS             = 0x1426,\\n    ROLL_UP_4_ROWS             = 0x1427,\\n    CARRIAGE_RETURN            = 0x142d,\\n    // Erasure\\n    BACKSPACE                  = 0x1421,\\n    ERASE_DISPLAYED_MEMORY     = 0x142c,\\n    ERASE_NON_DISPLAYED_MEMORY = 0x142e;\\n\\n// the index of the last row in a CEA-608 display buffer\\nvar BOTTOM_ROW = 14;\\n// CEA-608 captions are rendered onto a 34x15 matrix of character\\n// cells. The \\\"bottom\\\" row is the last element in the outer array.\\nvar createDisplayBuffer = function() {\\n  var result = [], i = BOTTOM_ROW + 1;\\n  while (i--) {\\n    result.push('');\\n  }\\n  return result;\\n};\\n\\nvar Cea608Stream = function() {\\n  Cea608Stream.prototype.init.call(this);\\n\\n  this.mode_ = 'popOn';\\n  // When in roll-up mode, the index of the last row that will\\n  // actually display captions. If a caption is shifted to a row\\n  // with a lower index than this, it is cleared from the display\\n  // buffer\\n  this.topRow_ = 0;\\n  this.startPts_ = 0;\\n  this.displayed_ = createDisplayBuffer();\\n  this.nonDisplayed_ = createDisplayBuffer();\\n  this.lastControlCode_ = null;\\n\\n  this.push = function(packet) {\\n    // Ignore other channels\\n    if (packet.type !== 0) {\\n      return;\\n    }\\n    var data, swap, char0, char1;\\n    // remove the parity bits\\n    data = packet.ccData & 0x7f7f;\\n\\n    // ignore duplicate control codes\\n    if (data === this.lastControlCode_) {\\n      this.lastControlCode_ = null;\\n      return;\\n    }\\n\\n    // Store control codes\\n    if ((data & 0xf000) === 0x1000) {\\n      this.lastControlCode_ = data;\\n    } else {\\n      this.lastControlCode_ = null;\\n    }\\n\\n    switch (data) {\\n    case PADDING:\\n      break;\\n    case RESUME_CAPTION_LOADING:\\n      this.mode_ = 'popOn';\\n      break;\\n    case END_OF_CAPTION:\\n      // if a caption was being displayed, it's gone now\\n      this.flushDisplayed(packet.pts);\\n\\n      // flip memory\\n      swap = this.displayed_;\\n      this.displayed_ = this.nonDisplayed_;\\n      this.nonDisplayed_ = swap;\\n\\n      // start measuring the time to display the caption\\n      this.startPts_ = packet.pts;\\n      break;\\n\\n    case ROLL_UP_2_ROWS:\\n      this.topRow_ = BOTTOM_ROW - 1;\\n      this.mode_ = 'rollUp';\\n      break;\\n    case ROLL_UP_3_ROWS:\\n      this.topRow_ = BOTTOM_ROW - 2;\\n      this.mode_ = 'rollUp';\\n      break;\\n    case ROLL_UP_4_ROWS:\\n      this.topRow_ = BOTTOM_ROW - 3;\\n      this.mode_ = 'rollUp';\\n      break;\\n    case CARRIAGE_RETURN:\\n      this.flushDisplayed(packet.pts);\\n      this.shiftRowsUp_();\\n      this.startPts_ = packet.pts;\\n      break;\\n\\n    case BACKSPACE:\\n      if (this.mode_ === 'popOn') {\\n        this.nonDisplayed_[BOTTOM_ROW] = this.nonDisplayed_[BOTTOM_ROW].slice(0, -1);\\n      } else {\\n        this.displayed_[BOTTOM_ROW] = this.displayed_[BOTTOM_ROW].slice(0, -1);\\n      }\\n      break;\\n    case ERASE_DISPLAYED_MEMORY:\\n      this.flushDisplayed(packet.pts);\\n      this.displayed_ = createDisplayBuffer();\\n      break;\\n    case ERASE_NON_DISPLAYED_MEMORY:\\n      this.nonDisplayed_ = createDisplayBuffer();\\n      break;\\n    default:\\n      char0 = data >>> 8;\\n      char1 = data & 0xff;\\n\\n      // Look for a Channel 1 Preamble Address Code\\n      if (char0 >= 0x10 && char0 <= 0x17 &&\\n          char1 >= 0x40 && char1 <= 0x7F &&\\n          (char0 !== 0x10 || char1 < 0x60)) {\\n        // Follow Safari's lead and replace the PAC with a space\\n        char0 = 0x20;\\n        // we only want one space so make the second character null\\n        // which will get become '' in getCharFromCode\\n        char1 = null;\\n      }\\n\\n      // Look for special character sets\\n      if ((char0 === 0x11 || char0 === 0x19) &&\\n          (char1 >= 0x30 && char1 <= 0x3F)) {\\n        // Put in eigth note and space\\n        char0 = 0x266A;\\n        char1 = '';\\n      }\\n\\n      // ignore unsupported control codes\\n      if ((char0 & 0xf0) === 0x10) {\\n        return;\\n      }\\n\\n      // character handling is dependent on the current mode\\n      this[this.mode_](packet.pts, char0, char1);\\n      break;\\n    }\\n  };\\n};\\nCea608Stream.prototype = new Stream();\\n// Trigger a cue point that captures the current state of the\\n// display buffer\\nCea608Stream.prototype.flushDisplayed = function(pts) {\\n  var content = this.displayed_\\n    // remove spaces from the start and end of the string\\n    .map(function(row) {\\n      return row.trim();\\n    })\\n    // remove empty rows\\n    .filter(function(row) {\\n      return row.length;\\n    })\\n    // combine all text rows to display in one cue\\n    .join('\\\\n');\\n\\n  if (content.length) {\\n    this.trigger('data', {\\n      startPts: this.startPts_,\\n      endPts: pts,\\n      text: content\\n    });\\n  }\\n};\\n\\n// Mode Implementations\\nCea608Stream.prototype.popOn = function(pts, char0, char1) {\\n  var baseRow = this.nonDisplayed_[BOTTOM_ROW];\\n\\n  // buffer characters\\n  baseRow += getCharFromCode(char0);\\n  baseRow += getCharFromCode(char1);\\n  this.nonDisplayed_[BOTTOM_ROW] = baseRow;\\n};\\n\\nCea608Stream.prototype.rollUp = function(pts, char0, char1) {\\n  var baseRow = this.displayed_[BOTTOM_ROW];\\n  if (baseRow === '') {\\n    // we're starting to buffer new display input, so flush out the\\n    // current display\\n    this.flushDisplayed(pts);\\n\\n    this.startPts_ = pts;\\n  }\\n\\n  baseRow += getCharFromCode(char0);\\n  baseRow += getCharFromCode(char1);\\n\\n  this.displayed_[BOTTOM_ROW] = baseRow;\\n};\\nCea608Stream.prototype.shiftRowsUp_ = function() {\\n  var i;\\n  // clear out inactive rows\\n  for (i = 0; i < this.topRow_; i++) {\\n    this.displayed_[i] = '';\\n  }\\n  // shift displayed rows up\\n  for (i = this.topRow_; i < BOTTOM_ROW; i++) {\\n    this.displayed_[i] = this.displayed_[i + 1];\\n  }\\n  // clear out the bottom row\\n  this.displayed_[BOTTOM_ROW] = '';\\n};\\n\\n// exports\\nmodule.exports = {\\n  CaptionStream: CaptionStream,\\n  Cea608Stream: Cea608Stream\\n};\\n\\n},{\\\"../utils/stream\\\":94}],86:[function(require,module,exports){\\n/**\\n * mux.js\\n *\\n * Copyright (c) 2015 Brightcove\\n * All rights reserved.\\n *\\n * A stream-based mp2t to mp4 converter. This utility can be used to\\n * deliver mp4s to a SourceBuffer on platforms that support native\\n * Media Source Extensions.\\n */\\n'use strict';\\nvar Stream = require('../utils/stream.js'),\\n  CaptionStream = require('./caption-stream'),\\n  StreamTypes = require('./stream-types'),\\n  TimestampRolloverStream = require('./timestamp-rollover-stream');\\n\\nvar m2tsStreamTypes = require('./stream-types.js');\\n\\n// object types\\nvar TransportPacketStream, TransportParseStream, ElementaryStream;\\n\\n// constants\\nvar\\n  MP2T_PACKET_LENGTH = 188, // bytes\\n  SYNC_BYTE = 0x47;\\n\\n/**\\n * Splits an incoming stream of binary data into MPEG-2 Transport\\n * Stream packets.\\n */\\nTransportPacketStream = function() {\\n  var\\n    buffer = new Uint8Array(MP2T_PACKET_LENGTH),\\n    bytesInBuffer = 0;\\n\\n  TransportPacketStream.prototype.init.call(this);\\n\\n   // Deliver new bytes to the stream.\\n\\n  this.push = function(bytes) {\\n    var\\n      startIndex = 0,\\n      endIndex = MP2T_PACKET_LENGTH,\\n      everything;\\n\\n    // If there are bytes remaining from the last segment, prepend them to the\\n    // bytes that were pushed in\\n    if (bytesInBuffer) {\\n      everything = new Uint8Array(bytes.byteLength + bytesInBuffer);\\n      everything.set(buffer.subarray(0, bytesInBuffer));\\n      everything.set(bytes, bytesInBuffer);\\n      bytesInBuffer = 0;\\n    } else {\\n      everything = bytes;\\n    }\\n\\n    // While we have enough data for a packet\\n    while (endIndex < everything.byteLength) {\\n      // Look for a pair of start and end sync bytes in the data..\\n      if (everything[startIndex] === SYNC_BYTE && everything[endIndex] === SYNC_BYTE) {\\n        // We found a packet so emit it and jump one whole packet forward in\\n        // the stream\\n        this.trigger('data', everything.subarray(startIndex, endIndex));\\n        startIndex += MP2T_PACKET_LENGTH;\\n        endIndex += MP2T_PACKET_LENGTH;\\n        continue;\\n      }\\n      // If we get here, we have somehow become de-synchronized and we need to step\\n      // forward one byte at a time until we find a pair of sync bytes that denote\\n      // a packet\\n      startIndex++;\\n      endIndex++;\\n    }\\n\\n    // If there was some data left over at the end of the segment that couldn't\\n    // possibly be a whole packet, keep it because it might be the start of a packet\\n    // that continues in the next segment\\n    if (startIndex < everything.byteLength) {\\n      buffer.set(everything.subarray(startIndex), 0);\\n      bytesInBuffer = everything.byteLength - startIndex;\\n    }\\n  };\\n\\n  this.flush = function() {\\n    // If the buffer contains a whole packet when we are being flushed, emit it\\n    // and empty the buffer. Otherwise hold onto the data because it may be\\n    // important for decoding the next segment\\n    if (bytesInBuffer === MP2T_PACKET_LENGTH && buffer[0] === SYNC_BYTE) {\\n      this.trigger('data', buffer);\\n      bytesInBuffer = 0;\\n    }\\n    this.trigger('done');\\n  };\\n};\\nTransportPacketStream.prototype = new Stream();\\n\\n/**\\n * Accepts an MP2T TransportPacketStream and emits data events with parsed\\n * forms of the individual transport stream packets.\\n */\\nTransportParseStream = function() {\\n  var parsePsi, parsePat, parsePmt, self;\\n  TransportParseStream.prototype.init.call(this);\\n  self = this;\\n\\n  this.packetsWaitingForPmt = [];\\n  this.programMapTable = undefined;\\n\\n  parsePsi = function(payload, psi) {\\n    var offset = 0;\\n\\n    // PSI packets may be split into multiple sections and those\\n    // sections may be split into multiple packets. If a PSI\\n    // section starts in this packet, the payload_unit_start_indicator\\n    // will be true and the first byte of the payload will indicate\\n    // the offset from the current position to the start of the\\n    // section.\\n    if (psi.payloadUnitStartIndicator) {\\n      offset += payload[offset] + 1;\\n    }\\n\\n    if (psi.type === 'pat') {\\n      parsePat(payload.subarray(offset), psi);\\n    } else {\\n      parsePmt(payload.subarray(offset), psi);\\n    }\\n  };\\n\\n  parsePat = function(payload, pat) {\\n    pat.section_number = payload[7]; // eslint-disable-line camelcase\\n    pat.last_section_number = payload[8]; // eslint-disable-line camelcase\\n\\n    // skip the PSI header and parse the first PMT entry\\n    self.pmtPid = (payload[10] & 0x1F) << 8 | payload[11];\\n    pat.pmtPid = self.pmtPid;\\n  };\\n\\n  /**\\n   * Parse out the relevant fields of a Program Map Table (PMT).\\n   * @param payload {Uint8Array} the PMT-specific portion of an MP2T\\n   * packet. The first byte in this array should be the table_id\\n   * field.\\n   * @param pmt {object} the object that should be decorated with\\n   * fields parsed from the PMT.\\n   */\\n  parsePmt = function(payload, pmt) {\\n    var sectionLength, tableEnd, programInfoLength, offset;\\n\\n    // PMTs can be sent ahead of the time when they should actually\\n    // take effect. We don't believe this should ever be the case\\n    // for HLS but we'll ignore \\\"forward\\\" PMT declarations if we see\\n    // them. Future PMT declarations have the current_next_indicator\\n    // set to zero.\\n    if (!(payload[5] & 0x01)) {\\n      return;\\n    }\\n\\n    // overwrite any existing program map table\\n    self.programMapTable = {};\\n\\n    // the mapping table ends at the end of the current section\\n    sectionLength = (payload[1] & 0x0f) << 8 | payload[2];\\n    tableEnd = 3 + sectionLength - 4;\\n\\n    // to determine where the table is, we have to figure out how\\n    // long the program info descriptors are\\n    programInfoLength = (payload[10] & 0x0f) << 8 | payload[11];\\n\\n    // advance the offset to the first entry in the mapping table\\n    offset = 12 + programInfoLength;\\n    while (offset < tableEnd) {\\n      // add an entry that maps the elementary_pid to the stream_type\\n      self.programMapTable[(payload[offset + 1] & 0x1F) << 8 | payload[offset + 2]] = payload[offset];\\n\\n      // move to the next table entry\\n      // skip past the elementary stream descriptors, if present\\n      offset += ((payload[offset + 3] & 0x0F) << 8 | payload[offset + 4]) + 5;\\n    }\\n\\n    // record the map on the packet as well\\n    pmt.programMapTable = self.programMapTable;\\n\\n    // if there are any packets waiting for a PMT to be found, process them now\\n    while (self.packetsWaitingForPmt.length) {\\n      self.processPes_.apply(self, self.packetsWaitingForPmt.shift());\\n    }\\n  };\\n\\n  /**\\n   * Deliver a new MP2T packet to the stream.\\n   */\\n  this.push = function(packet) {\\n    var\\n      result = {},\\n      offset = 4;\\n\\n    result.payloadUnitStartIndicator = !!(packet[1] & 0x40);\\n\\n    // pid is a 13-bit field starting at the last bit of packet[1]\\n    result.pid = packet[1] & 0x1f;\\n    result.pid <<= 8;\\n    result.pid |= packet[2];\\n\\n    // if an adaption field is present, its length is specified by the\\n    // fifth byte of the TS packet header. The adaptation field is\\n    // used to add stuffing to PES packets that don't fill a complete\\n    // TS packet, and to specify some forms of timing and control data\\n    // that we do not currently use.\\n    if (((packet[3] & 0x30) >>> 4) > 0x01) {\\n      offset += packet[offset] + 1;\\n    }\\n\\n    // parse the rest of the packet based on the type\\n    if (result.pid === 0) {\\n      result.type = 'pat';\\n      parsePsi(packet.subarray(offset), result);\\n      this.trigger('data', result);\\n    } else if (result.pid === this.pmtPid) {\\n      result.type = 'pmt';\\n      parsePsi(packet.subarray(offset), result);\\n      this.trigger('data', result);\\n    } else if (this.programMapTable === undefined) {\\n      // When we have not seen a PMT yet, defer further processing of\\n      // PES packets until one has been parsed\\n      this.packetsWaitingForPmt.push([packet, offset, result]);\\n    } else {\\n      this.processPes_(packet, offset, result);\\n    }\\n  };\\n\\n  this.processPes_ = function(packet, offset, result) {\\n    result.streamType = this.programMapTable[result.pid];\\n    result.type = 'pes';\\n    result.data = packet.subarray(offset);\\n\\n    this.trigger('data', result);\\n  };\\n\\n};\\nTransportParseStream.prototype = new Stream();\\nTransportParseStream.STREAM_TYPES  = {\\n  h264: 0x1b,\\n  adts: 0x0f\\n};\\n\\n/**\\n * Reconsistutes program elementary stream (PES) packets from parsed\\n * transport stream packets. That is, if you pipe an\\n * mp2t.TransportParseStream into a mp2t.ElementaryStream, the output\\n * events will be events which capture the bytes for individual PES\\n * packets plus relevant metadata that has been extracted from the\\n * container.\\n */\\nElementaryStream = function() {\\n  var\\n    self = this,\\n    // PES packet fragments\\n    video = {\\n      data: [],\\n      size: 0\\n    },\\n    audio = {\\n      data: [],\\n      size: 0\\n    },\\n    timedMetadata = {\\n      data: [],\\n      size: 0\\n    },\\n    parsePes = function(payload, pes) {\\n      var ptsDtsFlags;\\n\\n      // find out if this packets starts a new keyframe\\n      pes.dataAlignmentIndicator = (payload[6] & 0x04) !== 0;\\n      // PES packets may be annotated with a PTS value, or a PTS value\\n      // and a DTS value. Determine what combination of values is\\n      // available to work with.\\n      ptsDtsFlags = payload[7];\\n\\n      // PTS and DTS are normally stored as a 33-bit number.  Javascript\\n      // performs all bitwise operations on 32-bit integers but javascript\\n      // supports a much greater range (52-bits) of integer using standard\\n      // mathematical operations.\\n      // We construct a 31-bit value using bitwise operators over the 31\\n      // most significant bits and then multiply by 4 (equal to a left-shift\\n      // of 2) before we add the final 2 least significant bits of the\\n      // timestamp (equal to an OR.)\\n      if (ptsDtsFlags & 0xC0) {\\n        // the PTS and DTS are not written out directly. For information\\n        // on how they are encoded, see\\n        // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\\n        pes.pts = (payload[9] & 0x0E) << 27 |\\n          (payload[10] & 0xFF) << 20 |\\n          (payload[11] & 0xFE) << 12 |\\n          (payload[12] & 0xFF) <<  5 |\\n          (payload[13] & 0xFE) >>>  3;\\n        pes.pts *= 4; // Left shift by 2\\n        pes.pts += (payload[13] & 0x06) >>> 1; // OR by the two LSBs\\n        pes.dts = pes.pts;\\n        if (ptsDtsFlags & 0x40) {\\n          pes.dts = (payload[14] & 0x0E) << 27 |\\n            (payload[15] & 0xFF) << 20 |\\n            (payload[16] & 0xFE) << 12 |\\n            (payload[17] & 0xFF) << 5 |\\n            (payload[18] & 0xFE) >>> 3;\\n          pes.dts *= 4; // Left shift by 2\\n          pes.dts += (payload[18] & 0x06) >>> 1; // OR by the two LSBs\\n        }\\n      }\\n      // the data section starts immediately after the PES header.\\n      // pes_header_data_length specifies the number of header bytes\\n      // that follow the last byte of the field.\\n      pes.data = payload.subarray(9 + payload[8]);\\n    },\\n    flushStream = function(stream, type) {\\n      var\\n        packetData = new Uint8Array(stream.size),\\n        event = {\\n          type: type\\n        },\\n        i = 0,\\n        fragment;\\n\\n      // do nothing if there is no buffered data\\n      if (!stream.data.length) {\\n        return;\\n      }\\n      event.trackId = stream.data[0].pid;\\n\\n      // reassemble the packet\\n      while (stream.data.length) {\\n        fragment = stream.data.shift();\\n\\n        packetData.set(fragment.data, i);\\n        i += fragment.data.byteLength;\\n      }\\n\\n      // parse assembled packet's PES header\\n      parsePes(packetData, event);\\n\\n      stream.size = 0;\\n\\n      self.trigger('data', event);\\n    };\\n\\n  ElementaryStream.prototype.init.call(this);\\n\\n  this.push = function(data) {\\n    ({\\n      pat: function() {\\n        // we have to wait for the PMT to arrive as well before we\\n        // have any meaningful metadata\\n      },\\n      pes: function() {\\n        var stream, streamType;\\n\\n        switch (data.streamType) {\\n        case StreamTypes.H264_STREAM_TYPE:\\n        case m2tsStreamTypes.H264_STREAM_TYPE:\\n          stream = video;\\n          streamType = 'video';\\n          break;\\n        case StreamTypes.ADTS_STREAM_TYPE:\\n          stream = audio;\\n          streamType = 'audio';\\n          break;\\n        case StreamTypes.METADATA_STREAM_TYPE:\\n          stream = timedMetadata;\\n          streamType = 'timed-metadata';\\n          break;\\n        default:\\n          // ignore unknown stream types\\n          return;\\n        }\\n\\n        // if a new packet is starting, we can flush the completed\\n        // packet\\n        if (data.payloadUnitStartIndicator) {\\n          flushStream(stream, streamType);\\n        }\\n\\n        // buffer this fragment until we are sure we've received the\\n        // complete payload\\n        stream.data.push(data);\\n        stream.size += data.data.byteLength;\\n      },\\n      pmt: function() {\\n        var\\n          event = {\\n            type: 'metadata',\\n            tracks: []\\n          },\\n          programMapTable = data.programMapTable,\\n          k,\\n          track;\\n\\n        // translate streams to tracks\\n        for (k in programMapTable) {\\n          if (programMapTable.hasOwnProperty(k)) {\\n            track = {\\n              timelineStartInfo: {\\n                baseMediaDecodeTime: 0\\n              }\\n            };\\n            track.id = +k;\\n            if (programMapTable[k] === m2tsStreamTypes.H264_STREAM_TYPE) {\\n              track.codec = 'avc';\\n              track.type = 'video';\\n            } else if (programMapTable[k] === m2tsStreamTypes.ADTS_STREAM_TYPE) {\\n              track.codec = 'adts';\\n              track.type = 'audio';\\n            }\\n            event.tracks.push(track);\\n          }\\n        }\\n        self.trigger('data', event);\\n      }\\n    })[data.type]();\\n  };\\n\\n  /**\\n   * Flush any remaining input. Video PES packets may be of variable\\n   * length. Normally, the start of a new video packet can trigger the\\n   * finalization of the previous packet. That is not possible if no\\n   * more video is forthcoming, however. In that case, some other\\n   * mechanism (like the end of the file) has to be employed. When it is\\n   * clear that no additional data is forthcoming, calling this method\\n   * will flush the buffered packets.\\n   */\\n  this.flush = function() {\\n    // !!THIS ORDER IS IMPORTANT!!\\n    // video first then audio\\n    flushStream(video, 'video');\\n    flushStream(audio, 'audio');\\n    flushStream(timedMetadata, 'timed-metadata');\\n    this.trigger('done');\\n  };\\n};\\nElementaryStream.prototype = new Stream();\\n\\nvar m2ts = {\\n  PAT_PID: 0x0000,\\n  MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH,\\n  TransportPacketStream: TransportPacketStream,\\n  TransportParseStream: TransportParseStream,\\n  ElementaryStream: ElementaryStream,\\n  TimestampRolloverStream: TimestampRolloverStream,\\n  CaptionStream: CaptionStream.CaptionStream,\\n  Cea608Stream: CaptionStream.Cea608Stream,\\n  MetadataStream: require('./metadata-stream')\\n};\\n\\nfor (var type in StreamTypes) {\\n  if (StreamTypes.hasOwnProperty(type)) {\\n    m2ts[type] = StreamTypes[type];\\n  }\\n}\\n\\nmodule.exports = m2ts;\\n\\n},{\\\"../utils/stream.js\\\":94,\\\"./caption-stream\\\":85,\\\"./metadata-stream\\\":87,\\\"./stream-types\\\":88,\\\"./stream-types.js\\\":88,\\\"./timestamp-rollover-stream\\\":89}],87:[function(require,module,exports){\\n/**\\n * Accepts program elementary stream (PES) data events and parses out\\n * ID3 metadata from them, if present.\\n * @see http://id3.org/id3v2.3.0\\n */\\n'use strict';\\nvar\\n  Stream = require('../utils/stream'),\\n  StreamTypes = require('./stream-types'),\\n  // return a percent-encoded representation of the specified byte range\\n  // @see http://en.wikipedia.org/wiki/Percent-encoding\\n  percentEncode = function(bytes, start, end) {\\n    var i, result = '';\\n    for (i = start; i < end; i++) {\\n      result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\\n    }\\n    return result;\\n  },\\n  // return the string representation of the specified byte range,\\n  // interpreted as UTf-8.\\n  parseUtf8 = function(bytes, start, end) {\\n    return decodeURIComponent(percentEncode(bytes, start, end));\\n  },\\n  // return the string representation of the specified byte range,\\n  // interpreted as ISO-8859-1.\\n  parseIso88591 = function(bytes, start, end) {\\n    return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\\n  },\\n  parseSyncSafeInteger = function(data) {\\n    return (data[0] << 21) |\\n            (data[1] << 14) |\\n            (data[2] << 7) |\\n            (data[3]);\\n  },\\n  tagParsers = {\\n    TXXX: function(tag) {\\n      var i;\\n      if (tag.data[0] !== 3) {\\n        // ignore frames with unrecognized character encodings\\n        return;\\n      }\\n\\n      for (i = 1; i < tag.data.length; i++) {\\n        if (tag.data[i] === 0) {\\n          // parse the text fields\\n          tag.description = parseUtf8(tag.data, 1, i);\\n          // do not include the null terminator in the tag value\\n          tag.value = parseUtf8(tag.data, i + 1, tag.data.length - 1);\\n          break;\\n        }\\n      }\\n      tag.data = tag.value;\\n    },\\n    WXXX: function(tag) {\\n      var i;\\n      if (tag.data[0] !== 3) {\\n        // ignore frames with unrecognized character encodings\\n        return;\\n      }\\n\\n      for (i = 1; i < tag.data.length; i++) {\\n        if (tag.data[i] === 0) {\\n          // parse the description and URL fields\\n          tag.description = parseUtf8(tag.data, 1, i);\\n          tag.url = parseUtf8(tag.data, i + 1, tag.data.length);\\n          break;\\n        }\\n      }\\n    },\\n    PRIV: function(tag) {\\n      var i;\\n\\n      for (i = 0; i < tag.data.length; i++) {\\n        if (tag.data[i] === 0) {\\n          // parse the description and URL fields\\n          tag.owner = parseIso88591(tag.data, 0, i);\\n          break;\\n        }\\n      }\\n      tag.privateData = tag.data.subarray(i + 1);\\n      tag.data = tag.privateData;\\n    }\\n  },\\n  MetadataStream;\\n\\nMetadataStream = function(options) {\\n  var\\n    settings = {\\n      debug: !!(options && options.debug),\\n\\n      // the bytes of the program-level descriptor field in MP2T\\n      // see ISO/IEC 13818-1:2013 (E), section 2.6 \\\"Program and\\n      // program element descriptors\\\"\\n      descriptor: options && options.descriptor\\n    },\\n    // the total size in bytes of the ID3 tag being parsed\\n    tagSize = 0,\\n    // tag data that is not complete enough to be parsed\\n    buffer = [],\\n    // the total number of bytes currently in the buffer\\n    bufferSize = 0,\\n    i;\\n\\n  MetadataStream.prototype.init.call(this);\\n\\n  // calculate the text track in-band metadata track dispatch type\\n  // https://html.spec.whatwg.org/multipage/embedded-content.html#steps-to-expose-a-media-resource-specific-text-track\\n  this.dispatchType = StreamTypes.METADATA_STREAM_TYPE.toString(16);\\n  if (settings.descriptor) {\\n    for (i = 0; i < settings.descriptor.length; i++) {\\n      this.dispatchType += ('00' + settings.descriptor[i].toString(16)).slice(-2);\\n    }\\n  }\\n\\n  this.push = function(chunk) {\\n    var tag, frameStart, frameSize, frame, i, frameHeader;\\n    if (chunk.type !== 'timed-metadata') {\\n      return;\\n    }\\n\\n    // if data_alignment_indicator is set in the PES header,\\n    // we must have the start of a new ID3 tag. Assume anything\\n    // remaining in the buffer was malformed and throw it out\\n    if (chunk.dataAlignmentIndicator) {\\n      bufferSize = 0;\\n      buffer.length = 0;\\n    }\\n\\n    // ignore events that don't look like ID3 data\\n    if (buffer.length === 0 &&\\n        (chunk.data.length < 10 ||\\n          chunk.data[0] !== 'I'.charCodeAt(0) ||\\n          chunk.data[1] !== 'D'.charCodeAt(0) ||\\n          chunk.data[2] !== '3'.charCodeAt(0))) {\\n      if (settings.debug) {\\n        // eslint-disable-next-line no-console\\n        console.log('Skipping unrecognized metadata packet');\\n      }\\n      return;\\n    }\\n\\n    // add this chunk to the data we've collected so far\\n\\n    buffer.push(chunk);\\n    bufferSize += chunk.data.byteLength;\\n\\n    // grab the size of the entire frame from the ID3 header\\n    if (buffer.length === 1) {\\n      // the frame size is transmitted as a 28-bit integer in the\\n      // last four bytes of the ID3 header.\\n      // The most significant bit of each byte is dropped and the\\n      // results concatenated to recover the actual value.\\n      tagSize = parseSyncSafeInteger(chunk.data.subarray(6, 10));\\n\\n      // ID3 reports the tag size excluding the header but it's more\\n      // convenient for our comparisons to include it\\n      tagSize += 10;\\n    }\\n\\n    // if the entire frame has not arrived, wait for more data\\n    if (bufferSize < tagSize) {\\n      return;\\n    }\\n\\n    // collect the entire frame so it can be parsed\\n    tag = {\\n      data: new Uint8Array(tagSize),\\n      frames: [],\\n      pts: buffer[0].pts,\\n      dts: buffer[0].dts\\n    };\\n    for (i = 0; i < tagSize;) {\\n      tag.data.set(buffer[0].data.subarray(0, tagSize - i), i);\\n      i += buffer[0].data.byteLength;\\n      bufferSize -= buffer[0].data.byteLength;\\n      buffer.shift();\\n    }\\n\\n    // find the start of the first frame and the end of the tag\\n    frameStart = 10;\\n    if (tag.data[5] & 0x40) {\\n      // advance the frame start past the extended header\\n      frameStart += 4; // header size field\\n      frameStart += parseSyncSafeInteger(tag.data.subarray(10, 14));\\n\\n      // clip any padding off the end\\n      tagSize -= parseSyncSafeInteger(tag.data.subarray(16, 20));\\n    }\\n\\n    // parse one or more ID3 frames\\n    // http://id3.org/id3v2.3.0#ID3v2_frame_overview\\n    do {\\n      // determine the number of bytes in this frame\\n      frameSize = parseSyncSafeInteger(tag.data.subarray(frameStart + 4, frameStart + 8));\\n      if (frameSize < 1) {\\n         // eslint-disable-next-line no-console\\n        return console.log('Malformed ID3 frame encountered. Skipping metadata parsing.');\\n      }\\n      frameHeader = String.fromCharCode(tag.data[frameStart],\\n                                        tag.data[frameStart + 1],\\n                                        tag.data[frameStart + 2],\\n                                        tag.data[frameStart + 3]);\\n\\n\\n      frame = {\\n        id: frameHeader,\\n        data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)\\n      };\\n      frame.key = frame.id;\\n      if (tagParsers[frame.id]) {\\n        tagParsers[frame.id](frame);\\n        if (frame.owner === 'com.apple.streaming.transportStreamTimestamp') {\\n          var\\n            d = frame.data,\\n            size = ((d[3] & 0x01)  << 30) |\\n                   (d[4]  << 22) |\\n                   (d[5] << 14) |\\n                   (d[6] << 6) |\\n                   (d[7] >>> 2);\\n\\n          size *= 4;\\n          size += d[7] & 0x03;\\n          frame.timeStamp = size;\\n          this.trigger('timestamp', frame);\\n        }\\n      }\\n      tag.frames.push(frame);\\n\\n      frameStart += 10; // advance past the frame header\\n      frameStart += frameSize; // advance past the frame body\\n    } while (frameStart < tagSize);\\n    this.trigger('data', tag);\\n  };\\n};\\nMetadataStream.prototype = new Stream();\\n\\nmodule.exports = MetadataStream;\\n\\n},{\\\"../utils/stream\\\":94,\\\"./stream-types\\\":88}],88:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = {\\n  H264_STREAM_TYPE: 0x1B,\\n  ADTS_STREAM_TYPE: 0x0F,\\n  METADATA_STREAM_TYPE: 0x15\\n};\\n\\n},{}],89:[function(require,module,exports){\\n/**\\n * mux.js\\n *\\n * Copyright (c) 2016 Brightcove\\n * All rights reserved.\\n *\\n * Accepts program elementary stream (PES) data events and corrects\\n * decode and presentation time stamps to account for a rollover\\n * of the 33 bit value.\\n */\\n\\n'use strict';\\n\\nvar Stream = require('../utils/stream');\\n\\nvar MAX_TS = 8589934592;\\n\\nvar RO_THRESH = 4294967296;\\n\\nvar TimestampRolloverStream = function(type) {\\n  var lastDTS, referenceDTS;\\n\\n  TimestampRolloverStream.prototype.init.call(this);\\n\\n  this.type_ = type;\\n\\n  var handleRollover = function(value, reference) {\\n    var direction = 1;\\n\\n    if (value > reference) {\\n      // If the current timestamp value is greater than our reference timestamp and we detect a\\n      // timestamp rollover, this means the roll over is happening in the opposite direction.\\n      // Example scenario: Enter a long stream/video just after a rollover occurred. The reference\\n      // point will be set to a small number, e.g. 1. The user then seeks backwards over the\\n      // rollover point. In loading this segment, the timestamp values will be very large,\\n      // e.g. 2^33 - 1. Since this comes before the data we loaded previously, we want to adjust\\n      // the time stamp to be `value - 2^33`.\\n      direction = -1;\\n    }\\n\\n    // Note: A seek forwards or back that is greater than the RO_THRESH (2^32, ~13 hours) will\\n    // cause an incorrect adjustment.\\n    while (Math.abs(reference - value) > RO_THRESH) {\\n      value += (direction * MAX_TS);\\n    }\\n\\n    return value;\\n  };\\n\\n  this.push = function(data) {\\n    if (data.type !== this.type_) {\\n      return;\\n    }\\n\\n    if (referenceDTS === undefined) {\\n      referenceDTS = data.dts;\\n    }\\n\\n    data.dts = handleRollover(data.dts, referenceDTS);\\n    data.pts = handleRollover(data.pts, referenceDTS);\\n\\n    lastDTS = data.dts;\\n\\n    this.trigger('data', data);\\n  };\\n\\n  this.flush = function() {\\n    referenceDTS = lastDTS;\\n    this.trigger('done');\\n  };\\n\\n};\\n\\nTimestampRolloverStream.prototype = new Stream();\\n\\nmodule.exports = TimestampRolloverStream;\\n\\n},{\\\"../utils/stream\\\":94}],90:[function(require,module,exports){\\nmodule.exports = {\\n  generator: require('./mp4-generator'),\\n  Transmuxer: require('./transmuxer').Transmuxer,\\n  AudioSegmentStream: require('./transmuxer').AudioSegmentStream,\\n  VideoSegmentStream: require('./transmuxer').VideoSegmentStream\\n};\\n\\n},{\\\"./mp4-generator\\\":91,\\\"./transmuxer\\\":92}],91:[function(require,module,exports){\\n/**\\n * mux.js\\n *\\n * Copyright (c) 2015 Brightcove\\n * All rights reserved.\\n *\\n * Functions that generate fragmented MP4s suitable for use with Media\\n * Source Extensions.\\n */\\n'use strict';\\n\\nvar box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd,\\n    trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex,\\n    trun, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR,\\n    AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS;\\n\\n// pre-calculate constants\\n(function() {\\n  var i;\\n  types = {\\n    avc1: [], // codingname\\n    avcC: [],\\n    btrt: [],\\n    dinf: [],\\n    dref: [],\\n    esds: [],\\n    ftyp: [],\\n    hdlr: [],\\n    mdat: [],\\n    mdhd: [],\\n    mdia: [],\\n    mfhd: [],\\n    minf: [],\\n    moof: [],\\n    moov: [],\\n    mp4a: [], // codingname\\n    mvex: [],\\n    mvhd: [],\\n    sdtp: [],\\n    smhd: [],\\n    stbl: [],\\n    stco: [],\\n    stsc: [],\\n    stsd: [],\\n    stsz: [],\\n    stts: [],\\n    styp: [],\\n    tfdt: [],\\n    tfhd: [],\\n    traf: [],\\n    trak: [],\\n    trun: [],\\n    trex: [],\\n    tkhd: [],\\n    vmhd: []\\n  };\\n\\n  // In environments where Uint8Array is undefined (e.g., IE8), skip set up so that we\\n  // don't throw an error\\n  if (typeof Uint8Array === 'undefined') {\\n    return;\\n  }\\n\\n  for (i in types) {\\n    if (types.hasOwnProperty(i)) {\\n      types[i] = [\\n        i.charCodeAt(0),\\n        i.charCodeAt(1),\\n        i.charCodeAt(2),\\n        i.charCodeAt(3)\\n      ];\\n    }\\n  }\\n\\n  MAJOR_BRAND = new Uint8Array([\\n    'i'.charCodeAt(0),\\n    's'.charCodeAt(0),\\n    'o'.charCodeAt(0),\\n    'm'.charCodeAt(0)\\n  ]);\\n  AVC1_BRAND = new Uint8Array([\\n    'a'.charCodeAt(0),\\n    'v'.charCodeAt(0),\\n    'c'.charCodeAt(0),\\n    '1'.charCodeAt(0)\\n  ]);\\n  MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);\\n  VIDEO_HDLR = new Uint8Array([\\n    0x00, // version 0\\n    0x00, 0x00, 0x00, // flags\\n    0x00, 0x00, 0x00, 0x00, // pre_defined\\n    0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\\n    0x00, 0x00, 0x00, 0x00, // reserved\\n    0x00, 0x00, 0x00, 0x00, // reserved\\n    0x00, 0x00, 0x00, 0x00, // reserved\\n    0x56, 0x69, 0x64, 0x65,\\n    0x6f, 0x48, 0x61, 0x6e,\\n    0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\\n  ]);\\n  AUDIO_HDLR = new Uint8Array([\\n    0x00, // version 0\\n    0x00, 0x00, 0x00, // flags\\n    0x00, 0x00, 0x00, 0x00, // pre_defined\\n    0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\\n    0x00, 0x00, 0x00, 0x00, // reserved\\n    0x00, 0x00, 0x00, 0x00, // reserved\\n    0x00, 0x00, 0x00, 0x00, // reserved\\n    0x53, 0x6f, 0x75, 0x6e,\\n    0x64, 0x48, 0x61, 0x6e,\\n    0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\\n  ]);\\n  HDLR_TYPES = {\\n    video: VIDEO_HDLR,\\n    audio: AUDIO_HDLR\\n  };\\n  DREF = new Uint8Array([\\n    0x00, // version 0\\n    0x00, 0x00, 0x00, // flags\\n    0x00, 0x00, 0x00, 0x01, // entry_count\\n    0x00, 0x00, 0x00, 0x0c, // entry_size\\n    0x75, 0x72, 0x6c, 0x20, // 'url' type\\n    0x00, // version 0\\n    0x00, 0x00, 0x01 // entry_flags\\n  ]);\\n  SMHD = new Uint8Array([\\n    0x00,             // version\\n    0x00, 0x00, 0x00, // flags\\n    0x00, 0x00,       // balance, 0 means centered\\n    0x00, 0x00        // reserved\\n  ]);\\n  STCO = new Uint8Array([\\n    0x00, // version\\n    0x00, 0x00, 0x00, // flags\\n    0x00, 0x00, 0x00, 0x00 // entry_count\\n  ]);\\n  STSC = STCO;\\n  STSZ = new Uint8Array([\\n    0x00, // version\\n    0x00, 0x00, 0x00, // flags\\n    0x00, 0x00, 0x00, 0x00, // sample_size\\n    0x00, 0x00, 0x00, 0x00 // sample_count\\n  ]);\\n  STTS = STCO;\\n  VMHD = new Uint8Array([\\n    0x00, // version\\n    0x00, 0x00, 0x01, // flags\\n    0x00, 0x00, // graphicsmode\\n    0x00, 0x00,\\n    0x00, 0x00,\\n    0x00, 0x00 // opcolor\\n  ]);\\n}());\\n\\nbox = function(type) {\\n  var\\n    payload = [],\\n    size = 0,\\n    i,\\n    result,\\n    view;\\n\\n  for (i = 1; i < arguments.length; i++) {\\n    payload.push(arguments[i]);\\n  }\\n\\n  i = payload.length;\\n\\n  // calculate the total size we need to allocate\\n  while (i--) {\\n    size += payload[i].byteLength;\\n  }\\n  result = new Uint8Array(size + 8);\\n  view = new DataView(result.buffer, result.byteOffset, result.byteLength);\\n  view.setUint32(0, result.byteLength);\\n  result.set(type, 4);\\n\\n  // copy the payload into the result\\n  for (i = 0, size = 8; i < payload.length; i++) {\\n    result.set(payload[i], size);\\n    size += payload[i].byteLength;\\n  }\\n  return result;\\n};\\n\\ndinf = function() {\\n  return box(types.dinf, box(types.dref, DREF));\\n};\\n\\nesds = function(track) {\\n  return box(types.esds, new Uint8Array([\\n    0x00, // version\\n    0x00, 0x00, 0x00, // flags\\n\\n    // ES_Descriptor\\n    0x03, // tag, ES_DescrTag\\n    0x19, // length\\n    0x00, 0x00, // ES_ID\\n    0x00, // streamDependenceFlag, URL_flag, reserved, streamPriority\\n\\n    // DecoderConfigDescriptor\\n    0x04, // tag, DecoderConfigDescrTag\\n    0x11, // length\\n    0x40, // object type\\n    0x15,  // streamType\\n    0x00, 0x06, 0x00, // bufferSizeDB\\n    0x00, 0x00, 0xda, 0xc0, // maxBitrate\\n    0x00, 0x00, 0xda, 0xc0, // avgBitrate\\n\\n    // DecoderSpecificInfo\\n    0x05, // tag, DecoderSpecificInfoTag\\n    0x02, // length\\n    // ISO/IEC 14496-3, AudioSpecificConfig\\n    // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35\\n    (track.audioobjecttype << 3) | (track.samplingfrequencyindex >>> 1),\\n    (track.samplingfrequencyindex << 7) | (track.channelcount << 3),\\n    0x06, 0x01, 0x02 // GASpecificConfig\\n  ]));\\n};\\n\\nftyp = function() {\\n  return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);\\n};\\n\\nhdlr = function(type) {\\n  return box(types.hdlr, HDLR_TYPES[type]);\\n};\\nmdat = function(data) {\\n  return box(types.mdat, data);\\n};\\nmdhd = function(track) {\\n  var result = new Uint8Array([\\n    0x00,                   // version 0\\n    0x00, 0x00, 0x00,       // flags\\n    0x00, 0x00, 0x00, 0x02, // creation_time\\n    0x00, 0x00, 0x00, 0x03, // modification_time\\n    0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \\\"ticks\\\" per second\\n\\n    (track.duration >>> 24) & 0xFF,\\n    (track.duration >>> 16) & 0xFF,\\n    (track.duration >>>  8) & 0xFF,\\n    track.duration & 0xFF,  // duration\\n    0x55, 0xc4,             // 'und' language (undetermined)\\n    0x00, 0x00\\n  ]);\\n\\n  // Use the sample rate from the track metadata, when it is\\n  // defined. The sample rate can be parsed out of an ADTS header, for\\n  // instance.\\n  if (track.samplerate) {\\n    result[12] = (track.samplerate >>> 24) & 0xFF;\\n    result[13] = (track.samplerate >>> 16) & 0xFF;\\n    result[14] = (track.samplerate >>>  8) & 0xFF;\\n    result[15] = (track.samplerate)        & 0xFF;\\n  }\\n\\n  return box(types.mdhd, result);\\n};\\nmdia = function(track) {\\n  return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));\\n};\\nmfhd = function(sequenceNumber) {\\n  return box(types.mfhd, new Uint8Array([\\n    0x00,\\n    0x00, 0x00, 0x00, // flags\\n    (sequenceNumber & 0xFF000000) >> 24,\\n    (sequenceNumber & 0xFF0000) >> 16,\\n    (sequenceNumber & 0xFF00) >> 8,\\n    sequenceNumber & 0xFF // sequence_number\\n  ]));\\n};\\nminf = function(track) {\\n  return box(types.minf,\\n             track.type === 'video' ? box(types.vmhd, VMHD) : box(types.smhd, SMHD),\\n             dinf(),\\n             stbl(track));\\n};\\nmoof = function(sequenceNumber, tracks) {\\n  var\\n    trackFragments = [],\\n    i = tracks.length;\\n  // build traf boxes for each track fragment\\n  while (i--) {\\n    trackFragments[i] = traf(tracks[i]);\\n  }\\n  return box.apply(null, [\\n    types.moof,\\n    mfhd(sequenceNumber)\\n  ].concat(trackFragments));\\n};\\n/**\\n * Returns a movie box.\\n * @param tracks {array} the tracks associated with this movie\\n * @see ISO/IEC 14496-12:2012(E), section 8.2.1\\n */\\nmoov = function(tracks) {\\n  var\\n    i = tracks.length,\\n    boxes = [];\\n\\n  while (i--) {\\n    boxes[i] = trak(tracks[i]);\\n  }\\n\\n  return box.apply(null, [types.moov, mvhd(0xffffffff)].concat(boxes).concat(mvex(tracks)));\\n};\\nmvex = function(tracks) {\\n  var\\n    i = tracks.length,\\n    boxes = [];\\n\\n  while (i--) {\\n    boxes[i] = trex(tracks[i]);\\n  }\\n  return box.apply(null, [types.mvex].concat(boxes));\\n};\\nmvhd = function(duration) {\\n  var\\n    bytes = new Uint8Array([\\n      0x00, // version 0\\n      0x00, 0x00, 0x00, // flags\\n      0x00, 0x00, 0x00, 0x01, // creation_time\\n      0x00, 0x00, 0x00, 0x02, // modification_time\\n      0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \\\"ticks\\\" per second\\n      (duration & 0xFF000000) >> 24,\\n      (duration & 0xFF0000) >> 16,\\n      (duration & 0xFF00) >> 8,\\n      duration & 0xFF, // duration\\n      0x00, 0x01, 0x00, 0x00, // 1.0 rate\\n      0x01, 0x00, // 1.0 volume\\n      0x00, 0x00, // reserved\\n      0x00, 0x00, 0x00, 0x00, // reserved\\n      0x00, 0x00, 0x00, 0x00, // reserved\\n      0x00, 0x01, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x01, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00, // pre_defined\\n      0xff, 0xff, 0xff, 0xff // next_track_ID\\n    ]);\\n  return box(types.mvhd, bytes);\\n};\\n\\nsdtp = function(track) {\\n  var\\n    samples = track.samples || [],\\n    bytes = new Uint8Array(4 + samples.length),\\n    flags,\\n    i;\\n\\n  // leave the full box header (4 bytes) all zero\\n\\n  // write the sample table\\n  for (i = 0; i < samples.length; i++) {\\n    flags = samples[i].flags;\\n\\n    bytes[i + 4] = (flags.dependsOn << 4) |\\n      (flags.isDependedOn << 2) |\\n      (flags.hasRedundancy);\\n  }\\n\\n  return box(types.sdtp,\\n             bytes);\\n};\\n\\nstbl = function(track) {\\n  return box(types.stbl,\\n             stsd(track),\\n             box(types.stts, STTS),\\n             box(types.stsc, STSC),\\n             box(types.stsz, STSZ),\\n             box(types.stco, STCO));\\n};\\n\\n(function() {\\n  var videoSample, audioSample;\\n\\n  stsd = function(track) {\\n\\n    return box(types.stsd, new Uint8Array([\\n      0x00, // version 0\\n      0x00, 0x00, 0x00, // flags\\n      0x00, 0x00, 0x00, 0x01\\n    ]), track.type === 'video' ? videoSample(track) : audioSample(track));\\n  };\\n\\n  videoSample = function(track) {\\n    var\\n      sps = track.sps || [],\\n      pps = track.pps || [],\\n      sequenceParameterSets = [],\\n      pictureParameterSets = [],\\n      i;\\n\\n    // assemble the SPSs\\n    for (i = 0; i < sps.length; i++) {\\n      sequenceParameterSets.push((sps[i].byteLength & 0xFF00) >>> 8);\\n      sequenceParameterSets.push((sps[i].byteLength & 0xFF)); // sequenceParameterSetLength\\n      sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i])); // SPS\\n    }\\n\\n    // assemble the PPSs\\n    for (i = 0; i < pps.length; i++) {\\n      pictureParameterSets.push((pps[i].byteLength & 0xFF00) >>> 8);\\n      pictureParameterSets.push((pps[i].byteLength & 0xFF));\\n      pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));\\n    }\\n\\n    return box(types.avc1, new Uint8Array([\\n      0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, // reserved\\n      0x00, 0x01, // data_reference_index\\n      0x00, 0x00, // pre_defined\\n      0x00, 0x00, // reserved\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00, // pre_defined\\n      (track.width & 0xff00) >> 8,\\n      track.width & 0xff, // width\\n      (track.height & 0xff00) >> 8,\\n      track.height & 0xff, // height\\n      0x00, 0x48, 0x00, 0x00, // horizresolution\\n      0x00, 0x48, 0x00, 0x00, // vertresolution\\n      0x00, 0x00, 0x00, 0x00, // reserved\\n      0x00, 0x01, // frame_count\\n      0x13,\\n      0x76, 0x69, 0x64, 0x65,\\n      0x6f, 0x6a, 0x73, 0x2d,\\n      0x63, 0x6f, 0x6e, 0x74,\\n      0x72, 0x69, 0x62, 0x2d,\\n      0x68, 0x6c, 0x73, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, // compressorname\\n      0x00, 0x18, // depth = 24\\n      0x11, 0x11 // pre_defined = -1\\n    ]), box(types.avcC, new Uint8Array([\\n      0x01, // configurationVersion\\n      track.profileIdc, // AVCProfileIndication\\n      track.profileCompatibility, // profile_compatibility\\n      track.levelIdc, // AVCLevelIndication\\n      0xff // lengthSizeMinusOne, hard-coded to 4 bytes\\n    ].concat([\\n      sps.length // numOfSequenceParameterSets\\n    ]).concat(sequenceParameterSets).concat([\\n      pps.length // numOfPictureParameterSets\\n    ]).concat(pictureParameterSets))), // \\\"PPS\\\"\\n            box(types.btrt, new Uint8Array([\\n              0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\\n              0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\\n              0x00, 0x2d, 0xc6, 0xc0\\n            ])) // avgBitrate\\n              );\\n  };\\n\\n  audioSample = function(track) {\\n    return box(types.mp4a, new Uint8Array([\\n\\n      // SampleEntry, ISO/IEC 14496-12\\n      0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, // reserved\\n      0x00, 0x01, // data_reference_index\\n\\n      // AudioSampleEntry, ISO/IEC 14496-12\\n      0x00, 0x00, 0x00, 0x00, // reserved\\n      0x00, 0x00, 0x00, 0x00, // reserved\\n      (track.channelcount & 0xff00) >> 8,\\n      (track.channelcount & 0xff), // channelcount\\n\\n      (track.samplesize & 0xff00) >> 8,\\n      (track.samplesize & 0xff), // samplesize\\n      0x00, 0x00, // pre_defined\\n      0x00, 0x00, // reserved\\n\\n      (track.samplerate & 0xff00) >> 8,\\n      (track.samplerate & 0xff),\\n      0x00, 0x00 // samplerate, 16.16\\n\\n      // MP4AudioSampleEntry, ISO/IEC 14496-14\\n    ]), esds(track));\\n  };\\n}());\\n\\ntkhd = function(track) {\\n  var result = new Uint8Array([\\n    0x00, // version 0\\n    0x00, 0x00, 0x07, // flags\\n    0x00, 0x00, 0x00, 0x00, // creation_time\\n    0x00, 0x00, 0x00, 0x00, // modification_time\\n    (track.id & 0xFF000000) >> 24,\\n    (track.id & 0xFF0000) >> 16,\\n    (track.id & 0xFF00) >> 8,\\n    track.id & 0xFF, // track_ID\\n    0x00, 0x00, 0x00, 0x00, // reserved\\n    (track.duration & 0xFF000000) >> 24,\\n    (track.duration & 0xFF0000) >> 16,\\n    (track.duration & 0xFF00) >> 8,\\n    track.duration & 0xFF, // duration\\n    0x00, 0x00, 0x00, 0x00,\\n    0x00, 0x00, 0x00, 0x00, // reserved\\n    0x00, 0x00, // layer\\n    0x00, 0x00, // alternate_group\\n    0x01, 0x00, // non-audio track volume\\n    0x00, 0x00, // reserved\\n    0x00, 0x01, 0x00, 0x00,\\n    0x00, 0x00, 0x00, 0x00,\\n    0x00, 0x00, 0x00, 0x00,\\n    0x00, 0x00, 0x00, 0x00,\\n    0x00, 0x01, 0x00, 0x00,\\n    0x00, 0x00, 0x00, 0x00,\\n    0x00, 0x00, 0x00, 0x00,\\n    0x00, 0x00, 0x00, 0x00,\\n    0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\\n    (track.width & 0xFF00) >> 8,\\n    track.width & 0xFF,\\n    0x00, 0x00, // width\\n    (track.height & 0xFF00) >> 8,\\n    track.height & 0xFF,\\n    0x00, 0x00 // height\\n  ]);\\n\\n  return box(types.tkhd, result);\\n};\\n\\n/**\\n * Generate a track fragment (traf) box. A traf box collects metadata\\n * about tracks in a movie fragment (moof) box.\\n */\\ntraf = function(track) {\\n  var trackFragmentHeader, trackFragmentDecodeTime,\\n      trackFragmentRun, sampleDependencyTable, dataOffset;\\n\\n  trackFragmentHeader = box(types.tfhd, new Uint8Array([\\n    0x00, // version 0\\n    0x00, 0x00, 0x3a, // flags\\n    (track.id & 0xFF000000) >> 24,\\n    (track.id & 0xFF0000) >> 16,\\n    (track.id & 0xFF00) >> 8,\\n    (track.id & 0xFF), // track_ID\\n    0x00, 0x00, 0x00, 0x01, // sample_description_index\\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\\n    0x00, 0x00, 0x00, 0x00  // default_sample_flags\\n  ]));\\n\\n  trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([\\n    0x00, // version 0\\n    0x00, 0x00, 0x00, // flags\\n    // baseMediaDecodeTime\\n    (track.baseMediaDecodeTime >>> 24) & 0xFF,\\n    (track.baseMediaDecodeTime >>> 16) & 0xFF,\\n    (track.baseMediaDecodeTime >>> 8) & 0xFF,\\n    track.baseMediaDecodeTime & 0xFF\\n  ]));\\n\\n  // the data offset specifies the number of bytes from the start of\\n  // the containing moof to the first payload byte of the associated\\n  // mdat\\n  dataOffset = (32 + // tfhd\\n                16 + // tfdt\\n                8 +  // traf header\\n                16 + // mfhd\\n                8 +  // moof header\\n                8);  // mdat header\\n\\n  // audio tracks require less metadata\\n  if (track.type === 'audio') {\\n    trackFragmentRun = trun(track, dataOffset);\\n    return box(types.traf,\\n               trackFragmentHeader,\\n               trackFragmentDecodeTime,\\n               trackFragmentRun);\\n  }\\n\\n  // video tracks should contain an independent and disposable samples\\n  // box (sdtp)\\n  // generate one and adjust offsets to match\\n  sampleDependencyTable = sdtp(track);\\n  trackFragmentRun = trun(track,\\n                          sampleDependencyTable.length + dataOffset);\\n  return box(types.traf,\\n             trackFragmentHeader,\\n             trackFragmentDecodeTime,\\n             trackFragmentRun,\\n             sampleDependencyTable);\\n};\\n\\n/**\\n * Generate a track box.\\n * @param track {object} a track definition\\n * @return {Uint8Array} the track box\\n */\\ntrak = function(track) {\\n  track.duration = track.duration || 0xffffffff;\\n  return box(types.trak,\\n             tkhd(track),\\n             mdia(track));\\n};\\n\\ntrex = function(track) {\\n  var result = new Uint8Array([\\n    0x00, // version 0\\n    0x00, 0x00, 0x00, // flags\\n    (track.id & 0xFF000000) >> 24,\\n    (track.id & 0xFF0000) >> 16,\\n    (track.id & 0xFF00) >> 8,\\n    (track.id & 0xFF), // track_ID\\n    0x00, 0x00, 0x00, 0x01, // default_sample_description_index\\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\\n  ]);\\n  // the last two bytes of default_sample_flags is the sample\\n  // degradation priority, a hint about the importance of this sample\\n  // relative to others. Lower the degradation priority for all sample\\n  // types other than video.\\n  if (track.type !== 'video') {\\n    result[result.length - 1] = 0x00;\\n  }\\n\\n  return box(types.trex, result);\\n};\\n\\n(function() {\\n  var audioTrun, videoTrun, trunHeader;\\n\\n  // This method assumes all samples are uniform. That is, if a\\n  // duration is present for the first sample, it will be present for\\n  // all subsequent samples.\\n  // see ISO/IEC 14496-12:2012, Section 8.8.8.1\\n  trunHeader = function(samples, offset) {\\n    var durationPresent = 0, sizePresent = 0,\\n        flagsPresent = 0, compositionTimeOffset = 0;\\n\\n    // trun flag constants\\n    if (samples.length) {\\n      if (samples[0].duration !== undefined) {\\n        durationPresent = 0x1;\\n      }\\n      if (samples[0].size !== undefined) {\\n        sizePresent = 0x2;\\n      }\\n      if (samples[0].flags !== undefined) {\\n        flagsPresent = 0x4;\\n      }\\n      if (samples[0].compositionTimeOffset !== undefined) {\\n        compositionTimeOffset = 0x8;\\n      }\\n    }\\n\\n    return [\\n      0x00, // version 0\\n      0x00,\\n      durationPresent | sizePresent | flagsPresent | compositionTimeOffset,\\n      0x01, // flags\\n      (samples.length & 0xFF000000) >>> 24,\\n      (samples.length & 0xFF0000) >>> 16,\\n      (samples.length & 0xFF00) >>> 8,\\n      samples.length & 0xFF, // sample_count\\n      (offset & 0xFF000000) >>> 24,\\n      (offset & 0xFF0000) >>> 16,\\n      (offset & 0xFF00) >>> 8,\\n      offset & 0xFF // data_offset\\n    ];\\n  };\\n\\n  videoTrun = function(track, offset) {\\n    var bytes, samples, sample, i;\\n\\n    samples = track.samples || [];\\n    offset += 8 + 12 + (16 * samples.length);\\n\\n    bytes = trunHeader(samples, offset);\\n\\n    for (i = 0; i < samples.length; i++) {\\n      sample = samples[i];\\n      bytes = bytes.concat([\\n        (sample.duration & 0xFF000000) >>> 24,\\n        (sample.duration & 0xFF0000) >>> 16,\\n        (sample.duration & 0xFF00) >>> 8,\\n        sample.duration & 0xFF, // sample_duration\\n        (sample.size & 0xFF000000) >>> 24,\\n        (sample.size & 0xFF0000) >>> 16,\\n        (sample.size & 0xFF00) >>> 8,\\n        sample.size & 0xFF, // sample_size\\n        (sample.flags.isLeading << 2) | sample.flags.dependsOn,\\n        (sample.flags.isDependedOn << 6) |\\n          (sample.flags.hasRedundancy << 4) |\\n          (sample.flags.paddingValue << 1) |\\n          sample.flags.isNonSyncSample,\\n        sample.flags.degradationPriority & 0xF0 << 8,\\n        sample.flags.degradationPriority & 0x0F, // sample_flags\\n        (sample.compositionTimeOffset & 0xFF000000) >>> 24,\\n        (sample.compositionTimeOffset & 0xFF0000) >>> 16,\\n        (sample.compositionTimeOffset & 0xFF00) >>> 8,\\n        sample.compositionTimeOffset & 0xFF // sample_composition_time_offset\\n      ]);\\n    }\\n    return box(types.trun, new Uint8Array(bytes));\\n  };\\n\\n  audioTrun = function(track, offset) {\\n    var bytes, samples, sample, i;\\n\\n    samples = track.samples || [];\\n    offset += 8 + 12 + (8 * samples.length);\\n\\n    bytes = trunHeader(samples, offset);\\n\\n    for (i = 0; i < samples.length; i++) {\\n      sample = samples[i];\\n      bytes = bytes.concat([\\n        (sample.duration & 0xFF000000) >>> 24,\\n        (sample.duration & 0xFF0000) >>> 16,\\n        (sample.duration & 0xFF00) >>> 8,\\n        sample.duration & 0xFF, // sample_duration\\n        (sample.size & 0xFF000000) >>> 24,\\n        (sample.size & 0xFF0000) >>> 16,\\n        (sample.size & 0xFF00) >>> 8,\\n        sample.size & 0xFF]); // sample_size\\n    }\\n\\n    return box(types.trun, new Uint8Array(bytes));\\n  };\\n\\n  trun = function(track, offset) {\\n    if (track.type === 'audio') {\\n      return audioTrun(track, offset);\\n    }\\n\\n    return videoTrun(track, offset);\\n  };\\n}());\\n\\nmodule.exports = {\\n  ftyp: ftyp,\\n  mdat: mdat,\\n  moof: moof,\\n  moov: moov,\\n  initSegment: function(tracks) {\\n    var\\n      fileType = ftyp(),\\n      movie = moov(tracks),\\n      result;\\n\\n    result = new Uint8Array(fileType.byteLength + movie.byteLength);\\n    result.set(fileType);\\n    result.set(movie, fileType.byteLength);\\n    return result;\\n  }\\n};\\n\\n},{}],92:[function(require,module,exports){\\n/**\\n * mux.js\\n *\\n * Copyright (c) 2015 Brightcove\\n * All rights reserved.\\n *\\n * A stream-based mp2t to mp4 converter. This utility can be used to\\n * deliver mp4s to a SourceBuffer on platforms that support native\\n * Media Source Extensions.\\n */\\n'use strict';\\n\\nvar Stream = require('../utils/stream.js');\\nvar mp4 = require('./mp4-generator.js');\\nvar m2ts = require('../m2ts/m2ts.js');\\nvar AdtsStream = require('../codecs/adts.js');\\nvar H264Stream = require('../codecs/h264').H264Stream;\\nvar AacStream = require('../aac');\\n\\n// constants\\nvar AUDIO_PROPERTIES = [\\n  'audioobjecttype',\\n  'channelcount',\\n  'samplerate',\\n  'samplingfrequencyindex',\\n  'samplesize'\\n];\\n\\nvar VIDEO_PROPERTIES = [\\n  'width',\\n  'height',\\n  'profileIdc',\\n  'levelIdc',\\n  'profileCompatibility'\\n];\\n\\n// object types\\nvar VideoSegmentStream, AudioSegmentStream, Transmuxer, CoalesceStream;\\n\\n// Helper functions\\nvar\\n  createDefaultSample,\\n  isLikelyAacData,\\n  collectDtsInfo,\\n  clearDtsInfo,\\n  calculateTrackBaseMediaDecodeTime,\\n  arrayEquals,\\n  sumFrameByteLengths;\\n\\n/**\\n * Default sample object\\n * see ISO/IEC 14496-12:2012, section 8.6.4.3\\n */\\ncreateDefaultSample = function() {\\n  return {\\n    size: 0,\\n    flags: {\\n      isLeading: 0,\\n      dependsOn: 1,\\n      isDependedOn: 0,\\n      hasRedundancy: 0,\\n      degradationPriority: 0\\n    }\\n  };\\n};\\n\\nisLikelyAacData = function(data) {\\n  if ((data[0] === 'I'.charCodeAt(0)) &&\\n      (data[1] === 'D'.charCodeAt(0)) &&\\n      (data[2] === '3'.charCodeAt(0))) {\\n    return true;\\n  }\\n  return false;\\n};\\n\\n/**\\n * Compare two arrays (even typed) for same-ness\\n */\\narrayEquals = function(a, b) {\\n  var\\n    i;\\n\\n  if (a.length !== b.length) {\\n    return false;\\n  }\\n\\n  // compare the value of each element in the array\\n  for (i = 0; i < a.length; i++) {\\n    if (a[i] !== b[i]) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n};\\n\\n/**\\n * Sum the `byteLength` properties of the data in each AAC frame\\n */\\nsumFrameByteLengths = function(array) {\\n  var\\n    i,\\n    currentObj,\\n    sum = 0;\\n\\n  // sum the byteLength's all each nal unit in the frame\\n  for (i = 0; i < array.length; i++) {\\n    currentObj = array[i];\\n    sum += currentObj.data.byteLength;\\n  }\\n\\n  return sum;\\n};\\n\\n/**\\n * Constructs a single-track, ISO BMFF media segment from AAC data\\n * events. The output of this stream can be fed to a SourceBuffer\\n * configured with a suitable initialization segment.\\n */\\nAudioSegmentStream = function(track) {\\n  var\\n    adtsFrames = [],\\n    sequenceNumber = 0,\\n    earliestAllowedDts = 0;\\n\\n  AudioSegmentStream.prototype.init.call(this);\\n\\n  this.push = function(data) {\\n    collectDtsInfo(track, data);\\n\\n    if (track) {\\n      AUDIO_PROPERTIES.forEach(function(prop) {\\n        track[prop] = data[prop];\\n      });\\n    }\\n\\n    // buffer audio data until end() is called\\n    adtsFrames.push(data);\\n  };\\n\\n  this.setEarliestDts = function(earliestDts) {\\n    earliestAllowedDts = earliestDts - track.timelineStartInfo.baseMediaDecodeTime;\\n  };\\n\\n  this.flush = function() {\\n    var\\n      frames,\\n      moof,\\n      mdat,\\n      boxes;\\n\\n    // return early if no audio data has been observed\\n    if (adtsFrames.length === 0) {\\n      this.trigger('done', 'AudioSegmentStream');\\n      return;\\n    }\\n\\n    frames = this.trimAdtsFramesByEarliestDts_(adtsFrames);\\n\\n    // we have to build the index from byte locations to\\n    // samples (that is, adts frames) in the audio data\\n    track.samples = this.generateSampleTable_(frames);\\n\\n    // concatenate the audio data to constuct the mdat\\n    mdat = mp4.mdat(this.concatenateFrameData_(frames));\\n\\n    adtsFrames = [];\\n\\n    calculateTrackBaseMediaDecodeTime(track);\\n    moof = mp4.moof(sequenceNumber, [track]);\\n    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\\n\\n    // bump the sequence number for next time\\n    sequenceNumber++;\\n\\n    boxes.set(moof);\\n    boxes.set(mdat, moof.byteLength);\\n\\n    clearDtsInfo(track);\\n\\n    this.trigger('data', {track: track, boxes: boxes});\\n    this.trigger('done', 'AudioSegmentStream');\\n  };\\n\\n  // If the audio segment extends before the earliest allowed dts\\n  // value, remove AAC frames until starts at or after the earliest\\n  // allowed DTS so that we don't end up with a negative baseMedia-\\n  // DecodeTime for the audio track\\n  this.trimAdtsFramesByEarliestDts_ = function(adtsFrames) {\\n    if (track.minSegmentDts >= earliestAllowedDts) {\\n      return adtsFrames;\\n    }\\n\\n    // We will need to recalculate the earliest segment Dts\\n    track.minSegmentDts = Infinity;\\n\\n    return adtsFrames.filter(function(currentFrame) {\\n      // If this is an allowed frame, keep it and record it's Dts\\n      if (currentFrame.dts >= earliestAllowedDts) {\\n        track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);\\n        track.minSegmentPts = track.minSegmentDts;\\n        return true;\\n      }\\n      // Otherwise, discard it\\n      return false;\\n    });\\n  };\\n\\n  // generate the track's raw mdat data from an array of frames\\n  this.generateSampleTable_ = function(frames) {\\n    var\\n      i,\\n      currentFrame,\\n      samples = [];\\n\\n    for (i = 0; i < frames.length; i++) {\\n      currentFrame = frames[i];\\n      samples.push({\\n        size: currentFrame.data.byteLength,\\n        duration: 1024 // For AAC audio, all samples contain 1024 samples\\n      });\\n    }\\n    return samples;\\n  };\\n\\n  // generate the track's sample table from an array of frames\\n  this.concatenateFrameData_ = function(frames) {\\n    var\\n      i,\\n      currentFrame,\\n      dataOffset = 0,\\n      data = new Uint8Array(sumFrameByteLengths(frames));\\n\\n    for (i = 0; i < frames.length; i++) {\\n      currentFrame = frames[i];\\n\\n      data.set(currentFrame.data, dataOffset);\\n      dataOffset += currentFrame.data.byteLength;\\n    }\\n    return data;\\n  };\\n};\\n\\nAudioSegmentStream.prototype = new Stream();\\n\\n/**\\n * Constructs a single-track, ISO BMFF media segment from H264 data\\n * events. The output of this stream can be fed to a SourceBuffer\\n * configured with a suitable initialization segment.\\n * @param track {object} track metadata configuration\\n */\\nVideoSegmentStream = function(track) {\\n  var\\n    sequenceNumber = 0,\\n    nalUnits = [],\\n    config,\\n    pps;\\n\\n  VideoSegmentStream.prototype.init.call(this);\\n\\n  delete track.minPTS;\\n\\n  this.gopCache_ = [];\\n\\n  this.push = function(nalUnit) {\\n    collectDtsInfo(track, nalUnit);\\n\\n    // record the track config\\n    if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\\n      config = nalUnit.config;\\n      track.sps = [nalUnit.data];\\n\\n      VIDEO_PROPERTIES.forEach(function(prop) {\\n        track[prop] = config[prop];\\n      }, this);\\n    }\\n\\n    if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' &&\\n        !pps) {\\n      pps = nalUnit.data;\\n      track.pps = [nalUnit.data];\\n    }\\n\\n    // buffer video until flush() is called\\n    nalUnits.push(nalUnit);\\n  };\\n\\n  this.flush = function() {\\n    var\\n      frames,\\n      gopForFusion,\\n      gops,\\n      moof,\\n      mdat,\\n      boxes;\\n\\n    // Throw away nalUnits at the start of the byte stream until\\n    // we find the first AUD\\n    while (nalUnits.length) {\\n      if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\\n        break;\\n      }\\n      nalUnits.shift();\\n    }\\n\\n    // Return early if no video data has been observed\\n    if (nalUnits.length === 0) {\\n      this.resetStream_();\\n      this.trigger('done', 'VideoSegmentStream');\\n      return;\\n    }\\n\\n    // Organize the raw nal-units into arrays that represent\\n    // higher-level constructs such as frames and gops\\n    // (group-of-pictures)\\n    frames = this.groupNalsIntoFrames_(nalUnits);\\n    gops = this.groupFramesIntoGops_(frames);\\n\\n    // If the first frame of this fragment is not a keyframe we have\\n    // a problem since MSE (on Chrome) requires a leading keyframe.\\n    //\\n    // We have two approaches to repairing this situation:\\n    // 1) GOP-FUSION:\\n    //    This is where we keep track of the GOPS (group-of-pictures)\\n    //    from previous fragments and attempt to find one that we can\\n    //    prepend to the current fragment in order to create a valid\\n    //    fragment.\\n    // 2) KEYFRAME-PULLING:\\n    //    Here we search for the first keyframe in the fragment and\\n    //    throw away all the frames between the start of the fragment\\n    //    and that keyframe. We then extend the duration and pull the\\n    //    PTS of the keyframe forward so that it covers the time range\\n    //    of the frames that were disposed of.\\n    //\\n    // #1 is far prefereable over #2 which can cause \\\"stuttering\\\" but\\n    // requires more things to be just right.\\n    if (!gops[0][0].keyFrame) {\\n      // Search for a gop for fusion from our gopCache\\n      gopForFusion = this.getGopForFusion_(nalUnits[0], track);\\n\\n      if (gopForFusion) {\\n        gops.unshift(gopForFusion);\\n        // Adjust Gops' metadata to account for the inclusion of the\\n        // new gop at the beginning\\n        gops.byteLength += gopForFusion.byteLength;\\n        gops.nalCount += gopForFusion.nalCount;\\n        gops.pts = gopForFusion.pts;\\n        gops.dts = gopForFusion.dts;\\n        gops.duration += gopForFusion.duration;\\n      } else {\\n        // If we didn't find a candidate gop fall back to keyrame-pulling\\n        gops = this.extendFirstKeyFrame_(gops);\\n      }\\n    }\\n    collectDtsInfo(track, gops);\\n\\n    // First, we have to build the index from byte locations to\\n    // samples (that is, frames) in the video data\\n    track.samples = this.generateSampleTable_(gops);\\n\\n    // Concatenate the video data and construct the mdat\\n    mdat = mp4.mdat(this.concatenateNalData_(gops));\\n\\n    // save all the nals in the last GOP into the gop cache\\n    this.gopCache_.unshift({\\n      gop: gops.pop(),\\n      pps: track.pps,\\n      sps: track.sps\\n    });\\n\\n    // Keep a maximum of 6 GOPs in the cache\\n    this.gopCache_.length = Math.min(6, this.gopCache_.length);\\n\\n    // Clear nalUnits\\n    nalUnits = [];\\n\\n    calculateTrackBaseMediaDecodeTime(track);\\n\\n    this.trigger('timelineStartInfo', track.timelineStartInfo);\\n\\n    moof = mp4.moof(sequenceNumber, [track]);\\n\\n    // it would be great to allocate this array up front instead of\\n    // throwing away hundreds of media segment fragments\\n    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\\n\\n    // Bump the sequence number for next time\\n    sequenceNumber++;\\n\\n    boxes.set(moof);\\n    boxes.set(mdat, moof.byteLength);\\n\\n    this.trigger('data', {track: track, boxes: boxes});\\n\\n    this.resetStream_();\\n\\n    // Continue with the flush process now\\n    this.trigger('done', 'VideoSegmentStream');\\n  };\\n\\n  this.resetStream_ = function() {\\n    clearDtsInfo(track);\\n\\n    // reset config and pps because they may differ across segments\\n    // for instance, when we are rendition switching\\n    config = undefined;\\n    pps = undefined;\\n  };\\n\\n  // Search for a candidate Gop for gop-fusion from the gop cache and\\n  // return it or return null if no good candidate was found\\n  this.getGopForFusion_ = function(nalUnit) {\\n    var\\n      halfSecond = 45000, // Half-a-second in a 90khz clock\\n      allowableOverlap = 10000, // About 3 frames @ 30fps\\n      nearestDistance = Infinity,\\n      dtsDistance,\\n      nearestGopObj,\\n      currentGop,\\n      currentGopObj,\\n      i;\\n\\n    // Search for the GOP nearest to the beginning of this nal unit\\n    for (i = 0; i < this.gopCache_.length; i++) {\\n      currentGopObj = this.gopCache_[i];\\n      currentGop = currentGopObj.gop;\\n\\n      // Reject Gops with different SPS or PPS\\n      if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) ||\\n          !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {\\n        continue;\\n      }\\n\\n      // Reject Gops that would require a negative baseMediaDecodeTime\\n      if (currentGop.dts < track.timelineStartInfo.dts) {\\n        continue;\\n      }\\n\\n      // The distance between the end of the gop and the start of the nalUnit\\n      dtsDistance = (nalUnit.dts - currentGop.dts) - currentGop.duration;\\n\\n      // Only consider GOPS that start before the nal unit and end within\\n      // a half-second of the nal unit\\n      if (dtsDistance >= -allowableOverlap &&\\n          dtsDistance <= halfSecond) {\\n\\n        // Always use the closest GOP we found if there is more than\\n        // one candidate\\n        if (!nearestGopObj ||\\n            nearestDistance > dtsDistance) {\\n          nearestGopObj = currentGopObj;\\n          nearestDistance = dtsDistance;\\n        }\\n      }\\n    }\\n\\n    if (nearestGopObj) {\\n      return nearestGopObj.gop;\\n    }\\n    return null;\\n  };\\n\\n  this.extendFirstKeyFrame_ = function(gops) {\\n    var currentGop;\\n\\n    if (!gops[0][0].keyFrame) {\\n      // Remove the first GOP\\n      currentGop = gops.shift();\\n\\n      gops.byteLength -=  currentGop.byteLength;\\n      gops.nalCount -= currentGop.nalCount;\\n\\n      // Extend the first frame of what is now the\\n      // first gop to cover the time period of the\\n      // frames we just removed\\n      gops[0][0].dts = currentGop.dts;\\n      gops[0][0].pts = currentGop.pts;\\n      gops[0][0].duration += currentGop.duration;\\n    }\\n\\n    return gops;\\n  };\\n\\n  // Convert an array of nal units into an array of frames with each frame being\\n  // composed of the nal units that make up that frame\\n  // Also keep track of cummulative data about the frame from the nal units such\\n  // as the frame duration, starting pts, etc.\\n  this.groupNalsIntoFrames_ = function(nalUnits) {\\n    var\\n      i,\\n      currentNal,\\n      currentFrame = [],\\n      frames = [];\\n\\n    currentFrame.byteLength = 0;\\n\\n    for (i = 0; i < nalUnits.length; i++) {\\n      currentNal = nalUnits[i];\\n\\n      // Split on 'aud'-type nal units\\n      if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\\n        // Since the very first nal unit is expected to be an AUD\\n        // only push to the frames array when currentFrame is not empty\\n        if (currentFrame.length) {\\n          currentFrame.duration = currentNal.dts - currentFrame.dts;\\n          frames.push(currentFrame);\\n        }\\n        currentFrame = [currentNal];\\n        currentFrame.byteLength = currentNal.data.byteLength;\\n        currentFrame.pts = currentNal.pts;\\n        currentFrame.dts = currentNal.dts;\\n      } else {\\n        // Specifically flag key frames for ease of use later\\n        if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\\n          currentFrame.keyFrame = true;\\n        }\\n        currentFrame.duration = currentNal.dts - currentFrame.dts;\\n        currentFrame.byteLength += currentNal.data.byteLength;\\n        currentFrame.push(currentNal);\\n      }\\n    }\\n\\n    // For the last frame, use the duration of the previous frame if we\\n    // have nothing better to go on\\n    if (frames.length &&\\n        (!currentFrame.duration ||\\n         currentFrame.duration <= 0)) {\\n      currentFrame.duration = frames[frames.length - 1].duration;\\n    }\\n\\n    // Push the final frame\\n    frames.push(currentFrame);\\n    return frames;\\n  };\\n\\n  // Convert an array of frames into an array of Gop with each Gop being composed\\n  // of the frames that make up that Gop\\n  // Also keep track of cummulative data about the Gop from the frames such as the\\n  // Gop duration, starting pts, etc.\\n  this.groupFramesIntoGops_ = function(frames) {\\n    var\\n      i,\\n      currentFrame,\\n      currentGop = [],\\n      gops = [];\\n\\n    // We must pre-set some of the values on the Gop since we\\n    // keep running totals of these values\\n    currentGop.byteLength = 0;\\n    currentGop.nalCount = 0;\\n    currentGop.duration = 0;\\n    currentGop.pts = frames[0].pts;\\n    currentGop.dts = frames[0].dts;\\n\\n    // store some metadata about all the Gops\\n    gops.byteLength = 0;\\n    gops.nalCount = 0;\\n    gops.duration = 0;\\n    gops.pts = frames[0].pts;\\n    gops.dts = frames[0].dts;\\n\\n    for (i = 0; i < frames.length; i++) {\\n      currentFrame = frames[i];\\n\\n      if (currentFrame.keyFrame) {\\n        // Since the very first frame is expected to be an keyframe\\n        // only push to the gops array when currentGop is not empty\\n        if (currentGop.length) {\\n          gops.push(currentGop);\\n          gops.byteLength += currentGop.byteLength;\\n          gops.nalCount += currentGop.nalCount;\\n          gops.duration += currentGop.duration;\\n        }\\n\\n        currentGop = [currentFrame];\\n        currentGop.nalCount = currentFrame.length;\\n        currentGop.byteLength = currentFrame.byteLength;\\n        currentGop.pts = currentFrame.pts;\\n        currentGop.dts = currentFrame.dts;\\n        currentGop.duration = currentFrame.duration;\\n      } else {\\n        currentGop.duration += currentFrame.duration;\\n        currentGop.nalCount += currentFrame.length;\\n        currentGop.byteLength += currentFrame.byteLength;\\n        currentGop.push(currentFrame);\\n      }\\n    }\\n\\n    if (gops.length && currentGop.duration <= 0) {\\n      currentGop.duration = gops[gops.length - 1].duration;\\n    }\\n    gops.byteLength += currentGop.byteLength;\\n    gops.nalCount += currentGop.nalCount;\\n    gops.duration += currentGop.duration;\\n\\n    // push the final Gop\\n    gops.push(currentGop);\\n    return gops;\\n  };\\n\\n  // generate the track's sample table from an array of gops\\n  this.generateSampleTable_ = function(gops, baseDataOffset) {\\n    var\\n      h, i,\\n      sample,\\n      currentGop,\\n      currentFrame,\\n      dataOffset = baseDataOffset || 0,\\n      samples = [];\\n\\n    for (h = 0; h < gops.length; h++) {\\n      currentGop = gops[h];\\n\\n      for (i = 0; i < currentGop.length; i++) {\\n        currentFrame = currentGop[i];\\n\\n        sample = createDefaultSample();\\n\\n        sample.dataOffset = dataOffset;\\n        sample.compositionTimeOffset = currentFrame.pts - currentFrame.dts;\\n        sample.duration = currentFrame.duration;\\n        sample.size = 4 * currentFrame.length; // Space for nal unit size\\n        sample.size += currentFrame.byteLength;\\n\\n        if (currentFrame.keyFrame) {\\n          sample.flags.dependsOn = 2;\\n        }\\n\\n        dataOffset += sample.size;\\n\\n        samples.push(sample);\\n      }\\n    }\\n    return samples;\\n  };\\n\\n  // generate the track's raw mdat data from an array of gops\\n  this.concatenateNalData_ = function(gops) {\\n    var\\n      h, i, j,\\n      currentGop,\\n      currentFrame,\\n      currentNal,\\n      dataOffset = 0,\\n      nalsByteLength = gops.byteLength,\\n      numberOfNals = gops.nalCount,\\n      totalByteLength = nalsByteLength + 4 * numberOfNals,\\n      data = new Uint8Array(totalByteLength),\\n      view = new DataView(data.buffer);\\n\\n    // For each Gop..\\n    for (h = 0; h < gops.length; h++) {\\n      currentGop = gops[h];\\n\\n      // For each Frame..\\n      for (i = 0; i < currentGop.length; i++) {\\n        currentFrame = currentGop[i];\\n\\n        // For each NAL..\\n        for (j = 0; j < currentFrame.length; j++) {\\n          currentNal = currentFrame[j];\\n\\n          view.setUint32(dataOffset, currentNal.data.byteLength);\\n          dataOffset += 4;\\n          data.set(currentNal.data, dataOffset);\\n          dataOffset += currentNal.data.byteLength;\\n        }\\n      }\\n    }\\n    return data;\\n  };\\n};\\n\\nVideoSegmentStream.prototype = new Stream();\\n\\n/**\\n * Store information about the start and end of the track and the\\n * duration for each frame/sample we process in order to calculate\\n * the baseMediaDecodeTime\\n */\\ncollectDtsInfo = function(track, data) {\\n  if (typeof data.pts === 'number') {\\n    if (track.timelineStartInfo.pts === undefined) {\\n      track.timelineStartInfo.pts = data.pts;\\n    }\\n\\n    if (track.minSegmentPts === undefined) {\\n      track.minSegmentPts = data.pts;\\n    } else {\\n      track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);\\n    }\\n\\n    if (track.maxSegmentPts === undefined) {\\n      track.maxSegmentPts = data.pts;\\n    } else {\\n      track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);\\n    }\\n  }\\n\\n  if (typeof data.dts === 'number') {\\n    if (track.timelineStartInfo.dts === undefined) {\\n      track.timelineStartInfo.dts = data.dts;\\n    }\\n\\n    if (track.minSegmentDts === undefined) {\\n      track.minSegmentDts = data.dts;\\n    } else {\\n      track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);\\n    }\\n\\n    if (track.maxSegmentDts === undefined) {\\n      track.maxSegmentDts = data.dts;\\n    } else {\\n      track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);\\n    }\\n  }\\n};\\n\\n/**\\n * Clear values used to calculate the baseMediaDecodeTime between\\n * tracks\\n */\\nclearDtsInfo = function(track) {\\n  delete track.minSegmentDts;\\n  delete track.maxSegmentDts;\\n  delete track.minSegmentPts;\\n  delete track.maxSegmentPts;\\n};\\n\\n/**\\n * Calculate the track's baseMediaDecodeTime based on the earliest\\n * DTS the transmuxer has ever seen and the minimum DTS for the\\n * current track\\n */\\ncalculateTrackBaseMediaDecodeTime = function(track) {\\n  var\\n    oneSecondInPTS = 90000, // 90kHz clock\\n    scale,\\n    // Calculate the distance, in time, that this segment starts from the start\\n    // of the timeline (earliest time seen since the transmuxer initialized)\\n    timeSinceStartOfTimeline = track.minSegmentDts - track.timelineStartInfo.dts,\\n    // Calculate the first sample's effective compositionTimeOffset\\n    firstSampleCompositionOffset = track.minSegmentPts - track.minSegmentDts;\\n\\n  // track.timelineStartInfo.baseMediaDecodeTime is the location, in time, where\\n  // we want the start of the first segment to be placed\\n  track.baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime;\\n\\n  // Add to that the distance this segment is from the very first\\n  track.baseMediaDecodeTime += timeSinceStartOfTimeline;\\n\\n  // Subtract this segment's \\\"compositionTimeOffset\\\" so that the first frame of\\n  // this segment is displayed exactly at the `baseMediaDecodeTime` or at the\\n  // end of the previous segment\\n  track.baseMediaDecodeTime -= firstSampleCompositionOffset;\\n\\n  // baseMediaDecodeTime must not become negative\\n  track.baseMediaDecodeTime = Math.max(0, track.baseMediaDecodeTime);\\n\\n  if (track.type === 'audio') {\\n    // Audio has a different clock equal to the sampling_rate so we need to\\n    // scale the PTS values into the clock rate of the track\\n    scale = track.samplerate / oneSecondInPTS;\\n    track.baseMediaDecodeTime *= scale;\\n    track.baseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime);\\n  }\\n};\\n\\n/**\\n * A Stream that can combine multiple streams (ie. audio & video)\\n * into a single output segment for MSE. Also supports audio-only\\n * and video-only streams.\\n */\\nCoalesceStream = function(options, metadataStream) {\\n  // Number of Tracks per output segment\\n  // If greater than 1, we combine multiple\\n  // tracks into a single segment\\n  this.numberOfTracks = 0;\\n  this.metadataStream = metadataStream;\\n\\n  if (typeof options.remux !== 'undefined') {\\n    this.remuxTracks = !!options.remux;\\n  } else {\\n    this.remuxTracks = true;\\n  }\\n\\n  this.pendingTracks = [];\\n  this.videoTrack = null;\\n  this.pendingBoxes = [];\\n  this.pendingCaptions = [];\\n  this.pendingMetadata = [];\\n  this.pendingBytes = 0;\\n  this.emittedTracks = 0;\\n\\n  CoalesceStream.prototype.init.call(this);\\n\\n  // Take output from multiple\\n  this.push = function(output) {\\n    // buffer incoming captions until the associated video segment\\n    // finishes\\n    if (output.text) {\\n      return this.pendingCaptions.push(output);\\n    }\\n    // buffer incoming id3 tags until the final flush\\n    if (output.frames) {\\n      return this.pendingMetadata.push(output);\\n    }\\n\\n    // Add this track to the list of pending tracks and store\\n    // important information required for the construction of\\n    // the final segment\\n    this.pendingTracks.push(output.track);\\n    this.pendingBoxes.push(output.boxes);\\n    this.pendingBytes += output.boxes.byteLength;\\n\\n    if (output.track.type === 'video') {\\n      this.videoTrack = output.track;\\n    }\\n    if (output.track.type === 'audio') {\\n      this.audioTrack = output.track;\\n    }\\n  };\\n};\\n\\nCoalesceStream.prototype = new Stream();\\nCoalesceStream.prototype.flush = function(flushSource) {\\n  var\\n    offset = 0,\\n    event = {\\n      captions: [],\\n      metadata: [],\\n      info: {}\\n    },\\n    caption,\\n    id3,\\n    initSegment,\\n    timelineStartPts = 0,\\n    i;\\n\\n  if (this.pendingTracks.length < this.numberOfTracks) {\\n    if (flushSource !== 'VideoSegmentStream' &&\\n        flushSource !== 'AudioSegmentStream') {\\n      // Return because we haven't received a flush from a data-generating\\n      // portion of the segment (meaning that we have only recieved meta-data\\n      // or captions.)\\n      return;\\n    } else if (this.remuxTracks) {\\n      // Return until we have enough tracks from the pipeline to remux (if we\\n      // are remuxing audio and video into a single MP4)\\n      return;\\n    } else if (this.pendingTracks.length === 0) {\\n      // In the case where we receive a flush without any data having been\\n      // received we consider it an emitted track for the purposes of coalescing\\n      // `done` events.\\n      // We do this for the case where there is an audio and video track in the\\n      // segment but no audio data. (seen in several playlists with alternate\\n      // audio tracks and no audio present in the main TS segments.)\\n      this.emittedTracks++;\\n\\n      if (this.emittedTracks >= this.numberOfTracks) {\\n        this.trigger('done');\\n        this.emittedTracks = 0;\\n      }\\n      return;\\n    }\\n  }\\n\\n  if (this.videoTrack) {\\n    timelineStartPts = this.videoTrack.timelineStartInfo.pts;\\n    VIDEO_PROPERTIES.forEach(function(prop) {\\n      event.info[prop] = this.videoTrack[prop];\\n    }, this);\\n  } else if (this.audioTrack) {\\n    timelineStartPts = this.audioTrack.timelineStartInfo.pts;\\n    AUDIO_PROPERTIES.forEach(function(prop) {\\n      event.info[prop] = this.audioTrack[prop];\\n    }, this);\\n  }\\n\\n  if (this.pendingTracks.length === 1) {\\n    event.type = this.pendingTracks[0].type;\\n  } else {\\n    event.type = 'combined';\\n  }\\n\\n  this.emittedTracks += this.pendingTracks.length;\\n\\n  initSegment = mp4.initSegment(this.pendingTracks);\\n\\n  // Create a new typed array large enough to hold the init\\n  // segment and all tracks\\n  event.data = new Uint8Array(initSegment.byteLength +\\n                              this.pendingBytes);\\n\\n  // Create an init segment containing a moov\\n  // and track definitions\\n  event.data.set(initSegment);\\n  offset += initSegment.byteLength;\\n\\n  // Append each moof+mdat (one per track) after the init segment\\n  for (i = 0; i < this.pendingBoxes.length; i++) {\\n    event.data.set(this.pendingBoxes[i], offset);\\n    offset += this.pendingBoxes[i].byteLength;\\n  }\\n\\n  // Translate caption PTS times into second offsets into the\\n  // video timeline for the segment\\n  for (i = 0; i < this.pendingCaptions.length; i++) {\\n    caption = this.pendingCaptions[i];\\n    caption.startTime = (caption.startPts - timelineStartPts);\\n    caption.startTime /= 90e3;\\n    caption.endTime = (caption.endPts - timelineStartPts);\\n    caption.endTime /= 90e3;\\n    event.captions.push(caption);\\n  }\\n\\n  // Translate ID3 frame PTS times into second offsets into the\\n  // video timeline for the segment\\n  for (i = 0; i < this.pendingMetadata.length; i++) {\\n    id3 = this.pendingMetadata[i];\\n    id3.cueTime = (id3.pts - timelineStartPts);\\n    id3.cueTime /= 90e3;\\n    event.metadata.push(id3);\\n  }\\n  // We add this to every single emitted segment even though we only need\\n  // it for the first\\n  event.metadata.dispatchType = this.metadataStream.dispatchType;\\n\\n  // Reset stream state\\n  this.pendingTracks.length = 0;\\n  this.videoTrack = null;\\n  this.pendingBoxes.length = 0;\\n  this.pendingCaptions.length = 0;\\n  this.pendingBytes = 0;\\n  this.pendingMetadata.length = 0;\\n\\n  // Emit the built segment\\n  this.trigger('data', event);\\n\\n  // Only emit `done` if all tracks have been flushed and emitted\\n  if (this.emittedTracks >= this.numberOfTracks) {\\n    this.trigger('done');\\n    this.emittedTracks = 0;\\n  }\\n};\\n/**\\n * A Stream that expects MP2T binary data as input and produces\\n * corresponding media segments, suitable for use with Media Source\\n * Extension (MSE) implementations that support the ISO BMFF byte\\n * stream format, like Chrome.\\n */\\nTransmuxer = function(options) {\\n  var\\n    self = this,\\n    hasFlushed = true,\\n    videoTrack,\\n    audioTrack;\\n\\n  Transmuxer.prototype.init.call(this);\\n\\n  options = options || {};\\n  this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\\n  this.transmuxPipeline_ = {};\\n\\n  this.setupAacPipeline = function() {\\n    var pipeline = {};\\n    this.transmuxPipeline_ = pipeline;\\n\\n    pipeline.type = 'aac';\\n    pipeline.metadataStream = new m2ts.MetadataStream();\\n\\n    // set up the parsing pipeline\\n    pipeline.aacStream = new AacStream();\\n    pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\\n    pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\\n    pipeline.adtsStream = new AdtsStream();\\n    pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\\n    pipeline.headOfPipeline = pipeline.aacStream;\\n\\n    pipeline.aacStream\\n      .pipe(pipeline.audioTimestampRolloverStream)\\n      .pipe(pipeline.adtsStream);\\n    pipeline.aacStream\\n      .pipe(pipeline.timedMetadataTimestampRolloverStream)\\n      .pipe(pipeline.metadataStream)\\n      .pipe(pipeline.coalesceStream);\\n\\n    pipeline.metadataStream.on('timestamp', function(frame) {\\n      pipeline.aacStream.setTimestamp(frame.timeStamp);\\n    });\\n\\n    pipeline.aacStream.on('data', function(data) {\\n      if (data.type === 'timed-metadata' && !pipeline.audioSegmentStream) {\\n        audioTrack = audioTrack || {\\n          timelineStartInfo: {\\n            baseMediaDecodeTime: self.baseMediaDecodeTime\\n          },\\n          codec: 'adts',\\n          type: 'audio'\\n        };\\n        // hook up the audio segment stream to the first track with aac data\\n        pipeline.coalesceStream.numberOfTracks++;\\n        pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack);\\n        // Set up the final part of the audio pipeline\\n        pipeline.adtsStream\\n          .pipe(pipeline.audioSegmentStream)\\n          .pipe(pipeline.coalesceStream);\\n      }\\n    });\\n\\n    // Re-emit any data coming from the coalesce stream to the outside world\\n    pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\\n    // Let the consumer know we have finished flushing the entire pipeline\\n    pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\\n  };\\n\\n  this.setupTsPipeline = function() {\\n    var pipeline = {};\\n    this.transmuxPipeline_ = pipeline;\\n\\n    pipeline.type = 'ts';\\n    pipeline.metadataStream = new m2ts.MetadataStream();\\n\\n    // set up the parsing pipeline\\n    pipeline.packetStream = new m2ts.TransportPacketStream();\\n    pipeline.parseStream = new m2ts.TransportParseStream();\\n    pipeline.elementaryStream = new m2ts.ElementaryStream();\\n    pipeline.videoTimestampRolloverStream = new m2ts.TimestampRolloverStream('video');\\n    pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\\n    pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\\n    pipeline.adtsStream = new AdtsStream();\\n    pipeline.h264Stream = new H264Stream();\\n    pipeline.captionStream = new m2ts.CaptionStream();\\n    pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\\n    pipeline.headOfPipeline = pipeline.packetStream;\\n\\n    // disassemble MPEG2-TS packets into elementary streams\\n    pipeline.packetStream\\n      .pipe(pipeline.parseStream)\\n      .pipe(pipeline.elementaryStream);\\n\\n    // !!THIS ORDER IS IMPORTANT!!\\n    // demux the streams\\n    pipeline.elementaryStream\\n      .pipe(pipeline.videoTimestampRolloverStream)\\n      .pipe(pipeline.h264Stream);\\n    pipeline.elementaryStream\\n      .pipe(pipeline.audioTimestampRolloverStream)\\n      .pipe(pipeline.adtsStream);\\n\\n    pipeline.elementaryStream\\n      .pipe(pipeline.timedMetadataTimestampRolloverStream)\\n      .pipe(pipeline.metadataStream)\\n      .pipe(pipeline.coalesceStream);\\n\\n    // Hook up CEA-608/708 caption stream\\n    pipeline.h264Stream.pipe(pipeline.captionStream)\\n      .pipe(pipeline.coalesceStream);\\n\\n    pipeline.elementaryStream.on('data', function(data) {\\n      var i;\\n\\n      if (data.type === 'metadata') {\\n        i = data.tracks.length;\\n\\n        // scan the tracks listed in the metadata\\n        while (i--) {\\n          if (!videoTrack && data.tracks[i].type === 'video') {\\n            videoTrack = data.tracks[i];\\n            videoTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\\n          } else if (!audioTrack && data.tracks[i].type === 'audio') {\\n            audioTrack = data.tracks[i];\\n            audioTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\\n          }\\n        }\\n\\n        // hook up the video segment stream to the first track with h264 data\\n        if (videoTrack && !pipeline.videoSegmentStream) {\\n          pipeline.coalesceStream.numberOfTracks++;\\n          pipeline.videoSegmentStream = new VideoSegmentStream(videoTrack);\\n\\n          pipeline.videoSegmentStream.on('timelineStartInfo', function(timelineStartInfo) {\\n          // When video emits timelineStartInfo data after a flush, we forward that\\n          // info to the AudioSegmentStream, if it exists, because video timeline\\n          // data takes precedence.\\n            if (audioTrack) {\\n              audioTrack.timelineStartInfo = timelineStartInfo;\\n              // On the first segment we trim AAC frames that exist before the\\n              // very earliest DTS we have seen in video because Chrome will\\n              // interpret any video track with a baseMediaDecodeTime that is\\n              // non-zero as a gap.\\n              pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts);\\n            }\\n          });\\n\\n          // Set up the final part of the video pipeline\\n          pipeline.h264Stream\\n            .pipe(pipeline.videoSegmentStream)\\n            .pipe(pipeline.coalesceStream);\\n        }\\n\\n        if (audioTrack && !pipeline.audioSegmentStream) {\\n          // hook up the audio segment stream to the first track with aac data\\n          pipeline.coalesceStream.numberOfTracks++;\\n          pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack);\\n\\n          // Set up the final part of the audio pipeline\\n          pipeline.adtsStream\\n            .pipe(pipeline.audioSegmentStream)\\n            .pipe(pipeline.coalesceStream);\\n        }\\n      }\\n    });\\n\\n    // Re-emit any data coming from the coalesce stream to the outside world\\n    pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\\n    // Let the consumer know we have finished flushing the entire pipeline\\n    pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\\n  };\\n\\n  // hook up the segment streams once track metadata is delivered\\n  this.setBaseMediaDecodeTime = function(baseMediaDecodeTime) {\\n    var pipeline = this.transmuxPipeline_;\\n\\n    this.baseMediaDecodeTime = baseMediaDecodeTime;\\n    if (audioTrack) {\\n      audioTrack.timelineStartInfo.dts = undefined;\\n      audioTrack.timelineStartInfo.pts = undefined;\\n      clearDtsInfo(audioTrack);\\n      audioTrack.timelineStartInfo.baseMediaDecodeTime = baseMediaDecodeTime;\\n    }\\n    if (videoTrack) {\\n      if (pipeline.videoSegmentStream) {\\n        pipeline.videoSegmentStream.gopCache_ = [];\\n      }\\n      videoTrack.timelineStartInfo.dts = undefined;\\n      videoTrack.timelineStartInfo.pts = undefined;\\n      clearDtsInfo(videoTrack);\\n      videoTrack.timelineStartInfo.baseMediaDecodeTime = baseMediaDecodeTime;\\n    }\\n  };\\n\\n  // feed incoming data to the front of the parsing pipeline\\n  this.push = function(data) {\\n    if (hasFlushed) {\\n      var isAac = isLikelyAacData(data);\\n\\n      if (isAac && this.transmuxPipeline_.type !== 'aac') {\\n        this.setupAacPipeline();\\n      } else if (!isAac && this.transmuxPipeline_.type !== 'ts') {\\n        this.setupTsPipeline();\\n      }\\n      hasFlushed = false;\\n    }\\n    this.transmuxPipeline_.headOfPipeline.push(data);\\n  };\\n\\n  // flush any buffered data\\n  this.flush = function() {\\n      hasFlushed = true;\\n    // Start at the top of the pipeline and flush all pending work\\n    this.transmuxPipeline_.headOfPipeline.flush();\\n  };\\n};\\nTransmuxer.prototype = new Stream();\\n\\nmodule.exports = {\\n  Transmuxer: Transmuxer,\\n  VideoSegmentStream: VideoSegmentStream,\\n  AudioSegmentStream: AudioSegmentStream,\\n  AUDIO_PROPERTIES: AUDIO_PROPERTIES,\\n  VIDEO_PROPERTIES: VIDEO_PROPERTIES\\n};\\n\\n},{\\\"../aac\\\":79,\\\"../codecs/adts.js\\\":80,\\\"../codecs/h264\\\":81,\\\"../m2ts/m2ts.js\\\":86,\\\"../utils/stream.js\\\":94,\\\"./mp4-generator.js\\\":91}],93:[function(require,module,exports){\\n'use strict';\\n\\nvar ExpGolomb;\\n\\n/**\\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding\\n * scheme used by h264.\\n */\\nExpGolomb = function(workingData) {\\n  var\\n    // the number of bytes left to examine in workingData\\n    workingBytesAvailable = workingData.byteLength,\\n\\n    // the current word being examined\\n    workingWord = 0, // :uint\\n\\n    // the number of bits left to examine in the current word\\n    workingBitsAvailable = 0; // :uint;\\n\\n  // ():uint\\n  this.length = function() {\\n    return (8 * workingBytesAvailable);\\n  };\\n\\n  // ():uint\\n  this.bitsAvailable = function() {\\n    return (8 * workingBytesAvailable) + workingBitsAvailable;\\n  };\\n\\n  // ():void\\n  this.loadWord = function() {\\n    var\\n      position = workingData.byteLength - workingBytesAvailable,\\n      workingBytes = new Uint8Array(4),\\n      availableBytes = Math.min(4, workingBytesAvailable);\\n\\n    if (availableBytes === 0) {\\n      throw new Error('no bytes available');\\n    }\\n\\n    workingBytes.set(workingData.subarray(position,\\n                                          position + availableBytes));\\n    workingWord = new DataView(workingBytes.buffer).getUint32(0);\\n\\n    // track the amount of workingData that has been processed\\n    workingBitsAvailable = availableBytes * 8;\\n    workingBytesAvailable -= availableBytes;\\n  };\\n\\n  // (count:int):void\\n  this.skipBits = function(count) {\\n    var skipBytes; // :int\\n    if (workingBitsAvailable > count) {\\n      workingWord          <<= count;\\n      workingBitsAvailable -= count;\\n    } else {\\n      count -= workingBitsAvailable;\\n      skipBytes = Math.floor(count / 8);\\n\\n      count -= (skipBytes * 8);\\n      workingBytesAvailable -= skipBytes;\\n\\n      this.loadWord();\\n\\n      workingWord <<= count;\\n      workingBitsAvailable -= count;\\n    }\\n  };\\n\\n  // (size:int):uint\\n  this.readBits = function(size) {\\n    var\\n      bits = Math.min(workingBitsAvailable, size), // :uint\\n      valu = workingWord >>> (32 - bits); // :uint\\n    // if size > 31, handle error\\n    workingBitsAvailable -= bits;\\n    if (workingBitsAvailable > 0) {\\n      workingWord <<= bits;\\n    } else if (workingBytesAvailable > 0) {\\n      this.loadWord();\\n    }\\n\\n    bits = size - bits;\\n    if (bits > 0) {\\n      return valu << bits | this.readBits(bits);\\n    }\\n    return valu;\\n  };\\n\\n  // ():uint\\n  this.skipLeadingZeros = function() {\\n    var leadingZeroCount; // :uint\\n    for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {\\n      if ((workingWord & (0x80000000 >>> leadingZeroCount)) !== 0) {\\n        // the first bit of working word is 1\\n        workingWord <<= leadingZeroCount;\\n        workingBitsAvailable -= leadingZeroCount;\\n        return leadingZeroCount;\\n      }\\n    }\\n\\n    // we exhausted workingWord and still have not found a 1\\n    this.loadWord();\\n    return leadingZeroCount + this.skipLeadingZeros();\\n  };\\n\\n  // ():void\\n  this.skipUnsignedExpGolomb = function() {\\n    this.skipBits(1 + this.skipLeadingZeros());\\n  };\\n\\n  // ():void\\n  this.skipExpGolomb = function() {\\n    this.skipBits(1 + this.skipLeadingZeros());\\n  };\\n\\n  // ():uint\\n  this.readUnsignedExpGolomb = function() {\\n    var clz = this.skipLeadingZeros(); // :uint\\n    return this.readBits(clz + 1) - 1;\\n  };\\n\\n  // ():int\\n  this.readExpGolomb = function() {\\n    var valu = this.readUnsignedExpGolomb(); // :int\\n    if (0x01 & valu) {\\n      // the number is odd if the low order bit is set\\n      return (1 + valu) >>> 1; // add 1 to make it even, and divide by 2\\n    }\\n    return -1 * (valu >>> 1); // divide by two then make it negative\\n  };\\n\\n  // Some convenience functions\\n  // :Boolean\\n  this.readBoolean = function() {\\n    return this.readBits(1) === 1;\\n  };\\n\\n  // ():int\\n  this.readUnsignedByte = function() {\\n    return this.readBits(8);\\n  };\\n\\n  this.loadWord();\\n};\\n\\nmodule.exports = ExpGolomb;\\n\\n},{}],94:[function(require,module,exports){\\n/**\\n * mux.js\\n *\\n * Copyright (c) 2014 Brightcove\\n * All rights reserved.\\n *\\n * A lightweight readable stream implemention that handles event dispatching.\\n * Objects that inherit from streams should call init in their constructors.\\n */\\n'use strict';\\n\\nvar Stream = function() {\\n  this.init = function() {\\n    var listeners = {};\\n    /**\\n     * Add a listener for a specified event type.\\n     * @param type {string} the event name\\n     * @param listener {function} the callback to be invoked when an event of\\n     * the specified type occurs\\n     */\\n    this.on = function(type, listener) {\\n      if (!listeners[type]) {\\n        listeners[type] = [];\\n      }\\n      listeners[type].push(listener);\\n    };\\n    /**\\n     * Remove a listener for a specified event type.\\n     * @param type {string} the event name\\n     * @param listener {function} a function previously registered for this\\n     * type of event through `on`\\n     */\\n    this.off = function(type, listener) {\\n      var index;\\n      if (!listeners[type]) {\\n        return false;\\n      }\\n      index = listeners[type].indexOf(listener);\\n      listeners[type].splice(index, 1);\\n      return index > -1;\\n    };\\n    /**\\n     * Trigger an event of the specified type on this stream. Any additional\\n     * arguments to this function are passed as parameters to event listeners.\\n     * @param type {string} the event name\\n     */\\n    this.trigger = function(type) {\\n      var callbacks, i, length, args;\\n      callbacks = listeners[type];\\n      if (!callbacks) {\\n        return;\\n      }\\n      // Slicing the arguments on every invocation of this method\\n      // can add a significant amount of overhead. Avoid the\\n      // intermediate object creation for the common case of a\\n      // single callback argument\\n      if (arguments.length === 2) {\\n        length = callbacks.length;\\n        for (i = 0; i < length; ++i) {\\n          callbacks[i].call(this, arguments[1]);\\n        }\\n      } else {\\n        args = [];\\n        i = arguments.length;\\n        for (i = 1; i < arguments.length; ++i) {\\n          args.push(arguments[i]);\\n        }\\n        length = callbacks.length;\\n        for (i = 0; i < length; ++i) {\\n          callbacks[i].apply(this, args);\\n        }\\n      }\\n    };\\n    /**\\n     * Destroys the stream and cleans up.\\n     */\\n    this.dispose = function() {\\n      listeners = {};\\n    };\\n  };\\n};\\n\\n/**\\n * Forwards all `data` events on this stream to the destination stream. The\\n * destination stream should provide a method `push` to receive the data\\n * events as they arrive.\\n * @param destination {stream} the stream that will receive all `data` events\\n * @param autoFlush {boolean} if false, we will not call `flush` on the destination\\n *                            when the current stream emits a 'done' event\\n * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\\n */\\nStream.prototype.pipe = function(destination) {\\n  this.on('data', function(data) {\\n    destination.push(data);\\n  });\\n\\n  this.on('done', function(flushSource) {\\n    destination.flush(flushSource);\\n  });\\n\\n  return destination;\\n};\\n\\n// Default stream functions that are expected to be overridden to perform\\n// actual work. These are provided by the prototype as a sort of no-op\\n// implementation so that we don't have to check for their existence in the\\n// `pipe` function above.\\nStream.prototype.push = function(data) {\\n  this.trigger('data', data);\\n};\\n\\nStream.prototype.flush = function(flushSource) {\\n  this.trigger('done', flushSource);\\n};\\n\\nmodule.exports = Stream;\\n\\n},{}],95:[function(require,module,exports){\\nvar bundleFn = arguments[3];\\nvar sources = arguments[4];\\nvar cache = arguments[5];\\n\\nvar stringify = JSON.stringify;\\n\\nmodule.exports = function (fn) {\\n    var keys = [];\\n    var wkey;\\n    var cacheKeys = Object.keys(cache);\\n\\n    for (var i = 0, l = cacheKeys.length; i < l; i++) {\\n        var key = cacheKeys[i];\\n        if (cache[key].exports === fn) {\\n            wkey = key;\\n            break;\\n        }\\n    }\\n\\n    if (!wkey) {\\n        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\\n        var wcache = {};\\n        for (var i = 0, l = cacheKeys.length; i < l; i++) {\\n            var key = cacheKeys[i];\\n            wcache[key] = key;\\n        }\\n        sources[wkey] = [\\n            Function(['require','module','exports'], '(' + fn + ')(self)'),\\n            wcache\\n        ];\\n    }\\n    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\\n\\n    var scache = {}; scache[wkey] = wkey;\\n    sources[skey] = [\\n        Function(['require'],'require(' + stringify(wkey) + ')(self)'),\\n        scache\\n    ];\\n\\n    var src = '(' + bundleFn + ')({'\\n        + Object.keys(sources).map(function (key) {\\n            return stringify(key) + ':['\\n                + sources[key][0]\\n                + ',' + stringify(sources[key][1]) + ']'\\n            ;\\n        }).join(',')\\n        + '},{},[' + stringify(skey) + '])'\\n    ;\\n\\n    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\\n\\n    return new Worker(URL.createObjectURL(\\n        new Blob([src], { type: 'text/javascript' })\\n    ));\\n};\\n\\n},{}],96:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file videojs-contrib-hls.js\\n *\\n * The main file for the HLS project.\\n * License: https://github.com/videojs/videojs-contrib-hls/blob/master/LICENSE\\n */\\n'use strict';\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _globalDocument = require('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _playlistLoader = require('./playlist-loader');\\n\\nvar _playlistLoader2 = _interopRequireDefault(_playlistLoader);\\n\\nvar _playlist = require('./playlist');\\n\\nvar _playlist2 = _interopRequireDefault(_playlist);\\n\\nvar _xhr = require('./xhr');\\n\\nvar _xhr2 = _interopRequireDefault(_xhr);\\n\\nvar _aesDecrypter = require('aes-decrypter');\\n\\nvar _binUtils = require('./bin-utils');\\n\\nvar _binUtils2 = _interopRequireDefault(_binUtils);\\n\\nvar _videojsContribMediaSources = require('videojs-contrib-media-sources');\\n\\nvar _m3u8Parser = require('m3u8-parser');\\n\\nvar _m3u8Parser2 = _interopRequireDefault(_m3u8Parser);\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\nvar _masterPlaylistController = require('./master-playlist-controller');\\n\\nvar _masterPlaylistController2 = _interopRequireDefault(_masterPlaylistController);\\n\\nvar _config = require('./config');\\n\\nvar _config2 = _interopRequireDefault(_config);\\n\\nvar _renditionMixin = require('./rendition-mixin');\\n\\nvar _renditionMixin2 = _interopRequireDefault(_renditionMixin);\\n\\nvar _gapSkipper = require('./gap-skipper');\\n\\nvar _gapSkipper2 = _interopRequireDefault(_gapSkipper);\\n\\nvar _globalWindow = require('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\n/**\\n * determine if an object a is differnt from\\n * and object b. both only having one dimensional\\n * properties\\n *\\n * @param {Object} a object one\\n * @param {Object} b object two\\n * @return {Boolean} if the object has changed or not\\n */\\nvar objectChanged = function objectChanged(a, b) {\\n  if (typeof a !== typeof b) {\\n    return true;\\n  }\\n  // if we have a different number of elements\\n  // something has changed\\n  if (Object.keys(a).length !== Object.keys(b).length) {\\n    return true;\\n  }\\n\\n  for (var prop in a) {\\n    if (!b[prop] || a[prop] !== b[prop]) {\\n      return true;\\n    }\\n  }\\n  return false;\\n};\\n\\nvar Hls = {\\n  PlaylistLoader: _playlistLoader2['default'],\\n  Playlist: _playlist2['default'],\\n  Decrypter: _aesDecrypter.Decrypter,\\n  AsyncStream: _aesDecrypter.AsyncStream,\\n  decrypt: _aesDecrypter.decrypt,\\n  utils: _binUtils2['default'],\\n  xhr: (0, _xhr2['default'])()\\n};\\n\\nObject.defineProperty(Hls, 'GOAL_BUFFER_LENGTH', {\\n  get: function get() {\\n    _videoJs2['default'].log.warn('using Hls.GOAL_BUFFER_LENGTH is UNSAFE be sure ' + 'you know what you are doing');\\n    return _config2['default'].GOAL_BUFFER_LENGTH;\\n  },\\n  set: function set(v) {\\n    _videoJs2['default'].log.warn('using Hls.GOAL_BUFFER_LENGTH is UNSAFE be sure ' + 'you know what you are doing');\\n    if (typeof v !== 'number' || v <= 0) {\\n      _videoJs2['default'].log.warn('value passed to Hls.GOAL_BUFFER_LENGTH ' + 'must be a number and greater than 0');\\n      return;\\n    }\\n    _config2['default'].GOAL_BUFFER_LENGTH = v;\\n  }\\n});\\n\\n// A fudge factor to apply to advertised playlist bitrates to account for\\n// temporary flucations in client bandwidth\\nvar BANDWIDTH_VARIANCE = 1.2;\\n\\n/**\\n * Returns the CSS value for the specified property on an element\\n * using `getComputedStyle`. Firefox has a long-standing issue where\\n * getComputedStyle() may return null when running in an iframe with\\n * `display: none`.\\n *\\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=548397\\n * @param {HTMLElement} el the htmlelement to work on\\n * @param {string} the proprety to get the style for\\n */\\nvar safeGetComputedStyle = function safeGetComputedStyle(el, property) {\\n  var result = undefined;\\n\\n  if (!el) {\\n    return '';\\n  }\\n\\n  result = _globalWindow2['default'].getComputedStyle(el);\\n  if (!result) {\\n    return '';\\n  }\\n\\n  return result[property];\\n};\\n\\n/**\\n * Chooses the appropriate media playlist based on the current\\n * bandwidth estimate and the player size.\\n *\\n * @return {Playlist} the highest bitrate playlist less than the currently detected\\n * bandwidth, accounting for some amount of bandwidth variance\\n */\\nHls.STANDARD_PLAYLIST_SELECTOR = function () {\\n  var effectiveBitrate = undefined;\\n  var sortedPlaylists = this.playlists.master.playlists.slice();\\n  var bandwidthPlaylists = [];\\n  var now = +new Date();\\n  var i = undefined;\\n  var variant = undefined;\\n  var bandwidthBestVariant = undefined;\\n  var resolutionPlusOne = undefined;\\n  var resolutionPlusOneAttribute = undefined;\\n  var resolutionBestVariant = undefined;\\n  var width = undefined;\\n  var height = undefined;\\n\\n  sortedPlaylists.sort(Hls.comparePlaylistBandwidth);\\n\\n  // filter out any playlists that have been excluded due to\\n  // incompatible configurations or playback errors\\n  sortedPlaylists = sortedPlaylists.filter(function (localVariant) {\\n    if (typeof localVariant.excludeUntil !== 'undefined') {\\n      return now >= localVariant.excludeUntil;\\n    }\\n    return true;\\n  });\\n\\n  // filter out any variant that has greater effective bitrate\\n  // than the current estimated bandwidth\\n  i = sortedPlaylists.length;\\n  while (i--) {\\n    variant = sortedPlaylists[i];\\n\\n    // ignore playlists without bandwidth information\\n    if (!variant.attributes || !variant.attributes.BANDWIDTH) {\\n      continue;\\n    }\\n\\n    effectiveBitrate = variant.attributes.BANDWIDTH * BANDWIDTH_VARIANCE;\\n\\n    if (effectiveBitrate < this.bandwidth) {\\n      bandwidthPlaylists.push(variant);\\n\\n      // since the playlists are sorted in ascending order by\\n      // bandwidth, the first viable variant is the best\\n      if (!bandwidthBestVariant) {\\n        bandwidthBestVariant = variant;\\n      }\\n    }\\n  }\\n\\n  i = bandwidthPlaylists.length;\\n\\n  // sort variants by resolution\\n  bandwidthPlaylists.sort(Hls.comparePlaylistResolution);\\n\\n  // forget our old variant from above,\\n  // or we might choose that in high-bandwidth scenarios\\n  // (this could be the lowest bitrate rendition as  we go through all of them above)\\n  variant = null;\\n\\n  width = parseInt(safeGetComputedStyle(this.tech_.el(), 'width'), 10);\\n  height = parseInt(safeGetComputedStyle(this.tech_.el(), 'height'), 10);\\n\\n  // iterate through the bandwidth-filtered playlists and find\\n  // best rendition by player dimension\\n  while (i--) {\\n    variant = bandwidthPlaylists[i];\\n\\n    // ignore playlists without resolution information\\n    if (!variant.attributes || !variant.attributes.RESOLUTION || !variant.attributes.RESOLUTION.width || !variant.attributes.RESOLUTION.height) {\\n      continue;\\n    }\\n\\n    // since the playlists are sorted, the first variant that has\\n    // dimensions less than or equal to the player size is the best\\n    var variantResolution = variant.attributes.RESOLUTION;\\n\\n    if (variantResolution.width === width && variantResolution.height === height) {\\n      // if we have the exact resolution as the player use it\\n      resolutionPlusOne = null;\\n      resolutionBestVariant = variant;\\n      break;\\n    } else if (variantResolution.width < width && variantResolution.height < height) {\\n      // if both dimensions are less than the player use the\\n      // previous (next-largest) variant\\n      break;\\n    } else if (!resolutionPlusOne || variantResolution.width < resolutionPlusOneAttribute.width && variantResolution.height < resolutionPlusOneAttribute.height) {\\n      // If we still haven't found a good match keep a\\n      // reference to the previous variant for the next loop\\n      // iteration\\n\\n      // By only saving variants if they are smaller than the\\n      // previously saved variant, we ensure that we also pick\\n      // the highest bandwidth variant that is just-larger-than\\n      // the video player\\n      resolutionPlusOne = variant;\\n      resolutionPlusOneAttribute = resolutionPlusOne.attributes.RESOLUTION;\\n    }\\n  }\\n\\n  // fallback chain of variants\\n  return resolutionPlusOne || resolutionBestVariant || bandwidthBestVariant || sortedPlaylists[0];\\n};\\n\\n// HLS is a source handler, not a tech. Make sure attempts to use it\\n// as one do not cause exceptions.\\nHls.canPlaySource = function () {\\n  return _videoJs2['default'].log.warn('HLS is no longer a tech. Please remove it from ' + 'your player\\\\'s techOrder.');\\n};\\n\\n/**\\n * Whether the browser has built-in HLS support.\\n */\\nHls.supportsNativeHls = (function () {\\n  var video = _globalDocument2['default'].createElement('video');\\n\\n  // native HLS is definitely not supported if HTML5 video isn't\\n  if (!_videoJs2['default'].getComponent('Html5').isSupported()) {\\n    return false;\\n  }\\n\\n  // HLS manifests can go by many mime-types\\n  var canPlay = [\\n  // Apple santioned\\n  'application/vnd.apple.mpegurl',\\n  // Apple sanctioned for backwards compatibility\\n  'audio/mpegurl',\\n  // Very common\\n  'audio/x-mpegurl',\\n  // Very common\\n  'application/x-mpegurl',\\n  // Included for completeness\\n  'video/x-mpegurl', 'video/mpegurl', 'application/mpegurl'];\\n\\n  return canPlay.some(function (canItPlay) {\\n    return (/maybe|probably/i.test(video.canPlayType(canItPlay))\\n    );\\n  });\\n})();\\n\\n/**\\n * HLS is a source handler, not a tech. Make sure attempts to use it\\n * as one do not cause exceptions.\\n */\\nHls.isSupported = function () {\\n  return _videoJs2['default'].log.warn('HLS is no longer a tech. Please remove it from ' + 'your player\\\\'s techOrder.');\\n};\\n\\nvar Component = _videoJs2['default'].getComponent('Component');\\n\\n/**\\n * The Hls Handler object, where we orchestrate all of the parts\\n * of HLS to interact with video.js\\n *\\n * @class HlsHandler\\n * @extends videojs.Component\\n * @param {Object} source the soruce object\\n * @param {Tech} tech the parent tech object\\n * @param {Object} options optional and required options\\n */\\n\\nvar HlsHandler = (function (_Component) {\\n  _inherits(HlsHandler, _Component);\\n\\n  function HlsHandler(source, tech, options) {\\n    var _this = this;\\n\\n    _classCallCheck(this, HlsHandler);\\n\\n    _get(Object.getPrototypeOf(HlsHandler.prototype), 'constructor', this).call(this, tech);\\n\\n    // tech.player() is deprecated but setup a reference to HLS for\\n    // backwards-compatibility\\n    if (tech.options_ && tech.options_.playerId) {\\n      var _player = (0, _videoJs2['default'])(tech.options_.playerId);\\n\\n      if (!_player.hasOwnProperty('hls')) {\\n        Object.defineProperty(_player, 'hls', {\\n          get: function get() {\\n            _videoJs2['default'].log.warn('player.hls is deprecated. Use player.tech.hls instead.');\\n            return _this;\\n          }\\n        });\\n      }\\n    }\\n\\n    this.tech_ = tech;\\n    this.source_ = source;\\n    this.stats = {};\\n\\n    // handle global & Source Handler level options\\n    this.options_ = _videoJs2['default'].mergeOptions(_videoJs2['default'].options.hls || {}, options.hls);\\n    this.setOptions_();\\n\\n    // listen for fullscreenchange events for this player so that we\\n    // can adjust our quality selection quickly\\n    this.on(_globalDocument2['default'], ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'], function (event) {\\n      var fullscreenElement = _globalDocument2['default'].fullscreenElement || _globalDocument2['default'].webkitFullscreenElement || _globalDocument2['default'].mozFullScreenElement || _globalDocument2['default'].msFullscreenElement;\\n\\n      if (fullscreenElement && fullscreenElement.contains(_this.tech_.el())) {\\n        _this.masterPlaylistController_.fastQualityChange_();\\n      }\\n    });\\n\\n    this.on(this.tech_, 'seeking', function () {\\n      this.setCurrentTime(this.tech_.currentTime());\\n    });\\n    this.on(this.tech_, 'error', function () {\\n      if (this.masterPlaylistController_) {\\n        this.masterPlaylistController_.pauseLoading();\\n      }\\n    });\\n\\n    this.audioTrackChange_ = function () {\\n      _this.masterPlaylistController_.useAudio();\\n    };\\n\\n    this.on(this.tech_, 'play', this.play);\\n  }\\n\\n  /**\\n   * The Source Handler object, which informs video.js what additional\\n   * MIME types are supported and sets up playback. It is registered\\n   * automatically to the appropriate tech based on the capabilities of\\n   * the browser it is running in. It is not necessary to use or modify\\n   * this object in normal usage.\\n   */\\n\\n  _createClass(HlsHandler, [{\\n    key: 'setOptions_',\\n    value: function setOptions_() {\\n      var _this2 = this;\\n\\n      // defaults\\n      this.options_.withCredentials = this.options_.withCredentials || false;\\n\\n      // start playlist selection at a reasonable bandwidth for\\n      // broadband internet\\n      // 0.5 MB/s\\n      this.options_.bandwidth = this.options_.bandwidth || 4194304;\\n\\n      // grab options passed to player.src\\n      ['withCredentials', 'bandwidth'].forEach(function (option) {\\n        if (typeof _this2.source_[option] !== 'undefined') {\\n          _this2.options_[option] = _this2.source_[option];\\n        }\\n      });\\n\\n      this.bandwidth = this.options_.bandwidth;\\n    }\\n\\n    /**\\n     * called when player.src gets called, handle a new source\\n     *\\n     * @param {Object} src the source object to handle\\n     */\\n  }, {\\n    key: 'src',\\n    value: function src(_src) {\\n      var _this3 = this;\\n\\n      // do nothing if the src is falsey\\n      if (!_src) {\\n        return;\\n      }\\n      this.setOptions_();\\n      // add master playlist controller options\\n      this.options_.url = this.source_.src;\\n      this.options_.tech = this.tech_;\\n      this.options_.externHls = Hls;\\n      this.masterPlaylistController_ = new _masterPlaylistController2['default'](this.options_);\\n      this.gapSkipper_ = new _gapSkipper2['default'](this.options_);\\n\\n      // `this` in selectPlaylist should be the HlsHandler for backwards\\n      // compatibility with < v2\\n      this.masterPlaylistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : Hls.STANDARD_PLAYLIST_SELECTOR.bind(this);\\n\\n      // re-expose some internal objects for backwards compatibility with < v2\\n      this.playlists = this.masterPlaylistController_.masterPlaylistLoader_;\\n      this.mediaSource = this.masterPlaylistController_.mediaSource;\\n\\n      // Proxy assignment of some properties to the master playlist\\n      // controller. Using a custom property for backwards compatibility\\n      // with < v2\\n      Object.defineProperties(this, {\\n        selectPlaylist: {\\n          get: function get() {\\n            return this.masterPlaylistController_.selectPlaylist;\\n          },\\n          set: function set(selectPlaylist) {\\n            this.masterPlaylistController_.selectPlaylist = selectPlaylist.bind(this);\\n          }\\n        },\\n        bandwidth: {\\n          get: function get() {\\n            return this.masterPlaylistController_.mainSegmentLoader_.bandwidth;\\n          },\\n          set: function set(bandwidth) {\\n            this.masterPlaylistController_.mainSegmentLoader_.bandwidth = bandwidth;\\n          }\\n        }\\n      });\\n\\n      Object.defineProperties(this.stats, {\\n        bandwidth: {\\n          get: function get() {\\n            return _this3.bandwidth || 0;\\n          },\\n          enumerable: true\\n        },\\n        mediaRequests: {\\n          get: function get() {\\n            return _this3.masterPlaylistController_.mediaRequests_() || 0;\\n          },\\n          enumerable: true\\n        },\\n        mediaTransferDuration: {\\n          get: function get() {\\n            return _this3.masterPlaylistController_.mediaTransferDuration_() || 0;\\n          },\\n          enumerable: true\\n        },\\n        mediaBytesTransferred: {\\n          get: function get() {\\n            return _this3.masterPlaylistController_.mediaBytesTransferred_() || 0;\\n          },\\n          enumerable: true\\n        }\\n      });\\n\\n      this.tech_.one('canplay', this.masterPlaylistController_.setupFirstPlay.bind(this.masterPlaylistController_));\\n\\n      this.masterPlaylistController_.on('sourceopen', function () {\\n        _this3.tech_.audioTracks().addEventListener('change', _this3.audioTrackChange_);\\n      });\\n\\n      this.masterPlaylistController_.on('audioinfo', function (e) {\\n        if (!_videoJs2['default'].browser.IS_FIREFOX || !_this3.audioInfo_ || !objectChanged(_this3.audioInfo_, e.info)) {\\n          _this3.audioInfo_ = e.info;\\n          return;\\n        }\\n\\n        var error = 'had different audio properties (channels, sample rate, etc.) ' + 'or changed in some other way.  This behavior is currently ' + 'unsupported in Firefox due to an issue: \\\\n\\\\n' + 'https://bugzilla.mozilla.org/show_bug.cgi?id=1247138\\\\n\\\\n';\\n\\n        var enabledTrack = undefined;\\n        var defaultTrack = undefined;\\n\\n        _this3.masterPlaylistController_.audioTracks_.forEach(function (t) {\\n          if (!defaultTrack && t['default']) {\\n            defaultTrack = t;\\n          }\\n\\n          if (!enabledTrack && t.enabled) {\\n            enabledTrack = t;\\n          }\\n        });\\n\\n        // they did not switch audiotracks\\n        // blacklist the current playlist\\n        if (!enabledTrack.getLoader(_this3.activeAudioGroup_())) {\\n          error = 'The rendition that we tried to switch to ' + error + 'Unfortunately that means we will have to blacklist ' + 'the current playlist and switch to another. Sorry!';\\n          _this3.masterPlaylistController_.blacklistCurrentPlaylist();\\n        } else {\\n          error = 'The audio track \\\\'' + enabledTrack.label + '\\\\' that we tried to ' + ('switch to ' + error + ' Unfortunately this means we will have to ') + ('return you to the main track \\\\'' + defaultTrack.label + '\\\\'. Sorry!');\\n          defaultTrack.enabled = true;\\n          _this3.tech_.audioTracks().removeTrack(enabledTrack);\\n        }\\n\\n        _videoJs2['default'].log.warn(error);\\n        _this3.masterPlaylistController_.useAudio();\\n      });\\n      this.masterPlaylistController_.on('selectedinitialmedia', function () {\\n        // clear current audioTracks\\n        _this3.tech_.clearTracks('audio');\\n        _this3.masterPlaylistController_.audioTracks_.forEach(function (track) {\\n          _this3.tech_.audioTracks().addTrack(track);\\n        });\\n\\n        // Add the manual rendition mix-in to HlsHandler\\n        (0, _renditionMixin2['default'])(_this3);\\n      });\\n\\n      // the bandwidth of the primary segment loader is our best\\n      // estimate of overall bandwidth\\n      this.on(this.masterPlaylistController_, 'progress', function () {\\n        this.bandwidth = this.masterPlaylistController_.mainSegmentLoader_.bandwidth;\\n        this.tech_.trigger('progress');\\n      });\\n\\n      // do nothing if the tech has been disposed already\\n      // this can occur if someone sets the src in player.ready(), for instance\\n      if (!this.tech_.el()) {\\n        return;\\n      }\\n\\n      this.tech_.src(_videoJs2['default'].URL.createObjectURL(this.masterPlaylistController_.mediaSource));\\n    }\\n\\n    /**\\n     * a helper for grabbing the active audio group from MasterPlaylistController\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'activeAudioGroup_',\\n    value: function activeAudioGroup_() {\\n      return this.masterPlaylistController_.activeAudioGroup();\\n    }\\n\\n    /**\\n     * Begin playing the video.\\n     */\\n  }, {\\n    key: 'play',\\n    value: function play() {\\n      this.masterPlaylistController_.play();\\n    }\\n\\n    /**\\n     * a wrapper around the function in MasterPlaylistController\\n     */\\n  }, {\\n    key: 'setCurrentTime',\\n    value: function setCurrentTime(currentTime) {\\n      this.masterPlaylistController_.setCurrentTime(currentTime);\\n    }\\n\\n    /**\\n     * a wrapper around the function in MasterPlaylistController\\n     */\\n  }, {\\n    key: 'duration',\\n    value: function duration() {\\n      return this.masterPlaylistController_.duration();\\n    }\\n\\n    /**\\n     * a wrapper around the function in MasterPlaylistController\\n     */\\n  }, {\\n    key: 'seekable',\\n    value: function seekable() {\\n      return this.masterPlaylistController_.seekable();\\n    }\\n\\n    /**\\n    * Abort all outstanding work and cleanup.\\n    */\\n  }, {\\n    key: 'dispose',\\n    value: function dispose() {\\n      if (this.masterPlaylistController_) {\\n        this.masterPlaylistController_.dispose();\\n      }\\n      this.gapSkipper_.dispose();\\n      this.tech_.audioTracks().removeEventListener('change', this.audioTrackChange_);\\n      _get(Object.getPrototypeOf(HlsHandler.prototype), 'dispose', this).call(this);\\n    }\\n  }]);\\n\\n  return HlsHandler;\\n})(Component);\\n\\nvar HlsSourceHandler = function HlsSourceHandler(mode) {\\n  return {\\n    canHandleSource: function canHandleSource(srcObj) {\\n      // this forces video.js to skip this tech/mode if its not the one we have been\\n      // overriden to use, by returing that we cannot handle the source.\\n      if (_videoJs2['default'].options.hls && _videoJs2['default'].options.hls.mode && _videoJs2['default'].options.hls.mode !== mode) {\\n        return false;\\n      }\\n      return HlsSourceHandler.canPlayType(srcObj.type);\\n    },\\n    handleSource: function handleSource(source, tech, options) {\\n      if (mode === 'flash') {\\n        // We need to trigger this asynchronously to give others the chance\\n        // to bind to the event when a source is set at player creation\\n        tech.setTimeout(function () {\\n          tech.trigger('loadstart');\\n        }, 1);\\n      }\\n\\n      var settings = _videoJs2['default'].mergeOptions(options, { hls: { mode: mode } });\\n\\n      tech.hls = new HlsHandler(source, tech, settings);\\n\\n      tech.hls.xhr = (0, _xhr2['default'])();\\n      // Use a global `before` function if specified on videojs.Hls.xhr\\n      // but still allow for a per-player override\\n      if (_videoJs2['default'].Hls.xhr.beforeRequest) {\\n        tech.hls.xhr.beforeRequest = _videoJs2['default'].Hls.xhr.beforeRequest;\\n      }\\n\\n      tech.hls.src(source.src);\\n      return tech.hls;\\n    },\\n    canPlayType: function canPlayType(type) {\\n      if (HlsSourceHandler.canPlayType(type)) {\\n        return 'maybe';\\n      }\\n      return '';\\n    }\\n  };\\n};\\n\\n/**\\n * A comparator function to sort two playlist object by bandwidth.\\n *\\n * @param {Object} left a media playlist object\\n * @param {Object} right a media playlist object\\n * @return {Number} Greater than zero if the bandwidth attribute of\\n * left is greater than the corresponding attribute of right. Less\\n * than zero if the bandwidth of right is greater than left and\\n * exactly zero if the two are equal.\\n */\\nHls.comparePlaylistBandwidth = function (left, right) {\\n  var leftBandwidth = undefined;\\n  var rightBandwidth = undefined;\\n\\n  if (left.attributes && left.attributes.BANDWIDTH) {\\n    leftBandwidth = left.attributes.BANDWIDTH;\\n  }\\n  leftBandwidth = leftBandwidth || _globalWindow2['default'].Number.MAX_VALUE;\\n  if (right.attributes && right.attributes.BANDWIDTH) {\\n    rightBandwidth = right.attributes.BANDWIDTH;\\n  }\\n  rightBandwidth = rightBandwidth || _globalWindow2['default'].Number.MAX_VALUE;\\n\\n  return leftBandwidth - rightBandwidth;\\n};\\n\\n/**\\n * A comparator function to sort two playlist object by resolution (width).\\n * @param {Object} left a media playlist object\\n * @param {Object} right a media playlist object\\n * @return {Number} Greater than zero if the resolution.width attribute of\\n * left is greater than the corresponding attribute of right. Less\\n * than zero if the resolution.width of right is greater than left and\\n * exactly zero if the two are equal.\\n */\\nHls.comparePlaylistResolution = function (left, right) {\\n  var leftWidth = undefined;\\n  var rightWidth = undefined;\\n\\n  if (left.attributes && left.attributes.RESOLUTION && left.attributes.RESOLUTION.width) {\\n    leftWidth = left.attributes.RESOLUTION.width;\\n  }\\n\\n  leftWidth = leftWidth || _globalWindow2['default'].Number.MAX_VALUE;\\n\\n  if (right.attributes && right.attributes.RESOLUTION && right.attributes.RESOLUTION.width) {\\n    rightWidth = right.attributes.RESOLUTION.width;\\n  }\\n\\n  rightWidth = rightWidth || _globalWindow2['default'].Number.MAX_VALUE;\\n\\n  // NOTE - Fallback to bandwidth sort as appropriate in cases where multiple renditions\\n  // have the same media dimensions/ resolution\\n  if (leftWidth === rightWidth && left.attributes.BANDWIDTH && right.attributes.BANDWIDTH) {\\n    return left.attributes.BANDWIDTH - right.attributes.BANDWIDTH;\\n  }\\n  return leftWidth - rightWidth;\\n};\\n\\nHlsSourceHandler.canPlayType = function (type) {\\n  var mpegurlRE = /^(audio|video|application)\\\\/(x-|vnd\\\\.apple\\\\.)?mpegurl/i;\\n\\n  // favor native HLS support if it's available\\n  if (Hls.supportsNativeHls) {\\n    return false;\\n  }\\n  return mpegurlRE.test(type);\\n};\\n\\nif (typeof _videoJs2['default'].MediaSource === 'undefined' || typeof _videoJs2['default'].URL === 'undefined') {\\n  _videoJs2['default'].MediaSource = _videojsContribMediaSources.MediaSource;\\n  _videoJs2['default'].URL = _videojsContribMediaSources.URL;\\n}\\n\\n// register source handlers with the appropriate techs\\nif (_videojsContribMediaSources.MediaSource.supportsNativeMediaSources()) {\\n  _videoJs2['default'].getComponent('Html5').registerSourceHandler(HlsSourceHandler('html5'));\\n}\\nif (_globalWindow2['default'].Uint8Array) {\\n  _videoJs2['default'].getComponent('Flash').registerSourceHandler(HlsSourceHandler('flash'));\\n}\\n\\n_videoJs2['default'].HlsHandler = HlsHandler;\\n_videoJs2['default'].HlsSourceHandler = HlsSourceHandler;\\n_videoJs2['default'].Hls = Hls;\\n_videoJs2['default'].m3u8 = _m3u8Parser2['default'];\\n_videoJs2['default'].registerComponent('Hls', Hls);\\n_videoJs2['default'].options.hls = _videoJs2['default'].options.hls || {};\\n\\nmodule.exports = {\\n  Hls: Hls,\\n  HlsHandler: HlsHandler,\\n  HlsSourceHandler: HlsSourceHandler\\n};\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./bin-utils\\\":2,\\\"./config\\\":3,\\\"./gap-skipper\\\":4,\\\"./master-playlist-controller\\\":6,\\\"./playlist\\\":8,\\\"./playlist-loader\\\":7,\\\"./rendition-mixin\\\":10,\\\"./xhr\\\":15,\\\"aes-decrypter\\\":19,\\\"global/document\\\":25,\\\"global/window\\\":26,\\\"m3u8-parser\\\":63,\\\"videojs-contrib-media-sources\\\":77}]},{},[96])(96)\\n});\\n\"\n\n/***/ },\n\n/***/ 831:\n/***/ function(module, exports) {\n\nmodule.exports = \"/*! tether 1.4.0 */\\n\\n(function(root, factory) {\\n  if (typeof define === 'function' && define.amd) {\\n    define(factory);\\n  } else if (typeof exports === 'object') {\\n    module.exports = factory(require, exports, module);\\n  } else {\\n    root.Tether = factory();\\n  }\\n}(this, function(require, exports, module) {\\n\\n'use strict';\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nvar TetherBase = undefined;\\nif (typeof TetherBase === 'undefined') {\\n  TetherBase = { modules: [] };\\n}\\n\\nvar zeroElement = null;\\n\\n// Same as native getBoundingClientRect, except it takes into account parent <frame> offsets\\n// if the element lies within a nested document (<frame> or <iframe>-like).\\nfunction getActualBoundingClientRect(node) {\\n  var boundingRect = node.getBoundingClientRect();\\n\\n  // The original object returned by getBoundingClientRect is immutable, so we clone it\\n  // We can't use extend because the properties are not considered part of the object by hasOwnProperty in IE9\\n  var rect = {};\\n  for (var k in boundingRect) {\\n    rect[k] = boundingRect[k];\\n  }\\n\\n  if (node.ownerDocument !== document) {\\n    var _frameElement = node.ownerDocument.defaultView.frameElement;\\n    if (_frameElement) {\\n      var frameRect = getActualBoundingClientRect(_frameElement);\\n      rect.top += frameRect.top;\\n      rect.bottom += frameRect.top;\\n      rect.left += frameRect.left;\\n      rect.right += frameRect.left;\\n    }\\n  }\\n\\n  return rect;\\n}\\n\\nfunction getScrollParents(el) {\\n  // In firefox if the el is inside an iframe with display: none; window.getComputedStyle() will return null;\\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=548397\\n  var computedStyle = getComputedStyle(el) || {};\\n  var position = computedStyle.position;\\n  var parents = [];\\n\\n  if (position === 'fixed') {\\n    return [el];\\n  }\\n\\n  var parent = el;\\n  while ((parent = parent.parentNode) && parent && parent.nodeType === 1) {\\n    var style = undefined;\\n    try {\\n      style = getComputedStyle(parent);\\n    } catch (err) {}\\n\\n    if (typeof style === 'undefined' || style === null) {\\n      parents.push(parent);\\n      return parents;\\n    }\\n\\n    var _style = style;\\n    var overflow = _style.overflow;\\n    var overflowX = _style.overflowX;\\n    var overflowY = _style.overflowY;\\n\\n    if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {\\n      if (position !== 'absolute' || ['relative', 'absolute', 'fixed'].indexOf(style.position) >= 0) {\\n        parents.push(parent);\\n      }\\n    }\\n  }\\n\\n  parents.push(el.ownerDocument.body);\\n\\n  // If the node is within a frame, account for the parent window scroll\\n  if (el.ownerDocument !== document) {\\n    parents.push(el.ownerDocument.defaultView);\\n  }\\n\\n  return parents;\\n}\\n\\nvar uniqueId = (function () {\\n  var id = 0;\\n  return function () {\\n    return ++id;\\n  };\\n})();\\n\\nvar zeroPosCache = {};\\nvar getOrigin = function getOrigin() {\\n  // getBoundingClientRect is unfortunately too accurate.  It introduces a pixel or two of\\n  // jitter as the user scrolls that messes with our ability to detect if two positions\\n  // are equivilant or not.  We place an element at the top left of the page that will\\n  // get the same jitter, so we can cancel the two out.\\n  var node = zeroElement;\\n  if (!node || !document.body.contains(node)) {\\n    node = document.createElement('div');\\n    node.setAttribute('data-tether-id', uniqueId());\\n    extend(node.style, {\\n      top: 0,\\n      left: 0,\\n      position: 'absolute'\\n    });\\n\\n    document.body.appendChild(node);\\n\\n    zeroElement = node;\\n  }\\n\\n  var id = node.getAttribute('data-tether-id');\\n  if (typeof zeroPosCache[id] === 'undefined') {\\n    zeroPosCache[id] = getActualBoundingClientRect(node);\\n\\n    // Clear the cache when this position call is done\\n    defer(function () {\\n      delete zeroPosCache[id];\\n    });\\n  }\\n\\n  return zeroPosCache[id];\\n};\\n\\nfunction removeUtilElements() {\\n  if (zeroElement) {\\n    document.body.removeChild(zeroElement);\\n  }\\n  zeroElement = null;\\n};\\n\\nfunction getBounds(el) {\\n  var doc = undefined;\\n  if (el === document) {\\n    doc = document;\\n    el = document.documentElement;\\n  } else {\\n    doc = el.ownerDocument;\\n  }\\n\\n  var docEl = doc.documentElement;\\n\\n  var box = getActualBoundingClientRect(el);\\n\\n  var origin = getOrigin();\\n\\n  box.top -= origin.top;\\n  box.left -= origin.left;\\n\\n  if (typeof box.width === 'undefined') {\\n    box.width = document.body.scrollWidth - box.left - box.right;\\n  }\\n  if (typeof box.height === 'undefined') {\\n    box.height = document.body.scrollHeight - box.top - box.bottom;\\n  }\\n\\n  box.top = box.top - docEl.clientTop;\\n  box.left = box.left - docEl.clientLeft;\\n  box.right = doc.body.clientWidth - box.width - box.left;\\n  box.bottom = doc.body.clientHeight - box.height - box.top;\\n\\n  return box;\\n}\\n\\nfunction getOffsetParent(el) {\\n  return el.offsetParent || document.documentElement;\\n}\\n\\nvar _scrollBarSize = null;\\nfunction getScrollBarSize() {\\n  if (_scrollBarSize) {\\n    return _scrollBarSize;\\n  }\\n  var inner = document.createElement('div');\\n  inner.style.width = '100%';\\n  inner.style.height = '200px';\\n\\n  var outer = document.createElement('div');\\n  extend(outer.style, {\\n    position: 'absolute',\\n    top: 0,\\n    left: 0,\\n    pointerEvents: 'none',\\n    visibility: 'hidden',\\n    width: '200px',\\n    height: '150px',\\n    overflow: 'hidden'\\n  });\\n\\n  outer.appendChild(inner);\\n\\n  document.body.appendChild(outer);\\n\\n  var widthContained = inner.offsetWidth;\\n  outer.style.overflow = 'scroll';\\n  var widthScroll = inner.offsetWidth;\\n\\n  if (widthContained === widthScroll) {\\n    widthScroll = outer.clientWidth;\\n  }\\n\\n  document.body.removeChild(outer);\\n\\n  var width = widthContained - widthScroll;\\n\\n  _scrollBarSize = { width: width, height: width };\\n  return _scrollBarSize;\\n}\\n\\nfunction extend() {\\n  var out = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\\n\\n  var args = [];\\n\\n  Array.prototype.push.apply(args, arguments);\\n\\n  args.slice(1).forEach(function (obj) {\\n    if (obj) {\\n      for (var key in obj) {\\n        if (({}).hasOwnProperty.call(obj, key)) {\\n          out[key] = obj[key];\\n        }\\n      }\\n    }\\n  });\\n\\n  return out;\\n}\\n\\nfunction removeClass(el, name) {\\n  if (typeof el.classList !== 'undefined') {\\n    name.split(' ').forEach(function (cls) {\\n      if (cls.trim()) {\\n        el.classList.remove(cls);\\n      }\\n    });\\n  } else {\\n    var regex = new RegExp('(^| )' + name.split(' ').join('|') + '( |$)', 'gi');\\n    var className = getClassName(el).replace(regex, ' ');\\n    setClassName(el, className);\\n  }\\n}\\n\\nfunction addClass(el, name) {\\n  if (typeof el.classList !== 'undefined') {\\n    name.split(' ').forEach(function (cls) {\\n      if (cls.trim()) {\\n        el.classList.add(cls);\\n      }\\n    });\\n  } else {\\n    removeClass(el, name);\\n    var cls = getClassName(el) + (' ' + name);\\n    setClassName(el, cls);\\n  }\\n}\\n\\nfunction hasClass(el, name) {\\n  if (typeof el.classList !== 'undefined') {\\n    return el.classList.contains(name);\\n  }\\n  var className = getClassName(el);\\n  return new RegExp('(^| )' + name + '( |$)', 'gi').test(className);\\n}\\n\\nfunction getClassName(el) {\\n  // Can't use just SVGAnimatedString here since nodes within a Frame in IE have\\n  // completely separately SVGAnimatedString base classes\\n  if (el.className instanceof el.ownerDocument.defaultView.SVGAnimatedString) {\\n    return el.className.baseVal;\\n  }\\n  return el.className;\\n}\\n\\nfunction setClassName(el, className) {\\n  el.setAttribute('class', className);\\n}\\n\\nfunction updateClasses(el, add, all) {\\n  // Of the set of 'all' classes, we need the 'add' classes, and only the\\n  // 'add' classes to be set.\\n  all.forEach(function (cls) {\\n    if (add.indexOf(cls) === -1 && hasClass(el, cls)) {\\n      removeClass(el, cls);\\n    }\\n  });\\n\\n  add.forEach(function (cls) {\\n    if (!hasClass(el, cls)) {\\n      addClass(el, cls);\\n    }\\n  });\\n}\\n\\nvar deferred = [];\\n\\nvar defer = function defer(fn) {\\n  deferred.push(fn);\\n};\\n\\nvar flush = function flush() {\\n  var fn = undefined;\\n  while (fn = deferred.pop()) {\\n    fn();\\n  }\\n};\\n\\nvar Evented = (function () {\\n  function Evented() {\\n    _classCallCheck(this, Evented);\\n  }\\n\\n  _createClass(Evented, [{\\n    key: 'on',\\n    value: function on(event, handler, ctx) {\\n      var once = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];\\n\\n      if (typeof this.bindings === 'undefined') {\\n        this.bindings = {};\\n      }\\n      if (typeof this.bindings[event] === 'undefined') {\\n        this.bindings[event] = [];\\n      }\\n      this.bindings[event].push({ handler: handler, ctx: ctx, once: once });\\n    }\\n  }, {\\n    key: 'once',\\n    value: function once(event, handler, ctx) {\\n      this.on(event, handler, ctx, true);\\n    }\\n  }, {\\n    key: 'off',\\n    value: function off(event, handler) {\\n      if (typeof this.bindings === 'undefined' || typeof this.bindings[event] === 'undefined') {\\n        return;\\n      }\\n\\n      if (typeof handler === 'undefined') {\\n        delete this.bindings[event];\\n      } else {\\n        var i = 0;\\n        while (i < this.bindings[event].length) {\\n          if (this.bindings[event][i].handler === handler) {\\n            this.bindings[event].splice(i, 1);\\n          } else {\\n            ++i;\\n          }\\n        }\\n      }\\n    }\\n  }, {\\n    key: 'trigger',\\n    value: function trigger(event) {\\n      if (typeof this.bindings !== 'undefined' && this.bindings[event]) {\\n        var i = 0;\\n\\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n          args[_key - 1] = arguments[_key];\\n        }\\n\\n        while (i < this.bindings[event].length) {\\n          var _bindings$event$i = this.bindings[event][i];\\n          var handler = _bindings$event$i.handler;\\n          var ctx = _bindings$event$i.ctx;\\n          var once = _bindings$event$i.once;\\n\\n          var context = ctx;\\n          if (typeof context === 'undefined') {\\n            context = this;\\n          }\\n\\n          handler.apply(context, args);\\n\\n          if (once) {\\n            this.bindings[event].splice(i, 1);\\n          } else {\\n            ++i;\\n          }\\n        }\\n      }\\n    }\\n  }]);\\n\\n  return Evented;\\n})();\\n\\nTetherBase.Utils = {\\n  getActualBoundingClientRect: getActualBoundingClientRect,\\n  getScrollParents: getScrollParents,\\n  getBounds: getBounds,\\n  getOffsetParent: getOffsetParent,\\n  extend: extend,\\n  addClass: addClass,\\n  removeClass: removeClass,\\n  hasClass: hasClass,\\n  updateClasses: updateClasses,\\n  defer: defer,\\n  flush: flush,\\n  uniqueId: uniqueId,\\n  Evented: Evented,\\n  getScrollBarSize: getScrollBarSize,\\n  removeUtilElements: removeUtilElements\\n};\\n/* globals TetherBase, performance */\\n\\n'use strict';\\n\\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x6, _x7, _x8) { var _again = true; _function: while (_again) { var object = _x6, property = _x7, receiver = _x8; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x6 = parent; _x7 = property; _x8 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nif (typeof TetherBase === 'undefined') {\\n  throw new Error('You must include the utils.js file before tether.js');\\n}\\n\\nvar _TetherBase$Utils = TetherBase.Utils;\\nvar getScrollParents = _TetherBase$Utils.getScrollParents;\\nvar getBounds = _TetherBase$Utils.getBounds;\\nvar getOffsetParent = _TetherBase$Utils.getOffsetParent;\\nvar extend = _TetherBase$Utils.extend;\\nvar addClass = _TetherBase$Utils.addClass;\\nvar removeClass = _TetherBase$Utils.removeClass;\\nvar updateClasses = _TetherBase$Utils.updateClasses;\\nvar defer = _TetherBase$Utils.defer;\\nvar flush = _TetherBase$Utils.flush;\\nvar getScrollBarSize = _TetherBase$Utils.getScrollBarSize;\\nvar removeUtilElements = _TetherBase$Utils.removeUtilElements;\\n\\nfunction within(a, b) {\\n  var diff = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];\\n\\n  return a + diff >= b && b >= a - diff;\\n}\\n\\nvar transformKey = (function () {\\n  if (typeof document === 'undefined') {\\n    return '';\\n  }\\n  var el = document.createElement('div');\\n\\n  var transforms = ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform'];\\n  for (var i = 0; i < transforms.length; ++i) {\\n    var key = transforms[i];\\n    if (el.style[key] !== undefined) {\\n      return key;\\n    }\\n  }\\n})();\\n\\nvar tethers = [];\\n\\nvar position = function position() {\\n  tethers.forEach(function (tether) {\\n    tether.position(false);\\n  });\\n  flush();\\n};\\n\\nfunction now() {\\n  if (typeof performance !== 'undefined' && typeof performance.now !== 'undefined') {\\n    return performance.now();\\n  }\\n  return +new Date();\\n}\\n\\n(function () {\\n  var lastCall = null;\\n  var lastDuration = null;\\n  var pendingTimeout = null;\\n\\n  var tick = function tick() {\\n    if (typeof lastDuration !== 'undefined' && lastDuration > 16) {\\n      // We voluntarily throttle ourselves if we can't manage 60fps\\n      lastDuration = Math.min(lastDuration - 16, 250);\\n\\n      // Just in case this is the last event, remember to position just once more\\n      pendingTimeout = setTimeout(tick, 250);\\n      return;\\n    }\\n\\n    if (typeof lastCall !== 'undefined' && now() - lastCall < 10) {\\n      // Some browsers call events a little too frequently, refuse to run more than is reasonable\\n      return;\\n    }\\n\\n    if (pendingTimeout != null) {\\n      clearTimeout(pendingTimeout);\\n      pendingTimeout = null;\\n    }\\n\\n    lastCall = now();\\n    position();\\n    lastDuration = now() - lastCall;\\n  };\\n\\n  if (typeof window !== 'undefined' && typeof window.addEventListener !== 'undefined') {\\n    ['resize', 'scroll', 'touchmove'].forEach(function (event) {\\n      window.addEventListener(event, tick);\\n    });\\n  }\\n})();\\n\\nvar MIRROR_LR = {\\n  center: 'center',\\n  left: 'right',\\n  right: 'left'\\n};\\n\\nvar MIRROR_TB = {\\n  middle: 'middle',\\n  top: 'bottom',\\n  bottom: 'top'\\n};\\n\\nvar OFFSET_MAP = {\\n  top: 0,\\n  left: 0,\\n  middle: '50%',\\n  center: '50%',\\n  bottom: '100%',\\n  right: '100%'\\n};\\n\\nvar autoToFixedAttachment = function autoToFixedAttachment(attachment, relativeToAttachment) {\\n  var left = attachment.left;\\n  var top = attachment.top;\\n\\n  if (left === 'auto') {\\n    left = MIRROR_LR[relativeToAttachment.left];\\n  }\\n\\n  if (top === 'auto') {\\n    top = MIRROR_TB[relativeToAttachment.top];\\n  }\\n\\n  return { left: left, top: top };\\n};\\n\\nvar attachmentToOffset = function attachmentToOffset(attachment) {\\n  var left = attachment.left;\\n  var top = attachment.top;\\n\\n  if (typeof OFFSET_MAP[attachment.left] !== 'undefined') {\\n    left = OFFSET_MAP[attachment.left];\\n  }\\n\\n  if (typeof OFFSET_MAP[attachment.top] !== 'undefined') {\\n    top = OFFSET_MAP[attachment.top];\\n  }\\n\\n  return { left: left, top: top };\\n};\\n\\nfunction addOffset() {\\n  var out = { top: 0, left: 0 };\\n\\n  for (var _len = arguments.length, offsets = Array(_len), _key = 0; _key < _len; _key++) {\\n    offsets[_key] = arguments[_key];\\n  }\\n\\n  offsets.forEach(function (_ref) {\\n    var top = _ref.top;\\n    var left = _ref.left;\\n\\n    if (typeof top === 'string') {\\n      top = parseFloat(top, 10);\\n    }\\n    if (typeof left === 'string') {\\n      left = parseFloat(left, 10);\\n    }\\n\\n    out.top += top;\\n    out.left += left;\\n  });\\n\\n  return out;\\n}\\n\\nfunction offsetToPx(offset, size) {\\n  if (typeof offset.left === 'string' && offset.left.indexOf('%') !== -1) {\\n    offset.left = parseFloat(offset.left, 10) / 100 * size.width;\\n  }\\n  if (typeof offset.top === 'string' && offset.top.indexOf('%') !== -1) {\\n    offset.top = parseFloat(offset.top, 10) / 100 * size.height;\\n  }\\n\\n  return offset;\\n}\\n\\nvar parseOffset = function parseOffset(value) {\\n  var _value$split = value.split(' ');\\n\\n  var _value$split2 = _slicedToArray(_value$split, 2);\\n\\n  var top = _value$split2[0];\\n  var left = _value$split2[1];\\n\\n  return { top: top, left: left };\\n};\\nvar parseAttachment = parseOffset;\\n\\nvar TetherClass = (function (_Evented) {\\n  _inherits(TetherClass, _Evented);\\n\\n  function TetherClass(options) {\\n    var _this = this;\\n\\n    _classCallCheck(this, TetherClass);\\n\\n    _get(Object.getPrototypeOf(TetherClass.prototype), 'constructor', this).call(this);\\n    this.position = this.position.bind(this);\\n\\n    tethers.push(this);\\n\\n    this.history = [];\\n\\n    this.setOptions(options, false);\\n\\n    TetherBase.modules.forEach(function (module) {\\n      if (typeof module.initialize !== 'undefined') {\\n        module.initialize.call(_this);\\n      }\\n    });\\n\\n    this.position();\\n  }\\n\\n  _createClass(TetherClass, [{\\n    key: 'getClass',\\n    value: function getClass() {\\n      var key = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\\n      var classes = this.options.classes;\\n\\n      if (typeof classes !== 'undefined' && classes[key]) {\\n        return this.options.classes[key];\\n      } else if (this.options.classPrefix) {\\n        return this.options.classPrefix + '-' + key;\\n      } else {\\n        return key;\\n      }\\n    }\\n  }, {\\n    key: 'setOptions',\\n    value: function setOptions(options) {\\n      var _this2 = this;\\n\\n      var pos = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\\n\\n      var defaults = {\\n        offset: '0 0',\\n        targetOffset: '0 0',\\n        targetAttachment: 'auto auto',\\n        classPrefix: 'tether'\\n      };\\n\\n      this.options = extend(defaults, options);\\n\\n      var _options = this.options;\\n      var element = _options.element;\\n      var target = _options.target;\\n      var targetModifier = _options.targetModifier;\\n\\n      this.element = element;\\n      this.target = target;\\n      this.targetModifier = targetModifier;\\n\\n      if (this.target === 'viewport') {\\n        this.target = document.body;\\n        this.targetModifier = 'visible';\\n      } else if (this.target === 'scroll-handle') {\\n        this.target = document.body;\\n        this.targetModifier = 'scroll-handle';\\n      }\\n\\n      ['element', 'target'].forEach(function (key) {\\n        if (typeof _this2[key] === 'undefined') {\\n          throw new Error('Tether Error: Both element and target must be defined');\\n        }\\n\\n        if (typeof _this2[key].jquery !== 'undefined') {\\n          _this2[key] = _this2[key][0];\\n        } else if (typeof _this2[key] === 'string') {\\n          _this2[key] = document.querySelector(_this2[key]);\\n        }\\n      });\\n\\n      addClass(this.element, this.getClass('element'));\\n      if (!(this.options.addTargetClasses === false)) {\\n        addClass(this.target, this.getClass('target'));\\n      }\\n\\n      if (!this.options.attachment) {\\n        throw new Error('Tether Error: You must provide an attachment');\\n      }\\n\\n      this.targetAttachment = parseAttachment(this.options.targetAttachment);\\n      this.attachment = parseAttachment(this.options.attachment);\\n      this.offset = parseOffset(this.options.offset);\\n      this.targetOffset = parseOffset(this.options.targetOffset);\\n\\n      if (typeof this.scrollParents !== 'undefined') {\\n        this.disable();\\n      }\\n\\n      if (this.targetModifier === 'scroll-handle') {\\n        this.scrollParents = [this.target];\\n      } else {\\n        this.scrollParents = getScrollParents(this.target);\\n      }\\n\\n      if (!(this.options.enabled === false)) {\\n        this.enable(pos);\\n      }\\n    }\\n  }, {\\n    key: 'getTargetBounds',\\n    value: function getTargetBounds() {\\n      if (typeof this.targetModifier !== 'undefined') {\\n        if (this.targetModifier === 'visible') {\\n          if (this.target === document.body) {\\n            return { top: pageYOffset, left: pageXOffset, height: innerHeight, width: innerWidth };\\n          } else {\\n            var bounds = getBounds(this.target);\\n\\n            var out = {\\n              height: bounds.height,\\n              width: bounds.width,\\n              top: bounds.top,\\n              left: bounds.left\\n            };\\n\\n            out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));\\n            out.height = Math.min(out.height, bounds.height - (bounds.top + bounds.height - (pageYOffset + innerHeight)));\\n            out.height = Math.min(innerHeight, out.height);\\n            out.height -= 2;\\n\\n            out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));\\n            out.width = Math.min(out.width, bounds.width - (bounds.left + bounds.width - (pageXOffset + innerWidth)));\\n            out.width = Math.min(innerWidth, out.width);\\n            out.width -= 2;\\n\\n            if (out.top < pageYOffset) {\\n              out.top = pageYOffset;\\n            }\\n            if (out.left < pageXOffset) {\\n              out.left = pageXOffset;\\n            }\\n\\n            return out;\\n          }\\n        } else if (this.targetModifier === 'scroll-handle') {\\n          var bounds = undefined;\\n          var target = this.target;\\n          if (target === document.body) {\\n            target = document.documentElement;\\n\\n            bounds = {\\n              left: pageXOffset,\\n              top: pageYOffset,\\n              height: innerHeight,\\n              width: innerWidth\\n            };\\n          } else {\\n            bounds = getBounds(target);\\n          }\\n\\n          var style = getComputedStyle(target);\\n\\n          var hasBottomScroll = target.scrollWidth > target.clientWidth || [style.overflow, style.overflowX].indexOf('scroll') >= 0 || this.target !== document.body;\\n\\n          var scrollBottom = 0;\\n          if (hasBottomScroll) {\\n            scrollBottom = 15;\\n          }\\n\\n          var height = bounds.height - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth) - scrollBottom;\\n\\n          var out = {\\n            width: 15,\\n            height: height * 0.975 * (height / target.scrollHeight),\\n            left: bounds.left + bounds.width - parseFloat(style.borderLeftWidth) - 15\\n          };\\n\\n          var fitAdj = 0;\\n          if (height < 408 && this.target === document.body) {\\n            fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;\\n          }\\n\\n          if (this.target !== document.body) {\\n            out.height = Math.max(out.height, 24);\\n          }\\n\\n          var scrollPercentage = this.target.scrollTop / (target.scrollHeight - height);\\n          out.top = scrollPercentage * (height - out.height - fitAdj) + bounds.top + parseFloat(style.borderTopWidth);\\n\\n          if (this.target === document.body) {\\n            out.height = Math.max(out.height, 24);\\n          }\\n\\n          return out;\\n        }\\n      } else {\\n        return getBounds(this.target);\\n      }\\n    }\\n  }, {\\n    key: 'clearCache',\\n    value: function clearCache() {\\n      this._cache = {};\\n    }\\n  }, {\\n    key: 'cache',\\n    value: function cache(k, getter) {\\n      // More than one module will often need the same DOM info, so\\n      // we keep a cache which is cleared on each position call\\n      if (typeof this._cache === 'undefined') {\\n        this._cache = {};\\n      }\\n\\n      if (typeof this._cache[k] === 'undefined') {\\n        this._cache[k] = getter.call(this);\\n      }\\n\\n      return this._cache[k];\\n    }\\n  }, {\\n    key: 'enable',\\n    value: function enable() {\\n      var _this3 = this;\\n\\n      var pos = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\\n\\n      if (!(this.options.addTargetClasses === false)) {\\n        addClass(this.target, this.getClass('enabled'));\\n      }\\n      addClass(this.element, this.getClass('enabled'));\\n      this.enabled = true;\\n\\n      this.scrollParents.forEach(function (parent) {\\n        if (parent !== _this3.target.ownerDocument) {\\n          parent.addEventListener('scroll', _this3.position);\\n        }\\n      });\\n\\n      if (pos) {\\n        this.position();\\n      }\\n    }\\n  }, {\\n    key: 'disable',\\n    value: function disable() {\\n      var _this4 = this;\\n\\n      removeClass(this.target, this.getClass('enabled'));\\n      removeClass(this.element, this.getClass('enabled'));\\n      this.enabled = false;\\n\\n      if (typeof this.scrollParents !== 'undefined') {\\n        this.scrollParents.forEach(function (parent) {\\n          parent.removeEventListener('scroll', _this4.position);\\n        });\\n      }\\n    }\\n  }, {\\n    key: 'destroy',\\n    value: function destroy() {\\n      var _this5 = this;\\n\\n      this.disable();\\n\\n      tethers.forEach(function (tether, i) {\\n        if (tether === _this5) {\\n          tethers.splice(i, 1);\\n        }\\n      });\\n\\n      // Remove any elements we were using for convenience from the DOM\\n      if (tethers.length === 0) {\\n        removeUtilElements();\\n      }\\n    }\\n  }, {\\n    key: 'updateAttachClasses',\\n    value: function updateAttachClasses(elementAttach, targetAttach) {\\n      var _this6 = this;\\n\\n      elementAttach = elementAttach || this.attachment;\\n      targetAttach = targetAttach || this.targetAttachment;\\n      var sides = ['left', 'top', 'bottom', 'right', 'middle', 'center'];\\n\\n      if (typeof this._addAttachClasses !== 'undefined' && this._addAttachClasses.length) {\\n        // updateAttachClasses can be called more than once in a position call, so\\n        // we need to clean up after ourselves such that when the last defer gets\\n        // ran it doesn't add any extra classes from previous calls.\\n        this._addAttachClasses.splice(0, this._addAttachClasses.length);\\n      }\\n\\n      if (typeof this._addAttachClasses === 'undefined') {\\n        this._addAttachClasses = [];\\n      }\\n      var add = this._addAttachClasses;\\n\\n      if (elementAttach.top) {\\n        add.push(this.getClass('element-attached') + '-' + elementAttach.top);\\n      }\\n      if (elementAttach.left) {\\n        add.push(this.getClass('element-attached') + '-' + elementAttach.left);\\n      }\\n      if (targetAttach.top) {\\n        add.push(this.getClass('target-attached') + '-' + targetAttach.top);\\n      }\\n      if (targetAttach.left) {\\n        add.push(this.getClass('target-attached') + '-' + targetAttach.left);\\n      }\\n\\n      var all = [];\\n      sides.forEach(function (side) {\\n        all.push(_this6.getClass('element-attached') + '-' + side);\\n        all.push(_this6.getClass('target-attached') + '-' + side);\\n      });\\n\\n      defer(function () {\\n        if (!(typeof _this6._addAttachClasses !== 'undefined')) {\\n          return;\\n        }\\n\\n        updateClasses(_this6.element, _this6._addAttachClasses, all);\\n        if (!(_this6.options.addTargetClasses === false)) {\\n          updateClasses(_this6.target, _this6._addAttachClasses, all);\\n        }\\n\\n        delete _this6._addAttachClasses;\\n      });\\n    }\\n  }, {\\n    key: 'position',\\n    value: function position() {\\n      var _this7 = this;\\n\\n      var flushChanges = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\\n\\n      // flushChanges commits the changes immediately, leave true unless you are positioning multiple\\n      // tethers (in which case call Tether.Utils.flush yourself when you're done)\\n\\n      if (!this.enabled) {\\n        return;\\n      }\\n\\n      this.clearCache();\\n\\n      // Turn 'auto' attachments into the appropriate corner or edge\\n      var targetAttachment = autoToFixedAttachment(this.targetAttachment, this.attachment);\\n\\n      this.updateAttachClasses(this.attachment, targetAttachment);\\n\\n      var elementPos = this.cache('element-bounds', function () {\\n        return getBounds(_this7.element);\\n      });\\n\\n      var width = elementPos.width;\\n      var height = elementPos.height;\\n\\n      if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {\\n        var _lastSize = this.lastSize;\\n\\n        // We cache the height and width to make it possible to position elements that are\\n        // getting hidden.\\n        width = _lastSize.width;\\n        height = _lastSize.height;\\n      } else {\\n        this.lastSize = { width: width, height: height };\\n      }\\n\\n      var targetPos = this.cache('target-bounds', function () {\\n        return _this7.getTargetBounds();\\n      });\\n      var targetSize = targetPos;\\n\\n      // Get an actual px offset from the attachment\\n      var offset = offsetToPx(attachmentToOffset(this.attachment), { width: width, height: height });\\n      var targetOffset = offsetToPx(attachmentToOffset(targetAttachment), targetSize);\\n\\n      var manualOffset = offsetToPx(this.offset, { width: width, height: height });\\n      var manualTargetOffset = offsetToPx(this.targetOffset, targetSize);\\n\\n      // Add the manually provided offset\\n      offset = addOffset(offset, manualOffset);\\n      targetOffset = addOffset(targetOffset, manualTargetOffset);\\n\\n      // It's now our goal to make (element position + offset) == (target position + target offset)\\n      var left = targetPos.left + targetOffset.left - offset.left;\\n      var top = targetPos.top + targetOffset.top - offset.top;\\n\\n      for (var i = 0; i < TetherBase.modules.length; ++i) {\\n        var _module2 = TetherBase.modules[i];\\n        var ret = _module2.position.call(this, {\\n          left: left,\\n          top: top,\\n          targetAttachment: targetAttachment,\\n          targetPos: targetPos,\\n          elementPos: elementPos,\\n          offset: offset,\\n          targetOffset: targetOffset,\\n          manualOffset: manualOffset,\\n          manualTargetOffset: manualTargetOffset,\\n          scrollbarSize: scrollbarSize,\\n          attachment: this.attachment\\n        });\\n\\n        if (ret === false) {\\n          return false;\\n        } else if (typeof ret === 'undefined' || typeof ret !== 'object') {\\n          continue;\\n        } else {\\n          top = ret.top;\\n          left = ret.left;\\n        }\\n      }\\n\\n      // We describe the position three different ways to give the optimizer\\n      // a chance to decide the best possible way to position the element\\n      // with the fewest repaints.\\n      var next = {\\n        // It's position relative to the page (absolute positioning when\\n        // the element is a child of the body)\\n        page: {\\n          top: top,\\n          left: left\\n        },\\n\\n        // It's position relative to the viewport (fixed positioning)\\n        viewport: {\\n          top: top - pageYOffset,\\n          bottom: pageYOffset - top - height + innerHeight,\\n          left: left - pageXOffset,\\n          right: pageXOffset - left - width + innerWidth\\n        }\\n      };\\n\\n      var doc = this.target.ownerDocument;\\n      var win = doc.defaultView;\\n\\n      var scrollbarSize = undefined;\\n      if (win.innerHeight > doc.documentElement.clientHeight) {\\n        scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);\\n        next.viewport.bottom -= scrollbarSize.height;\\n      }\\n\\n      if (win.innerWidth > doc.documentElement.clientWidth) {\\n        scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);\\n        next.viewport.right -= scrollbarSize.width;\\n      }\\n\\n      if (['', 'static'].indexOf(doc.body.style.position) === -1 || ['', 'static'].indexOf(doc.body.parentElement.style.position) === -1) {\\n        // Absolute positioning in the body will be relative to the page, not the 'initial containing block'\\n        next.page.bottom = doc.body.scrollHeight - top - height;\\n        next.page.right = doc.body.scrollWidth - left - width;\\n      }\\n\\n      if (typeof this.options.optimizations !== 'undefined' && this.options.optimizations.moveElement !== false && !(typeof this.targetModifier !== 'undefined')) {\\n        (function () {\\n          var offsetParent = _this7.cache('target-offsetparent', function () {\\n            return getOffsetParent(_this7.target);\\n          });\\n          var offsetPosition = _this7.cache('target-offsetparent-bounds', function () {\\n            return getBounds(offsetParent);\\n          });\\n          var offsetParentStyle = getComputedStyle(offsetParent);\\n          var offsetParentSize = offsetPosition;\\n\\n          var offsetBorder = {};\\n          ['Top', 'Left', 'Bottom', 'Right'].forEach(function (side) {\\n            offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle['border' + side + 'Width']);\\n          });\\n\\n          offsetPosition.right = doc.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;\\n          offsetPosition.bottom = doc.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;\\n\\n          if (next.page.top >= offsetPosition.top + offsetBorder.top && next.page.bottom >= offsetPosition.bottom) {\\n            if (next.page.left >= offsetPosition.left + offsetBorder.left && next.page.right >= offsetPosition.right) {\\n              // We're within the visible part of the target's scroll parent\\n              var scrollTop = offsetParent.scrollTop;\\n              var scrollLeft = offsetParent.scrollLeft;\\n\\n              // It's position relative to the target's offset parent (absolute positioning when\\n              // the element is moved to be a child of the target's offset parent).\\n              next.offset = {\\n                top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,\\n                left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left\\n              };\\n            }\\n          }\\n        })();\\n      }\\n\\n      // We could also travel up the DOM and try each containing context, rather than only\\n      // looking at the body, but we're gonna get diminishing returns.\\n\\n      this.move(next);\\n\\n      this.history.unshift(next);\\n\\n      if (this.history.length > 3) {\\n        this.history.pop();\\n      }\\n\\n      if (flushChanges) {\\n        flush();\\n      }\\n\\n      return true;\\n    }\\n\\n    // THE ISSUE\\n  }, {\\n    key: 'move',\\n    value: function move(pos) {\\n      var _this8 = this;\\n\\n      if (!(typeof this.element.parentNode !== 'undefined')) {\\n        return;\\n      }\\n\\n      var same = {};\\n\\n      for (var type in pos) {\\n        same[type] = {};\\n\\n        for (var key in pos[type]) {\\n          var found = false;\\n\\n          for (var i = 0; i < this.history.length; ++i) {\\n            var point = this.history[i];\\n            if (typeof point[type] !== 'undefined' && !within(point[type][key], pos[type][key])) {\\n              found = true;\\n              break;\\n            }\\n          }\\n\\n          if (!found) {\\n            same[type][key] = true;\\n          }\\n        }\\n      }\\n\\n      var css = { top: '', left: '', right: '', bottom: '' };\\n\\n      var transcribe = function transcribe(_same, _pos) {\\n        var hasOptimizations = typeof _this8.options.optimizations !== 'undefined';\\n        var gpu = hasOptimizations ? _this8.options.optimizations.gpu : null;\\n        if (gpu !== false) {\\n          var yPos = undefined,\\n              xPos = undefined;\\n          if (_same.top) {\\n            css.top = 0;\\n            yPos = _pos.top;\\n          } else {\\n            css.bottom = 0;\\n            yPos = -_pos.bottom;\\n          }\\n\\n          if (_same.left) {\\n            css.left = 0;\\n            xPos = _pos.left;\\n          } else {\\n            css.right = 0;\\n            xPos = -_pos.right;\\n          }\\n\\n          if (window.matchMedia) {\\n            // HubSpot/tether#207\\n            var retina = window.matchMedia('only screen and (min-resolution: 1.3dppx)').matches || window.matchMedia('only screen and (-webkit-min-device-pixel-ratio: 1.3)').matches;\\n            if (!retina) {\\n              xPos = Math.round(xPos);\\n              yPos = Math.round(yPos);\\n            }\\n          }\\n\\n          css[transformKey] = 'translateX(' + xPos + 'px) translateY(' + yPos + 'px)';\\n\\n          if (transformKey !== 'msTransform') {\\n            // The Z transform will keep this in the GPU (faster, and prevents artifacts),\\n            // but IE9 doesn't support 3d transforms and will choke.\\n            css[transformKey] += \\\" translateZ(0)\\\";\\n          }\\n        } else {\\n          if (_same.top) {\\n            css.top = _pos.top + 'px';\\n          } else {\\n            css.bottom = _pos.bottom + 'px';\\n          }\\n\\n          if (_same.left) {\\n            css.left = _pos.left + 'px';\\n          } else {\\n            css.right = _pos.right + 'px';\\n          }\\n        }\\n      };\\n\\n      var moved = false;\\n      if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {\\n        css.position = 'absolute';\\n        transcribe(same.page, pos.page);\\n      } else if ((same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {\\n        css.position = 'fixed';\\n        transcribe(same.viewport, pos.viewport);\\n      } else if (typeof same.offset !== 'undefined' && same.offset.top && same.offset.left) {\\n        (function () {\\n          css.position = 'absolute';\\n          var offsetParent = _this8.cache('target-offsetparent', function () {\\n            return getOffsetParent(_this8.target);\\n          });\\n\\n          if (getOffsetParent(_this8.element) !== offsetParent) {\\n            defer(function () {\\n              _this8.element.parentNode.removeChild(_this8.element);\\n              offsetParent.appendChild(_this8.element);\\n            });\\n          }\\n\\n          transcribe(same.offset, pos.offset);\\n          moved = true;\\n        })();\\n      } else {\\n        css.position = 'absolute';\\n        transcribe({ top: true, left: true }, pos.page);\\n      }\\n\\n      if (!moved) {\\n        if (this.options.bodyElement) {\\n          this.options.bodyElement.appendChild(this.element);\\n        } else {\\n          var offsetParentIsBody = true;\\n          var currentNode = this.element.parentNode;\\n          while (currentNode && currentNode.nodeType === 1 && currentNode.tagName !== 'BODY') {\\n            if (getComputedStyle(currentNode).position !== 'static') {\\n              offsetParentIsBody = false;\\n              break;\\n            }\\n\\n            currentNode = currentNode.parentNode;\\n          }\\n\\n          if (!offsetParentIsBody) {\\n            this.element.parentNode.removeChild(this.element);\\n            this.element.ownerDocument.body.appendChild(this.element);\\n          }\\n        }\\n      }\\n\\n      // Any css change will trigger a repaint, so let's avoid one if nothing changed\\n      var writeCSS = {};\\n      var write = false;\\n      for (var key in css) {\\n        var val = css[key];\\n        var elVal = this.element.style[key];\\n\\n        if (elVal !== val) {\\n          write = true;\\n          writeCSS[key] = val;\\n        }\\n      }\\n\\n      if (write) {\\n        defer(function () {\\n          extend(_this8.element.style, writeCSS);\\n          _this8.trigger('repositioned');\\n        });\\n      }\\n    }\\n  }]);\\n\\n  return TetherClass;\\n})(Evented);\\n\\nTetherClass.modules = [];\\n\\nTetherBase.position = position;\\n\\nvar Tether = extend(TetherClass, TetherBase);\\n/* globals TetherBase */\\n\\n'use strict';\\n\\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\\n\\nvar _TetherBase$Utils = TetherBase.Utils;\\nvar getBounds = _TetherBase$Utils.getBounds;\\nvar extend = _TetherBase$Utils.extend;\\nvar updateClasses = _TetherBase$Utils.updateClasses;\\nvar defer = _TetherBase$Utils.defer;\\n\\nvar BOUNDS_FORMAT = ['left', 'top', 'right', 'bottom'];\\n\\nfunction getBoundingRect(tether, to) {\\n  if (to === 'scrollParent') {\\n    to = tether.scrollParents[0];\\n  } else if (to === 'window') {\\n    to = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset];\\n  }\\n\\n  if (to === document) {\\n    to = to.documentElement;\\n  }\\n\\n  if (typeof to.nodeType !== 'undefined') {\\n    (function () {\\n      var node = to;\\n      var size = getBounds(to);\\n      var pos = size;\\n      var style = getComputedStyle(to);\\n\\n      to = [pos.left, pos.top, size.width + pos.left, size.height + pos.top];\\n\\n      // Account any parent Frames scroll offset\\n      if (node.ownerDocument !== document) {\\n        var win = node.ownerDocument.defaultView;\\n        to[0] += win.pageXOffset;\\n        to[1] += win.pageYOffset;\\n        to[2] += win.pageXOffset;\\n        to[3] += win.pageYOffset;\\n      }\\n\\n      BOUNDS_FORMAT.forEach(function (side, i) {\\n        side = side[0].toUpperCase() + side.substr(1);\\n        if (side === 'Top' || side === 'Left') {\\n          to[i] += parseFloat(style['border' + side + 'Width']);\\n        } else {\\n          to[i] -= parseFloat(style['border' + side + 'Width']);\\n        }\\n      });\\n    })();\\n  }\\n\\n  return to;\\n}\\n\\nTetherBase.modules.push({\\n  position: function position(_ref) {\\n    var _this = this;\\n\\n    var top = _ref.top;\\n    var left = _ref.left;\\n    var targetAttachment = _ref.targetAttachment;\\n\\n    if (!this.options.constraints) {\\n      return true;\\n    }\\n\\n    var _cache = this.cache('element-bounds', function () {\\n      return getBounds(_this.element);\\n    });\\n\\n    var height = _cache.height;\\n    var width = _cache.width;\\n\\n    if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {\\n      var _lastSize = this.lastSize;\\n\\n      // Handle the item getting hidden as a result of our positioning without glitching\\n      // the classes in and out\\n      width = _lastSize.width;\\n      height = _lastSize.height;\\n    }\\n\\n    var targetSize = this.cache('target-bounds', function () {\\n      return _this.getTargetBounds();\\n    });\\n\\n    var targetHeight = targetSize.height;\\n    var targetWidth = targetSize.width;\\n\\n    var allClasses = [this.getClass('pinned'), this.getClass('out-of-bounds')];\\n\\n    this.options.constraints.forEach(function (constraint) {\\n      var outOfBoundsClass = constraint.outOfBoundsClass;\\n      var pinnedClass = constraint.pinnedClass;\\n\\n      if (outOfBoundsClass) {\\n        allClasses.push(outOfBoundsClass);\\n      }\\n      if (pinnedClass) {\\n        allClasses.push(pinnedClass);\\n      }\\n    });\\n\\n    allClasses.forEach(function (cls) {\\n      ['left', 'top', 'right', 'bottom'].forEach(function (side) {\\n        allClasses.push(cls + '-' + side);\\n      });\\n    });\\n\\n    var addClasses = [];\\n\\n    var tAttachment = extend({}, targetAttachment);\\n    var eAttachment = extend({}, this.attachment);\\n\\n    this.options.constraints.forEach(function (constraint) {\\n      var to = constraint.to;\\n      var attachment = constraint.attachment;\\n      var pin = constraint.pin;\\n\\n      if (typeof attachment === 'undefined') {\\n        attachment = '';\\n      }\\n\\n      var changeAttachX = undefined,\\n          changeAttachY = undefined;\\n      if (attachment.indexOf(' ') >= 0) {\\n        var _attachment$split = attachment.split(' ');\\n\\n        var _attachment$split2 = _slicedToArray(_attachment$split, 2);\\n\\n        changeAttachY = _attachment$split2[0];\\n        changeAttachX = _attachment$split2[1];\\n      } else {\\n        changeAttachX = changeAttachY = attachment;\\n      }\\n\\n      var bounds = getBoundingRect(_this, to);\\n\\n      if (changeAttachY === 'target' || changeAttachY === 'both') {\\n        if (top < bounds[1] && tAttachment.top === 'top') {\\n          top += targetHeight;\\n          tAttachment.top = 'bottom';\\n        }\\n\\n        if (top + height > bounds[3] && tAttachment.top === 'bottom') {\\n          top -= targetHeight;\\n          tAttachment.top = 'top';\\n        }\\n      }\\n\\n      if (changeAttachY === 'together') {\\n        if (tAttachment.top === 'top') {\\n          if (eAttachment.top === 'bottom' && top < bounds[1]) {\\n            top += targetHeight;\\n            tAttachment.top = 'bottom';\\n\\n            top += height;\\n            eAttachment.top = 'top';\\n          } else if (eAttachment.top === 'top' && top + height > bounds[3] && top - (height - targetHeight) >= bounds[1]) {\\n            top -= height - targetHeight;\\n            tAttachment.top = 'bottom';\\n\\n            eAttachment.top = 'bottom';\\n          }\\n        }\\n\\n        if (tAttachment.top === 'bottom') {\\n          if (eAttachment.top === 'top' && top + height > bounds[3]) {\\n            top -= targetHeight;\\n            tAttachment.top = 'top';\\n\\n            top -= height;\\n            eAttachment.top = 'bottom';\\n          } else if (eAttachment.top === 'bottom' && top < bounds[1] && top + (height * 2 - targetHeight) <= bounds[3]) {\\n            top += height - targetHeight;\\n            tAttachment.top = 'top';\\n\\n            eAttachment.top = 'top';\\n          }\\n        }\\n\\n        if (tAttachment.top === 'middle') {\\n          if (top + height > bounds[3] && eAttachment.top === 'top') {\\n            top -= height;\\n            eAttachment.top = 'bottom';\\n          } else if (top < bounds[1] && eAttachment.top === 'bottom') {\\n            top += height;\\n            eAttachment.top = 'top';\\n          }\\n        }\\n      }\\n\\n      if (changeAttachX === 'target' || changeAttachX === 'both') {\\n        if (left < bounds[0] && tAttachment.left === 'left') {\\n          left += targetWidth;\\n          tAttachment.left = 'right';\\n        }\\n\\n        if (left + width > bounds[2] && tAttachment.left === 'right') {\\n          left -= targetWidth;\\n          tAttachment.left = 'left';\\n        }\\n      }\\n\\n      if (changeAttachX === 'together') {\\n        if (left < bounds[0] && tAttachment.left === 'left') {\\n          if (eAttachment.left === 'right') {\\n            left += targetWidth;\\n            tAttachment.left = 'right';\\n\\n            left += width;\\n            eAttachment.left = 'left';\\n          } else if (eAttachment.left === 'left') {\\n            left += targetWidth;\\n            tAttachment.left = 'right';\\n\\n            left -= width;\\n            eAttachment.left = 'right';\\n          }\\n        } else if (left + width > bounds[2] && tAttachment.left === 'right') {\\n          if (eAttachment.left === 'left') {\\n            left -= targetWidth;\\n            tAttachment.left = 'left';\\n\\n            left -= width;\\n            eAttachment.left = 'right';\\n          } else if (eAttachment.left === 'right') {\\n            left -= targetWidth;\\n            tAttachment.left = 'left';\\n\\n            left += width;\\n            eAttachment.left = 'left';\\n          }\\n        } else if (tAttachment.left === 'center') {\\n          if (left + width > bounds[2] && eAttachment.left === 'left') {\\n            left -= width;\\n            eAttachment.left = 'right';\\n          } else if (left < bounds[0] && eAttachment.left === 'right') {\\n            left += width;\\n            eAttachment.left = 'left';\\n          }\\n        }\\n      }\\n\\n      if (changeAttachY === 'element' || changeAttachY === 'both') {\\n        if (top < bounds[1] && eAttachment.top === 'bottom') {\\n          top += height;\\n          eAttachment.top = 'top';\\n        }\\n\\n        if (top + height > bounds[3] && eAttachment.top === 'top') {\\n          top -= height;\\n          eAttachment.top = 'bottom';\\n        }\\n      }\\n\\n      if (changeAttachX === 'element' || changeAttachX === 'both') {\\n        if (left < bounds[0]) {\\n          if (eAttachment.left === 'right') {\\n            left += width;\\n            eAttachment.left = 'left';\\n          } else if (eAttachment.left === 'center') {\\n            left += width / 2;\\n            eAttachment.left = 'left';\\n          }\\n        }\\n\\n        if (left + width > bounds[2]) {\\n          if (eAttachment.left === 'left') {\\n            left -= width;\\n            eAttachment.left = 'right';\\n          } else if (eAttachment.left === 'center') {\\n            left -= width / 2;\\n            eAttachment.left = 'right';\\n          }\\n        }\\n      }\\n\\n      if (typeof pin === 'string') {\\n        pin = pin.split(',').map(function (p) {\\n          return p.trim();\\n        });\\n      } else if (pin === true) {\\n        pin = ['top', 'left', 'right', 'bottom'];\\n      }\\n\\n      pin = pin || [];\\n\\n      var pinned = [];\\n      var oob = [];\\n\\n      if (top < bounds[1]) {\\n        if (pin.indexOf('top') >= 0) {\\n          top = bounds[1];\\n          pinned.push('top');\\n        } else {\\n          oob.push('top');\\n        }\\n      }\\n\\n      if (top + height > bounds[3]) {\\n        if (pin.indexOf('bottom') >= 0) {\\n          top = bounds[3] - height;\\n          pinned.push('bottom');\\n        } else {\\n          oob.push('bottom');\\n        }\\n      }\\n\\n      if (left < bounds[0]) {\\n        if (pin.indexOf('left') >= 0) {\\n          left = bounds[0];\\n          pinned.push('left');\\n        } else {\\n          oob.push('left');\\n        }\\n      }\\n\\n      if (left + width > bounds[2]) {\\n        if (pin.indexOf('right') >= 0) {\\n          left = bounds[2] - width;\\n          pinned.push('right');\\n        } else {\\n          oob.push('right');\\n        }\\n      }\\n\\n      if (pinned.length) {\\n        (function () {\\n          var pinnedClass = undefined;\\n          if (typeof _this.options.pinnedClass !== 'undefined') {\\n            pinnedClass = _this.options.pinnedClass;\\n          } else {\\n            pinnedClass = _this.getClass('pinned');\\n          }\\n\\n          addClasses.push(pinnedClass);\\n          pinned.forEach(function (side) {\\n            addClasses.push(pinnedClass + '-' + side);\\n          });\\n        })();\\n      }\\n\\n      if (oob.length) {\\n        (function () {\\n          var oobClass = undefined;\\n          if (typeof _this.options.outOfBoundsClass !== 'undefined') {\\n            oobClass = _this.options.outOfBoundsClass;\\n          } else {\\n            oobClass = _this.getClass('out-of-bounds');\\n          }\\n\\n          addClasses.push(oobClass);\\n          oob.forEach(function (side) {\\n            addClasses.push(oobClass + '-' + side);\\n          });\\n        })();\\n      }\\n\\n      if (pinned.indexOf('left') >= 0 || pinned.indexOf('right') >= 0) {\\n        eAttachment.left = tAttachment.left = false;\\n      }\\n      if (pinned.indexOf('top') >= 0 || pinned.indexOf('bottom') >= 0) {\\n        eAttachment.top = tAttachment.top = false;\\n      }\\n\\n      if (tAttachment.top !== targetAttachment.top || tAttachment.left !== targetAttachment.left || eAttachment.top !== _this.attachment.top || eAttachment.left !== _this.attachment.left) {\\n        _this.updateAttachClasses(eAttachment, tAttachment);\\n        _this.trigger('update', {\\n          attachment: eAttachment,\\n          targetAttachment: tAttachment\\n        });\\n      }\\n    });\\n\\n    defer(function () {\\n      if (!(_this.options.addTargetClasses === false)) {\\n        updateClasses(_this.target, addClasses, allClasses);\\n      }\\n      updateClasses(_this.element, addClasses, allClasses);\\n    });\\n\\n    return { top: top, left: left };\\n  }\\n});\\n/* globals TetherBase */\\n\\n'use strict';\\n\\nvar _TetherBase$Utils = TetherBase.Utils;\\nvar getBounds = _TetherBase$Utils.getBounds;\\nvar updateClasses = _TetherBase$Utils.updateClasses;\\nvar defer = _TetherBase$Utils.defer;\\n\\nTetherBase.modules.push({\\n  position: function position(_ref) {\\n    var _this = this;\\n\\n    var top = _ref.top;\\n    var left = _ref.left;\\n\\n    var _cache = this.cache('element-bounds', function () {\\n      return getBounds(_this.element);\\n    });\\n\\n    var height = _cache.height;\\n    var width = _cache.width;\\n\\n    var targetPos = this.getTargetBounds();\\n\\n    var bottom = top + height;\\n    var right = left + width;\\n\\n    var abutted = [];\\n    if (top <= targetPos.bottom && bottom >= targetPos.top) {\\n      ['left', 'right'].forEach(function (side) {\\n        var targetPosSide = targetPos[side];\\n        if (targetPosSide === left || targetPosSide === right) {\\n          abutted.push(side);\\n        }\\n      });\\n    }\\n\\n    if (left <= targetPos.right && right >= targetPos.left) {\\n      ['top', 'bottom'].forEach(function (side) {\\n        var targetPosSide = targetPos[side];\\n        if (targetPosSide === top || targetPosSide === bottom) {\\n          abutted.push(side);\\n        }\\n      });\\n    }\\n\\n    var allClasses = [];\\n    var addClasses = [];\\n\\n    var sides = ['left', 'top', 'right', 'bottom'];\\n    allClasses.push(this.getClass('abutted'));\\n    sides.forEach(function (side) {\\n      allClasses.push(_this.getClass('abutted') + '-' + side);\\n    });\\n\\n    if (abutted.length) {\\n      addClasses.push(this.getClass('abutted'));\\n    }\\n\\n    abutted.forEach(function (side) {\\n      addClasses.push(_this.getClass('abutted') + '-' + side);\\n    });\\n\\n    defer(function () {\\n      if (!(_this.options.addTargetClasses === false)) {\\n        updateClasses(_this.target, addClasses, allClasses);\\n      }\\n      updateClasses(_this.element, addClasses, allClasses);\\n    });\\n\\n    return true;\\n  }\\n});\\n/* globals TetherBase */\\n\\n'use strict';\\n\\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\\n\\nTetherBase.modules.push({\\n  position: function position(_ref) {\\n    var top = _ref.top;\\n    var left = _ref.left;\\n\\n    if (!this.options.shift) {\\n      return;\\n    }\\n\\n    var shift = this.options.shift;\\n    if (typeof this.options.shift === 'function') {\\n      shift = this.options.shift.call(this, { top: top, left: left });\\n    }\\n\\n    var shiftTop = undefined,\\n        shiftLeft = undefined;\\n    if (typeof shift === 'string') {\\n      shift = shift.split(' ');\\n      shift[1] = shift[1] || shift[0];\\n\\n      var _shift = shift;\\n\\n      var _shift2 = _slicedToArray(_shift, 2);\\n\\n      shiftTop = _shift2[0];\\n      shiftLeft = _shift2[1];\\n\\n      shiftTop = parseFloat(shiftTop, 10);\\n      shiftLeft = parseFloat(shiftLeft, 10);\\n    } else {\\n      shiftTop = shift.top;\\n      shiftLeft = shift.left;\\n    }\\n\\n    top += shiftTop;\\n    left += shiftLeft;\\n\\n    return { top: top, left: left };\\n  }\\n});\\nreturn Tether;\\n\\n}));\\n\"\n\n/***/ }\n\n},[1116]);\n\n\n// WEBPACK FOOTER //\n// scripts.bf57562ff54fc229c6a6.bundle.js","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript !== \"undefined\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/francoisdagostini/Projects/infiniteUx-prototype/~/script-loader/addScript.js\n// module id = 130\n// module chunks = 3","require(\"!!/Users/francoisdagostini/Projects/infiniteUx-prototype/node_modules/script-loader/addScript.js\")(require(\"!!/Users/francoisdagostini/Projects/infiniteUx-prototype/node_modules/raw-loader/index.js!/Users/francoisdagostini/Projects/infiniteUx-prototype/node_modules/bootstrap/dist/js/bootstrap.js\"))\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/francoisdagostini/Projects/infiniteUx-prototype/~/bootstrap/dist/js/bootstrap.js\n// module id = 517\n// module chunks = 3","require(\"!!/Users/francoisdagostini/Projects/infiniteUx-prototype/node_modules/script-loader/addScript.js\")(require(\"!!/Users/francoisdagostini/Projects/infiniteUx-prototype/node_modules/raw-loader/index.js!/Users/francoisdagostini/Projects/infiniteUx-prototype/node_modules/jquery/dist/jquery.js\"))\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/francoisdagostini/Projects/infiniteUx-prototype/~/jquery/dist/jquery.js\n// module id = 518\n// module chunks = 3","require(\"!!/Users/francoisdagostini/Projects/infiniteUx-prototype/node_modules/script-loader/addScript.js\")(require(\"!!/Users/francoisdagostini/Projects/infiniteUx-prototype/node_modules/raw-loader/index.js!/Users/francoisdagostini/Projects/infiniteUx-prototype/node_modules/source-map-loader/index.js!/Users/francoisdagostini/Projects/infiniteUx-prototype/src/assets/videojs/video.js\"))\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/francoisdagostini/Projects/infiniteUx-prototype/src/assets/videojs/video.js\n// module id = 519\n// module chunks = 3","require(\"!!/Users/francoisdagostini/Projects/infiniteUx-prototype/node_modules/script-loader/addScript.js\")(require(\"!!/Users/francoisdagostini/Projects/infiniteUx-prototype/node_modules/raw-loader/index.js!/Users/francoisdagostini/Projects/infiniteUx-prototype/node_modules/source-map-loader/index.js!/Users/francoisdagostini/Projects/infiniteUx-prototype/src/assets/videojs/videojs-contrib-hls.js\"))\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/francoisdagostini/Projects/infiniteUx-prototype/src/assets/videojs/videojs-contrib-hls.js\n// module id = 520\n// module chunks = 3","require(\"!!/Users/francoisdagostini/Projects/infiniteUx-prototype/node_modules/script-loader/addScript.js\")(require(\"!!/Users/francoisdagostini/Projects/infiniteUx-prototype/node_modules/raw-loader/index.js!/Users/francoisdagostini/Projects/infiniteUx-prototype/node_modules/tether/dist/js/tether.js\"))\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/francoisdagostini/Projects/infiniteUx-prototype/~/tether/dist/js/tether.js\n// module id = 521\n// module chunks = 3","module.exports = \"/*!\\n * Bootstrap v4.0.0-alpha.5 (https://getbootstrap.com)\\n * Copyright 2011-2016 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n */\\n\\nif (typeof jQuery === 'undefined') {\\n  throw new Error('Bootstrap\\\\'s JavaScript requires jQuery')\\n}\\n\\n+function ($) {\\n  var version = $.fn.jquery.split(' ')[0].split('.')\\n  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1) || (version[0] >= 4)) {\\n    throw new Error('Bootstrap\\\\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0')\\n  }\\n}(jQuery);\\n\\n\\n+function () {\\n\\nvar _typeof = typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; };\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v4.0.0-alpha.5): util.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\nvar Util = function ($) {\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Private TransitionEnd Helpers\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var transition = false;\\n\\n  var MAX_UID = 1000000;\\n\\n  var TransitionEndEvent = {\\n    WebkitTransition: 'webkitTransitionEnd',\\n    MozTransition: 'transitionend',\\n    OTransition: 'oTransitionEnd otransitionend',\\n    transition: 'transitionend'\\n  };\\n\\n  // shoutout AngusCroll (https://goo.gl/pxwQGp)\\n  function toType(obj) {\\n    return {}.toString.call(obj).match(/\\\\s([a-zA-Z]+)/)[1].toLowerCase();\\n  }\\n\\n  function isElement(obj) {\\n    return (obj[0] || obj).nodeType;\\n  }\\n\\n  function getSpecialTransitionEndEvent() {\\n    return {\\n      bindType: transition.end,\\n      delegateType: transition.end,\\n      handle: function handle(event) {\\n        if ($(event.target).is(this)) {\\n          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params\\n        }\\n        return undefined;\\n      }\\n    };\\n  }\\n\\n  function transitionEndTest() {\\n    if (window.QUnit) {\\n      return false;\\n    }\\n\\n    var el = document.createElement('bootstrap');\\n\\n    for (var name in TransitionEndEvent) {\\n      if (el.style[name] !== undefined) {\\n        return { end: TransitionEndEvent[name] };\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  function transitionEndEmulator(duration) {\\n    var _this = this;\\n\\n    var called = false;\\n\\n    $(this).one(Util.TRANSITION_END, function () {\\n      called = true;\\n    });\\n\\n    setTimeout(function () {\\n      if (!called) {\\n        Util.triggerTransitionEnd(_this);\\n      }\\n    }, duration);\\n\\n    return this;\\n  }\\n\\n  function setTransitionEndSupport() {\\n    transition = transitionEndTest();\\n\\n    $.fn.emulateTransitionEnd = transitionEndEmulator;\\n\\n    if (Util.supportsTransitionEnd()) {\\n      $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();\\n    }\\n  }\\n\\n  /**\\n   * --------------------------------------------------------------------------\\n   * Public Util Api\\n   * --------------------------------------------------------------------------\\n   */\\n\\n  var Util = {\\n\\n    TRANSITION_END: 'bsTransitionEnd',\\n\\n    getUID: function getUID(prefix) {\\n      do {\\n        /* eslint-disable no-bitwise */\\n        prefix += ~~(Math.random() * MAX_UID); // \\\"~~\\\" acts like a faster Math.floor() here\\n        /* eslint-enable no-bitwise */\\n      } while (document.getElementById(prefix));\\n      return prefix;\\n    },\\n    getSelectorFromElement: function getSelectorFromElement(element) {\\n      var selector = element.getAttribute('data-target');\\n\\n      if (!selector) {\\n        selector = element.getAttribute('href') || '';\\n        selector = /^#[a-z]/i.test(selector) ? selector : null;\\n      }\\n\\n      return selector;\\n    },\\n    reflow: function reflow(element) {\\n      new Function('bs', 'return bs')(element.offsetHeight);\\n    },\\n    triggerTransitionEnd: function triggerTransitionEnd(element) {\\n      $(element).trigger(transition.end);\\n    },\\n    supportsTransitionEnd: function supportsTransitionEnd() {\\n      return Boolean(transition);\\n    },\\n    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {\\n      for (var property in configTypes) {\\n        if (configTypes.hasOwnProperty(property)) {\\n          var expectedTypes = configTypes[property];\\n          var value = config[property];\\n          var valueType = void 0;\\n\\n          if (value && isElement(value)) {\\n            valueType = 'element';\\n          } else {\\n            valueType = toType(value);\\n          }\\n\\n          if (!new RegExp(expectedTypes).test(valueType)) {\\n            throw new Error(componentName.toUpperCase() + ': ' + ('Option \\\"' + property + '\\\" provided type \\\"' + valueType + '\\\" ') + ('but expected type \\\"' + expectedTypes + '\\\".'));\\n          }\\n        }\\n      }\\n    }\\n  };\\n\\n  setTransitionEndSupport();\\n\\n  return Util;\\n}(jQuery);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v4.0.0-alpha.5): alert.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\nvar Alert = function ($) {\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME = 'alert';\\n  var VERSION = '4.0.0-alpha.5';\\n  var DATA_KEY = 'bs.alert';\\n  var EVENT_KEY = '.' + DATA_KEY;\\n  var DATA_API_KEY = '.data-api';\\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\\n  var TRANSITION_DURATION = 150;\\n\\n  var Selector = {\\n    DISMISS: '[data-dismiss=\\\"alert\\\"]'\\n  };\\n\\n  var Event = {\\n    CLOSE: 'close' + EVENT_KEY,\\n    CLOSED: 'closed' + EVENT_KEY,\\n    CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY\\n  };\\n\\n  var ClassName = {\\n    ALERT: 'alert',\\n    FADE: 'fade',\\n    IN: 'in'\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Alert = function () {\\n    function Alert(element) {\\n      _classCallCheck(this, Alert);\\n\\n      this._element = element;\\n    }\\n\\n    // getters\\n\\n    // public\\n\\n    Alert.prototype.close = function close(element) {\\n      element = element || this._element;\\n\\n      var rootElement = this._getRootElement(element);\\n      var customEvent = this._triggerCloseEvent(rootElement);\\n\\n      if (customEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      this._removeElement(rootElement);\\n    };\\n\\n    Alert.prototype.dispose = function dispose() {\\n      $.removeData(this._element, DATA_KEY);\\n      this._element = null;\\n    };\\n\\n    // private\\n\\n    Alert.prototype._getRootElement = function _getRootElement(element) {\\n      var selector = Util.getSelectorFromElement(element);\\n      var parent = false;\\n\\n      if (selector) {\\n        parent = $(selector)[0];\\n      }\\n\\n      if (!parent) {\\n        parent = $(element).closest('.' + ClassName.ALERT)[0];\\n      }\\n\\n      return parent;\\n    };\\n\\n    Alert.prototype._triggerCloseEvent = function _triggerCloseEvent(element) {\\n      var closeEvent = $.Event(Event.CLOSE);\\n\\n      $(element).trigger(closeEvent);\\n      return closeEvent;\\n    };\\n\\n    Alert.prototype._removeElement = function _removeElement(element) {\\n      $(element).removeClass(ClassName.IN);\\n\\n      if (!Util.supportsTransitionEnd() || !$(element).hasClass(ClassName.FADE)) {\\n        this._destroyElement(element);\\n        return;\\n      }\\n\\n      $(element).one(Util.TRANSITION_END, $.proxy(this._destroyElement, this, element)).emulateTransitionEnd(TRANSITION_DURATION);\\n    };\\n\\n    Alert.prototype._destroyElement = function _destroyElement(element) {\\n      $(element).detach().trigger(Event.CLOSED).remove();\\n    };\\n\\n    // static\\n\\n    Alert._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var $element = $(this);\\n        var data = $element.data(DATA_KEY);\\n\\n        if (!data) {\\n          data = new Alert(this);\\n          $element.data(DATA_KEY, data);\\n        }\\n\\n        if (config === 'close') {\\n          data[config](this);\\n        }\\n      });\\n    };\\n\\n    Alert._handleDismiss = function _handleDismiss(alertInstance) {\\n      return function (event) {\\n        if (event) {\\n          event.preventDefault();\\n        }\\n\\n        alertInstance.close(this);\\n      };\\n    };\\n\\n    _createClass(Alert, null, [{\\n      key: 'VERSION',\\n      get: function get() {\\n        return VERSION;\\n      }\\n    }]);\\n\\n    return Alert;\\n  }();\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME] = Alert._jQueryInterface;\\n  $.fn[NAME].Constructor = Alert;\\n  $.fn[NAME].noConflict = function () {\\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\\n    return Alert._jQueryInterface;\\n  };\\n\\n  return Alert;\\n}(jQuery);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v4.0.0-alpha.5): button.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\nvar Button = function ($) {\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME = 'button';\\n  var VERSION = '4.0.0-alpha.5';\\n  var DATA_KEY = 'bs.button';\\n  var EVENT_KEY = '.' + DATA_KEY;\\n  var DATA_API_KEY = '.data-api';\\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\\n\\n  var ClassName = {\\n    ACTIVE: 'active',\\n    BUTTON: 'btn',\\n    FOCUS: 'focus'\\n  };\\n\\n  var Selector = {\\n    DATA_TOGGLE_CARROT: '[data-toggle^=\\\"button\\\"]',\\n    DATA_TOGGLE: '[data-toggle=\\\"buttons\\\"]',\\n    INPUT: 'input',\\n    ACTIVE: '.active',\\n    BUTTON: '.btn'\\n  };\\n\\n  var Event = {\\n    CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY,\\n    FOCUS_BLUR_DATA_API: 'focus' + EVENT_KEY + DATA_API_KEY + ' ' + ('blur' + EVENT_KEY + DATA_API_KEY)\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Button = function () {\\n    function Button(element) {\\n      _classCallCheck(this, Button);\\n\\n      this._element = element;\\n    }\\n\\n    // getters\\n\\n    // public\\n\\n    Button.prototype.toggle = function toggle() {\\n      var triggerChangeEvent = true;\\n      var rootElement = $(this._element).closest(Selector.DATA_TOGGLE)[0];\\n\\n      if (rootElement) {\\n        var input = $(this._element).find(Selector.INPUT)[0];\\n\\n        if (input) {\\n          if (input.type === 'radio') {\\n            if (input.checked && $(this._element).hasClass(ClassName.ACTIVE)) {\\n              triggerChangeEvent = false;\\n            } else {\\n              var activeElement = $(rootElement).find(Selector.ACTIVE)[0];\\n\\n              if (activeElement) {\\n                $(activeElement).removeClass(ClassName.ACTIVE);\\n              }\\n            }\\n          }\\n\\n          if (triggerChangeEvent) {\\n            input.checked = !$(this._element).hasClass(ClassName.ACTIVE);\\n            $(this._element).trigger('change');\\n          }\\n\\n          input.focus();\\n        }\\n      } else {\\n        this._element.setAttribute('aria-pressed', !$(this._element).hasClass(ClassName.ACTIVE));\\n      }\\n\\n      if (triggerChangeEvent) {\\n        $(this._element).toggleClass(ClassName.ACTIVE);\\n      }\\n    };\\n\\n    Button.prototype.dispose = function dispose() {\\n      $.removeData(this._element, DATA_KEY);\\n      this._element = null;\\n    };\\n\\n    // static\\n\\n    Button._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var data = $(this).data(DATA_KEY);\\n\\n        if (!data) {\\n          data = new Button(this);\\n          $(this).data(DATA_KEY, data);\\n        }\\n\\n        if (config === 'toggle') {\\n          data[config]();\\n        }\\n      });\\n    };\\n\\n    _createClass(Button, null, [{\\n      key: 'VERSION',\\n      get: function get() {\\n        return VERSION;\\n      }\\n    }]);\\n\\n    return Button;\\n  }();\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {\\n    event.preventDefault();\\n\\n    var button = event.target;\\n\\n    if (!$(button).hasClass(ClassName.BUTTON)) {\\n      button = $(button).closest(Selector.BUTTON);\\n    }\\n\\n    Button._jQueryInterface.call($(button), 'toggle');\\n  }).on(Event.FOCUS_BLUR_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {\\n    var button = $(event.target).closest(Selector.BUTTON)[0];\\n    $(button).toggleClass(ClassName.FOCUS, /^focus(in)?$/.test(event.type));\\n  });\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME] = Button._jQueryInterface;\\n  $.fn[NAME].Constructor = Button;\\n  $.fn[NAME].noConflict = function () {\\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\\n    return Button._jQueryInterface;\\n  };\\n\\n  return Button;\\n}(jQuery);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v4.0.0-alpha.5): carousel.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\nvar Carousel = function ($) {\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME = 'carousel';\\n  var VERSION = '4.0.0-alpha.5';\\n  var DATA_KEY = 'bs.carousel';\\n  var EVENT_KEY = '.' + DATA_KEY;\\n  var DATA_API_KEY = '.data-api';\\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\\n  var TRANSITION_DURATION = 600;\\n  var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key\\n  var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key\\n\\n  var Default = {\\n    interval: 5000,\\n    keyboard: true,\\n    slide: false,\\n    pause: 'hover',\\n    wrap: true\\n  };\\n\\n  var DefaultType = {\\n    interval: '(number|boolean)',\\n    keyboard: 'boolean',\\n    slide: '(boolean|string)',\\n    pause: '(string|boolean)',\\n    wrap: 'boolean'\\n  };\\n\\n  var Direction = {\\n    NEXT: 'next',\\n    PREVIOUS: 'prev'\\n  };\\n\\n  var Event = {\\n    SLIDE: 'slide' + EVENT_KEY,\\n    SLID: 'slid' + EVENT_KEY,\\n    KEYDOWN: 'keydown' + EVENT_KEY,\\n    MOUSEENTER: 'mouseenter' + EVENT_KEY,\\n    MOUSELEAVE: 'mouseleave' + EVENT_KEY,\\n    LOAD_DATA_API: 'load' + EVENT_KEY + DATA_API_KEY,\\n    CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY\\n  };\\n\\n  var ClassName = {\\n    CAROUSEL: 'carousel',\\n    ACTIVE: 'active',\\n    SLIDE: 'slide',\\n    RIGHT: 'right',\\n    LEFT: 'left',\\n    ITEM: 'carousel-item'\\n  };\\n\\n  var Selector = {\\n    ACTIVE: '.active',\\n    ACTIVE_ITEM: '.active.carousel-item',\\n    ITEM: '.carousel-item',\\n    NEXT_PREV: '.next, .prev',\\n    INDICATORS: '.carousel-indicators',\\n    DATA_SLIDE: '[data-slide], [data-slide-to]',\\n    DATA_RIDE: '[data-ride=\\\"carousel\\\"]'\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Carousel = function () {\\n    function Carousel(element, config) {\\n      _classCallCheck(this, Carousel);\\n\\n      this._items = null;\\n      this._interval = null;\\n      this._activeElement = null;\\n\\n      this._isPaused = false;\\n      this._isSliding = false;\\n\\n      this._config = this._getConfig(config);\\n      this._element = $(element)[0];\\n      this._indicatorsElement = $(this._element).find(Selector.INDICATORS)[0];\\n\\n      this._addEventListeners();\\n    }\\n\\n    // getters\\n\\n    // public\\n\\n    Carousel.prototype.next = function next() {\\n      if (!this._isSliding) {\\n        this._slide(Direction.NEXT);\\n      }\\n    };\\n\\n    Carousel.prototype.nextWhenVisible = function nextWhenVisible() {\\n      // Don't call next when the page isn't visible\\n      if (!document.hidden) {\\n        this.next();\\n      }\\n    };\\n\\n    Carousel.prototype.prev = function prev() {\\n      if (!this._isSliding) {\\n        this._slide(Direction.PREVIOUS);\\n      }\\n    };\\n\\n    Carousel.prototype.pause = function pause(event) {\\n      if (!event) {\\n        this._isPaused = true;\\n      }\\n\\n      if ($(this._element).find(Selector.NEXT_PREV)[0] && Util.supportsTransitionEnd()) {\\n        Util.triggerTransitionEnd(this._element);\\n        this.cycle(true);\\n      }\\n\\n      clearInterval(this._interval);\\n      this._interval = null;\\n    };\\n\\n    Carousel.prototype.cycle = function cycle(event) {\\n      if (!event) {\\n        this._isPaused = false;\\n      }\\n\\n      if (this._interval) {\\n        clearInterval(this._interval);\\n        this._interval = null;\\n      }\\n\\n      if (this._config.interval && !this._isPaused) {\\n        this._interval = setInterval($.proxy(document.visibilityState ? this.nextWhenVisible : this.next, this), this._config.interval);\\n      }\\n    };\\n\\n    Carousel.prototype.to = function to(index) {\\n      var _this2 = this;\\n\\n      this._activeElement = $(this._element).find(Selector.ACTIVE_ITEM)[0];\\n\\n      var activeIndex = this._getItemIndex(this._activeElement);\\n\\n      if (index > this._items.length - 1 || index < 0) {\\n        return;\\n      }\\n\\n      if (this._isSliding) {\\n        $(this._element).one(Event.SLID, function () {\\n          return _this2.to(index);\\n        });\\n        return;\\n      }\\n\\n      if (activeIndex === index) {\\n        this.pause();\\n        this.cycle();\\n        return;\\n      }\\n\\n      var direction = index > activeIndex ? Direction.NEXT : Direction.PREVIOUS;\\n\\n      this._slide(direction, this._items[index]);\\n    };\\n\\n    Carousel.prototype.dispose = function dispose() {\\n      $(this._element).off(EVENT_KEY);\\n      $.removeData(this._element, DATA_KEY);\\n\\n      this._items = null;\\n      this._config = null;\\n      this._element = null;\\n      this._interval = null;\\n      this._isPaused = null;\\n      this._isSliding = null;\\n      this._activeElement = null;\\n      this._indicatorsElement = null;\\n    };\\n\\n    // private\\n\\n    Carousel.prototype._getConfig = function _getConfig(config) {\\n      config = $.extend({}, Default, config);\\n      Util.typeCheckConfig(NAME, config, DefaultType);\\n      return config;\\n    };\\n\\n    Carousel.prototype._addEventListeners = function _addEventListeners() {\\n      if (this._config.keyboard) {\\n        $(this._element).on(Event.KEYDOWN, $.proxy(this._keydown, this));\\n      }\\n\\n      if (this._config.pause === 'hover' && !('ontouchstart' in document.documentElement)) {\\n        $(this._element).on(Event.MOUSEENTER, $.proxy(this.pause, this)).on(Event.MOUSELEAVE, $.proxy(this.cycle, this));\\n      }\\n    };\\n\\n    Carousel.prototype._keydown = function _keydown(event) {\\n      event.preventDefault();\\n\\n      if (/input|textarea/i.test(event.target.tagName)) {\\n        return;\\n      }\\n\\n      switch (event.which) {\\n        case ARROW_LEFT_KEYCODE:\\n          this.prev();\\n          break;\\n        case ARROW_RIGHT_KEYCODE:\\n          this.next();\\n          break;\\n        default:\\n          return;\\n      }\\n    };\\n\\n    Carousel.prototype._getItemIndex = function _getItemIndex(element) {\\n      this._items = $.makeArray($(element).parent().find(Selector.ITEM));\\n      return this._items.indexOf(element);\\n    };\\n\\n    Carousel.prototype._getItemByDirection = function _getItemByDirection(direction, activeElement) {\\n      var isNextDirection = direction === Direction.NEXT;\\n      var isPrevDirection = direction === Direction.PREVIOUS;\\n      var activeIndex = this._getItemIndex(activeElement);\\n      var lastItemIndex = this._items.length - 1;\\n      var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;\\n\\n      if (isGoingToWrap && !this._config.wrap) {\\n        return activeElement;\\n      }\\n\\n      var delta = direction === Direction.PREVIOUS ? -1 : 1;\\n      var itemIndex = (activeIndex + delta) % this._items.length;\\n\\n      return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];\\n    };\\n\\n    Carousel.prototype._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, directionalClassname) {\\n      var slideEvent = $.Event(Event.SLIDE, {\\n        relatedTarget: relatedTarget,\\n        direction: directionalClassname\\n      });\\n\\n      $(this._element).trigger(slideEvent);\\n\\n      return slideEvent;\\n    };\\n\\n    Carousel.prototype._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {\\n      if (this._indicatorsElement) {\\n        $(this._indicatorsElement).find(Selector.ACTIVE).removeClass(ClassName.ACTIVE);\\n\\n        var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];\\n\\n        if (nextIndicator) {\\n          $(nextIndicator).addClass(ClassName.ACTIVE);\\n        }\\n      }\\n    };\\n\\n    Carousel.prototype._slide = function _slide(direction, element) {\\n      var _this3 = this;\\n\\n      var activeElement = $(this._element).find(Selector.ACTIVE_ITEM)[0];\\n      var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);\\n\\n      var isCycling = Boolean(this._interval);\\n\\n      var directionalClassName = direction === Direction.NEXT ? ClassName.LEFT : ClassName.RIGHT;\\n\\n      if (nextElement && $(nextElement).hasClass(ClassName.ACTIVE)) {\\n        this._isSliding = false;\\n        return;\\n      }\\n\\n      var slideEvent = this._triggerSlideEvent(nextElement, directionalClassName);\\n      if (slideEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      if (!activeElement || !nextElement) {\\n        // some weirdness is happening, so we bail\\n        return;\\n      }\\n\\n      this._isSliding = true;\\n\\n      if (isCycling) {\\n        this.pause();\\n      }\\n\\n      this._setActiveIndicatorElement(nextElement);\\n\\n      var slidEvent = $.Event(Event.SLID, {\\n        relatedTarget: nextElement,\\n        direction: directionalClassName\\n      });\\n\\n      if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.SLIDE)) {\\n\\n        $(nextElement).addClass(direction);\\n\\n        Util.reflow(nextElement);\\n\\n        $(activeElement).addClass(directionalClassName);\\n        $(nextElement).addClass(directionalClassName);\\n\\n        $(activeElement).one(Util.TRANSITION_END, function () {\\n          $(nextElement).removeClass(directionalClassName).removeClass(direction);\\n\\n          $(nextElement).addClass(ClassName.ACTIVE);\\n\\n          $(activeElement).removeClass(ClassName.ACTIVE).removeClass(direction).removeClass(directionalClassName);\\n\\n          _this3._isSliding = false;\\n\\n          setTimeout(function () {\\n            return $(_this3._element).trigger(slidEvent);\\n          }, 0);\\n        }).emulateTransitionEnd(TRANSITION_DURATION);\\n      } else {\\n        $(activeElement).removeClass(ClassName.ACTIVE);\\n        $(nextElement).addClass(ClassName.ACTIVE);\\n\\n        this._isSliding = false;\\n        $(this._element).trigger(slidEvent);\\n      }\\n\\n      if (isCycling) {\\n        this.cycle();\\n      }\\n    };\\n\\n    // static\\n\\n    Carousel._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var data = $(this).data(DATA_KEY);\\n        var _config = $.extend({}, Default, $(this).data());\\n\\n        if ((typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object') {\\n          $.extend(_config, config);\\n        }\\n\\n        var action = typeof config === 'string' ? config : _config.slide;\\n\\n        if (!data) {\\n          data = new Carousel(this, _config);\\n          $(this).data(DATA_KEY, data);\\n        }\\n\\n        if (typeof config === 'number') {\\n          data.to(config);\\n        } else if (typeof action === 'string') {\\n          if (data[action] === undefined) {\\n            throw new Error('No method named \\\"' + action + '\\\"');\\n          }\\n          data[action]();\\n        } else if (_config.interval) {\\n          data.pause();\\n          data.cycle();\\n        }\\n      });\\n    };\\n\\n    Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {\\n      var selector = Util.getSelectorFromElement(this);\\n\\n      if (!selector) {\\n        return;\\n      }\\n\\n      var target = $(selector)[0];\\n\\n      if (!target || !$(target).hasClass(ClassName.CAROUSEL)) {\\n        return;\\n      }\\n\\n      var config = $.extend({}, $(target).data(), $(this).data());\\n      var slideIndex = this.getAttribute('data-slide-to');\\n\\n      if (slideIndex) {\\n        config.interval = false;\\n      }\\n\\n      Carousel._jQueryInterface.call($(target), config);\\n\\n      if (slideIndex) {\\n        $(target).data(DATA_KEY).to(slideIndex);\\n      }\\n\\n      event.preventDefault();\\n    };\\n\\n    _createClass(Carousel, null, [{\\n      key: 'VERSION',\\n      get: function get() {\\n        return VERSION;\\n      }\\n    }, {\\n      key: 'Default',\\n      get: function get() {\\n        return Default;\\n      }\\n    }]);\\n\\n    return Carousel;\\n  }();\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_SLIDE, Carousel._dataApiClickHandler);\\n\\n  $(window).on(Event.LOAD_DATA_API, function () {\\n    $(Selector.DATA_RIDE).each(function () {\\n      var $carousel = $(this);\\n      Carousel._jQueryInterface.call($carousel, $carousel.data());\\n    });\\n  });\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME] = Carousel._jQueryInterface;\\n  $.fn[NAME].Constructor = Carousel;\\n  $.fn[NAME].noConflict = function () {\\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\\n    return Carousel._jQueryInterface;\\n  };\\n\\n  return Carousel;\\n}(jQuery);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v4.0.0-alpha.5): collapse.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\nvar Collapse = function ($) {\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME = 'collapse';\\n  var VERSION = '4.0.0-alpha.5';\\n  var DATA_KEY = 'bs.collapse';\\n  var EVENT_KEY = '.' + DATA_KEY;\\n  var DATA_API_KEY = '.data-api';\\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\\n  var TRANSITION_DURATION = 600;\\n\\n  var Default = {\\n    toggle: true,\\n    parent: ''\\n  };\\n\\n  var DefaultType = {\\n    toggle: 'boolean',\\n    parent: 'string'\\n  };\\n\\n  var Event = {\\n    SHOW: 'show' + EVENT_KEY,\\n    SHOWN: 'shown' + EVENT_KEY,\\n    HIDE: 'hide' + EVENT_KEY,\\n    HIDDEN: 'hidden' + EVENT_KEY,\\n    CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY\\n  };\\n\\n  var ClassName = {\\n    IN: 'in',\\n    COLLAPSE: 'collapse',\\n    COLLAPSING: 'collapsing',\\n    COLLAPSED: 'collapsed'\\n  };\\n\\n  var Dimension = {\\n    WIDTH: 'width',\\n    HEIGHT: 'height'\\n  };\\n\\n  var Selector = {\\n    ACTIVES: '.card > .in, .card > .collapsing',\\n    DATA_TOGGLE: '[data-toggle=\\\"collapse\\\"]'\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Collapse = function () {\\n    function Collapse(element, config) {\\n      _classCallCheck(this, Collapse);\\n\\n      this._isTransitioning = false;\\n      this._element = element;\\n      this._config = this._getConfig(config);\\n      this._triggerArray = $.makeArray($('[data-toggle=\\\"collapse\\\"][href=\\\"#' + element.id + '\\\"],' + ('[data-toggle=\\\"collapse\\\"][data-target=\\\"#' + element.id + '\\\"]')));\\n\\n      this._parent = this._config.parent ? this._getParent() : null;\\n\\n      if (!this._config.parent) {\\n        this._addAriaAndCollapsedClass(this._element, this._triggerArray);\\n      }\\n\\n      if (this._config.toggle) {\\n        this.toggle();\\n      }\\n    }\\n\\n    // getters\\n\\n    // public\\n\\n    Collapse.prototype.toggle = function toggle() {\\n      if ($(this._element).hasClass(ClassName.IN)) {\\n        this.hide();\\n      } else {\\n        this.show();\\n      }\\n    };\\n\\n    Collapse.prototype.show = function show() {\\n      var _this4 = this;\\n\\n      if (this._isTransitioning || $(this._element).hasClass(ClassName.IN)) {\\n        return;\\n      }\\n\\n      var actives = void 0;\\n      var activesData = void 0;\\n\\n      if (this._parent) {\\n        actives = $.makeArray($(Selector.ACTIVES));\\n        if (!actives.length) {\\n          actives = null;\\n        }\\n      }\\n\\n      if (actives) {\\n        activesData = $(actives).data(DATA_KEY);\\n        if (activesData && activesData._isTransitioning) {\\n          return;\\n        }\\n      }\\n\\n      var startEvent = $.Event(Event.SHOW);\\n      $(this._element).trigger(startEvent);\\n      if (startEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      if (actives) {\\n        Collapse._jQueryInterface.call($(actives), 'hide');\\n        if (!activesData) {\\n          $(actives).data(DATA_KEY, null);\\n        }\\n      }\\n\\n      var dimension = this._getDimension();\\n\\n      $(this._element).removeClass(ClassName.COLLAPSE).addClass(ClassName.COLLAPSING);\\n\\n      this._element.style[dimension] = 0;\\n      this._element.setAttribute('aria-expanded', true);\\n\\n      if (this._triggerArray.length) {\\n        $(this._triggerArray).removeClass(ClassName.COLLAPSED).attr('aria-expanded', true);\\n      }\\n\\n      this.setTransitioning(true);\\n\\n      var complete = function complete() {\\n        $(_this4._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).addClass(ClassName.IN);\\n\\n        _this4._element.style[dimension] = '';\\n\\n        _this4.setTransitioning(false);\\n\\n        $(_this4._element).trigger(Event.SHOWN);\\n      };\\n\\n      if (!Util.supportsTransitionEnd()) {\\n        complete();\\n        return;\\n      }\\n\\n      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\\n      var scrollSize = 'scroll' + capitalizedDimension;\\n\\n      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);\\n\\n      this._element.style[dimension] = this._element[scrollSize] + 'px';\\n    };\\n\\n    Collapse.prototype.hide = function hide() {\\n      var _this5 = this;\\n\\n      if (this._isTransitioning || !$(this._element).hasClass(ClassName.IN)) {\\n        return;\\n      }\\n\\n      var startEvent = $.Event(Event.HIDE);\\n      $(this._element).trigger(startEvent);\\n      if (startEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      var dimension = this._getDimension();\\n      var offsetDimension = dimension === Dimension.WIDTH ? 'offsetWidth' : 'offsetHeight';\\n\\n      this._element.style[dimension] = this._element[offsetDimension] + 'px';\\n\\n      Util.reflow(this._element);\\n\\n      $(this._element).addClass(ClassName.COLLAPSING).removeClass(ClassName.COLLAPSE).removeClass(ClassName.IN);\\n\\n      this._element.setAttribute('aria-expanded', false);\\n\\n      if (this._triggerArray.length) {\\n        $(this._triggerArray).addClass(ClassName.COLLAPSED).attr('aria-expanded', false);\\n      }\\n\\n      this.setTransitioning(true);\\n\\n      var complete = function complete() {\\n        _this5.setTransitioning(false);\\n        $(_this5._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).trigger(Event.HIDDEN);\\n      };\\n\\n      this._element.style[dimension] = '';\\n\\n      if (!Util.supportsTransitionEnd()) {\\n        complete();\\n        return;\\n      }\\n\\n      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);\\n    };\\n\\n    Collapse.prototype.setTransitioning = function setTransitioning(isTransitioning) {\\n      this._isTransitioning = isTransitioning;\\n    };\\n\\n    Collapse.prototype.dispose = function dispose() {\\n      $.removeData(this._element, DATA_KEY);\\n\\n      this._config = null;\\n      this._parent = null;\\n      this._element = null;\\n      this._triggerArray = null;\\n      this._isTransitioning = null;\\n    };\\n\\n    // private\\n\\n    Collapse.prototype._getConfig = function _getConfig(config) {\\n      config = $.extend({}, Default, config);\\n      config.toggle = Boolean(config.toggle); // coerce string values\\n      Util.typeCheckConfig(NAME, config, DefaultType);\\n      return config;\\n    };\\n\\n    Collapse.prototype._getDimension = function _getDimension() {\\n      var hasWidth = $(this._element).hasClass(Dimension.WIDTH);\\n      return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;\\n    };\\n\\n    Collapse.prototype._getParent = function _getParent() {\\n      var _this6 = this;\\n\\n      var parent = $(this._config.parent)[0];\\n      var selector = '[data-toggle=\\\"collapse\\\"][data-parent=\\\"' + this._config.parent + '\\\"]';\\n\\n      $(parent).find(selector).each(function (i, element) {\\n        _this6._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);\\n      });\\n\\n      return parent;\\n    };\\n\\n    Collapse.prototype._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {\\n      if (element) {\\n        var isOpen = $(element).hasClass(ClassName.IN);\\n        element.setAttribute('aria-expanded', isOpen);\\n\\n        if (triggerArray.length) {\\n          $(triggerArray).toggleClass(ClassName.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);\\n        }\\n      }\\n    };\\n\\n    // static\\n\\n    Collapse._getTargetFromElement = function _getTargetFromElement(element) {\\n      var selector = Util.getSelectorFromElement(element);\\n      return selector ? $(selector)[0] : null;\\n    };\\n\\n    Collapse._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var $this = $(this);\\n        var data = $this.data(DATA_KEY);\\n        var _config = $.extend({}, Default, $this.data(), (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config);\\n\\n        if (!data && _config.toggle && /show|hide/.test(config)) {\\n          _config.toggle = false;\\n        }\\n\\n        if (!data) {\\n          data = new Collapse(this, _config);\\n          $this.data(DATA_KEY, data);\\n        }\\n\\n        if (typeof config === 'string') {\\n          if (data[config] === undefined) {\\n            throw new Error('No method named \\\"' + config + '\\\"');\\n          }\\n          data[config]();\\n        }\\n      });\\n    };\\n\\n    _createClass(Collapse, null, [{\\n      key: 'VERSION',\\n      get: function get() {\\n        return VERSION;\\n      }\\n    }, {\\n      key: 'Default',\\n      get: function get() {\\n        return Default;\\n      }\\n    }]);\\n\\n    return Collapse;\\n  }();\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {\\n    event.preventDefault();\\n\\n    var target = Collapse._getTargetFromElement(this);\\n    var data = $(target).data(DATA_KEY);\\n    var config = data ? 'toggle' : $(this).data();\\n\\n    Collapse._jQueryInterface.call($(target), config);\\n  });\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME] = Collapse._jQueryInterface;\\n  $.fn[NAME].Constructor = Collapse;\\n  $.fn[NAME].noConflict = function () {\\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\\n    return Collapse._jQueryInterface;\\n  };\\n\\n  return Collapse;\\n}(jQuery);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v4.0.0-alpha.5): dropdown.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\nvar Dropdown = function ($) {\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME = 'dropdown';\\n  var VERSION = '4.0.0-alpha.5';\\n  var DATA_KEY = 'bs.dropdown';\\n  var EVENT_KEY = '.' + DATA_KEY;\\n  var DATA_API_KEY = '.data-api';\\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\\n  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key\\n  var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key\\n  var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key\\n  var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)\\n\\n  var Event = {\\n    HIDE: 'hide' + EVENT_KEY,\\n    HIDDEN: 'hidden' + EVENT_KEY,\\n    SHOW: 'show' + EVENT_KEY,\\n    SHOWN: 'shown' + EVENT_KEY,\\n    CLICK: 'click' + EVENT_KEY,\\n    CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY,\\n    KEYDOWN_DATA_API: 'keydown' + EVENT_KEY + DATA_API_KEY\\n  };\\n\\n  var ClassName = {\\n    BACKDROP: 'dropdown-backdrop',\\n    DISABLED: 'disabled',\\n    OPEN: 'open'\\n  };\\n\\n  var Selector = {\\n    BACKDROP: '.dropdown-backdrop',\\n    DATA_TOGGLE: '[data-toggle=\\\"dropdown\\\"]',\\n    FORM_CHILD: '.dropdown form',\\n    ROLE_MENU: '[role=\\\"menu\\\"]',\\n    ROLE_LISTBOX: '[role=\\\"listbox\\\"]',\\n    NAVBAR_NAV: '.navbar-nav',\\n    VISIBLE_ITEMS: '[role=\\\"menu\\\"] li:not(.disabled) a, ' + '[role=\\\"listbox\\\"] li:not(.disabled) a'\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Dropdown = function () {\\n    function Dropdown(element) {\\n      _classCallCheck(this, Dropdown);\\n\\n      this._element = element;\\n\\n      this._addEventListeners();\\n    }\\n\\n    // getters\\n\\n    // public\\n\\n    Dropdown.prototype.toggle = function toggle() {\\n      if (this.disabled || $(this).hasClass(ClassName.DISABLED)) {\\n        return false;\\n      }\\n\\n      var parent = Dropdown._getParentFromElement(this);\\n      var isActive = $(parent).hasClass(ClassName.OPEN);\\n\\n      Dropdown._clearMenus();\\n\\n      if (isActive) {\\n        return false;\\n      }\\n\\n      if ('ontouchstart' in document.documentElement && !$(parent).closest(Selector.NAVBAR_NAV).length) {\\n\\n        // if mobile we use a backdrop because click events don't delegate\\n        var dropdown = document.createElement('div');\\n        dropdown.className = ClassName.BACKDROP;\\n        $(dropdown).insertBefore(this);\\n        $(dropdown).on('click', Dropdown._clearMenus);\\n      }\\n\\n      var relatedTarget = { relatedTarget: this };\\n      var showEvent = $.Event(Event.SHOW, relatedTarget);\\n\\n      $(parent).trigger(showEvent);\\n\\n      if (showEvent.isDefaultPrevented()) {\\n        return false;\\n      }\\n\\n      this.focus();\\n      this.setAttribute('aria-expanded', 'true');\\n\\n      $(parent).toggleClass(ClassName.OPEN);\\n      $(parent).trigger($.Event(Event.SHOWN, relatedTarget));\\n\\n      return false;\\n    };\\n\\n    Dropdown.prototype.dispose = function dispose() {\\n      $.removeData(this._element, DATA_KEY);\\n      $(this._element).off(EVENT_KEY);\\n      this._element = null;\\n    };\\n\\n    // private\\n\\n    Dropdown.prototype._addEventListeners = function _addEventListeners() {\\n      $(this._element).on(Event.CLICK, this.toggle);\\n    };\\n\\n    // static\\n\\n    Dropdown._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var data = $(this).data(DATA_KEY);\\n\\n        if (!data) {\\n          $(this).data(DATA_KEY, data = new Dropdown(this));\\n        }\\n\\n        if (typeof config === 'string') {\\n          if (data[config] === undefined) {\\n            throw new Error('No method named \\\"' + config + '\\\"');\\n          }\\n          data[config].call(this);\\n        }\\n      });\\n    };\\n\\n    Dropdown._clearMenus = function _clearMenus(event) {\\n      if (event && event.which === RIGHT_MOUSE_BUTTON_WHICH) {\\n        return;\\n      }\\n\\n      var backdrop = $(Selector.BACKDROP)[0];\\n      if (backdrop) {\\n        backdrop.parentNode.removeChild(backdrop);\\n      }\\n\\n      var toggles = $.makeArray($(Selector.DATA_TOGGLE));\\n\\n      for (var i = 0; i < toggles.length; i++) {\\n        var parent = Dropdown._getParentFromElement(toggles[i]);\\n        var relatedTarget = { relatedTarget: toggles[i] };\\n\\n        if (!$(parent).hasClass(ClassName.OPEN)) {\\n          continue;\\n        }\\n\\n        if (event && event.type === 'click' && /input|textarea/i.test(event.target.tagName) && $.contains(parent, event.target)) {\\n          continue;\\n        }\\n\\n        var hideEvent = $.Event(Event.HIDE, relatedTarget);\\n        $(parent).trigger(hideEvent);\\n        if (hideEvent.isDefaultPrevented()) {\\n          continue;\\n        }\\n\\n        toggles[i].setAttribute('aria-expanded', 'false');\\n\\n        $(parent).removeClass(ClassName.OPEN).trigger($.Event(Event.HIDDEN, relatedTarget));\\n      }\\n    };\\n\\n    Dropdown._getParentFromElement = function _getParentFromElement(element) {\\n      var parent = void 0;\\n      var selector = Util.getSelectorFromElement(element);\\n\\n      if (selector) {\\n        parent = $(selector)[0];\\n      }\\n\\n      return parent || element.parentNode;\\n    };\\n\\n    Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {\\n      if (!/(38|40|27|32)/.test(event.which) || /input|textarea/i.test(event.target.tagName)) {\\n        return;\\n      }\\n\\n      event.preventDefault();\\n      event.stopPropagation();\\n\\n      if (this.disabled || $(this).hasClass(ClassName.DISABLED)) {\\n        return;\\n      }\\n\\n      var parent = Dropdown._getParentFromElement(this);\\n      var isActive = $(parent).hasClass(ClassName.OPEN);\\n\\n      if (!isActive && event.which !== ESCAPE_KEYCODE || isActive && event.which === ESCAPE_KEYCODE) {\\n\\n        if (event.which === ESCAPE_KEYCODE) {\\n          var toggle = $(parent).find(Selector.DATA_TOGGLE)[0];\\n          $(toggle).trigger('focus');\\n        }\\n\\n        $(this).trigger('click');\\n        return;\\n      }\\n\\n      var items = $.makeArray($(Selector.VISIBLE_ITEMS));\\n\\n      items = items.filter(function (item) {\\n        return item.offsetWidth || item.offsetHeight;\\n      });\\n\\n      if (!items.length) {\\n        return;\\n      }\\n\\n      var index = items.indexOf(event.target);\\n\\n      if (event.which === ARROW_UP_KEYCODE && index > 0) {\\n        // up\\n        index--;\\n      }\\n\\n      if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {\\n        // down\\n        index++;\\n      }\\n\\n      if (index < 0) {\\n        index = 0;\\n      }\\n\\n      items[index].focus();\\n    };\\n\\n    _createClass(Dropdown, null, [{\\n      key: 'VERSION',\\n      get: function get() {\\n        return VERSION;\\n      }\\n    }]);\\n\\n    return Dropdown;\\n  }();\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $(document).on(Event.KEYDOWN_DATA_API, Selector.DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event.KEYDOWN_DATA_API, Selector.ROLE_MENU, Dropdown._dataApiKeydownHandler).on(Event.KEYDOWN_DATA_API, Selector.ROLE_LISTBOX, Dropdown._dataApiKeydownHandler).on(Event.CLICK_DATA_API, Dropdown._clearMenus).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, Dropdown.prototype.toggle).on(Event.CLICK_DATA_API, Selector.FORM_CHILD, function (e) {\\n    e.stopPropagation();\\n  });\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME] = Dropdown._jQueryInterface;\\n  $.fn[NAME].Constructor = Dropdown;\\n  $.fn[NAME].noConflict = function () {\\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\\n    return Dropdown._jQueryInterface;\\n  };\\n\\n  return Dropdown;\\n}(jQuery);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v4.0.0-alpha.5): modal.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\nvar Modal = function ($) {\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME = 'modal';\\n  var VERSION = '4.0.0-alpha.5';\\n  var DATA_KEY = 'bs.modal';\\n  var EVENT_KEY = '.' + DATA_KEY;\\n  var DATA_API_KEY = '.data-api';\\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\\n  var TRANSITION_DURATION = 300;\\n  var BACKDROP_TRANSITION_DURATION = 150;\\n  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key\\n\\n  var Default = {\\n    backdrop: true,\\n    keyboard: true,\\n    focus: true,\\n    show: true\\n  };\\n\\n  var DefaultType = {\\n    backdrop: '(boolean|string)',\\n    keyboard: 'boolean',\\n    focus: 'boolean',\\n    show: 'boolean'\\n  };\\n\\n  var Event = {\\n    HIDE: 'hide' + EVENT_KEY,\\n    HIDDEN: 'hidden' + EVENT_KEY,\\n    SHOW: 'show' + EVENT_KEY,\\n    SHOWN: 'shown' + EVENT_KEY,\\n    FOCUSIN: 'focusin' + EVENT_KEY,\\n    RESIZE: 'resize' + EVENT_KEY,\\n    CLICK_DISMISS: 'click.dismiss' + EVENT_KEY,\\n    KEYDOWN_DISMISS: 'keydown.dismiss' + EVENT_KEY,\\n    MOUSEUP_DISMISS: 'mouseup.dismiss' + EVENT_KEY,\\n    MOUSEDOWN_DISMISS: 'mousedown.dismiss' + EVENT_KEY,\\n    CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY\\n  };\\n\\n  var ClassName = {\\n    SCROLLBAR_MEASURER: 'modal-scrollbar-measure',\\n    BACKDROP: 'modal-backdrop',\\n    OPEN: 'modal-open',\\n    FADE: 'fade',\\n    IN: 'in'\\n  };\\n\\n  var Selector = {\\n    DIALOG: '.modal-dialog',\\n    DATA_TOGGLE: '[data-toggle=\\\"modal\\\"]',\\n    DATA_DISMISS: '[data-dismiss=\\\"modal\\\"]',\\n    FIXED_CONTENT: '.navbar-fixed-top, .navbar-fixed-bottom, .is-fixed'\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Modal = function () {\\n    function Modal(element, config) {\\n      _classCallCheck(this, Modal);\\n\\n      this._config = this._getConfig(config);\\n      this._element = element;\\n      this._dialog = $(element).find(Selector.DIALOG)[0];\\n      this._backdrop = null;\\n      this._isShown = false;\\n      this._isBodyOverflowing = false;\\n      this._ignoreBackdropClick = false;\\n      this._originalBodyPadding = 0;\\n      this._scrollbarWidth = 0;\\n    }\\n\\n    // getters\\n\\n    // public\\n\\n    Modal.prototype.toggle = function toggle(relatedTarget) {\\n      return this._isShown ? this.hide() : this.show(relatedTarget);\\n    };\\n\\n    Modal.prototype.show = function show(relatedTarget) {\\n      var _this7 = this;\\n\\n      var showEvent = $.Event(Event.SHOW, {\\n        relatedTarget: relatedTarget\\n      });\\n\\n      $(this._element).trigger(showEvent);\\n\\n      if (this._isShown || showEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      this._isShown = true;\\n\\n      this._checkScrollbar();\\n      this._setScrollbar();\\n\\n      $(document.body).addClass(ClassName.OPEN);\\n\\n      this._setEscapeEvent();\\n      this._setResizeEvent();\\n\\n      $(this._element).on(Event.CLICK_DISMISS, Selector.DATA_DISMISS, $.proxy(this.hide, this));\\n\\n      $(this._dialog).on(Event.MOUSEDOWN_DISMISS, function () {\\n        $(_this7._element).one(Event.MOUSEUP_DISMISS, function (event) {\\n          if ($(event.target).is(_this7._element)) {\\n            _this7._ignoreBackdropClick = true;\\n          }\\n        });\\n      });\\n\\n      this._showBackdrop($.proxy(this._showElement, this, relatedTarget));\\n    };\\n\\n    Modal.prototype.hide = function hide(event) {\\n      if (event) {\\n        event.preventDefault();\\n      }\\n\\n      var hideEvent = $.Event(Event.HIDE);\\n\\n      $(this._element).trigger(hideEvent);\\n\\n      if (!this._isShown || hideEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      this._isShown = false;\\n\\n      this._setEscapeEvent();\\n      this._setResizeEvent();\\n\\n      $(document).off(Event.FOCUSIN);\\n\\n      $(this._element).removeClass(ClassName.IN);\\n\\n      $(this._element).off(Event.CLICK_DISMISS);\\n      $(this._dialog).off(Event.MOUSEDOWN_DISMISS);\\n\\n      if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE)) {\\n\\n        $(this._element).one(Util.TRANSITION_END, $.proxy(this._hideModal, this)).emulateTransitionEnd(TRANSITION_DURATION);\\n      } else {\\n        this._hideModal();\\n      }\\n    };\\n\\n    Modal.prototype.dispose = function dispose() {\\n      $.removeData(this._element, DATA_KEY);\\n\\n      $(window).off(EVENT_KEY);\\n      $(document).off(EVENT_KEY);\\n      $(this._element).off(EVENT_KEY);\\n      $(this._backdrop).off(EVENT_KEY);\\n\\n      this._config = null;\\n      this._element = null;\\n      this._dialog = null;\\n      this._backdrop = null;\\n      this._isShown = null;\\n      this._isBodyOverflowing = null;\\n      this._ignoreBackdropClick = null;\\n      this._originalBodyPadding = null;\\n      this._scrollbarWidth = null;\\n    };\\n\\n    // private\\n\\n    Modal.prototype._getConfig = function _getConfig(config) {\\n      config = $.extend({}, Default, config);\\n      Util.typeCheckConfig(NAME, config, DefaultType);\\n      return config;\\n    };\\n\\n    Modal.prototype._showElement = function _showElement(relatedTarget) {\\n      var _this8 = this;\\n\\n      var transition = Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE);\\n\\n      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {\\n        // don't move modals dom position\\n        document.body.appendChild(this._element);\\n      }\\n\\n      this._element.style.display = 'block';\\n      this._element.removeAttribute('aria-hidden');\\n      this._element.scrollTop = 0;\\n\\n      if (transition) {\\n        Util.reflow(this._element);\\n      }\\n\\n      $(this._element).addClass(ClassName.IN);\\n\\n      if (this._config.focus) {\\n        this._enforceFocus();\\n      }\\n\\n      var shownEvent = $.Event(Event.SHOWN, {\\n        relatedTarget: relatedTarget\\n      });\\n\\n      var transitionComplete = function transitionComplete() {\\n        if (_this8._config.focus) {\\n          _this8._element.focus();\\n        }\\n        $(_this8._element).trigger(shownEvent);\\n      };\\n\\n      if (transition) {\\n        $(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(TRANSITION_DURATION);\\n      } else {\\n        transitionComplete();\\n      }\\n    };\\n\\n    Modal.prototype._enforceFocus = function _enforceFocus() {\\n      var _this9 = this;\\n\\n      $(document).off(Event.FOCUSIN) // guard against infinite focus loop\\n      .on(Event.FOCUSIN, function (event) {\\n        if (document !== event.target && _this9._element !== event.target && !$(_this9._element).has(event.target).length) {\\n          _this9._element.focus();\\n        }\\n      });\\n    };\\n\\n    Modal.prototype._setEscapeEvent = function _setEscapeEvent() {\\n      var _this10 = this;\\n\\n      if (this._isShown && this._config.keyboard) {\\n        $(this._element).on(Event.KEYDOWN_DISMISS, function (event) {\\n          if (event.which === ESCAPE_KEYCODE) {\\n            _this10.hide();\\n          }\\n        });\\n      } else if (!this._isShown) {\\n        $(this._element).off(Event.KEYDOWN_DISMISS);\\n      }\\n    };\\n\\n    Modal.prototype._setResizeEvent = function _setResizeEvent() {\\n      if (this._isShown) {\\n        $(window).on(Event.RESIZE, $.proxy(this._handleUpdate, this));\\n      } else {\\n        $(window).off(Event.RESIZE);\\n      }\\n    };\\n\\n    Modal.prototype._hideModal = function _hideModal() {\\n      var _this11 = this;\\n\\n      this._element.style.display = 'none';\\n      this._element.setAttribute('aria-hidden', 'true');\\n      this._showBackdrop(function () {\\n        $(document.body).removeClass(ClassName.OPEN);\\n        _this11._resetAdjustments();\\n        _this11._resetScrollbar();\\n        $(_this11._element).trigger(Event.HIDDEN);\\n      });\\n    };\\n\\n    Modal.prototype._removeBackdrop = function _removeBackdrop() {\\n      if (this._backdrop) {\\n        $(this._backdrop).remove();\\n        this._backdrop = null;\\n      }\\n    };\\n\\n    Modal.prototype._showBackdrop = function _showBackdrop(callback) {\\n      var _this12 = this;\\n\\n      var animate = $(this._element).hasClass(ClassName.FADE) ? ClassName.FADE : '';\\n\\n      if (this._isShown && this._config.backdrop) {\\n        var doAnimate = Util.supportsTransitionEnd() && animate;\\n\\n        this._backdrop = document.createElement('div');\\n        this._backdrop.className = ClassName.BACKDROP;\\n\\n        if (animate) {\\n          $(this._backdrop).addClass(animate);\\n        }\\n\\n        $(this._backdrop).appendTo(document.body);\\n\\n        $(this._element).on(Event.CLICK_DISMISS, function (event) {\\n          if (_this12._ignoreBackdropClick) {\\n            _this12._ignoreBackdropClick = false;\\n            return;\\n          }\\n          if (event.target !== event.currentTarget) {\\n            return;\\n          }\\n          if (_this12._config.backdrop === 'static') {\\n            _this12._element.focus();\\n          } else {\\n            _this12.hide();\\n          }\\n        });\\n\\n        if (doAnimate) {\\n          Util.reflow(this._backdrop);\\n        }\\n\\n        $(this._backdrop).addClass(ClassName.IN);\\n\\n        if (!callback) {\\n          return;\\n        }\\n\\n        if (!doAnimate) {\\n          callback();\\n          return;\\n        }\\n\\n        $(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);\\n      } else if (!this._isShown && this._backdrop) {\\n        $(this._backdrop).removeClass(ClassName.IN);\\n\\n        var callbackRemove = function callbackRemove() {\\n          _this12._removeBackdrop();\\n          if (callback) {\\n            callback();\\n          }\\n        };\\n\\n        if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE)) {\\n          $(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);\\n        } else {\\n          callbackRemove();\\n        }\\n      } else if (callback) {\\n        callback();\\n      }\\n    };\\n\\n    // ----------------------------------------------------------------------\\n    // the following methods are used to handle overflowing modals\\n    // todo (fat): these should probably be refactored out of modal.js\\n    // ----------------------------------------------------------------------\\n\\n    Modal.prototype._handleUpdate = function _handleUpdate() {\\n      this._adjustDialog();\\n    };\\n\\n    Modal.prototype._adjustDialog = function _adjustDialog() {\\n      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\\n\\n      if (!this._isBodyOverflowing && isModalOverflowing) {\\n        this._element.style.paddingLeft = this._scrollbarWidth + 'px';\\n      }\\n\\n      if (this._isBodyOverflowing && !isModalOverflowing) {\\n        this._element.style.paddingRight = this._scrollbarWidth + 'px';\\n      }\\n    };\\n\\n    Modal.prototype._resetAdjustments = function _resetAdjustments() {\\n      this._element.style.paddingLeft = '';\\n      this._element.style.paddingRight = '';\\n    };\\n\\n    Modal.prototype._checkScrollbar = function _checkScrollbar() {\\n      this._isBodyOverflowing = document.body.clientWidth < window.innerWidth;\\n      this._scrollbarWidth = this._getScrollbarWidth();\\n    };\\n\\n    Modal.prototype._setScrollbar = function _setScrollbar() {\\n      var bodyPadding = parseInt($(Selector.FIXED_CONTENT).css('padding-right') || 0, 10);\\n\\n      this._originalBodyPadding = document.body.style.paddingRight || '';\\n\\n      if (this._isBodyOverflowing) {\\n        document.body.style.paddingRight = bodyPadding + this._scrollbarWidth + 'px';\\n      }\\n    };\\n\\n    Modal.prototype._resetScrollbar = function _resetScrollbar() {\\n      document.body.style.paddingRight = this._originalBodyPadding;\\n    };\\n\\n    Modal.prototype._getScrollbarWidth = function _getScrollbarWidth() {\\n      // thx d.walsh\\n      var scrollDiv = document.createElement('div');\\n      scrollDiv.className = ClassName.SCROLLBAR_MEASURER;\\n      document.body.appendChild(scrollDiv);\\n      var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\\n      document.body.removeChild(scrollDiv);\\n      return scrollbarWidth;\\n    };\\n\\n    // static\\n\\n    Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {\\n      return this.each(function () {\\n        var data = $(this).data(DATA_KEY);\\n        var _config = $.extend({}, Modal.Default, $(this).data(), (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config);\\n\\n        if (!data) {\\n          data = new Modal(this, _config);\\n          $(this).data(DATA_KEY, data);\\n        }\\n\\n        if (typeof config === 'string') {\\n          if (data[config] === undefined) {\\n            throw new Error('No method named \\\"' + config + '\\\"');\\n          }\\n          data[config](relatedTarget);\\n        } else if (_config.show) {\\n          data.show(relatedTarget);\\n        }\\n      });\\n    };\\n\\n    _createClass(Modal, null, [{\\n      key: 'VERSION',\\n      get: function get() {\\n        return VERSION;\\n      }\\n    }, {\\n      key: 'Default',\\n      get: function get() {\\n        return Default;\\n      }\\n    }]);\\n\\n    return Modal;\\n  }();\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {\\n    var _this13 = this;\\n\\n    var target = void 0;\\n    var selector = Util.getSelectorFromElement(this);\\n\\n    if (selector) {\\n      target = $(selector)[0];\\n    }\\n\\n    var config = $(target).data(DATA_KEY) ? 'toggle' : $.extend({}, $(target).data(), $(this).data());\\n\\n    if (this.tagName === 'A') {\\n      event.preventDefault();\\n    }\\n\\n    var $target = $(target).one(Event.SHOW, function (showEvent) {\\n      if (showEvent.isDefaultPrevented()) {\\n        // only register focus restorer if modal will actually get shown\\n        return;\\n      }\\n\\n      $target.one(Event.HIDDEN, function () {\\n        if ($(_this13).is(':visible')) {\\n          _this13.focus();\\n        }\\n      });\\n    });\\n\\n    Modal._jQueryInterface.call($(target), config, this);\\n  });\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME] = Modal._jQueryInterface;\\n  $.fn[NAME].Constructor = Modal;\\n  $.fn[NAME].noConflict = function () {\\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\\n    return Modal._jQueryInterface;\\n  };\\n\\n  return Modal;\\n}(jQuery);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v4.0.0-alpha.5): scrollspy.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\nvar ScrollSpy = function ($) {\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME = 'scrollspy';\\n  var VERSION = '4.0.0-alpha.5';\\n  var DATA_KEY = 'bs.scrollspy';\\n  var EVENT_KEY = '.' + DATA_KEY;\\n  var DATA_API_KEY = '.data-api';\\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\\n\\n  var Default = {\\n    offset: 10,\\n    method: 'auto',\\n    target: ''\\n  };\\n\\n  var DefaultType = {\\n    offset: 'number',\\n    method: 'string',\\n    target: '(string|element)'\\n  };\\n\\n  var Event = {\\n    ACTIVATE: 'activate' + EVENT_KEY,\\n    SCROLL: 'scroll' + EVENT_KEY,\\n    LOAD_DATA_API: 'load' + EVENT_KEY + DATA_API_KEY\\n  };\\n\\n  var ClassName = {\\n    DROPDOWN_ITEM: 'dropdown-item',\\n    DROPDOWN_MENU: 'dropdown-menu',\\n    NAV_LINK: 'nav-link',\\n    NAV: 'nav',\\n    ACTIVE: 'active'\\n  };\\n\\n  var Selector = {\\n    DATA_SPY: '[data-spy=\\\"scroll\\\"]',\\n    ACTIVE: '.active',\\n    LIST_ITEM: '.list-item',\\n    LI: 'li',\\n    LI_DROPDOWN: 'li.dropdown',\\n    NAV_LINKS: '.nav-link',\\n    DROPDOWN: '.dropdown',\\n    DROPDOWN_ITEMS: '.dropdown-item',\\n    DROPDOWN_TOGGLE: '.dropdown-toggle'\\n  };\\n\\n  var OffsetMethod = {\\n    OFFSET: 'offset',\\n    POSITION: 'position'\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var ScrollSpy = function () {\\n    function ScrollSpy(element, config) {\\n      _classCallCheck(this, ScrollSpy);\\n\\n      this._element = element;\\n      this._scrollElement = element.tagName === 'BODY' ? window : element;\\n      this._config = this._getConfig(config);\\n      this._selector = this._config.target + ' ' + Selector.NAV_LINKS + ',' + (this._config.target + ' ' + Selector.DROPDOWN_ITEMS);\\n      this._offsets = [];\\n      this._targets = [];\\n      this._activeTarget = null;\\n      this._scrollHeight = 0;\\n\\n      $(this._scrollElement).on(Event.SCROLL, $.proxy(this._process, this));\\n\\n      this.refresh();\\n      this._process();\\n    }\\n\\n    // getters\\n\\n    // public\\n\\n    ScrollSpy.prototype.refresh = function refresh() {\\n      var _this14 = this;\\n\\n      var autoMethod = this._scrollElement !== this._scrollElement.window ? OffsetMethod.POSITION : OffsetMethod.OFFSET;\\n\\n      var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;\\n\\n      var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;\\n\\n      this._offsets = [];\\n      this._targets = [];\\n\\n      this._scrollHeight = this._getScrollHeight();\\n\\n      var targets = $.makeArray($(this._selector));\\n\\n      targets.map(function (element) {\\n        var target = void 0;\\n        var targetSelector = Util.getSelectorFromElement(element);\\n\\n        if (targetSelector) {\\n          target = $(targetSelector)[0];\\n        }\\n\\n        if (target && (target.offsetWidth || target.offsetHeight)) {\\n          // todo (fat): remove sketch reliance on jQuery position/offset\\n          return [$(target)[offsetMethod]().top + offsetBase, targetSelector];\\n        }\\n        return null;\\n      }).filter(function (item) {\\n        return item;\\n      }).sort(function (a, b) {\\n        return a[0] - b[0];\\n      }).forEach(function (item) {\\n        _this14._offsets.push(item[0]);\\n        _this14._targets.push(item[1]);\\n      });\\n    };\\n\\n    ScrollSpy.prototype.dispose = function dispose() {\\n      $.removeData(this._element, DATA_KEY);\\n      $(this._scrollElement).off(EVENT_KEY);\\n\\n      this._element = null;\\n      this._scrollElement = null;\\n      this._config = null;\\n      this._selector = null;\\n      this._offsets = null;\\n      this._targets = null;\\n      this._activeTarget = null;\\n      this._scrollHeight = null;\\n    };\\n\\n    // private\\n\\n    ScrollSpy.prototype._getConfig = function _getConfig(config) {\\n      config = $.extend({}, Default, config);\\n\\n      if (typeof config.target !== 'string') {\\n        var id = $(config.target).attr('id');\\n        if (!id) {\\n          id = Util.getUID(NAME);\\n          $(config.target).attr('id', id);\\n        }\\n        config.target = '#' + id;\\n      }\\n\\n      Util.typeCheckConfig(NAME, config, DefaultType);\\n\\n      return config;\\n    };\\n\\n    ScrollSpy.prototype._getScrollTop = function _getScrollTop() {\\n      return this._scrollElement === window ? this._scrollElement.scrollY : this._scrollElement.scrollTop;\\n    };\\n\\n    ScrollSpy.prototype._getScrollHeight = function _getScrollHeight() {\\n      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\\n    };\\n\\n    ScrollSpy.prototype._process = function _process() {\\n      var scrollTop = this._getScrollTop() + this._config.offset;\\n      var scrollHeight = this._getScrollHeight();\\n      var maxScroll = this._config.offset + scrollHeight - this._scrollElement.offsetHeight;\\n\\n      if (this._scrollHeight !== scrollHeight) {\\n        this.refresh();\\n      }\\n\\n      if (scrollTop >= maxScroll) {\\n        var target = this._targets[this._targets.length - 1];\\n\\n        if (this._activeTarget !== target) {\\n          this._activate(target);\\n        }\\n      }\\n\\n      if (this._activeTarget && scrollTop < this._offsets[0]) {\\n        this._activeTarget = null;\\n        this._clear();\\n        return;\\n      }\\n\\n      for (var i = this._offsets.length; i--;) {\\n        var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (this._offsets[i + 1] === undefined || scrollTop < this._offsets[i + 1]);\\n\\n        if (isActiveTarget) {\\n          this._activate(this._targets[i]);\\n        }\\n      }\\n    };\\n\\n    ScrollSpy.prototype._activate = function _activate(target) {\\n      this._activeTarget = target;\\n\\n      this._clear();\\n\\n      var queries = this._selector.split(',');\\n      queries = queries.map(function (selector) {\\n        return selector + '[data-target=\\\"' + target + '\\\"],' + (selector + '[href=\\\"' + target + '\\\"]');\\n      });\\n\\n      var $link = $(queries.join(','));\\n\\n      if ($link.hasClass(ClassName.DROPDOWN_ITEM)) {\\n        $link.closest(Selector.DROPDOWN).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);\\n        $link.addClass(ClassName.ACTIVE);\\n      } else {\\n        // todo (fat) this is kinda sus...\\n        // recursively add actives to tested nav-links\\n        $link.parents(Selector.LI).find(Selector.NAV_LINKS).addClass(ClassName.ACTIVE);\\n      }\\n\\n      $(this._scrollElement).trigger(Event.ACTIVATE, {\\n        relatedTarget: target\\n      });\\n    };\\n\\n    ScrollSpy.prototype._clear = function _clear() {\\n      $(this._selector).filter(Selector.ACTIVE).removeClass(ClassName.ACTIVE);\\n    };\\n\\n    // static\\n\\n    ScrollSpy._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var data = $(this).data(DATA_KEY);\\n        var _config = (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config || null;\\n\\n        if (!data) {\\n          data = new ScrollSpy(this, _config);\\n          $(this).data(DATA_KEY, data);\\n        }\\n\\n        if (typeof config === 'string') {\\n          if (data[config] === undefined) {\\n            throw new Error('No method named \\\"' + config + '\\\"');\\n          }\\n          data[config]();\\n        }\\n      });\\n    };\\n\\n    _createClass(ScrollSpy, null, [{\\n      key: 'VERSION',\\n      get: function get() {\\n        return VERSION;\\n      }\\n    }, {\\n      key: 'Default',\\n      get: function get() {\\n        return Default;\\n      }\\n    }]);\\n\\n    return ScrollSpy;\\n  }();\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $(window).on(Event.LOAD_DATA_API, function () {\\n    var scrollSpys = $.makeArray($(Selector.DATA_SPY));\\n\\n    for (var i = scrollSpys.length; i--;) {\\n      var $spy = $(scrollSpys[i]);\\n      ScrollSpy._jQueryInterface.call($spy, $spy.data());\\n    }\\n  });\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME] = ScrollSpy._jQueryInterface;\\n  $.fn[NAME].Constructor = ScrollSpy;\\n  $.fn[NAME].noConflict = function () {\\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\\n    return ScrollSpy._jQueryInterface;\\n  };\\n\\n  return ScrollSpy;\\n}(jQuery);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v4.0.0-alpha.5): tab.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\nvar Tab = function ($) {\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME = 'tab';\\n  var VERSION = '4.0.0-alpha.5';\\n  var DATA_KEY = 'bs.tab';\\n  var EVENT_KEY = '.' + DATA_KEY;\\n  var DATA_API_KEY = '.data-api';\\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\\n  var TRANSITION_DURATION = 150;\\n\\n  var Event = {\\n    HIDE: 'hide' + EVENT_KEY,\\n    HIDDEN: 'hidden' + EVENT_KEY,\\n    SHOW: 'show' + EVENT_KEY,\\n    SHOWN: 'shown' + EVENT_KEY,\\n    CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY\\n  };\\n\\n  var ClassName = {\\n    DROPDOWN_MENU: 'dropdown-menu',\\n    ACTIVE: 'active',\\n    FADE: 'fade',\\n    IN: 'in'\\n  };\\n\\n  var Selector = {\\n    A: 'a',\\n    LI: 'li',\\n    DROPDOWN: '.dropdown',\\n    UL: 'ul:not(.dropdown-menu)',\\n    FADE_CHILD: '> .nav-item .fade, > .fade',\\n    ACTIVE: '.active',\\n    ACTIVE_CHILD: '> .nav-item > .active, > .active',\\n    DATA_TOGGLE: '[data-toggle=\\\"tab\\\"], [data-toggle=\\\"pill\\\"]',\\n    DROPDOWN_TOGGLE: '.dropdown-toggle',\\n    DROPDOWN_ACTIVE_CHILD: '> .dropdown-menu .active'\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Tab = function () {\\n    function Tab(element) {\\n      _classCallCheck(this, Tab);\\n\\n      this._element = element;\\n    }\\n\\n    // getters\\n\\n    // public\\n\\n    Tab.prototype.show = function show() {\\n      var _this15 = this;\\n\\n      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $(this._element).hasClass(ClassName.ACTIVE)) {\\n        return;\\n      }\\n\\n      var target = void 0;\\n      var previous = void 0;\\n      var ulElement = $(this._element).closest(Selector.UL)[0];\\n      var selector = Util.getSelectorFromElement(this._element);\\n\\n      if (ulElement) {\\n        previous = $.makeArray($(ulElement).find(Selector.ACTIVE));\\n        previous = previous[previous.length - 1];\\n      }\\n\\n      var hideEvent = $.Event(Event.HIDE, {\\n        relatedTarget: this._element\\n      });\\n\\n      var showEvent = $.Event(Event.SHOW, {\\n        relatedTarget: previous\\n      });\\n\\n      if (previous) {\\n        $(previous).trigger(hideEvent);\\n      }\\n\\n      $(this._element).trigger(showEvent);\\n\\n      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      if (selector) {\\n        target = $(selector)[0];\\n      }\\n\\n      this._activate(this._element, ulElement);\\n\\n      var complete = function complete() {\\n        var hiddenEvent = $.Event(Event.HIDDEN, {\\n          relatedTarget: _this15._element\\n        });\\n\\n        var shownEvent = $.Event(Event.SHOWN, {\\n          relatedTarget: previous\\n        });\\n\\n        $(previous).trigger(hiddenEvent);\\n        $(_this15._element).trigger(shownEvent);\\n      };\\n\\n      if (target) {\\n        this._activate(target, target.parentNode, complete);\\n      } else {\\n        complete();\\n      }\\n    };\\n\\n    Tab.prototype.dispose = function dispose() {\\n      $.removeClass(this._element, DATA_KEY);\\n      this._element = null;\\n    };\\n\\n    // private\\n\\n    Tab.prototype._activate = function _activate(element, container, callback) {\\n      var active = $(container).find(Selector.ACTIVE_CHILD)[0];\\n      var isTransitioning = callback && Util.supportsTransitionEnd() && (active && $(active).hasClass(ClassName.FADE) || Boolean($(container).find(Selector.FADE_CHILD)[0]));\\n\\n      var complete = $.proxy(this._transitionComplete, this, element, active, isTransitioning, callback);\\n\\n      if (active && isTransitioning) {\\n        $(active).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);\\n      } else {\\n        complete();\\n      }\\n\\n      if (active) {\\n        $(active).removeClass(ClassName.IN);\\n      }\\n    };\\n\\n    Tab.prototype._transitionComplete = function _transitionComplete(element, active, isTransitioning, callback) {\\n      if (active) {\\n        $(active).removeClass(ClassName.ACTIVE);\\n\\n        var dropdownChild = $(active).find(Selector.DROPDOWN_ACTIVE_CHILD)[0];\\n\\n        if (dropdownChild) {\\n          $(dropdownChild).removeClass(ClassName.ACTIVE);\\n        }\\n\\n        active.setAttribute('aria-expanded', false);\\n      }\\n\\n      $(element).addClass(ClassName.ACTIVE);\\n      element.setAttribute('aria-expanded', true);\\n\\n      if (isTransitioning) {\\n        Util.reflow(element);\\n        $(element).addClass(ClassName.IN);\\n      } else {\\n        $(element).removeClass(ClassName.FADE);\\n      }\\n\\n      if (element.parentNode && $(element.parentNode).hasClass(ClassName.DROPDOWN_MENU)) {\\n\\n        var dropdownElement = $(element).closest(Selector.DROPDOWN)[0];\\n        if (dropdownElement) {\\n          $(dropdownElement).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);\\n        }\\n\\n        element.setAttribute('aria-expanded', true);\\n      }\\n\\n      if (callback) {\\n        callback();\\n      }\\n    };\\n\\n    // static\\n\\n    Tab._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var $this = $(this);\\n        var data = $this.data(DATA_KEY);\\n\\n        if (!data) {\\n          data = data = new Tab(this);\\n          $this.data(DATA_KEY, data);\\n        }\\n\\n        if (typeof config === 'string') {\\n          if (data[config] === undefined) {\\n            throw new Error('No method named \\\"' + config + '\\\"');\\n          }\\n          data[config]();\\n        }\\n      });\\n    };\\n\\n    _createClass(Tab, null, [{\\n      key: 'VERSION',\\n      get: function get() {\\n        return VERSION;\\n      }\\n    }]);\\n\\n    return Tab;\\n  }();\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {\\n    event.preventDefault();\\n    Tab._jQueryInterface.call($(this), 'show');\\n  });\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME] = Tab._jQueryInterface;\\n  $.fn[NAME].Constructor = Tab;\\n  $.fn[NAME].noConflict = function () {\\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\\n    return Tab._jQueryInterface;\\n  };\\n\\n  return Tab;\\n}(jQuery);\\n\\n/* global Tether */\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v4.0.0-alpha.5): tooltip.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\nvar Tooltip = function ($) {\\n\\n  /**\\n   * Check for Tether dependency\\n   * Tether - http://tether.io/\\n   */\\n  if (window.Tether === undefined) {\\n    throw new Error('Bootstrap tooltips require Tether (http://tether.io/)');\\n  }\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME = 'tooltip';\\n  var VERSION = '4.0.0-alpha.5';\\n  var DATA_KEY = 'bs.tooltip';\\n  var EVENT_KEY = '.' + DATA_KEY;\\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\\n  var TRANSITION_DURATION = 150;\\n  var CLASS_PREFIX = 'bs-tether';\\n\\n  var Default = {\\n    animation: true,\\n    template: '<div class=\\\"tooltip\\\" role=\\\"tooltip\\\">' + '<div class=\\\"tooltip-inner\\\"></div></div>',\\n    trigger: 'hover focus',\\n    title: '',\\n    delay: 0,\\n    html: false,\\n    selector: false,\\n    placement: 'top',\\n    offset: '0 0',\\n    constraints: []\\n  };\\n\\n  var DefaultType = {\\n    animation: 'boolean',\\n    template: 'string',\\n    title: '(string|element|function)',\\n    trigger: 'string',\\n    delay: '(number|object)',\\n    html: 'boolean',\\n    selector: '(string|boolean)',\\n    placement: '(string|function)',\\n    offset: 'string',\\n    constraints: 'array'\\n  };\\n\\n  var AttachmentMap = {\\n    TOP: 'bottom center',\\n    RIGHT: 'middle left',\\n    BOTTOM: 'top center',\\n    LEFT: 'middle right'\\n  };\\n\\n  var HoverState = {\\n    IN: 'in',\\n    OUT: 'out'\\n  };\\n\\n  var Event = {\\n    HIDE: 'hide' + EVENT_KEY,\\n    HIDDEN: 'hidden' + EVENT_KEY,\\n    SHOW: 'show' + EVENT_KEY,\\n    SHOWN: 'shown' + EVENT_KEY,\\n    INSERTED: 'inserted' + EVENT_KEY,\\n    CLICK: 'click' + EVENT_KEY,\\n    FOCUSIN: 'focusin' + EVENT_KEY,\\n    FOCUSOUT: 'focusout' + EVENT_KEY,\\n    MOUSEENTER: 'mouseenter' + EVENT_KEY,\\n    MOUSELEAVE: 'mouseleave' + EVENT_KEY\\n  };\\n\\n  var ClassName = {\\n    FADE: 'fade',\\n    IN: 'in'\\n  };\\n\\n  var Selector = {\\n    TOOLTIP: '.tooltip',\\n    TOOLTIP_INNER: '.tooltip-inner'\\n  };\\n\\n  var TetherClass = {\\n    element: false,\\n    enabled: false\\n  };\\n\\n  var Trigger = {\\n    HOVER: 'hover',\\n    FOCUS: 'focus',\\n    CLICK: 'click',\\n    MANUAL: 'manual'\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Tooltip = function () {\\n    function Tooltip(element, config) {\\n      _classCallCheck(this, Tooltip);\\n\\n      // private\\n      this._isEnabled = true;\\n      this._timeout = 0;\\n      this._hoverState = '';\\n      this._activeTrigger = {};\\n      this._tether = null;\\n\\n      // protected\\n      this.element = element;\\n      this.config = this._getConfig(config);\\n      this.tip = null;\\n\\n      this._setListeners();\\n    }\\n\\n    // getters\\n\\n    // public\\n\\n    Tooltip.prototype.enable = function enable() {\\n      this._isEnabled = true;\\n    };\\n\\n    Tooltip.prototype.disable = function disable() {\\n      this._isEnabled = false;\\n    };\\n\\n    Tooltip.prototype.toggleEnabled = function toggleEnabled() {\\n      this._isEnabled = !this._isEnabled;\\n    };\\n\\n    Tooltip.prototype.toggle = function toggle(event) {\\n      if (event) {\\n        var dataKey = this.constructor.DATA_KEY;\\n        var context = $(event.currentTarget).data(dataKey);\\n\\n        if (!context) {\\n          context = new this.constructor(event.currentTarget, this._getDelegateConfig());\\n          $(event.currentTarget).data(dataKey, context);\\n        }\\n\\n        context._activeTrigger.click = !context._activeTrigger.click;\\n\\n        if (context._isWithActiveTrigger()) {\\n          context._enter(null, context);\\n        } else {\\n          context._leave(null, context);\\n        }\\n      } else {\\n\\n        if ($(this.getTipElement()).hasClass(ClassName.IN)) {\\n          this._leave(null, this);\\n          return;\\n        }\\n\\n        this._enter(null, this);\\n      }\\n    };\\n\\n    Tooltip.prototype.dispose = function dispose() {\\n      clearTimeout(this._timeout);\\n\\n      this.cleanupTether();\\n\\n      $.removeData(this.element, this.constructor.DATA_KEY);\\n\\n      $(this.element).off(this.constructor.EVENT_KEY);\\n\\n      if (this.tip) {\\n        $(this.tip).remove();\\n      }\\n\\n      this._isEnabled = null;\\n      this._timeout = null;\\n      this._hoverState = null;\\n      this._activeTrigger = null;\\n      this._tether = null;\\n\\n      this.element = null;\\n      this.config = null;\\n      this.tip = null;\\n    };\\n\\n    Tooltip.prototype.show = function show() {\\n      var _this16 = this;\\n\\n      var showEvent = $.Event(this.constructor.Event.SHOW);\\n\\n      if (this.isWithContent() && this._isEnabled) {\\n        $(this.element).trigger(showEvent);\\n\\n        var isInTheDom = $.contains(this.element.ownerDocument.documentElement, this.element);\\n\\n        if (showEvent.isDefaultPrevented() || !isInTheDom) {\\n          return;\\n        }\\n\\n        var tip = this.getTipElement();\\n        var tipId = Util.getUID(this.constructor.NAME);\\n\\n        tip.setAttribute('id', tipId);\\n        this.element.setAttribute('aria-describedby', tipId);\\n\\n        this.setContent();\\n\\n        if (this.config.animation) {\\n          $(tip).addClass(ClassName.FADE);\\n        }\\n\\n        var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;\\n\\n        var attachment = this._getAttachment(placement);\\n\\n        $(tip).data(this.constructor.DATA_KEY, this).appendTo(document.body);\\n\\n        $(this.element).trigger(this.constructor.Event.INSERTED);\\n\\n        this._tether = new Tether({\\n          attachment: attachment,\\n          element: tip,\\n          target: this.element,\\n          classes: TetherClass,\\n          classPrefix: CLASS_PREFIX,\\n          offset: this.config.offset,\\n          constraints: this.config.constraints,\\n          addTargetClasses: false\\n        });\\n\\n        Util.reflow(tip);\\n        this._tether.position();\\n\\n        $(tip).addClass(ClassName.IN);\\n\\n        var complete = function complete() {\\n          var prevHoverState = _this16._hoverState;\\n          _this16._hoverState = null;\\n\\n          $(_this16.element).trigger(_this16.constructor.Event.SHOWN);\\n\\n          if (prevHoverState === HoverState.OUT) {\\n            _this16._leave(null, _this16);\\n          }\\n        };\\n\\n        if (Util.supportsTransitionEnd() && $(this.tip).hasClass(ClassName.FADE)) {\\n          $(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(Tooltip._TRANSITION_DURATION);\\n          return;\\n        }\\n\\n        complete();\\n      }\\n    };\\n\\n    Tooltip.prototype.hide = function hide(callback) {\\n      var _this17 = this;\\n\\n      var tip = this.getTipElement();\\n      var hideEvent = $.Event(this.constructor.Event.HIDE);\\n      var complete = function complete() {\\n        if (_this17._hoverState !== HoverState.IN && tip.parentNode) {\\n          tip.parentNode.removeChild(tip);\\n        }\\n\\n        _this17.element.removeAttribute('aria-describedby');\\n        $(_this17.element).trigger(_this17.constructor.Event.HIDDEN);\\n        _this17.cleanupTether();\\n\\n        if (callback) {\\n          callback();\\n        }\\n      };\\n\\n      $(this.element).trigger(hideEvent);\\n\\n      if (hideEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      $(tip).removeClass(ClassName.IN);\\n\\n      if (Util.supportsTransitionEnd() && $(this.tip).hasClass(ClassName.FADE)) {\\n\\n        $(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);\\n      } else {\\n        complete();\\n      }\\n\\n      this._hoverState = '';\\n    };\\n\\n    // protected\\n\\n    Tooltip.prototype.isWithContent = function isWithContent() {\\n      return Boolean(this.getTitle());\\n    };\\n\\n    Tooltip.prototype.getTipElement = function getTipElement() {\\n      return this.tip = this.tip || $(this.config.template)[0];\\n    };\\n\\n    Tooltip.prototype.setContent = function setContent() {\\n      var $tip = $(this.getTipElement());\\n\\n      this.setElementContent($tip.find(Selector.TOOLTIP_INNER), this.getTitle());\\n\\n      $tip.removeClass(ClassName.FADE).removeClass(ClassName.IN);\\n\\n      this.cleanupTether();\\n    };\\n\\n    Tooltip.prototype.setElementContent = function setElementContent($element, content) {\\n      var html = this.config.html;\\n      if ((typeof content === 'undefined' ? 'undefined' : _typeof(content)) === 'object' && (content.nodeType || content.jquery)) {\\n        // content is a DOM node or a jQuery\\n        if (html) {\\n          if (!$(content).parent().is($element)) {\\n            $element.empty().append(content);\\n          }\\n        } else {\\n          $element.text($(content).text());\\n        }\\n      } else {\\n        $element[html ? 'html' : 'text'](content);\\n      }\\n    };\\n\\n    Tooltip.prototype.getTitle = function getTitle() {\\n      var title = this.element.getAttribute('data-original-title');\\n\\n      if (!title) {\\n        title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;\\n      }\\n\\n      return title;\\n    };\\n\\n    Tooltip.prototype.cleanupTether = function cleanupTether() {\\n      if (this._tether) {\\n        this._tether.destroy();\\n      }\\n    };\\n\\n    // private\\n\\n    Tooltip.prototype._getAttachment = function _getAttachment(placement) {\\n      return AttachmentMap[placement.toUpperCase()];\\n    };\\n\\n    Tooltip.prototype._setListeners = function _setListeners() {\\n      var _this18 = this;\\n\\n      var triggers = this.config.trigger.split(' ');\\n\\n      triggers.forEach(function (trigger) {\\n        if (trigger === 'click') {\\n          $(_this18.element).on(_this18.constructor.Event.CLICK, _this18.config.selector, $.proxy(_this18.toggle, _this18));\\n        } else if (trigger !== Trigger.MANUAL) {\\n          var eventIn = trigger === Trigger.HOVER ? _this18.constructor.Event.MOUSEENTER : _this18.constructor.Event.FOCUSIN;\\n          var eventOut = trigger === Trigger.HOVER ? _this18.constructor.Event.MOUSELEAVE : _this18.constructor.Event.FOCUSOUT;\\n\\n          $(_this18.element).on(eventIn, _this18.config.selector, $.proxy(_this18._enter, _this18)).on(eventOut, _this18.config.selector, $.proxy(_this18._leave, _this18));\\n        }\\n      });\\n\\n      if (this.config.selector) {\\n        this.config = $.extend({}, this.config, {\\n          trigger: 'manual',\\n          selector: ''\\n        });\\n      } else {\\n        this._fixTitle();\\n      }\\n    };\\n\\n    Tooltip.prototype._fixTitle = function _fixTitle() {\\n      var titleType = _typeof(this.element.getAttribute('data-original-title'));\\n      if (this.element.getAttribute('title') || titleType !== 'string') {\\n        this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');\\n        this.element.setAttribute('title', '');\\n      }\\n    };\\n\\n    Tooltip.prototype._enter = function _enter(event, context) {\\n      var dataKey = this.constructor.DATA_KEY;\\n\\n      context = context || $(event.currentTarget).data(dataKey);\\n\\n      if (!context) {\\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\\n        $(event.currentTarget).data(dataKey, context);\\n      }\\n\\n      if (event) {\\n        context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;\\n      }\\n\\n      if ($(context.getTipElement()).hasClass(ClassName.IN) || context._hoverState === HoverState.IN) {\\n        context._hoverState = HoverState.IN;\\n        return;\\n      }\\n\\n      clearTimeout(context._timeout);\\n\\n      context._hoverState = HoverState.IN;\\n\\n      if (!context.config.delay || !context.config.delay.show) {\\n        context.show();\\n        return;\\n      }\\n\\n      context._timeout = setTimeout(function () {\\n        if (context._hoverState === HoverState.IN) {\\n          context.show();\\n        }\\n      }, context.config.delay.show);\\n    };\\n\\n    Tooltip.prototype._leave = function _leave(event, context) {\\n      var dataKey = this.constructor.DATA_KEY;\\n\\n      context = context || $(event.currentTarget).data(dataKey);\\n\\n      if (!context) {\\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\\n        $(event.currentTarget).data(dataKey, context);\\n      }\\n\\n      if (event) {\\n        context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;\\n      }\\n\\n      if (context._isWithActiveTrigger()) {\\n        return;\\n      }\\n\\n      clearTimeout(context._timeout);\\n\\n      context._hoverState = HoverState.OUT;\\n\\n      if (!context.config.delay || !context.config.delay.hide) {\\n        context.hide();\\n        return;\\n      }\\n\\n      context._timeout = setTimeout(function () {\\n        if (context._hoverState === HoverState.OUT) {\\n          context.hide();\\n        }\\n      }, context.config.delay.hide);\\n    };\\n\\n    Tooltip.prototype._isWithActiveTrigger = function _isWithActiveTrigger() {\\n      for (var trigger in this._activeTrigger) {\\n        if (this._activeTrigger[trigger]) {\\n          return true;\\n        }\\n      }\\n\\n      return false;\\n    };\\n\\n    Tooltip.prototype._getConfig = function _getConfig(config) {\\n      config = $.extend({}, this.constructor.Default, $(this.element).data(), config);\\n\\n      if (config.delay && typeof config.delay === 'number') {\\n        config.delay = {\\n          show: config.delay,\\n          hide: config.delay\\n        };\\n      }\\n\\n      Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);\\n\\n      return config;\\n    };\\n\\n    Tooltip.prototype._getDelegateConfig = function _getDelegateConfig() {\\n      var config = {};\\n\\n      if (this.config) {\\n        for (var key in this.config) {\\n          if (this.constructor.Default[key] !== this.config[key]) {\\n            config[key] = this.config[key];\\n          }\\n        }\\n      }\\n\\n      return config;\\n    };\\n\\n    // static\\n\\n    Tooltip._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var data = $(this).data(DATA_KEY);\\n        var _config = (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' ? config : null;\\n\\n        if (!data && /dispose|hide/.test(config)) {\\n          return;\\n        }\\n\\n        if (!data) {\\n          data = new Tooltip(this, _config);\\n          $(this).data(DATA_KEY, data);\\n        }\\n\\n        if (typeof config === 'string') {\\n          if (data[config] === undefined) {\\n            throw new Error('No method named \\\"' + config + '\\\"');\\n          }\\n          data[config]();\\n        }\\n      });\\n    };\\n\\n    _createClass(Tooltip, null, [{\\n      key: 'VERSION',\\n      get: function get() {\\n        return VERSION;\\n      }\\n    }, {\\n      key: 'Default',\\n      get: function get() {\\n        return Default;\\n      }\\n    }, {\\n      key: 'NAME',\\n      get: function get() {\\n        return NAME;\\n      }\\n    }, {\\n      key: 'DATA_KEY',\\n      get: function get() {\\n        return DATA_KEY;\\n      }\\n    }, {\\n      key: 'Event',\\n      get: function get() {\\n        return Event;\\n      }\\n    }, {\\n      key: 'EVENT_KEY',\\n      get: function get() {\\n        return EVENT_KEY;\\n      }\\n    }, {\\n      key: 'DefaultType',\\n      get: function get() {\\n        return DefaultType;\\n      }\\n    }]);\\n\\n    return Tooltip;\\n  }();\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME] = Tooltip._jQueryInterface;\\n  $.fn[NAME].Constructor = Tooltip;\\n  $.fn[NAME].noConflict = function () {\\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\\n    return Tooltip._jQueryInterface;\\n  };\\n\\n  return Tooltip;\\n}(jQuery);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v4.0.0-alpha.5): popover.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\nvar Popover = function ($) {\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME = 'popover';\\n  var VERSION = '4.0.0-alpha.5';\\n  var DATA_KEY = 'bs.popover';\\n  var EVENT_KEY = '.' + DATA_KEY;\\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\\n\\n  var Default = $.extend({}, Tooltip.Default, {\\n    placement: 'right',\\n    trigger: 'click',\\n    content: '',\\n    template: '<div class=\\\"popover\\\" role=\\\"tooltip\\\">' + '<h3 class=\\\"popover-title\\\"></h3>' + '<div class=\\\"popover-content\\\"></div></div>'\\n  });\\n\\n  var DefaultType = $.extend({}, Tooltip.DefaultType, {\\n    content: '(string|element|function)'\\n  });\\n\\n  var ClassName = {\\n    FADE: 'fade',\\n    IN: 'in'\\n  };\\n\\n  var Selector = {\\n    TITLE: '.popover-title',\\n    CONTENT: '.popover-content'\\n  };\\n\\n  var Event = {\\n    HIDE: 'hide' + EVENT_KEY,\\n    HIDDEN: 'hidden' + EVENT_KEY,\\n    SHOW: 'show' + EVENT_KEY,\\n    SHOWN: 'shown' + EVENT_KEY,\\n    INSERTED: 'inserted' + EVENT_KEY,\\n    CLICK: 'click' + EVENT_KEY,\\n    FOCUSIN: 'focusin' + EVENT_KEY,\\n    FOCUSOUT: 'focusout' + EVENT_KEY,\\n    MOUSEENTER: 'mouseenter' + EVENT_KEY,\\n    MOUSELEAVE: 'mouseleave' + EVENT_KEY\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Popover = function (_Tooltip) {\\n    _inherits(Popover, _Tooltip);\\n\\n    function Popover() {\\n      _classCallCheck(this, Popover);\\n\\n      return _possibleConstructorReturn(this, _Tooltip.apply(this, arguments));\\n    }\\n\\n    // overrides\\n\\n    Popover.prototype.isWithContent = function isWithContent() {\\n      return this.getTitle() || this._getContent();\\n    };\\n\\n    Popover.prototype.getTipElement = function getTipElement() {\\n      return this.tip = this.tip || $(this.config.template)[0];\\n    };\\n\\n    Popover.prototype.setContent = function setContent() {\\n      var $tip = $(this.getTipElement());\\n\\n      // we use append for html objects to maintain js events\\n      this.setElementContent($tip.find(Selector.TITLE), this.getTitle());\\n      this.setElementContent($tip.find(Selector.CONTENT), this._getContent());\\n\\n      $tip.removeClass(ClassName.FADE).removeClass(ClassName.IN);\\n\\n      this.cleanupTether();\\n    };\\n\\n    // private\\n\\n    Popover.prototype._getContent = function _getContent() {\\n      return this.element.getAttribute('data-content') || (typeof this.config.content === 'function' ? this.config.content.call(this.element) : this.config.content);\\n    };\\n\\n    // static\\n\\n    Popover._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var data = $(this).data(DATA_KEY);\\n        var _config = (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' ? config : null;\\n\\n        if (!data && /destroy|hide/.test(config)) {\\n          return;\\n        }\\n\\n        if (!data) {\\n          data = new Popover(this, _config);\\n          $(this).data(DATA_KEY, data);\\n        }\\n\\n        if (typeof config === 'string') {\\n          if (data[config] === undefined) {\\n            throw new Error('No method named \\\"' + config + '\\\"');\\n          }\\n          data[config]();\\n        }\\n      });\\n    };\\n\\n    _createClass(Popover, null, [{\\n      key: 'VERSION',\\n\\n\\n      // getters\\n\\n      get: function get() {\\n        return VERSION;\\n      }\\n    }, {\\n      key: 'Default',\\n      get: function get() {\\n        return Default;\\n      }\\n    }, {\\n      key: 'NAME',\\n      get: function get() {\\n        return NAME;\\n      }\\n    }, {\\n      key: 'DATA_KEY',\\n      get: function get() {\\n        return DATA_KEY;\\n      }\\n    }, {\\n      key: 'Event',\\n      get: function get() {\\n        return Event;\\n      }\\n    }, {\\n      key: 'EVENT_KEY',\\n      get: function get() {\\n        return EVENT_KEY;\\n      }\\n    }, {\\n      key: 'DefaultType',\\n      get: function get() {\\n        return DefaultType;\\n      }\\n    }]);\\n\\n    return Popover;\\n  }(Tooltip);\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME] = Popover._jQueryInterface;\\n  $.fn[NAME].Constructor = Popover;\\n  $.fn[NAME].noConflict = function () {\\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\\n    return Popover._jQueryInterface;\\n  };\\n\\n  return Popover;\\n}(jQuery);\\n\\n}();\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/francoisdagostini/Projects/infiniteUx-prototype/~/raw-loader!/Users/francoisdagostini/Projects/infiniteUx-prototype/~/bootstrap/dist/js/bootstrap.js\n// module id = 808\n// module chunks = 3","module.exports = \"/*!\\n * jQuery JavaScript Library v3.1.1\\n * https://jquery.com/\\n *\\n * Includes Sizzle.js\\n * https://sizzlejs.com/\\n *\\n * Copyright jQuery Foundation and other contributors\\n * Released under the MIT license\\n * https://jquery.org/license\\n *\\n * Date: 2016-09-22T22:30Z\\n */\\n( function( global, factory ) {\\n\\n\\t\\\"use strict\\\";\\n\\n\\tif ( typeof module === \\\"object\\\" && typeof module.exports === \\\"object\\\" ) {\\n\\n\\t\\t// For CommonJS and CommonJS-like environments where a proper `window`\\n\\t\\t// is present, execute the factory and get jQuery.\\n\\t\\t// For environments that do not have a `window` with a `document`\\n\\t\\t// (such as Node.js), expose a factory as module.exports.\\n\\t\\t// This accentuates the need for the creation of a real `window`.\\n\\t\\t// e.g. var jQuery = require(\\\"jquery\\\")(window);\\n\\t\\t// See ticket #14549 for more info.\\n\\t\\tmodule.exports = global.document ?\\n\\t\\t\\tfactory( global, true ) :\\n\\t\\t\\tfunction( w ) {\\n\\t\\t\\t\\tif ( !w.document ) {\\n\\t\\t\\t\\t\\tthrow new Error( \\\"jQuery requires a window with a document\\\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn factory( w );\\n\\t\\t\\t};\\n\\t} else {\\n\\t\\tfactory( global );\\n\\t}\\n\\n// Pass this if window is not defined yet\\n} )( typeof window !== \\\"undefined\\\" ? window : this, function( window, noGlobal ) {\\n\\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\\n// enough that all such attempts are guarded in a try block.\\n\\\"use strict\\\";\\n\\nvar arr = [];\\n\\nvar document = window.document;\\n\\nvar getProto = Object.getPrototypeOf;\\n\\nvar slice = arr.slice;\\n\\nvar concat = arr.concat;\\n\\nvar push = arr.push;\\n\\nvar indexOf = arr.indexOf;\\n\\nvar class2type = {};\\n\\nvar toString = class2type.toString;\\n\\nvar hasOwn = class2type.hasOwnProperty;\\n\\nvar fnToString = hasOwn.toString;\\n\\nvar ObjectFunctionString = fnToString.call( Object );\\n\\nvar support = {};\\n\\n\\n\\n\\tfunction DOMEval( code, doc ) {\\n\\t\\tdoc = doc || document;\\n\\n\\t\\tvar script = doc.createElement( \\\"script\\\" );\\n\\n\\t\\tscript.text = code;\\n\\t\\tdoc.head.appendChild( script ).parentNode.removeChild( script );\\n\\t}\\n/* global Symbol */\\n// Defining this global in .eslintrc.json would create a danger of using the global\\n// unguarded in another place, it seems safer to define global only for this module\\n\\n\\n\\nvar\\n\\tversion = \\\"3.1.1\\\",\\n\\n\\t// Define a local copy of jQuery\\n\\tjQuery = function( selector, context ) {\\n\\n\\t\\t// The jQuery object is actually just the init constructor 'enhanced'\\n\\t\\t// Need init if jQuery is called (just allow error to be thrown if not included)\\n\\t\\treturn new jQuery.fn.init( selector, context );\\n\\t},\\n\\n\\t// Support: Android <=4.0 only\\n\\t// Make sure we trim BOM and NBSP\\n\\trtrim = /^[\\\\s\\\\uFEFF\\\\xA0]+|[\\\\s\\\\uFEFF\\\\xA0]+$/g,\\n\\n\\t// Matches dashed string for camelizing\\n\\trmsPrefix = /^-ms-/,\\n\\trdashAlpha = /-([a-z])/g,\\n\\n\\t// Used by jQuery.camelCase as callback to replace()\\n\\tfcamelCase = function( all, letter ) {\\n\\t\\treturn letter.toUpperCase();\\n\\t};\\n\\njQuery.fn = jQuery.prototype = {\\n\\n\\t// The current version of jQuery being used\\n\\tjquery: version,\\n\\n\\tconstructor: jQuery,\\n\\n\\t// The default length of a jQuery object is 0\\n\\tlength: 0,\\n\\n\\ttoArray: function() {\\n\\t\\treturn slice.call( this );\\n\\t},\\n\\n\\t// Get the Nth element in the matched element set OR\\n\\t// Get the whole matched element set as a clean array\\n\\tget: function( num ) {\\n\\n\\t\\t// Return all the elements in a clean array\\n\\t\\tif ( num == null ) {\\n\\t\\t\\treturn slice.call( this );\\n\\t\\t}\\n\\n\\t\\t// Return just the one element from the set\\n\\t\\treturn num < 0 ? this[ num + this.length ] : this[ num ];\\n\\t},\\n\\n\\t// Take an array of elements and push it onto the stack\\n\\t// (returning the new matched element set)\\n\\tpushStack: function( elems ) {\\n\\n\\t\\t// Build a new jQuery matched element set\\n\\t\\tvar ret = jQuery.merge( this.constructor(), elems );\\n\\n\\t\\t// Add the old object onto the stack (as a reference)\\n\\t\\tret.prevObject = this;\\n\\n\\t\\t// Return the newly-formed element set\\n\\t\\treturn ret;\\n\\t},\\n\\n\\t// Execute a callback for every element in the matched set.\\n\\teach: function( callback ) {\\n\\t\\treturn jQuery.each( this, callback );\\n\\t},\\n\\n\\tmap: function( callback ) {\\n\\t\\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\\n\\t\\t\\treturn callback.call( elem, i, elem );\\n\\t\\t} ) );\\n\\t},\\n\\n\\tslice: function() {\\n\\t\\treturn this.pushStack( slice.apply( this, arguments ) );\\n\\t},\\n\\n\\tfirst: function() {\\n\\t\\treturn this.eq( 0 );\\n\\t},\\n\\n\\tlast: function() {\\n\\t\\treturn this.eq( -1 );\\n\\t},\\n\\n\\teq: function( i ) {\\n\\t\\tvar len = this.length,\\n\\t\\t\\tj = +i + ( i < 0 ? len : 0 );\\n\\t\\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\\n\\t},\\n\\n\\tend: function() {\\n\\t\\treturn this.prevObject || this.constructor();\\n\\t},\\n\\n\\t// For internal use only.\\n\\t// Behaves like an Array's method, not like a jQuery method.\\n\\tpush: push,\\n\\tsort: arr.sort,\\n\\tsplice: arr.splice\\n};\\n\\njQuery.extend = jQuery.fn.extend = function() {\\n\\tvar options, name, src, copy, copyIsArray, clone,\\n\\t\\ttarget = arguments[ 0 ] || {},\\n\\t\\ti = 1,\\n\\t\\tlength = arguments.length,\\n\\t\\tdeep = false;\\n\\n\\t// Handle a deep copy situation\\n\\tif ( typeof target === \\\"boolean\\\" ) {\\n\\t\\tdeep = target;\\n\\n\\t\\t// Skip the boolean and the target\\n\\t\\ttarget = arguments[ i ] || {};\\n\\t\\ti++;\\n\\t}\\n\\n\\t// Handle case when target is a string or something (possible in deep copy)\\n\\tif ( typeof target !== \\\"object\\\" && !jQuery.isFunction( target ) ) {\\n\\t\\ttarget = {};\\n\\t}\\n\\n\\t// Extend jQuery itself if only one argument is passed\\n\\tif ( i === length ) {\\n\\t\\ttarget = this;\\n\\t\\ti--;\\n\\t}\\n\\n\\tfor ( ; i < length; i++ ) {\\n\\n\\t\\t// Only deal with non-null/undefined values\\n\\t\\tif ( ( options = arguments[ i ] ) != null ) {\\n\\n\\t\\t\\t// Extend the base object\\n\\t\\t\\tfor ( name in options ) {\\n\\t\\t\\t\\tsrc = target[ name ];\\n\\t\\t\\t\\tcopy = options[ name ];\\n\\n\\t\\t\\t\\t// Prevent never-ending loop\\n\\t\\t\\t\\tif ( target === copy ) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Recurse if we're merging plain objects or arrays\\n\\t\\t\\t\\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\\n\\t\\t\\t\\t\\t( copyIsArray = jQuery.isArray( copy ) ) ) ) {\\n\\n\\t\\t\\t\\t\\tif ( copyIsArray ) {\\n\\t\\t\\t\\t\\t\\tcopyIsArray = false;\\n\\t\\t\\t\\t\\t\\tclone = src && jQuery.isArray( src ) ? src : [];\\n\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tclone = src && jQuery.isPlainObject( src ) ? src : {};\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Never move original objects, clone them\\n\\t\\t\\t\\t\\ttarget[ name ] = jQuery.extend( deep, clone, copy );\\n\\n\\t\\t\\t\\t// Don't bring in undefined values\\n\\t\\t\\t\\t} else if ( copy !== undefined ) {\\n\\t\\t\\t\\t\\ttarget[ name ] = copy;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the modified object\\n\\treturn target;\\n};\\n\\njQuery.extend( {\\n\\n\\t// Unique for each copy of jQuery on the page\\n\\texpando: \\\"jQuery\\\" + ( version + Math.random() ).replace( /\\\\D/g, \\\"\\\" ),\\n\\n\\t// Assume jQuery is ready without the ready module\\n\\tisReady: true,\\n\\n\\terror: function( msg ) {\\n\\t\\tthrow new Error( msg );\\n\\t},\\n\\n\\tnoop: function() {},\\n\\n\\tisFunction: function( obj ) {\\n\\t\\treturn jQuery.type( obj ) === \\\"function\\\";\\n\\t},\\n\\n\\tisArray: Array.isArray,\\n\\n\\tisWindow: function( obj ) {\\n\\t\\treturn obj != null && obj === obj.window;\\n\\t},\\n\\n\\tisNumeric: function( obj ) {\\n\\n\\t\\t// As of jQuery 3.0, isNumeric is limited to\\n\\t\\t// strings and numbers (primitives or objects)\\n\\t\\t// that can be coerced to finite numbers (gh-2662)\\n\\t\\tvar type = jQuery.type( obj );\\n\\t\\treturn ( type === \\\"number\\\" || type === \\\"string\\\" ) &&\\n\\n\\t\\t\\t// parseFloat NaNs numeric-cast false positives (\\\"\\\")\\n\\t\\t\\t// ...but misinterprets leading-number strings, particularly hex literals (\\\"0x...\\\")\\n\\t\\t\\t// subtraction forces infinities to NaN\\n\\t\\t\\t!isNaN( obj - parseFloat( obj ) );\\n\\t},\\n\\n\\tisPlainObject: function( obj ) {\\n\\t\\tvar proto, Ctor;\\n\\n\\t\\t// Detect obvious negatives\\n\\t\\t// Use toString instead of jQuery.type to catch host objects\\n\\t\\tif ( !obj || toString.call( obj ) !== \\\"[object Object]\\\" ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tproto = getProto( obj );\\n\\n\\t\\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\\n\\t\\tif ( !proto ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t// Objects with prototype are plain iff they were constructed by a global Object function\\n\\t\\tCtor = hasOwn.call( proto, \\\"constructor\\\" ) && proto.constructor;\\n\\t\\treturn typeof Ctor === \\\"function\\\" && fnToString.call( Ctor ) === ObjectFunctionString;\\n\\t},\\n\\n\\tisEmptyObject: function( obj ) {\\n\\n\\t\\t/* eslint-disable no-unused-vars */\\n\\t\\t// See https://github.com/eslint/eslint/issues/6125\\n\\t\\tvar name;\\n\\n\\t\\tfor ( name in obj ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t},\\n\\n\\ttype: function( obj ) {\\n\\t\\tif ( obj == null ) {\\n\\t\\t\\treturn obj + \\\"\\\";\\n\\t\\t}\\n\\n\\t\\t// Support: Android <=2.3 only (functionish RegExp)\\n\\t\\treturn typeof obj === \\\"object\\\" || typeof obj === \\\"function\\\" ?\\n\\t\\t\\tclass2type[ toString.call( obj ) ] || \\\"object\\\" :\\n\\t\\t\\ttypeof obj;\\n\\t},\\n\\n\\t// Evaluates a script in a global context\\n\\tglobalEval: function( code ) {\\n\\t\\tDOMEval( code );\\n\\t},\\n\\n\\t// Convert dashed to camelCase; used by the css and data modules\\n\\t// Support: IE <=9 - 11, Edge 12 - 13\\n\\t// Microsoft forgot to hump their vendor prefix (#9572)\\n\\tcamelCase: function( string ) {\\n\\t\\treturn string.replace( rmsPrefix, \\\"ms-\\\" ).replace( rdashAlpha, fcamelCase );\\n\\t},\\n\\n\\tnodeName: function( elem, name ) {\\n\\t\\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\\n\\t},\\n\\n\\teach: function( obj, callback ) {\\n\\t\\tvar length, i = 0;\\n\\n\\t\\tif ( isArrayLike( obj ) ) {\\n\\t\\t\\tlength = obj.length;\\n\\t\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\t\\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor ( i in obj ) {\\n\\t\\t\\t\\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn obj;\\n\\t},\\n\\n\\t// Support: Android <=4.0 only\\n\\ttrim: function( text ) {\\n\\t\\treturn text == null ?\\n\\t\\t\\t\\\"\\\" :\\n\\t\\t\\t( text + \\\"\\\" ).replace( rtrim, \\\"\\\" );\\n\\t},\\n\\n\\t// results is for internal usage only\\n\\tmakeArray: function( arr, results ) {\\n\\t\\tvar ret = results || [];\\n\\n\\t\\tif ( arr != null ) {\\n\\t\\t\\tif ( isArrayLike( Object( arr ) ) ) {\\n\\t\\t\\t\\tjQuery.merge( ret,\\n\\t\\t\\t\\t\\ttypeof arr === \\\"string\\\" ?\\n\\t\\t\\t\\t\\t[ arr ] : arr\\n\\t\\t\\t\\t);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpush.call( ret, arr );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ret;\\n\\t},\\n\\n\\tinArray: function( elem, arr, i ) {\\n\\t\\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\\n\\t},\\n\\n\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\tmerge: function( first, second ) {\\n\\t\\tvar len = +second.length,\\n\\t\\t\\tj = 0,\\n\\t\\t\\ti = first.length;\\n\\n\\t\\tfor ( ; j < len; j++ ) {\\n\\t\\t\\tfirst[ i++ ] = second[ j ];\\n\\t\\t}\\n\\n\\t\\tfirst.length = i;\\n\\n\\t\\treturn first;\\n\\t},\\n\\n\\tgrep: function( elems, callback, invert ) {\\n\\t\\tvar callbackInverse,\\n\\t\\t\\tmatches = [],\\n\\t\\t\\ti = 0,\\n\\t\\t\\tlength = elems.length,\\n\\t\\t\\tcallbackExpect = !invert;\\n\\n\\t\\t// Go through the array, only saving the items\\n\\t\\t// that pass the validator function\\n\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\tcallbackInverse = !callback( elems[ i ], i );\\n\\t\\t\\tif ( callbackInverse !== callbackExpect ) {\\n\\t\\t\\t\\tmatches.push( elems[ i ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn matches;\\n\\t},\\n\\n\\t// arg is for internal usage only\\n\\tmap: function( elems, callback, arg ) {\\n\\t\\tvar length, value,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tret = [];\\n\\n\\t\\t// Go through the array, translating each of the items to their new values\\n\\t\\tif ( isArrayLike( elems ) ) {\\n\\t\\t\\tlength = elems.length;\\n\\t\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\t\\tvalue = callback( elems[ i ], i, arg );\\n\\n\\t\\t\\t\\tif ( value != null ) {\\n\\t\\t\\t\\t\\tret.push( value );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Go through every key on the object,\\n\\t\\t} else {\\n\\t\\t\\tfor ( i in elems ) {\\n\\t\\t\\t\\tvalue = callback( elems[ i ], i, arg );\\n\\n\\t\\t\\t\\tif ( value != null ) {\\n\\t\\t\\t\\t\\tret.push( value );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Flatten any nested arrays\\n\\t\\treturn concat.apply( [], ret );\\n\\t},\\n\\n\\t// A global GUID counter for objects\\n\\tguid: 1,\\n\\n\\t// Bind a function to a context, optionally partially applying any\\n\\t// arguments.\\n\\tproxy: function( fn, context ) {\\n\\t\\tvar tmp, args, proxy;\\n\\n\\t\\tif ( typeof context === \\\"string\\\" ) {\\n\\t\\t\\ttmp = fn[ context ];\\n\\t\\t\\tcontext = fn;\\n\\t\\t\\tfn = tmp;\\n\\t\\t}\\n\\n\\t\\t// Quick check to determine if target is callable, in the spec\\n\\t\\t// this throws a TypeError, but we will just return undefined.\\n\\t\\tif ( !jQuery.isFunction( fn ) ) {\\n\\t\\t\\treturn undefined;\\n\\t\\t}\\n\\n\\t\\t// Simulated bind\\n\\t\\targs = slice.call( arguments, 2 );\\n\\t\\tproxy = function() {\\n\\t\\t\\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\\n\\t\\t};\\n\\n\\t\\t// Set the guid of unique handler to the same of original handler, so it can be removed\\n\\t\\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\\n\\n\\t\\treturn proxy;\\n\\t},\\n\\n\\tnow: Date.now,\\n\\n\\t// jQuery.support is not used in Core but other projects attach their\\n\\t// properties to it so it needs to exist.\\n\\tsupport: support\\n} );\\n\\nif ( typeof Symbol === \\\"function\\\" ) {\\n\\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\\n}\\n\\n// Populate the class2type map\\njQuery.each( \\\"Boolean Number String Function Array Date RegExp Object Error Symbol\\\".split( \\\" \\\" ),\\nfunction( i, name ) {\\n\\tclass2type[ \\\"[object \\\" + name + \\\"]\\\" ] = name.toLowerCase();\\n} );\\n\\nfunction isArrayLike( obj ) {\\n\\n\\t// Support: real iOS 8.2 only (not reproducible in simulator)\\n\\t// `in` check used to prevent JIT error (gh-2145)\\n\\t// hasOwn isn't used here due to false negatives\\n\\t// regarding Nodelist length in IE\\n\\tvar length = !!obj && \\\"length\\\" in obj && obj.length,\\n\\t\\ttype = jQuery.type( obj );\\n\\n\\tif ( type === \\\"function\\\" || jQuery.isWindow( obj ) ) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn type === \\\"array\\\" || length === 0 ||\\n\\t\\ttypeof length === \\\"number\\\" && length > 0 && ( length - 1 ) in obj;\\n}\\nvar Sizzle =\\n/*!\\n * Sizzle CSS Selector Engine v2.3.3\\n * https://sizzlejs.com/\\n *\\n * Copyright jQuery Foundation and other contributors\\n * Released under the MIT license\\n * http://jquery.org/license\\n *\\n * Date: 2016-08-08\\n */\\n(function( window ) {\\n\\nvar i,\\n\\tsupport,\\n\\tExpr,\\n\\tgetText,\\n\\tisXML,\\n\\ttokenize,\\n\\tcompile,\\n\\tselect,\\n\\toutermostContext,\\n\\tsortInput,\\n\\thasDuplicate,\\n\\n\\t// Local document vars\\n\\tsetDocument,\\n\\tdocument,\\n\\tdocElem,\\n\\tdocumentIsHTML,\\n\\trbuggyQSA,\\n\\trbuggyMatches,\\n\\tmatches,\\n\\tcontains,\\n\\n\\t// Instance-specific data\\n\\texpando = \\\"sizzle\\\" + 1 * new Date(),\\n\\tpreferredDoc = window.document,\\n\\tdirruns = 0,\\n\\tdone = 0,\\n\\tclassCache = createCache(),\\n\\ttokenCache = createCache(),\\n\\tcompilerCache = createCache(),\\n\\tsortOrder = function( a, b ) {\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t},\\n\\n\\t// Instance methods\\n\\thasOwn = ({}).hasOwnProperty,\\n\\tarr = [],\\n\\tpop = arr.pop,\\n\\tpush_native = arr.push,\\n\\tpush = arr.push,\\n\\tslice = arr.slice,\\n\\t// Use a stripped-down indexOf as it's faster than native\\n\\t// https://jsperf.com/thor-indexof-vs-for/5\\n\\tindexOf = function( list, elem ) {\\n\\t\\tvar i = 0,\\n\\t\\t\\tlen = list.length;\\n\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\tif ( list[i] === elem ) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t},\\n\\n\\tbooleans = \\\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\\\",\\n\\n\\t// Regular expressions\\n\\n\\t// http://www.w3.org/TR/css3-selectors/#whitespace\\n\\twhitespace = \\\"[\\\\\\\\x20\\\\\\\\t\\\\\\\\r\\\\\\\\n\\\\\\\\f]\\\",\\n\\n\\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\\n\\tidentifier = \\\"(?:\\\\\\\\\\\\\\\\.|[\\\\\\\\w-]|[^\\\\0-\\\\\\\\xa0])+\\\",\\n\\n\\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\\n\\tattributes = \\\"\\\\\\\\[\\\" + whitespace + \\\"*(\\\" + identifier + \\\")(?:\\\" + whitespace +\\n\\t\\t// Operator (capture 2)\\n\\t\\t\\\"*([*^$|!~]?=)\\\" + whitespace +\\n\\t\\t// \\\"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\\\"\\n\\t\\t\\\"*(?:'((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\'])*)'|\\\\\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\"])*)\\\\\\\"|(\\\" + identifier + \\\"))|)\\\" + whitespace +\\n\\t\\t\\\"*\\\\\\\\]\\\",\\n\\n\\tpseudos = \\\":(\\\" + identifier + \\\")(?:\\\\\\\\((\\\" +\\n\\t\\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\\n\\t\\t// 1. quoted (capture 3; capture 4 or capture 5)\\n\\t\\t\\\"('((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\'])*)'|\\\\\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\"])*)\\\\\\\")|\\\" +\\n\\t\\t// 2. simple (capture 6)\\n\\t\\t\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\()[\\\\\\\\]]|\\\" + attributes + \\\")*)|\\\" +\\n\\t\\t// 3. anything else (capture 2)\\n\\t\\t\\\".*\\\" +\\n\\t\\t\\\")\\\\\\\\)|)\\\",\\n\\n\\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\\n\\trwhitespace = new RegExp( whitespace + \\\"+\\\", \\\"g\\\" ),\\n\\trtrim = new RegExp( \\\"^\\\" + whitespace + \\\"+|((?:^|[^\\\\\\\\\\\\\\\\])(?:\\\\\\\\\\\\\\\\.)*)\\\" + whitespace + \\\"+$\\\", \\\"g\\\" ),\\n\\n\\trcomma = new RegExp( \\\"^\\\" + whitespace + \\\"*,\\\" + whitespace + \\\"*\\\" ),\\n\\trcombinators = new RegExp( \\\"^\\\" + whitespace + \\\"*([>+~]|\\\" + whitespace + \\\")\\\" + whitespace + \\\"*\\\" ),\\n\\n\\trattributeQuotes = new RegExp( \\\"=\\\" + whitespace + \\\"*([^\\\\\\\\]'\\\\\\\"]*?)\\\" + whitespace + \\\"*\\\\\\\\]\\\", \\\"g\\\" ),\\n\\n\\trpseudo = new RegExp( pseudos ),\\n\\tridentifier = new RegExp( \\\"^\\\" + identifier + \\\"$\\\" ),\\n\\n\\tmatchExpr = {\\n\\t\\t\\\"ID\\\": new RegExp( \\\"^#(\\\" + identifier + \\\")\\\" ),\\n\\t\\t\\\"CLASS\\\": new RegExp( \\\"^\\\\\\\\.(\\\" + identifier + \\\")\\\" ),\\n\\t\\t\\\"TAG\\\": new RegExp( \\\"^(\\\" + identifier + \\\"|[*])\\\" ),\\n\\t\\t\\\"ATTR\\\": new RegExp( \\\"^\\\" + attributes ),\\n\\t\\t\\\"PSEUDO\\\": new RegExp( \\\"^\\\" + pseudos ),\\n\\t\\t\\\"CHILD\\\": new RegExp( \\\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\\\\\(\\\" + whitespace +\\n\\t\\t\\t\\\"*(even|odd|(([+-]|)(\\\\\\\\d*)n|)\\\" + whitespace + \\\"*(?:([+-]|)\\\" + whitespace +\\n\\t\\t\\t\\\"*(\\\\\\\\d+)|))\\\" + whitespace + \\\"*\\\\\\\\)|)\\\", \\\"i\\\" ),\\n\\t\\t\\\"bool\\\": new RegExp( \\\"^(?:\\\" + booleans + \\\")$\\\", \\\"i\\\" ),\\n\\t\\t// For use in libraries implementing .is()\\n\\t\\t// We use this for POS matching in `select`\\n\\t\\t\\\"needsContext\\\": new RegExp( \\\"^\\\" + whitespace + \\\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\\\\\(\\\" +\\n\\t\\t\\twhitespace + \\\"*((?:-\\\\\\\\d)?\\\\\\\\d*)\\\" + whitespace + \\\"*\\\\\\\\)|)(?=[^-]|$)\\\", \\\"i\\\" )\\n\\t},\\n\\n\\trinputs = /^(?:input|select|textarea|button)$/i,\\n\\trheader = /^h\\\\d$/i,\\n\\n\\trnative = /^[^{]+\\\\{\\\\s*\\\\[native \\\\w/,\\n\\n\\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\\n\\trquickExpr = /^(?:#([\\\\w-]+)|(\\\\w+)|\\\\.([\\\\w-]+))$/,\\n\\n\\trsibling = /[+~]/,\\n\\n\\t// CSS escapes\\n\\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\\n\\trunescape = new RegExp( \\\"\\\\\\\\\\\\\\\\([\\\\\\\\da-f]{1,6}\\\" + whitespace + \\\"?|(\\\" + whitespace + \\\")|.)\\\", \\\"ig\\\" ),\\n\\tfunescape = function( _, escaped, escapedWhitespace ) {\\n\\t\\tvar high = \\\"0x\\\" + escaped - 0x10000;\\n\\t\\t// NaN means non-codepoint\\n\\t\\t// Support: Firefox<24\\n\\t\\t// Workaround erroneous numeric interpretation of +\\\"0x\\\"\\n\\t\\treturn high !== high || escapedWhitespace ?\\n\\t\\t\\tescaped :\\n\\t\\t\\thigh < 0 ?\\n\\t\\t\\t\\t// BMP codepoint\\n\\t\\t\\t\\tString.fromCharCode( high + 0x10000 ) :\\n\\t\\t\\t\\t// Supplemental Plane codepoint (surrogate pair)\\n\\t\\t\\t\\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\\n\\t},\\n\\n\\t// CSS string/identifier serialization\\n\\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\\n\\trcssescape = /([\\\\0-\\\\x1f\\\\x7f]|^-?\\\\d)|^-$|[^\\\\0-\\\\x1f\\\\x7f-\\\\uFFFF\\\\w-]/g,\\n\\tfcssescape = function( ch, asCodePoint ) {\\n\\t\\tif ( asCodePoint ) {\\n\\n\\t\\t\\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\\n\\t\\t\\tif ( ch === \\\"\\\\0\\\" ) {\\n\\t\\t\\t\\treturn \\\"\\\\uFFFD\\\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Control characters and (dependent upon position) numbers get escaped as code points\\n\\t\\t\\treturn ch.slice( 0, -1 ) + \\\"\\\\\\\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \\\" \\\";\\n\\t\\t}\\n\\n\\t\\t// Other potentially-special ASCII characters get backslash-escaped\\n\\t\\treturn \\\"\\\\\\\\\\\" + ch;\\n\\t},\\n\\n\\t// Used for iframes\\n\\t// See setDocument()\\n\\t// Removing the function wrapper causes a \\\"Permission Denied\\\"\\n\\t// error in IE\\n\\tunloadHandler = function() {\\n\\t\\tsetDocument();\\n\\t},\\n\\n\\tdisabledAncestor = addCombinator(\\n\\t\\tfunction( elem ) {\\n\\t\\t\\treturn elem.disabled === true && (\\\"form\\\" in elem || \\\"label\\\" in elem);\\n\\t\\t},\\n\\t\\t{ dir: \\\"parentNode\\\", next: \\\"legend\\\" }\\n\\t);\\n\\n// Optimize for push.apply( _, NodeList )\\ntry {\\n\\tpush.apply(\\n\\t\\t(arr = slice.call( preferredDoc.childNodes )),\\n\\t\\tpreferredDoc.childNodes\\n\\t);\\n\\t// Support: Android<4.0\\n\\t// Detect silently failing push.apply\\n\\tarr[ preferredDoc.childNodes.length ].nodeType;\\n} catch ( e ) {\\n\\tpush = { apply: arr.length ?\\n\\n\\t\\t// Leverage slice if possible\\n\\t\\tfunction( target, els ) {\\n\\t\\t\\tpush_native.apply( target, slice.call(els) );\\n\\t\\t} :\\n\\n\\t\\t// Support: IE<9\\n\\t\\t// Otherwise append directly\\n\\t\\tfunction( target, els ) {\\n\\t\\t\\tvar j = target.length,\\n\\t\\t\\t\\ti = 0;\\n\\t\\t\\t// Can't trust NodeList.length\\n\\t\\t\\twhile ( (target[j++] = els[i++]) ) {}\\n\\t\\t\\ttarget.length = j - 1;\\n\\t\\t}\\n\\t};\\n}\\n\\nfunction Sizzle( selector, context, results, seed ) {\\n\\tvar m, i, elem, nid, match, groups, newSelector,\\n\\t\\tnewContext = context && context.ownerDocument,\\n\\n\\t\\t// nodeType defaults to 9, since context defaults to document\\n\\t\\tnodeType = context ? context.nodeType : 9;\\n\\n\\tresults = results || [];\\n\\n\\t// Return early from calls with invalid selector or context\\n\\tif ( typeof selector !== \\\"string\\\" || !selector ||\\n\\t\\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\\n\\n\\t\\treturn results;\\n\\t}\\n\\n\\t// Try to shortcut find operations (as opposed to filters) in HTML documents\\n\\tif ( !seed ) {\\n\\n\\t\\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\\n\\t\\t\\tsetDocument( context );\\n\\t\\t}\\n\\t\\tcontext = context || document;\\n\\n\\t\\tif ( documentIsHTML ) {\\n\\n\\t\\t\\t// If the selector is sufficiently simple, try using a \\\"get*By*\\\" DOM method\\n\\t\\t\\t// (excepting DocumentFragment context, where the methods don't exist)\\n\\t\\t\\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\\n\\n\\t\\t\\t\\t// ID selector\\n\\t\\t\\t\\tif ( (m = match[1]) ) {\\n\\n\\t\\t\\t\\t\\t// Document context\\n\\t\\t\\t\\t\\tif ( nodeType === 9 ) {\\n\\t\\t\\t\\t\\t\\tif ( (elem = context.getElementById( m )) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: IE, Opera, Webkit\\n\\t\\t\\t\\t\\t\\t\\t// TODO: identify versions\\n\\t\\t\\t\\t\\t\\t\\t// getElementById can match elements by name instead of ID\\n\\t\\t\\t\\t\\t\\t\\tif ( elem.id === m ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Element context\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE, Opera, Webkit\\n\\t\\t\\t\\t\\t\\t// TODO: identify versions\\n\\t\\t\\t\\t\\t\\t// getElementById can match elements by name instead of ID\\n\\t\\t\\t\\t\\t\\tif ( newContext && (elem = newContext.getElementById( m )) &&\\n\\t\\t\\t\\t\\t\\t\\tcontains( context, elem ) &&\\n\\t\\t\\t\\t\\t\\t\\telem.id === m ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Type selector\\n\\t\\t\\t\\t} else if ( match[2] ) {\\n\\t\\t\\t\\t\\tpush.apply( results, context.getElementsByTagName( selector ) );\\n\\t\\t\\t\\t\\treturn results;\\n\\n\\t\\t\\t\\t// Class selector\\n\\t\\t\\t\\t} else if ( (m = match[3]) && support.getElementsByClassName &&\\n\\t\\t\\t\\t\\tcontext.getElementsByClassName ) {\\n\\n\\t\\t\\t\\t\\tpush.apply( results, context.getElementsByClassName( m ) );\\n\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Take advantage of querySelectorAll\\n\\t\\t\\tif ( support.qsa &&\\n\\t\\t\\t\\t!compilerCache[ selector + \\\" \\\" ] &&\\n\\t\\t\\t\\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\\n\\n\\t\\t\\t\\tif ( nodeType !== 1 ) {\\n\\t\\t\\t\\t\\tnewContext = context;\\n\\t\\t\\t\\t\\tnewSelector = selector;\\n\\n\\t\\t\\t\\t// qSA looks outside Element context, which is not what we want\\n\\t\\t\\t\\t// Thanks to Andrew Dupont for this workaround technique\\n\\t\\t\\t\\t// Support: IE <=8\\n\\t\\t\\t\\t// Exclude object elements\\n\\t\\t\\t\\t} else if ( context.nodeName.toLowerCase() !== \\\"object\\\" ) {\\n\\n\\t\\t\\t\\t\\t// Capture the context ID, setting it first if necessary\\n\\t\\t\\t\\t\\tif ( (nid = context.getAttribute( \\\"id\\\" )) ) {\\n\\t\\t\\t\\t\\t\\tnid = nid.replace( rcssescape, fcssescape );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcontext.setAttribute( \\\"id\\\", (nid = expando) );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Prefix every selector in the list\\n\\t\\t\\t\\t\\tgroups = tokenize( selector );\\n\\t\\t\\t\\t\\ti = groups.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tgroups[i] = \\\"#\\\" + nid + \\\" \\\" + toSelector( groups[i] );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnewSelector = groups.join( \\\",\\\" );\\n\\n\\t\\t\\t\\t\\t// Expand context for sibling selectors\\n\\t\\t\\t\\t\\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\\n\\t\\t\\t\\t\\t\\tcontext;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( newSelector ) {\\n\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\tpush.apply( results,\\n\\t\\t\\t\\t\\t\\t\\tnewContext.querySelectorAll( newSelector )\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t} catch ( qsaError ) {\\n\\t\\t\\t\\t\\t} finally {\\n\\t\\t\\t\\t\\t\\tif ( nid === expando ) {\\n\\t\\t\\t\\t\\t\\t\\tcontext.removeAttribute( \\\"id\\\" );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// All others\\n\\treturn select( selector.replace( rtrim, \\\"$1\\\" ), context, results, seed );\\n}\\n\\n/**\\n * Create key-value caches of limited size\\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\\n *\\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\\n *\\tdeleting the oldest entry\\n */\\nfunction createCache() {\\n\\tvar keys = [];\\n\\n\\tfunction cache( key, value ) {\\n\\t\\t// Use (key + \\\" \\\") to avoid collision with native prototype properties (see Issue #157)\\n\\t\\tif ( keys.push( key + \\\" \\\" ) > Expr.cacheLength ) {\\n\\t\\t\\t// Only keep the most recent entries\\n\\t\\t\\tdelete cache[ keys.shift() ];\\n\\t\\t}\\n\\t\\treturn (cache[ key + \\\" \\\" ] = value);\\n\\t}\\n\\treturn cache;\\n}\\n\\n/**\\n * Mark a function for special use by Sizzle\\n * @param {Function} fn The function to mark\\n */\\nfunction markFunction( fn ) {\\n\\tfn[ expando ] = true;\\n\\treturn fn;\\n}\\n\\n/**\\n * Support testing using an element\\n * @param {Function} fn Passed the created element and returns a boolean result\\n */\\nfunction assert( fn ) {\\n\\tvar el = document.createElement(\\\"fieldset\\\");\\n\\n\\ttry {\\n\\t\\treturn !!fn( el );\\n\\t} catch (e) {\\n\\t\\treturn false;\\n\\t} finally {\\n\\t\\t// Remove from its parent by default\\n\\t\\tif ( el.parentNode ) {\\n\\t\\t\\tel.parentNode.removeChild( el );\\n\\t\\t}\\n\\t\\t// release memory in IE\\n\\t\\tel = null;\\n\\t}\\n}\\n\\n/**\\n * Adds the same handler for all of the specified attrs\\n * @param {String} attrs Pipe-separated list of attributes\\n * @param {Function} handler The method that will be applied\\n */\\nfunction addHandle( attrs, handler ) {\\n\\tvar arr = attrs.split(\\\"|\\\"),\\n\\t\\ti = arr.length;\\n\\n\\twhile ( i-- ) {\\n\\t\\tExpr.attrHandle[ arr[i] ] = handler;\\n\\t}\\n}\\n\\n/**\\n * Checks document order of two siblings\\n * @param {Element} a\\n * @param {Element} b\\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\\n */\\nfunction siblingCheck( a, b ) {\\n\\tvar cur = b && a,\\n\\t\\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\\n\\t\\t\\ta.sourceIndex - b.sourceIndex;\\n\\n\\t// Use IE sourceIndex if available on both nodes\\n\\tif ( diff ) {\\n\\t\\treturn diff;\\n\\t}\\n\\n\\t// Check if b follows a\\n\\tif ( cur ) {\\n\\t\\twhile ( (cur = cur.nextSibling) ) {\\n\\t\\t\\tif ( cur === b ) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn a ? 1 : -1;\\n}\\n\\n/**\\n * Returns a function to use in pseudos for input types\\n * @param {String} type\\n */\\nfunction createInputPseudo( type ) {\\n\\treturn function( elem ) {\\n\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\treturn name === \\\"input\\\" && elem.type === type;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for buttons\\n * @param {String} type\\n */\\nfunction createButtonPseudo( type ) {\\n\\treturn function( elem ) {\\n\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\treturn (name === \\\"input\\\" || name === \\\"button\\\") && elem.type === type;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for :enabled/:disabled\\n * @param {Boolean} disabled true for :disabled; false for :enabled\\n */\\nfunction createDisabledPseudo( disabled ) {\\n\\n\\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\\n\\treturn function( elem ) {\\n\\n\\t\\t// Only certain elements can match :enabled or :disabled\\n\\t\\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\\n\\t\\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\\n\\t\\tif ( \\\"form\\\" in elem ) {\\n\\n\\t\\t\\t// Check for inherited disabledness on relevant non-disabled elements:\\n\\t\\t\\t// * listed form-associated elements in a disabled fieldset\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\\n\\t\\t\\t// * option elements in a disabled optgroup\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\\n\\t\\t\\t// All such elements have a \\\"form\\\" property.\\n\\t\\t\\tif ( elem.parentNode && elem.disabled === false ) {\\n\\n\\t\\t\\t\\t// Option elements defer to a parent optgroup if present\\n\\t\\t\\t\\tif ( \\\"label\\\" in elem ) {\\n\\t\\t\\t\\t\\tif ( \\\"label\\\" in elem.parentNode ) {\\n\\t\\t\\t\\t\\t\\treturn elem.parentNode.disabled === disabled;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn elem.disabled === disabled;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Support: IE 6 - 11\\n\\t\\t\\t\\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\\n\\t\\t\\t\\treturn elem.isDisabled === disabled ||\\n\\n\\t\\t\\t\\t\\t// Where there is no isDisabled, check manually\\n\\t\\t\\t\\t\\t/* jshint -W018 */\\n\\t\\t\\t\\t\\telem.isDisabled !== !disabled &&\\n\\t\\t\\t\\t\\t\\tdisabledAncestor( elem ) === disabled;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn elem.disabled === disabled;\\n\\n\\t\\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\\n\\t\\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\\n\\t\\t// even exist on them, let alone have a boolean value.\\n\\t\\t} else if ( \\\"label\\\" in elem ) {\\n\\t\\t\\treturn elem.disabled === disabled;\\n\\t\\t}\\n\\n\\t\\t// Remaining elements are neither :enabled nor :disabled\\n\\t\\treturn false;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for positionals\\n * @param {Function} fn\\n */\\nfunction createPositionalPseudo( fn ) {\\n\\treturn markFunction(function( argument ) {\\n\\t\\targument = +argument;\\n\\t\\treturn markFunction(function( seed, matches ) {\\n\\t\\t\\tvar j,\\n\\t\\t\\t\\tmatchIndexes = fn( [], seed.length, argument ),\\n\\t\\t\\t\\ti = matchIndexes.length;\\n\\n\\t\\t\\t// Match elements found at the specified indexes\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( seed[ (j = matchIndexes[i]) ] ) {\\n\\t\\t\\t\\t\\tseed[j] = !(matches[j] = seed[j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t});\\n}\\n\\n/**\\n * Checks a node for validity as a Sizzle context\\n * @param {Element|Object=} context\\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\\n */\\nfunction testContext( context ) {\\n\\treturn context && typeof context.getElementsByTagName !== \\\"undefined\\\" && context;\\n}\\n\\n// Expose support vars for convenience\\nsupport = Sizzle.support = {};\\n\\n/**\\n * Detects XML nodes\\n * @param {Element|Object} elem An element or a document\\n * @returns {Boolean} True iff elem is a non-HTML XML node\\n */\\nisXML = Sizzle.isXML = function( elem ) {\\n\\t// documentElement is verified for cases where it doesn't yet exist\\n\\t// (such as loading iframes in IE - #4833)\\n\\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\\n\\treturn documentElement ? documentElement.nodeName !== \\\"HTML\\\" : false;\\n};\\n\\n/**\\n * Sets document-related variables once based on the current document\\n * @param {Element|Object} [doc] An element or document object to use to set the document\\n * @returns {Object} Returns the current document\\n */\\nsetDocument = Sizzle.setDocument = function( node ) {\\n\\tvar hasCompare, subWindow,\\n\\t\\tdoc = node ? node.ownerDocument || node : preferredDoc;\\n\\n\\t// Return early if doc is invalid or already selected\\n\\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\\n\\t\\treturn document;\\n\\t}\\n\\n\\t// Update global variables\\n\\tdocument = doc;\\n\\tdocElem = document.documentElement;\\n\\tdocumentIsHTML = !isXML( document );\\n\\n\\t// Support: IE 9-11, Edge\\n\\t// Accessing iframe documents after unload throws \\\"permission denied\\\" errors (jQuery #13936)\\n\\tif ( preferredDoc !== document &&\\n\\t\\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\\n\\n\\t\\t// Support: IE 11, Edge\\n\\t\\tif ( subWindow.addEventListener ) {\\n\\t\\t\\tsubWindow.addEventListener( \\\"unload\\\", unloadHandler, false );\\n\\n\\t\\t// Support: IE 9 - 10 only\\n\\t\\t} else if ( subWindow.attachEvent ) {\\n\\t\\t\\tsubWindow.attachEvent( \\\"onunload\\\", unloadHandler );\\n\\t\\t}\\n\\t}\\n\\n\\t/* Attributes\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Support: IE<8\\n\\t// Verify that getAttribute really returns attributes and not properties\\n\\t// (excepting IE8 booleans)\\n\\tsupport.attributes = assert(function( el ) {\\n\\t\\tel.className = \\\"i\\\";\\n\\t\\treturn !el.getAttribute(\\\"className\\\");\\n\\t});\\n\\n\\t/* getElement(s)By*\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Check if getElementsByTagName(\\\"*\\\") returns only elements\\n\\tsupport.getElementsByTagName = assert(function( el ) {\\n\\t\\tel.appendChild( document.createComment(\\\"\\\") );\\n\\t\\treturn !el.getElementsByTagName(\\\"*\\\").length;\\n\\t});\\n\\n\\t// Support: IE<9\\n\\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\\n\\n\\t// Support: IE<10\\n\\t// Check if getElementById returns elements by name\\n\\t// The broken getElementById methods don't pick up programmatically-set names,\\n\\t// so use a roundabout getElementsByName test\\n\\tsupport.getById = assert(function( el ) {\\n\\t\\tdocElem.appendChild( el ).id = expando;\\n\\t\\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\\n\\t});\\n\\n\\t// ID filter and find\\n\\tif ( support.getById ) {\\n\\t\\tExpr.filter[\\\"ID\\\"] = function( id ) {\\n\\t\\t\\tvar attrId = id.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn elem.getAttribute(\\\"id\\\") === attrId;\\n\\t\\t\\t};\\n\\t\\t};\\n\\t\\tExpr.find[\\\"ID\\\"] = function( id, context ) {\\n\\t\\t\\tif ( typeof context.getElementById !== \\\"undefined\\\" && documentIsHTML ) {\\n\\t\\t\\t\\tvar elem = context.getElementById( id );\\n\\t\\t\\t\\treturn elem ? [ elem ] : [];\\n\\t\\t\\t}\\n\\t\\t};\\n\\t} else {\\n\\t\\tExpr.filter[\\\"ID\\\"] =  function( id ) {\\n\\t\\t\\tvar attrId = id.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar node = typeof elem.getAttributeNode !== \\\"undefined\\\" &&\\n\\t\\t\\t\\t\\telem.getAttributeNode(\\\"id\\\");\\n\\t\\t\\t\\treturn node && node.value === attrId;\\n\\t\\t\\t};\\n\\t\\t};\\n\\n\\t\\t// Support: IE 6 - 7 only\\n\\t\\t// getElementById is not reliable as a find shortcut\\n\\t\\tExpr.find[\\\"ID\\\"] = function( id, context ) {\\n\\t\\t\\tif ( typeof context.getElementById !== \\\"undefined\\\" && documentIsHTML ) {\\n\\t\\t\\t\\tvar node, i, elems,\\n\\t\\t\\t\\t\\telem = context.getElementById( id );\\n\\n\\t\\t\\t\\tif ( elem ) {\\n\\n\\t\\t\\t\\t\\t// Verify the id attribute\\n\\t\\t\\t\\t\\tnode = elem.getAttributeNode(\\\"id\\\");\\n\\t\\t\\t\\t\\tif ( node && node.value === id ) {\\n\\t\\t\\t\\t\\t\\treturn [ elem ];\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Fall back on getElementsByName\\n\\t\\t\\t\\t\\telems = context.getElementsByName( id );\\n\\t\\t\\t\\t\\ti = 0;\\n\\t\\t\\t\\t\\twhile ( (elem = elems[i++]) ) {\\n\\t\\t\\t\\t\\t\\tnode = elem.getAttributeNode(\\\"id\\\");\\n\\t\\t\\t\\t\\t\\tif ( node && node.value === id ) {\\n\\t\\t\\t\\t\\t\\t\\treturn [ elem ];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn [];\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\n\\t// Tag\\n\\tExpr.find[\\\"TAG\\\"] = support.getElementsByTagName ?\\n\\t\\tfunction( tag, context ) {\\n\\t\\t\\tif ( typeof context.getElementsByTagName !== \\\"undefined\\\" ) {\\n\\t\\t\\t\\treturn context.getElementsByTagName( tag );\\n\\n\\t\\t\\t// DocumentFragment nodes don't have gEBTN\\n\\t\\t\\t} else if ( support.qsa ) {\\n\\t\\t\\t\\treturn context.querySelectorAll( tag );\\n\\t\\t\\t}\\n\\t\\t} :\\n\\n\\t\\tfunction( tag, context ) {\\n\\t\\t\\tvar elem,\\n\\t\\t\\t\\ttmp = [],\\n\\t\\t\\t\\ti = 0,\\n\\t\\t\\t\\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\\n\\t\\t\\t\\tresults = context.getElementsByTagName( tag );\\n\\n\\t\\t\\t// Filter out possible comments\\n\\t\\t\\tif ( tag === \\\"*\\\" ) {\\n\\t\\t\\t\\twhile ( (elem = results[i++]) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\t\\t\\t\\ttmp.push( elem );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn tmp;\\n\\t\\t\\t}\\n\\t\\t\\treturn results;\\n\\t\\t};\\n\\n\\t// Class\\n\\tExpr.find[\\\"CLASS\\\"] = support.getElementsByClassName && function( className, context ) {\\n\\t\\tif ( typeof context.getElementsByClassName !== \\\"undefined\\\" && documentIsHTML ) {\\n\\t\\t\\treturn context.getElementsByClassName( className );\\n\\t\\t}\\n\\t};\\n\\n\\t/* QSA/matchesSelector\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// QSA and matchesSelector support\\n\\n\\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\\n\\trbuggyMatches = [];\\n\\n\\t// qSa(:focus) reports false when true (Chrome 21)\\n\\t// We allow this because of a bug in IE8/9 that throws an error\\n\\t// whenever `document.activeElement` is accessed on an iframe\\n\\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\\n\\t// See https://bugs.jquery.com/ticket/13378\\n\\trbuggyQSA = [];\\n\\n\\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\\n\\t\\t// Build QSA regex\\n\\t\\t// Regex strategy adopted from Diego Perini\\n\\t\\tassert(function( el ) {\\n\\t\\t\\t// Select is set to empty string on purpose\\n\\t\\t\\t// This is to test IE's treatment of not explicitly\\n\\t\\t\\t// setting a boolean content attribute,\\n\\t\\t\\t// since its presence should be enough\\n\\t\\t\\t// https://bugs.jquery.com/ticket/12359\\n\\t\\t\\tdocElem.appendChild( el ).innerHTML = \\\"<a id='\\\" + expando + \\\"'></a>\\\" +\\n\\t\\t\\t\\t\\\"<select id='\\\" + expando + \\\"-\\\\r\\\\\\\\' msallowcapture=''>\\\" +\\n\\t\\t\\t\\t\\\"<option selected=''></option></select>\\\";\\n\\n\\t\\t\\t// Support: IE8, Opera 11-12.16\\n\\t\\t\\t// Nothing should be selected when empty strings follow ^= or $= or *=\\n\\t\\t\\t// The test attribute must be unknown in Opera but \\\"safe\\\" for WinRT\\n\\t\\t\\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\\n\\t\\t\\tif ( el.querySelectorAll(\\\"[msallowcapture^='']\\\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\\"[*^$]=\\\" + whitespace + \\\"*(?:''|\\\\\\\"\\\\\\\")\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: IE8\\n\\t\\t\\t// Boolean attributes and \\\"value\\\" are not treated correctly\\n\\t\\t\\tif ( !el.querySelectorAll(\\\"[selected]\\\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\\"\\\\\\\\[\\\" + whitespace + \\\"*(?:value|\\\" + booleans + \\\")\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\\n\\t\\t\\tif ( !el.querySelectorAll( \\\"[id~=\\\" + expando + \\\"-]\\\" ).length ) {\\n\\t\\t\\t\\trbuggyQSA.push(\\\"~=\\\");\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Webkit/Opera - :checked should return selected option elements\\n\\t\\t\\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\\n\\t\\t\\t// IE8 throws error here and will not see later tests\\n\\t\\t\\tif ( !el.querySelectorAll(\\\":checked\\\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push(\\\":checked\\\");\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: Safari 8+, iOS 8+\\n\\t\\t\\t// https://bugs.webkit.org/show_bug.cgi?id=136851\\n\\t\\t\\t// In-page `selector#id sibling-combinator selector` fails\\n\\t\\t\\tif ( !el.querySelectorAll( \\\"a#\\\" + expando + \\\"+*\\\" ).length ) {\\n\\t\\t\\t\\trbuggyQSA.push(\\\".#.+[+~]\\\");\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tassert(function( el ) {\\n\\t\\t\\tel.innerHTML = \\\"<a href='' disabled='disabled'></a>\\\" +\\n\\t\\t\\t\\t\\\"<select disabled='disabled'><option/></select>\\\";\\n\\n\\t\\t\\t// Support: Windows 8 Native Apps\\n\\t\\t\\t// The type and name attributes are restricted during .innerHTML assignment\\n\\t\\t\\tvar input = document.createElement(\\\"input\\\");\\n\\t\\t\\tinput.setAttribute( \\\"type\\\", \\\"hidden\\\" );\\n\\t\\t\\tel.appendChild( input ).setAttribute( \\\"name\\\", \\\"D\\\" );\\n\\n\\t\\t\\t// Support: IE8\\n\\t\\t\\t// Enforce case-sensitivity of name attribute\\n\\t\\t\\tif ( el.querySelectorAll(\\\"[name=d]\\\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\\"name\\\" + whitespace + \\\"*[*^$|!~]?=\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\\n\\t\\t\\t// IE8 throws error here and will not see later tests\\n\\t\\t\\tif ( el.querySelectorAll(\\\":enabled\\\").length !== 2 ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\\":enabled\\\", \\\":disabled\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: IE9-11+\\n\\t\\t\\t// IE's :disabled selector does not pick up the children of disabled fieldsets\\n\\t\\t\\tdocElem.appendChild( el ).disabled = true;\\n\\t\\t\\tif ( el.querySelectorAll(\\\":disabled\\\").length !== 2 ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\\":enabled\\\", \\\":disabled\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Opera 10-11 does not throw on post-comma invalid pseudos\\n\\t\\t\\tel.querySelectorAll(\\\"*,:x\\\");\\n\\t\\t\\trbuggyQSA.push(\\\",.*:\\\");\\n\\t\\t});\\n\\t}\\n\\n\\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\\n\\t\\tdocElem.webkitMatchesSelector ||\\n\\t\\tdocElem.mozMatchesSelector ||\\n\\t\\tdocElem.oMatchesSelector ||\\n\\t\\tdocElem.msMatchesSelector) )) ) {\\n\\n\\t\\tassert(function( el ) {\\n\\t\\t\\t// Check to see if it's possible to do matchesSelector\\n\\t\\t\\t// on a disconnected node (IE 9)\\n\\t\\t\\tsupport.disconnectedMatch = matches.call( el, \\\"*\\\" );\\n\\n\\t\\t\\t// This should fail with an exception\\n\\t\\t\\t// Gecko does not error, returns false instead\\n\\t\\t\\tmatches.call( el, \\\"[s!='']:x\\\" );\\n\\t\\t\\trbuggyMatches.push( \\\"!=\\\", pseudos );\\n\\t\\t});\\n\\t}\\n\\n\\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\\\"|\\\") );\\n\\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\\\"|\\\") );\\n\\n\\t/* Contains\\n\\t---------------------------------------------------------------------- */\\n\\thasCompare = rnative.test( docElem.compareDocumentPosition );\\n\\n\\t// Element contains another\\n\\t// Purposefully self-exclusive\\n\\t// As in, an element does not contain itself\\n\\tcontains = hasCompare || rnative.test( docElem.contains ) ?\\n\\t\\tfunction( a, b ) {\\n\\t\\t\\tvar adown = a.nodeType === 9 ? a.documentElement : a,\\n\\t\\t\\t\\tbup = b && b.parentNode;\\n\\t\\t\\treturn a === bup || !!( bup && bup.nodeType === 1 && (\\n\\t\\t\\t\\tadown.contains ?\\n\\t\\t\\t\\t\\tadown.contains( bup ) :\\n\\t\\t\\t\\t\\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\\n\\t\\t\\t));\\n\\t\\t} :\\n\\t\\tfunction( a, b ) {\\n\\t\\t\\tif ( b ) {\\n\\t\\t\\t\\twhile ( (b = b.parentNode) ) {\\n\\t\\t\\t\\t\\tif ( b === a ) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t};\\n\\n\\t/* Sorting\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Document order sorting\\n\\tsortOrder = hasCompare ?\\n\\tfunction( a, b ) {\\n\\n\\t\\t// Flag for duplicate removal\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\t// Sort on method existence if only one input has compareDocumentPosition\\n\\t\\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\\n\\t\\tif ( compare ) {\\n\\t\\t\\treturn compare;\\n\\t\\t}\\n\\n\\t\\t// Calculate position if both inputs belong to the same document\\n\\t\\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\\n\\t\\t\\ta.compareDocumentPosition( b ) :\\n\\n\\t\\t\\t// Otherwise we know they are disconnected\\n\\t\\t\\t1;\\n\\n\\t\\t// Disconnected nodes\\n\\t\\tif ( compare & 1 ||\\n\\t\\t\\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\\n\\n\\t\\t\\t// Choose the first element that is related to our preferred document\\n\\t\\t\\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Maintain original order\\n\\t\\t\\treturn sortInput ?\\n\\t\\t\\t\\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\\n\\t\\t\\t\\t0;\\n\\t\\t}\\n\\n\\t\\treturn compare & 4 ? -1 : 1;\\n\\t} :\\n\\tfunction( a, b ) {\\n\\t\\t// Exit early if the nodes are identical\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tvar cur,\\n\\t\\t\\ti = 0,\\n\\t\\t\\taup = a.parentNode,\\n\\t\\t\\tbup = b.parentNode,\\n\\t\\t\\tap = [ a ],\\n\\t\\t\\tbp = [ b ];\\n\\n\\t\\t// Parentless nodes are either documents or disconnected\\n\\t\\tif ( !aup || !bup ) {\\n\\t\\t\\treturn a === document ? -1 :\\n\\t\\t\\t\\tb === document ? 1 :\\n\\t\\t\\t\\taup ? -1 :\\n\\t\\t\\t\\tbup ? 1 :\\n\\t\\t\\t\\tsortInput ?\\n\\t\\t\\t\\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\\n\\t\\t\\t\\t0;\\n\\n\\t\\t// If the nodes are siblings, we can do a quick check\\n\\t\\t} else if ( aup === bup ) {\\n\\t\\t\\treturn siblingCheck( a, b );\\n\\t\\t}\\n\\n\\t\\t// Otherwise we need full lists of their ancestors for comparison\\n\\t\\tcur = a;\\n\\t\\twhile ( (cur = cur.parentNode) ) {\\n\\t\\t\\tap.unshift( cur );\\n\\t\\t}\\n\\t\\tcur = b;\\n\\t\\twhile ( (cur = cur.parentNode) ) {\\n\\t\\t\\tbp.unshift( cur );\\n\\t\\t}\\n\\n\\t\\t// Walk down the tree looking for a discrepancy\\n\\t\\twhile ( ap[i] === bp[i] ) {\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\treturn i ?\\n\\t\\t\\t// Do a sibling check if the nodes have a common ancestor\\n\\t\\t\\tsiblingCheck( ap[i], bp[i] ) :\\n\\n\\t\\t\\t// Otherwise nodes in our document sort first\\n\\t\\t\\tap[i] === preferredDoc ? -1 :\\n\\t\\t\\tbp[i] === preferredDoc ? 1 :\\n\\t\\t\\t0;\\n\\t};\\n\\n\\treturn document;\\n};\\n\\nSizzle.matches = function( expr, elements ) {\\n\\treturn Sizzle( expr, null, null, elements );\\n};\\n\\nSizzle.matchesSelector = function( elem, expr ) {\\n\\t// Set document vars if needed\\n\\tif ( ( elem.ownerDocument || elem ) !== document ) {\\n\\t\\tsetDocument( elem );\\n\\t}\\n\\n\\t// Make sure that attribute selectors are quoted\\n\\texpr = expr.replace( rattributeQuotes, \\\"='$1']\\\" );\\n\\n\\tif ( support.matchesSelector && documentIsHTML &&\\n\\t\\t!compilerCache[ expr + \\\" \\\" ] &&\\n\\t\\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\\n\\t\\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\\n\\n\\t\\ttry {\\n\\t\\t\\tvar ret = matches.call( elem, expr );\\n\\n\\t\\t\\t// IE 9's matchesSelector returns false on disconnected nodes\\n\\t\\t\\tif ( ret || support.disconnectedMatch ||\\n\\t\\t\\t\\t\\t// As well, disconnected nodes are said to be in a document\\n\\t\\t\\t\\t\\t// fragment in IE 9\\n\\t\\t\\t\\t\\telem.document && elem.document.nodeType !== 11 ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {}\\n\\t}\\n\\n\\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\\n};\\n\\nSizzle.contains = function( context, elem ) {\\n\\t// Set document vars if needed\\n\\tif ( ( context.ownerDocument || context ) !== document ) {\\n\\t\\tsetDocument( context );\\n\\t}\\n\\treturn contains( context, elem );\\n};\\n\\nSizzle.attr = function( elem, name ) {\\n\\t// Set document vars if needed\\n\\tif ( ( elem.ownerDocument || elem ) !== document ) {\\n\\t\\tsetDocument( elem );\\n\\t}\\n\\n\\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\\n\\t\\t// Don't get fooled by Object.prototype properties (jQuery #13807)\\n\\t\\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\\n\\t\\t\\tfn( elem, name, !documentIsHTML ) :\\n\\t\\t\\tundefined;\\n\\n\\treturn val !== undefined ?\\n\\t\\tval :\\n\\t\\tsupport.attributes || !documentIsHTML ?\\n\\t\\t\\telem.getAttribute( name ) :\\n\\t\\t\\t(val = elem.getAttributeNode(name)) && val.specified ?\\n\\t\\t\\t\\tval.value :\\n\\t\\t\\t\\tnull;\\n};\\n\\nSizzle.escape = function( sel ) {\\n\\treturn (sel + \\\"\\\").replace( rcssescape, fcssescape );\\n};\\n\\nSizzle.error = function( msg ) {\\n\\tthrow new Error( \\\"Syntax error, unrecognized expression: \\\" + msg );\\n};\\n\\n/**\\n * Document sorting and removing duplicates\\n * @param {ArrayLike} results\\n */\\nSizzle.uniqueSort = function( results ) {\\n\\tvar elem,\\n\\t\\tduplicates = [],\\n\\t\\tj = 0,\\n\\t\\ti = 0;\\n\\n\\t// Unless we *know* we can detect duplicates, assume their presence\\n\\thasDuplicate = !support.detectDuplicates;\\n\\tsortInput = !support.sortStable && results.slice( 0 );\\n\\tresults.sort( sortOrder );\\n\\n\\tif ( hasDuplicate ) {\\n\\t\\twhile ( (elem = results[i++]) ) {\\n\\t\\t\\tif ( elem === results[ i ] ) {\\n\\t\\t\\t\\tj = duplicates.push( i );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile ( j-- ) {\\n\\t\\t\\tresults.splice( duplicates[ j ], 1 );\\n\\t\\t}\\n\\t}\\n\\n\\t// Clear input after sorting to release objects\\n\\t// See https://github.com/jquery/sizzle/pull/225\\n\\tsortInput = null;\\n\\n\\treturn results;\\n};\\n\\n/**\\n * Utility function for retrieving the text value of an array of DOM nodes\\n * @param {Array|Element} elem\\n */\\ngetText = Sizzle.getText = function( elem ) {\\n\\tvar node,\\n\\t\\tret = \\\"\\\",\\n\\t\\ti = 0,\\n\\t\\tnodeType = elem.nodeType;\\n\\n\\tif ( !nodeType ) {\\n\\t\\t// If no nodeType, this is expected to be an array\\n\\t\\twhile ( (node = elem[i++]) ) {\\n\\t\\t\\t// Do not traverse comment nodes\\n\\t\\t\\tret += getText( node );\\n\\t\\t}\\n\\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\\n\\t\\t// Use textContent for elements\\n\\t\\t// innerText usage removed for consistency of new lines (jQuery #11153)\\n\\t\\tif ( typeof elem.textContent === \\\"string\\\" ) {\\n\\t\\t\\treturn elem.textContent;\\n\\t\\t} else {\\n\\t\\t\\t// Traverse its children\\n\\t\\t\\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\\n\\t\\t\\t\\tret += getText( elem );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else if ( nodeType === 3 || nodeType === 4 ) {\\n\\t\\treturn elem.nodeValue;\\n\\t}\\n\\t// Do not include comment or processing instruction nodes\\n\\n\\treturn ret;\\n};\\n\\nExpr = Sizzle.selectors = {\\n\\n\\t// Can be adjusted by the user\\n\\tcacheLength: 50,\\n\\n\\tcreatePseudo: markFunction,\\n\\n\\tmatch: matchExpr,\\n\\n\\tattrHandle: {},\\n\\n\\tfind: {},\\n\\n\\trelative: {\\n\\t\\t\\\">\\\": { dir: \\\"parentNode\\\", first: true },\\n\\t\\t\\\" \\\": { dir: \\\"parentNode\\\" },\\n\\t\\t\\\"+\\\": { dir: \\\"previousSibling\\\", first: true },\\n\\t\\t\\\"~\\\": { dir: \\\"previousSibling\\\" }\\n\\t},\\n\\n\\tpreFilter: {\\n\\t\\t\\\"ATTR\\\": function( match ) {\\n\\t\\t\\tmatch[1] = match[1].replace( runescape, funescape );\\n\\n\\t\\t\\t// Move the given value to match[3] whether quoted or unquoted\\n\\t\\t\\tmatch[3] = ( match[3] || match[4] || match[5] || \\\"\\\" ).replace( runescape, funescape );\\n\\n\\t\\t\\tif ( match[2] === \\\"~=\\\" ) {\\n\\t\\t\\t\\tmatch[3] = \\\" \\\" + match[3] + \\\" \\\";\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn match.slice( 0, 4 );\\n\\t\\t},\\n\\n\\t\\t\\\"CHILD\\\": function( match ) {\\n\\t\\t\\t/* matches from matchExpr[\\\"CHILD\\\"]\\n\\t\\t\\t\\t1 type (only|nth|...)\\n\\t\\t\\t\\t2 what (child|of-type)\\n\\t\\t\\t\\t3 argument (even|odd|\\\\d*|\\\\d*n([+-]\\\\d+)?|...)\\n\\t\\t\\t\\t4 xn-component of xn+y argument ([+-]?\\\\d*n|)\\n\\t\\t\\t\\t5 sign of xn-component\\n\\t\\t\\t\\t6 x of xn-component\\n\\t\\t\\t\\t7 sign of y-component\\n\\t\\t\\t\\t8 y of y-component\\n\\t\\t\\t*/\\n\\t\\t\\tmatch[1] = match[1].toLowerCase();\\n\\n\\t\\t\\tif ( match[1].slice( 0, 3 ) === \\\"nth\\\" ) {\\n\\t\\t\\t\\t// nth-* requires argument\\n\\t\\t\\t\\tif ( !match[3] ) {\\n\\t\\t\\t\\t\\tSizzle.error( match[0] );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// numeric x and y parameters for Expr.filter.CHILD\\n\\t\\t\\t\\t// remember that false/true cast respectively to 0/1\\n\\t\\t\\t\\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \\\"even\\\" || match[3] === \\\"odd\\\" ) );\\n\\t\\t\\t\\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \\\"odd\\\" );\\n\\n\\t\\t\\t// other types prohibit arguments\\n\\t\\t\\t} else if ( match[3] ) {\\n\\t\\t\\t\\tSizzle.error( match[0] );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn match;\\n\\t\\t},\\n\\n\\t\\t\\\"PSEUDO\\\": function( match ) {\\n\\t\\t\\tvar excess,\\n\\t\\t\\t\\tunquoted = !match[6] && match[2];\\n\\n\\t\\t\\tif ( matchExpr[\\\"CHILD\\\"].test( match[0] ) ) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Accept quoted arguments as-is\\n\\t\\t\\tif ( match[3] ) {\\n\\t\\t\\t\\tmatch[2] = match[4] || match[5] || \\\"\\\";\\n\\n\\t\\t\\t// Strip excess characters from unquoted arguments\\n\\t\\t\\t} else if ( unquoted && rpseudo.test( unquoted ) &&\\n\\t\\t\\t\\t// Get excess from tokenize (recursively)\\n\\t\\t\\t\\t(excess = tokenize( unquoted, true )) &&\\n\\t\\t\\t\\t// advance to the next closing parenthesis\\n\\t\\t\\t\\t(excess = unquoted.indexOf( \\\")\\\", unquoted.length - excess ) - unquoted.length) ) {\\n\\n\\t\\t\\t\\t// excess is a negative index\\n\\t\\t\\t\\tmatch[0] = match[0].slice( 0, excess );\\n\\t\\t\\t\\tmatch[2] = unquoted.slice( 0, excess );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Return only captures needed by the pseudo filter method (type and argument)\\n\\t\\t\\treturn match.slice( 0, 3 );\\n\\t\\t}\\n\\t},\\n\\n\\tfilter: {\\n\\n\\t\\t\\\"TAG\\\": function( nodeNameSelector ) {\\n\\t\\t\\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\\n\\t\\t\\treturn nodeNameSelector === \\\"*\\\" ?\\n\\t\\t\\t\\tfunction() { return true; } :\\n\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\\n\\t\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\\\"CLASS\\\": function( className ) {\\n\\t\\t\\tvar pattern = classCache[ className + \\\" \\\" ];\\n\\n\\t\\t\\treturn pattern ||\\n\\t\\t\\t\\t(pattern = new RegExp( \\\"(^|\\\" + whitespace + \\\")\\\" + className + \\\"(\\\" + whitespace + \\\"|$)\\\" )) &&\\n\\t\\t\\t\\tclassCache( className, function( elem ) {\\n\\t\\t\\t\\t\\treturn pattern.test( typeof elem.className === \\\"string\\\" && elem.className || typeof elem.getAttribute !== \\\"undefined\\\" && elem.getAttribute(\\\"class\\\") || \\\"\\\" );\\n\\t\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\t\\\"ATTR\\\": function( name, operator, check ) {\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar result = Sizzle.attr( elem, name );\\n\\n\\t\\t\\t\\tif ( result == null ) {\\n\\t\\t\\t\\t\\treturn operator === \\\"!=\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( !operator ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tresult += \\\"\\\";\\n\\n\\t\\t\\t\\treturn operator === \\\"=\\\" ? result === check :\\n\\t\\t\\t\\t\\toperator === \\\"!=\\\" ? result !== check :\\n\\t\\t\\t\\t\\toperator === \\\"^=\\\" ? check && result.indexOf( check ) === 0 :\\n\\t\\t\\t\\t\\toperator === \\\"*=\\\" ? check && result.indexOf( check ) > -1 :\\n\\t\\t\\t\\t\\toperator === \\\"$=\\\" ? check && result.slice( -check.length ) === check :\\n\\t\\t\\t\\t\\toperator === \\\"~=\\\" ? ( \\\" \\\" + result.replace( rwhitespace, \\\" \\\" ) + \\\" \\\" ).indexOf( check ) > -1 :\\n\\t\\t\\t\\t\\toperator === \\\"|=\\\" ? result === check || result.slice( 0, check.length + 1 ) === check + \\\"-\\\" :\\n\\t\\t\\t\\t\\tfalse;\\n\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\\\"CHILD\\\": function( type, what, argument, first, last ) {\\n\\t\\t\\tvar simple = type.slice( 0, 3 ) !== \\\"nth\\\",\\n\\t\\t\\t\\tforward = type.slice( -4 ) !== \\\"last\\\",\\n\\t\\t\\t\\tofType = what === \\\"of-type\\\";\\n\\n\\t\\t\\treturn first === 1 && last === 0 ?\\n\\n\\t\\t\\t\\t// Shortcut for :nth-*(n)\\n\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\treturn !!elem.parentNode;\\n\\t\\t\\t\\t} :\\n\\n\\t\\t\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\t\\t\\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\\n\\t\\t\\t\\t\\t\\tdir = simple !== forward ? \\\"nextSibling\\\" : \\\"previousSibling\\\",\\n\\t\\t\\t\\t\\t\\tparent = elem.parentNode,\\n\\t\\t\\t\\t\\t\\tname = ofType && elem.nodeName.toLowerCase(),\\n\\t\\t\\t\\t\\t\\tuseCache = !xml && !ofType,\\n\\t\\t\\t\\t\\t\\tdiff = false;\\n\\n\\t\\t\\t\\t\\tif ( parent ) {\\n\\n\\t\\t\\t\\t\\t\\t// :(first|last|only)-(child|of-type)\\n\\t\\t\\t\\t\\t\\tif ( simple ) {\\n\\t\\t\\t\\t\\t\\t\\twhile ( dir ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tnode = elem;\\n\\t\\t\\t\\t\\t\\t\\t\\twhile ( (node = node[ dir ]) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( ofType ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeName.toLowerCase() === name :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeType === 1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t// Reverse direction for :only-* (if we haven't yet done so)\\n\\t\\t\\t\\t\\t\\t\\t\\tstart = dir = type === \\\"only\\\" && !start && \\\"nextSibling\\\";\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tstart = [ forward ? parent.firstChild : parent.lastChild ];\\n\\n\\t\\t\\t\\t\\t\\t// non-xml :nth-child(...) stores cache data on `parent`\\n\\t\\t\\t\\t\\t\\tif ( forward && useCache ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Seek `elem` from a previously-cached index\\n\\n\\t\\t\\t\\t\\t\\t\\t// ...in a gzip-friendly way\\n\\t\\t\\t\\t\\t\\t\\tnode = parent;\\n\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || (node[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t(outerCache[ node.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\tcache = uniqueCache[ type ] || [];\\n\\t\\t\\t\\t\\t\\t\\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\\n\\t\\t\\t\\t\\t\\t\\tdiff = nodeIndex && cache[ 2 ];\\n\\t\\t\\t\\t\\t\\t\\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Fallback to seeking `elem` from the start\\n\\t\\t\\t\\t\\t\\t\\t\\t(diff = nodeIndex = 0) || start.pop()) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// When found, cache indexes on `parent` and break\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( node.nodeType === 1 && ++diff && node === elem ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t// Use previously-cached element index if available\\n\\t\\t\\t\\t\\t\\t\\tif ( useCache ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t// ...in a gzip-friendly way\\n\\t\\t\\t\\t\\t\\t\\t\\tnode = elem;\\n\\t\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || (node[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(outerCache[ node.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcache = uniqueCache[ type ] || [];\\n\\t\\t\\t\\t\\t\\t\\t\\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\\n\\t\\t\\t\\t\\t\\t\\t\\tdiff = nodeIndex;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t// xml :nth-child(...)\\n\\t\\t\\t\\t\\t\\t\\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\\n\\t\\t\\t\\t\\t\\t\\tif ( diff === false ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t// Use the same loop as above to seek `elem` from the start\\n\\t\\t\\t\\t\\t\\t\\t\\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(diff = nodeIndex = 0) || start.pop()) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( ( ofType ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeName.toLowerCase() === name :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeType === 1 ) &&\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t++diff ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Cache the index of each encountered element\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( useCache ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || (node[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(outerCache[ node.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache[ type ] = [ dirruns, diff ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( node === elem ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Incorporate the offset, then check against cycle size\\n\\t\\t\\t\\t\\t\\tdiff -= last;\\n\\t\\t\\t\\t\\t\\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\\\"PSEUDO\\\": function( pseudo, argument ) {\\n\\t\\t\\t// pseudo-class names are case-insensitive\\n\\t\\t\\t// http://www.w3.org/TR/selectors/#pseudo-classes\\n\\t\\t\\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\\n\\t\\t\\t// Remember that setFilters inherits from pseudos\\n\\t\\t\\tvar args,\\n\\t\\t\\t\\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\\n\\t\\t\\t\\t\\tSizzle.error( \\\"unsupported pseudo: \\\" + pseudo );\\n\\n\\t\\t\\t// The user may use createPseudo to indicate that\\n\\t\\t\\t// arguments are needed to create the filter function\\n\\t\\t\\t// just as Sizzle does\\n\\t\\t\\tif ( fn[ expando ] ) {\\n\\t\\t\\t\\treturn fn( argument );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// But maintain support for old signatures\\n\\t\\t\\tif ( fn.length > 1 ) {\\n\\t\\t\\t\\targs = [ pseudo, pseudo, \\\"\\\", argument ];\\n\\t\\t\\t\\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\\n\\t\\t\\t\\t\\tmarkFunction(function( seed, matches ) {\\n\\t\\t\\t\\t\\t\\tvar idx,\\n\\t\\t\\t\\t\\t\\t\\tmatched = fn( seed, argument ),\\n\\t\\t\\t\\t\\t\\t\\ti = matched.length;\\n\\t\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\t\\tidx = indexOf( seed, matched[i] );\\n\\t\\t\\t\\t\\t\\t\\tseed[ idx ] = !( matches[ idx ] = matched[i] );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}) :\\n\\t\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\t\\treturn fn( elem, 0, args );\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn fn;\\n\\t\\t}\\n\\t},\\n\\n\\tpseudos: {\\n\\t\\t// Potentially complex pseudos\\n\\t\\t\\\"not\\\": markFunction(function( selector ) {\\n\\t\\t\\t// Trim the selector passed to compile\\n\\t\\t\\t// to avoid treating leading and trailing\\n\\t\\t\\t// spaces as combinators\\n\\t\\t\\tvar input = [],\\n\\t\\t\\t\\tresults = [],\\n\\t\\t\\t\\tmatcher = compile( selector.replace( rtrim, \\\"$1\\\" ) );\\n\\n\\t\\t\\treturn matcher[ expando ] ?\\n\\t\\t\\t\\tmarkFunction(function( seed, matches, context, xml ) {\\n\\t\\t\\t\\t\\tvar elem,\\n\\t\\t\\t\\t\\t\\tunmatched = matcher( seed, null, xml, [] ),\\n\\t\\t\\t\\t\\t\\ti = seed.length;\\n\\n\\t\\t\\t\\t\\t// Match elements unmatched by `matcher`\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tif ( (elem = unmatched[i]) ) {\\n\\t\\t\\t\\t\\t\\t\\tseed[i] = !(matches[i] = elem);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}) :\\n\\t\\t\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\t\\t\\tinput[0] = elem;\\n\\t\\t\\t\\t\\tmatcher( input, null, xml, results );\\n\\t\\t\\t\\t\\t// Don't keep the element (issue #299)\\n\\t\\t\\t\\t\\tinput[0] = null;\\n\\t\\t\\t\\t\\treturn !results.pop();\\n\\t\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t\\\"has\\\": markFunction(function( selector ) {\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn Sizzle( selector, elem ).length > 0;\\n\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t\\\"contains\\\": markFunction(function( text ) {\\n\\t\\t\\ttext = text.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\\n\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t// \\\"Whether an element is represented by a :lang() selector\\n\\t\\t// is based solely on the element's language value\\n\\t\\t// being equal to the identifier C,\\n\\t\\t// or beginning with the identifier C immediately followed by \\\"-\\\".\\n\\t\\t// The matching of C against the element's language value is performed case-insensitively.\\n\\t\\t// The identifier C does not have to be a valid language name.\\\"\\n\\t\\t// http://www.w3.org/TR/selectors/#lang-pseudo\\n\\t\\t\\\"lang\\\": markFunction( function( lang ) {\\n\\t\\t\\t// lang value must be a valid identifier\\n\\t\\t\\tif ( !ridentifier.test(lang || \\\"\\\") ) {\\n\\t\\t\\t\\tSizzle.error( \\\"unsupported lang: \\\" + lang );\\n\\t\\t\\t}\\n\\t\\t\\tlang = lang.replace( runescape, funescape ).toLowerCase();\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar elemLang;\\n\\t\\t\\t\\tdo {\\n\\t\\t\\t\\t\\tif ( (elemLang = documentIsHTML ?\\n\\t\\t\\t\\t\\t\\telem.lang :\\n\\t\\t\\t\\t\\t\\telem.getAttribute(\\\"xml:lang\\\") || elem.getAttribute(\\\"lang\\\")) ) {\\n\\n\\t\\t\\t\\t\\t\\telemLang = elemLang.toLowerCase();\\n\\t\\t\\t\\t\\t\\treturn elemLang === lang || elemLang.indexOf( lang + \\\"-\\\" ) === 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t// Miscellaneous\\n\\t\\t\\\"target\\\": function( elem ) {\\n\\t\\t\\tvar hash = window.location && window.location.hash;\\n\\t\\t\\treturn hash && hash.slice( 1 ) === elem.id;\\n\\t\\t},\\n\\n\\t\\t\\\"root\\\": function( elem ) {\\n\\t\\t\\treturn elem === docElem;\\n\\t\\t},\\n\\n\\t\\t\\\"focus\\\": function( elem ) {\\n\\t\\t\\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\\n\\t\\t},\\n\\n\\t\\t// Boolean properties\\n\\t\\t\\\"enabled\\\": createDisabledPseudo( false ),\\n\\t\\t\\\"disabled\\\": createDisabledPseudo( true ),\\n\\n\\t\\t\\\"checked\\\": function( elem ) {\\n\\t\\t\\t// In CSS3, :checked should return both checked and selected elements\\n\\t\\t\\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\\n\\t\\t\\tvar nodeName = elem.nodeName.toLowerCase();\\n\\t\\t\\treturn (nodeName === \\\"input\\\" && !!elem.checked) || (nodeName === \\\"option\\\" && !!elem.selected);\\n\\t\\t},\\n\\n\\t\\t\\\"selected\\\": function( elem ) {\\n\\t\\t\\t// Accessing this property makes selected-by-default\\n\\t\\t\\t// options in Safari work properly\\n\\t\\t\\tif ( elem.parentNode ) {\\n\\t\\t\\t\\telem.parentNode.selectedIndex;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn elem.selected === true;\\n\\t\\t},\\n\\n\\t\\t// Contents\\n\\t\\t\\\"empty\\\": function( elem ) {\\n\\t\\t\\t// http://www.w3.org/TR/selectors/#empty-pseudo\\n\\t\\t\\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\\n\\t\\t\\t//   but not by others (comment: 8; processing instruction: 7; etc.)\\n\\t\\t\\t// nodeType < 6 works because attributes (2) do not appear as children\\n\\t\\t\\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\\n\\t\\t\\t\\tif ( elem.nodeType < 6 ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t},\\n\\n\\t\\t\\\"parent\\\": function( elem ) {\\n\\t\\t\\treturn !Expr.pseudos[\\\"empty\\\"]( elem );\\n\\t\\t},\\n\\n\\t\\t// Element/input types\\n\\t\\t\\\"header\\\": function( elem ) {\\n\\t\\t\\treturn rheader.test( elem.nodeName );\\n\\t\\t},\\n\\n\\t\\t\\\"input\\\": function( elem ) {\\n\\t\\t\\treturn rinputs.test( elem.nodeName );\\n\\t\\t},\\n\\n\\t\\t\\\"button\\\": function( elem ) {\\n\\t\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\t\\treturn name === \\\"input\\\" && elem.type === \\\"button\\\" || name === \\\"button\\\";\\n\\t\\t},\\n\\n\\t\\t\\\"text\\\": function( elem ) {\\n\\t\\t\\tvar attr;\\n\\t\\t\\treturn elem.nodeName.toLowerCase() === \\\"input\\\" &&\\n\\t\\t\\t\\telem.type === \\\"text\\\" &&\\n\\n\\t\\t\\t\\t// Support: IE<8\\n\\t\\t\\t\\t// New HTML5 attribute values (e.g., \\\"search\\\") appear with elem.type === \\\"text\\\"\\n\\t\\t\\t\\t( (attr = elem.getAttribute(\\\"type\\\")) == null || attr.toLowerCase() === \\\"text\\\" );\\n\\t\\t},\\n\\n\\t\\t// Position-in-collection\\n\\t\\t\\\"first\\\": createPositionalPseudo(function() {\\n\\t\\t\\treturn [ 0 ];\\n\\t\\t}),\\n\\n\\t\\t\\\"last\\\": createPositionalPseudo(function( matchIndexes, length ) {\\n\\t\\t\\treturn [ length - 1 ];\\n\\t\\t}),\\n\\n\\t\\t\\\"eq\\\": createPositionalPseudo(function( matchIndexes, length, argument ) {\\n\\t\\t\\treturn [ argument < 0 ? argument + length : argument ];\\n\\t\\t}),\\n\\n\\t\\t\\\"even\\\": createPositionalPseudo(function( matchIndexes, length ) {\\n\\t\\t\\tvar i = 0;\\n\\t\\t\\tfor ( ; i < length; i += 2 ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t}),\\n\\n\\t\\t\\\"odd\\\": createPositionalPseudo(function( matchIndexes, length ) {\\n\\t\\t\\tvar i = 1;\\n\\t\\t\\tfor ( ; i < length; i += 2 ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t}),\\n\\n\\t\\t\\\"lt\\\": createPositionalPseudo(function( matchIndexes, length, argument ) {\\n\\t\\t\\tvar i = argument < 0 ? argument + length : argument;\\n\\t\\t\\tfor ( ; --i >= 0; ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t}),\\n\\n\\t\\t\\\"gt\\\": createPositionalPseudo(function( matchIndexes, length, argument ) {\\n\\t\\t\\tvar i = argument < 0 ? argument + length : argument;\\n\\t\\t\\tfor ( ; ++i < length; ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t})\\n\\t}\\n};\\n\\nExpr.pseudos[\\\"nth\\\"] = Expr.pseudos[\\\"eq\\\"];\\n\\n// Add button/input type pseudos\\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\\n\\tExpr.pseudos[ i ] = createInputPseudo( i );\\n}\\nfor ( i in { submit: true, reset: true } ) {\\n\\tExpr.pseudos[ i ] = createButtonPseudo( i );\\n}\\n\\n// Easy API for creating new setFilters\\nfunction setFilters() {}\\nsetFilters.prototype = Expr.filters = Expr.pseudos;\\nExpr.setFilters = new setFilters();\\n\\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\\n\\tvar matched, match, tokens, type,\\n\\t\\tsoFar, groups, preFilters,\\n\\t\\tcached = tokenCache[ selector + \\\" \\\" ];\\n\\n\\tif ( cached ) {\\n\\t\\treturn parseOnly ? 0 : cached.slice( 0 );\\n\\t}\\n\\n\\tsoFar = selector;\\n\\tgroups = [];\\n\\tpreFilters = Expr.preFilter;\\n\\n\\twhile ( soFar ) {\\n\\n\\t\\t// Comma and first run\\n\\t\\tif ( !matched || (match = rcomma.exec( soFar )) ) {\\n\\t\\t\\tif ( match ) {\\n\\t\\t\\t\\t// Don't consume trailing commas as valid\\n\\t\\t\\t\\tsoFar = soFar.slice( match[0].length ) || soFar;\\n\\t\\t\\t}\\n\\t\\t\\tgroups.push( (tokens = []) );\\n\\t\\t}\\n\\n\\t\\tmatched = false;\\n\\n\\t\\t// Combinators\\n\\t\\tif ( (match = rcombinators.exec( soFar )) ) {\\n\\t\\t\\tmatched = match.shift();\\n\\t\\t\\ttokens.push({\\n\\t\\t\\t\\tvalue: matched,\\n\\t\\t\\t\\t// Cast descendant combinators to space\\n\\t\\t\\t\\ttype: match[0].replace( rtrim, \\\" \\\" )\\n\\t\\t\\t});\\n\\t\\t\\tsoFar = soFar.slice( matched.length );\\n\\t\\t}\\n\\n\\t\\t// Filters\\n\\t\\tfor ( type in Expr.filter ) {\\n\\t\\t\\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\\n\\t\\t\\t\\t(match = preFilters[ type ]( match ))) ) {\\n\\t\\t\\t\\tmatched = match.shift();\\n\\t\\t\\t\\ttokens.push({\\n\\t\\t\\t\\t\\tvalue: matched,\\n\\t\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\t\\tmatches: match\\n\\t\\t\\t\\t});\\n\\t\\t\\t\\tsoFar = soFar.slice( matched.length );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( !matched ) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the length of the invalid excess\\n\\t// if we're just parsing\\n\\t// Otherwise, throw an error or return tokens\\n\\treturn parseOnly ?\\n\\t\\tsoFar.length :\\n\\t\\tsoFar ?\\n\\t\\t\\tSizzle.error( selector ) :\\n\\t\\t\\t// Cache the tokens\\n\\t\\t\\ttokenCache( selector, groups ).slice( 0 );\\n};\\n\\nfunction toSelector( tokens ) {\\n\\tvar i = 0,\\n\\t\\tlen = tokens.length,\\n\\t\\tselector = \\\"\\\";\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tselector += tokens[i].value;\\n\\t}\\n\\treturn selector;\\n}\\n\\nfunction addCombinator( matcher, combinator, base ) {\\n\\tvar dir = combinator.dir,\\n\\t\\tskip = combinator.next,\\n\\t\\tkey = skip || dir,\\n\\t\\tcheckNonElements = base && key === \\\"parentNode\\\",\\n\\t\\tdoneName = done++;\\n\\n\\treturn combinator.first ?\\n\\t\\t// Check against closest ancestor/preceding element\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\twhile ( (elem = elem[ dir ]) ) {\\n\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\treturn matcher( elem, context, xml );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t} :\\n\\n\\t\\t// Check against all ancestor/preceding elements\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\tvar oldCache, uniqueCache, outerCache,\\n\\t\\t\\t\\tnewCache = [ dirruns, doneName ];\\n\\n\\t\\t\\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\\n\\t\\t\\tif ( xml ) {\\n\\t\\t\\t\\twhile ( (elem = elem[ dir ]) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\t\\tif ( matcher( elem, context, xml ) ) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twhile ( (elem = elem[ dir ]) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\t\\touterCache = elem[ expando ] || (elem[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\\n\\t\\t\\t\\t\\t\\t\\telem = elem[ dir ] || elem;\\n\\t\\t\\t\\t\\t\\t} else if ( (oldCache = uniqueCache[ key ]) &&\\n\\t\\t\\t\\t\\t\\t\\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Assign to newCache so results back-propagate to previous elements\\n\\t\\t\\t\\t\\t\\t\\treturn (newCache[ 2 ] = oldCache[ 2 ]);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t// Reuse newcache so results back-propagate to previous elements\\n\\t\\t\\t\\t\\t\\t\\tuniqueCache[ key ] = newCache;\\n\\n\\t\\t\\t\\t\\t\\t\\t// A match means we're done; a fail means we have to keep checking\\n\\t\\t\\t\\t\\t\\t\\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t};\\n}\\n\\nfunction elementMatcher( matchers ) {\\n\\treturn matchers.length > 1 ?\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\tvar i = matchers.length;\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( !matchers[i]( elem, context, xml ) ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t} :\\n\\t\\tmatchers[0];\\n}\\n\\nfunction multipleContexts( selector, contexts, results ) {\\n\\tvar i = 0,\\n\\t\\tlen = contexts.length;\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tSizzle( selector, contexts[i], results );\\n\\t}\\n\\treturn results;\\n}\\n\\nfunction condense( unmatched, map, filter, context, xml ) {\\n\\tvar elem,\\n\\t\\tnewUnmatched = [],\\n\\t\\ti = 0,\\n\\t\\tlen = unmatched.length,\\n\\t\\tmapped = map != null;\\n\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tif ( (elem = unmatched[i]) ) {\\n\\t\\t\\tif ( !filter || filter( elem, context, xml ) ) {\\n\\t\\t\\t\\tnewUnmatched.push( elem );\\n\\t\\t\\t\\tif ( mapped ) {\\n\\t\\t\\t\\t\\tmap.push( i );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn newUnmatched;\\n}\\n\\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\\n\\tif ( postFilter && !postFilter[ expando ] ) {\\n\\t\\tpostFilter = setMatcher( postFilter );\\n\\t}\\n\\tif ( postFinder && !postFinder[ expando ] ) {\\n\\t\\tpostFinder = setMatcher( postFinder, postSelector );\\n\\t}\\n\\treturn markFunction(function( seed, results, context, xml ) {\\n\\t\\tvar temp, i, elem,\\n\\t\\t\\tpreMap = [],\\n\\t\\t\\tpostMap = [],\\n\\t\\t\\tpreexisting = results.length,\\n\\n\\t\\t\\t// Get initial elements from seed or context\\n\\t\\t\\telems = seed || multipleContexts( selector || \\\"*\\\", context.nodeType ? [ context ] : context, [] ),\\n\\n\\t\\t\\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\\n\\t\\t\\tmatcherIn = preFilter && ( seed || !selector ) ?\\n\\t\\t\\t\\tcondense( elems, preMap, preFilter, context, xml ) :\\n\\t\\t\\t\\telems,\\n\\n\\t\\t\\tmatcherOut = matcher ?\\n\\t\\t\\t\\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\\n\\t\\t\\t\\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\\n\\n\\t\\t\\t\\t\\t// ...intermediate processing is necessary\\n\\t\\t\\t\\t\\t[] :\\n\\n\\t\\t\\t\\t\\t// ...otherwise use results directly\\n\\t\\t\\t\\t\\tresults :\\n\\t\\t\\t\\tmatcherIn;\\n\\n\\t\\t// Find primary matches\\n\\t\\tif ( matcher ) {\\n\\t\\t\\tmatcher( matcherIn, matcherOut, context, xml );\\n\\t\\t}\\n\\n\\t\\t// Apply postFilter\\n\\t\\tif ( postFilter ) {\\n\\t\\t\\ttemp = condense( matcherOut, postMap );\\n\\t\\t\\tpostFilter( temp, [], context, xml );\\n\\n\\t\\t\\t// Un-match failing elements by moving them back to matcherIn\\n\\t\\t\\ti = temp.length;\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( (elem = temp[i]) ) {\\n\\t\\t\\t\\t\\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( seed ) {\\n\\t\\t\\tif ( postFinder || preFilter ) {\\n\\t\\t\\t\\tif ( postFinder ) {\\n\\t\\t\\t\\t\\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\\n\\t\\t\\t\\t\\ttemp = [];\\n\\t\\t\\t\\t\\ti = matcherOut.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tif ( (elem = matcherOut[i]) ) {\\n\\t\\t\\t\\t\\t\\t\\t// Restore matcherIn since elem is not yet a final match\\n\\t\\t\\t\\t\\t\\t\\ttemp.push( (matcherIn[i] = elem) );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tpostFinder( null, (matcherOut = []), temp, xml );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Move matched elements from seed to results to keep them synchronized\\n\\t\\t\\t\\ti = matcherOut.length;\\n\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\tif ( (elem = matcherOut[i]) &&\\n\\t\\t\\t\\t\\t\\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\\n\\n\\t\\t\\t\\t\\t\\tseed[temp] = !(results[temp] = elem);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Add elements to results, through postFinder if defined\\n\\t\\t} else {\\n\\t\\t\\tmatcherOut = condense(\\n\\t\\t\\t\\tmatcherOut === results ?\\n\\t\\t\\t\\t\\tmatcherOut.splice( preexisting, matcherOut.length ) :\\n\\t\\t\\t\\t\\tmatcherOut\\n\\t\\t\\t);\\n\\t\\t\\tif ( postFinder ) {\\n\\t\\t\\t\\tpostFinder( null, results, matcherOut, xml );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpush.apply( results, matcherOut );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n}\\n\\nfunction matcherFromTokens( tokens ) {\\n\\tvar checkContext, matcher, j,\\n\\t\\tlen = tokens.length,\\n\\t\\tleadingRelative = Expr.relative[ tokens[0].type ],\\n\\t\\timplicitRelative = leadingRelative || Expr.relative[\\\" \\\"],\\n\\t\\ti = leadingRelative ? 1 : 0,\\n\\n\\t\\t// The foundational matcher ensures that elements are reachable from top-level context(s)\\n\\t\\tmatchContext = addCombinator( function( elem ) {\\n\\t\\t\\treturn elem === checkContext;\\n\\t\\t}, implicitRelative, true ),\\n\\t\\tmatchAnyContext = addCombinator( function( elem ) {\\n\\t\\t\\treturn indexOf( checkContext, elem ) > -1;\\n\\t\\t}, implicitRelative, true ),\\n\\t\\tmatchers = [ function( elem, context, xml ) {\\n\\t\\t\\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\\n\\t\\t\\t\\t(checkContext = context).nodeType ?\\n\\t\\t\\t\\t\\tmatchContext( elem, context, xml ) :\\n\\t\\t\\t\\t\\tmatchAnyContext( elem, context, xml ) );\\n\\t\\t\\t// Avoid hanging onto element (issue #299)\\n\\t\\t\\tcheckContext = null;\\n\\t\\t\\treturn ret;\\n\\t\\t} ];\\n\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\\n\\t\\t\\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\\n\\t\\t} else {\\n\\t\\t\\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\\n\\n\\t\\t\\t// Return special upon seeing a positional matcher\\n\\t\\t\\tif ( matcher[ expando ] ) {\\n\\t\\t\\t\\t// Find the next relative operator (if any) for proper handling\\n\\t\\t\\t\\tj = ++i;\\n\\t\\t\\t\\tfor ( ; j < len; j++ ) {\\n\\t\\t\\t\\t\\tif ( Expr.relative[ tokens[j].type ] ) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn setMatcher(\\n\\t\\t\\t\\t\\ti > 1 && elementMatcher( matchers ),\\n\\t\\t\\t\\t\\ti > 1 && toSelector(\\n\\t\\t\\t\\t\\t\\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\\n\\t\\t\\t\\t\\t\\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \\\" \\\" ? \\\"*\\\" : \\\"\\\" })\\n\\t\\t\\t\\t\\t).replace( rtrim, \\\"$1\\\" ),\\n\\t\\t\\t\\t\\tmatcher,\\n\\t\\t\\t\\t\\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\\n\\t\\t\\t\\t\\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\\n\\t\\t\\t\\t\\tj < len && toSelector( tokens )\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t\\tmatchers.push( matcher );\\n\\t\\t}\\n\\t}\\n\\n\\treturn elementMatcher( matchers );\\n}\\n\\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\\n\\tvar bySet = setMatchers.length > 0,\\n\\t\\tbyElement = elementMatchers.length > 0,\\n\\t\\tsuperMatcher = function( seed, context, xml, results, outermost ) {\\n\\t\\t\\tvar elem, j, matcher,\\n\\t\\t\\t\\tmatchedCount = 0,\\n\\t\\t\\t\\ti = \\\"0\\\",\\n\\t\\t\\t\\tunmatched = seed && [],\\n\\t\\t\\t\\tsetMatched = [],\\n\\t\\t\\t\\tcontextBackup = outermostContext,\\n\\t\\t\\t\\t// We must always have either seed elements or outermost context\\n\\t\\t\\t\\telems = seed || byElement && Expr.find[\\\"TAG\\\"]( \\\"*\\\", outermost ),\\n\\t\\t\\t\\t// Use integer dirruns iff this is the outermost matcher\\n\\t\\t\\t\\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\\n\\t\\t\\t\\tlen = elems.length;\\n\\n\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\toutermostContext = context === document || context || outermost;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add elements passing elementMatchers directly to results\\n\\t\\t\\t// Support: IE<9, Safari\\n\\t\\t\\t// Tolerate NodeList properties (IE: \\\"length\\\"; Safari: <number>) matching elements by id\\n\\t\\t\\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\\n\\t\\t\\t\\tif ( byElement && elem ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\tif ( !context && elem.ownerDocument !== document ) {\\n\\t\\t\\t\\t\\t\\tsetDocument( elem );\\n\\t\\t\\t\\t\\t\\txml = !documentIsHTML;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\twhile ( (matcher = elementMatchers[j++]) ) {\\n\\t\\t\\t\\t\\t\\tif ( matcher( elem, context || document, xml) ) {\\n\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\t\\t\\tdirruns = dirrunsUnique;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Track unmatched elements for set filters\\n\\t\\t\\t\\tif ( bySet ) {\\n\\t\\t\\t\\t\\t// They will have gone through all possible matchers\\n\\t\\t\\t\\t\\tif ( (elem = !matcher && elem) ) {\\n\\t\\t\\t\\t\\t\\tmatchedCount--;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Lengthen the array for every element, matched or not\\n\\t\\t\\t\\t\\tif ( seed ) {\\n\\t\\t\\t\\t\\t\\tunmatched.push( elem );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\\n\\t\\t\\t// makes the latter nonnegative.\\n\\t\\t\\tmatchedCount += i;\\n\\n\\t\\t\\t// Apply set filters to unmatched elements\\n\\t\\t\\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\\n\\t\\t\\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\\n\\t\\t\\t// no element matchers and no seed.\\n\\t\\t\\t// Incrementing an initially-string \\\"0\\\" `i` allows `i` to remain a string only in that\\n\\t\\t\\t// case, which will result in a \\\"00\\\" `matchedCount` that differs from `i` but is also\\n\\t\\t\\t// numerically zero.\\n\\t\\t\\tif ( bySet && i !== matchedCount ) {\\n\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\twhile ( (matcher = setMatchers[j++]) ) {\\n\\t\\t\\t\\t\\tmatcher( unmatched, setMatched, context, xml );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( seed ) {\\n\\t\\t\\t\\t\\t// Reintegrate element matches to eliminate the need for sorting\\n\\t\\t\\t\\t\\tif ( matchedCount > 0 ) {\\n\\t\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( !(unmatched[i] || setMatched[i]) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tsetMatched[i] = pop.call( results );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Discard index placeholder values to get only actual matches\\n\\t\\t\\t\\t\\tsetMatched = condense( setMatched );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Add matches to results\\n\\t\\t\\t\\tpush.apply( results, setMatched );\\n\\n\\t\\t\\t\\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\\n\\t\\t\\t\\tif ( outermost && !seed && setMatched.length > 0 &&\\n\\t\\t\\t\\t\\t( matchedCount + setMatchers.length ) > 1 ) {\\n\\n\\t\\t\\t\\t\\tSizzle.uniqueSort( results );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Override manipulation of globals by nested matchers\\n\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\tdirruns = dirrunsUnique;\\n\\t\\t\\t\\toutermostContext = contextBackup;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn unmatched;\\n\\t\\t};\\n\\n\\treturn bySet ?\\n\\t\\tmarkFunction( superMatcher ) :\\n\\t\\tsuperMatcher;\\n}\\n\\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\\n\\tvar i,\\n\\t\\tsetMatchers = [],\\n\\t\\telementMatchers = [],\\n\\t\\tcached = compilerCache[ selector + \\\" \\\" ];\\n\\n\\tif ( !cached ) {\\n\\t\\t// Generate a function of recursive functions that can be used to check each element\\n\\t\\tif ( !match ) {\\n\\t\\t\\tmatch = tokenize( selector );\\n\\t\\t}\\n\\t\\ti = match.length;\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\tcached = matcherFromTokens( match[i] );\\n\\t\\t\\tif ( cached[ expando ] ) {\\n\\t\\t\\t\\tsetMatchers.push( cached );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\telementMatchers.push( cached );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Cache the compiled function\\n\\t\\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\\n\\n\\t\\t// Save selector and tokenization\\n\\t\\tcached.selector = selector;\\n\\t}\\n\\treturn cached;\\n};\\n\\n/**\\n * A low-level selection function that works with Sizzle's compiled\\n *  selector functions\\n * @param {String|Function} selector A selector or a pre-compiled\\n *  selector function built with Sizzle.compile\\n * @param {Element} context\\n * @param {Array} [results]\\n * @param {Array} [seed] A set of elements to match against\\n */\\nselect = Sizzle.select = function( selector, context, results, seed ) {\\n\\tvar i, tokens, token, type, find,\\n\\t\\tcompiled = typeof selector === \\\"function\\\" && selector,\\n\\t\\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\\n\\n\\tresults = results || [];\\n\\n\\t// Try to minimize operations if there is only one selector in the list and no seed\\n\\t// (the latter of which guarantees us context)\\n\\tif ( match.length === 1 ) {\\n\\n\\t\\t// Reduce context if the leading compound selector is an ID\\n\\t\\ttokens = match[0] = match[0].slice( 0 );\\n\\t\\tif ( tokens.length > 2 && (token = tokens[0]).type === \\\"ID\\\" &&\\n\\t\\t\\t\\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\\n\\n\\t\\t\\tcontext = ( Expr.find[\\\"ID\\\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\\n\\t\\t\\tif ( !context ) {\\n\\t\\t\\t\\treturn results;\\n\\n\\t\\t\\t// Precompiled matchers will still verify ancestry, so step up a level\\n\\t\\t\\t} else if ( compiled ) {\\n\\t\\t\\t\\tcontext = context.parentNode;\\n\\t\\t\\t}\\n\\n\\t\\t\\tselector = selector.slice( tokens.shift().value.length );\\n\\t\\t}\\n\\n\\t\\t// Fetch a seed set for right-to-left matching\\n\\t\\ti = matchExpr[\\\"needsContext\\\"].test( selector ) ? 0 : tokens.length;\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\ttoken = tokens[i];\\n\\n\\t\\t\\t// Abort if we hit a combinator\\n\\t\\t\\tif ( Expr.relative[ (type = token.type) ] ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif ( (find = Expr.find[ type ]) ) {\\n\\t\\t\\t\\t// Search, expanding context for leading sibling combinators\\n\\t\\t\\t\\tif ( (seed = find(\\n\\t\\t\\t\\t\\ttoken.matches[0].replace( runescape, funescape ),\\n\\t\\t\\t\\t\\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\\n\\t\\t\\t\\t)) ) {\\n\\n\\t\\t\\t\\t\\t// If seed is empty or no tokens remain, we can return early\\n\\t\\t\\t\\t\\ttokens.splice( i, 1 );\\n\\t\\t\\t\\t\\tselector = seed.length && toSelector( tokens );\\n\\t\\t\\t\\t\\tif ( !selector ) {\\n\\t\\t\\t\\t\\t\\tpush.apply( results, seed );\\n\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Compile and execute a filtering function if one is not provided\\n\\t// Provide `match` to avoid retokenization if we modified the selector above\\n\\t( compiled || compile( selector, match ) )(\\n\\t\\tseed,\\n\\t\\tcontext,\\n\\t\\t!documentIsHTML,\\n\\t\\tresults,\\n\\t\\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\\n\\t);\\n\\treturn results;\\n};\\n\\n// One-time assignments\\n\\n// Sort stability\\nsupport.sortStable = expando.split(\\\"\\\").sort( sortOrder ).join(\\\"\\\") === expando;\\n\\n// Support: Chrome 14-35+\\n// Always assume duplicates if they aren't passed to the comparison function\\nsupport.detectDuplicates = !!hasDuplicate;\\n\\n// Initialize against the default document\\nsetDocument();\\n\\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\\n// Detached nodes confoundingly follow *each other*\\nsupport.sortDetached = assert(function( el ) {\\n\\t// Should return 1, but returns 4 (following)\\n\\treturn el.compareDocumentPosition( document.createElement(\\\"fieldset\\\") ) & 1;\\n});\\n\\n// Support: IE<8\\n// Prevent attribute/property \\\"interpolation\\\"\\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\\nif ( !assert(function( el ) {\\n\\tel.innerHTML = \\\"<a href='#'></a>\\\";\\n\\treturn el.firstChild.getAttribute(\\\"href\\\") === \\\"#\\\" ;\\n}) ) {\\n\\taddHandle( \\\"type|href|height|width\\\", function( elem, name, isXML ) {\\n\\t\\tif ( !isXML ) {\\n\\t\\t\\treturn elem.getAttribute( name, name.toLowerCase() === \\\"type\\\" ? 1 : 2 );\\n\\t\\t}\\n\\t});\\n}\\n\\n// Support: IE<9\\n// Use defaultValue in place of getAttribute(\\\"value\\\")\\nif ( !support.attributes || !assert(function( el ) {\\n\\tel.innerHTML = \\\"<input/>\\\";\\n\\tel.firstChild.setAttribute( \\\"value\\\", \\\"\\\" );\\n\\treturn el.firstChild.getAttribute( \\\"value\\\" ) === \\\"\\\";\\n}) ) {\\n\\taddHandle( \\\"value\\\", function( elem, name, isXML ) {\\n\\t\\tif ( !isXML && elem.nodeName.toLowerCase() === \\\"input\\\" ) {\\n\\t\\t\\treturn elem.defaultValue;\\n\\t\\t}\\n\\t});\\n}\\n\\n// Support: IE<9\\n// Use getAttributeNode to fetch booleans when getAttribute lies\\nif ( !assert(function( el ) {\\n\\treturn el.getAttribute(\\\"disabled\\\") == null;\\n}) ) {\\n\\taddHandle( booleans, function( elem, name, isXML ) {\\n\\t\\tvar val;\\n\\t\\tif ( !isXML ) {\\n\\t\\t\\treturn elem[ name ] === true ? name.toLowerCase() :\\n\\t\\t\\t\\t\\t(val = elem.getAttributeNode( name )) && val.specified ?\\n\\t\\t\\t\\t\\tval.value :\\n\\t\\t\\t\\tnull;\\n\\t\\t}\\n\\t});\\n}\\n\\nreturn Sizzle;\\n\\n})( window );\\n\\n\\n\\njQuery.find = Sizzle;\\njQuery.expr = Sizzle.selectors;\\n\\n// Deprecated\\njQuery.expr[ \\\":\\\" ] = jQuery.expr.pseudos;\\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\\njQuery.text = Sizzle.getText;\\njQuery.isXMLDoc = Sizzle.isXML;\\njQuery.contains = Sizzle.contains;\\njQuery.escapeSelector = Sizzle.escape;\\n\\n\\n\\n\\nvar dir = function( elem, dir, until ) {\\n\\tvar matched = [],\\n\\t\\ttruncate = until !== undefined;\\n\\n\\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\\n\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\tif ( truncate && jQuery( elem ).is( until ) ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tmatched.push( elem );\\n\\t\\t}\\n\\t}\\n\\treturn matched;\\n};\\n\\n\\nvar siblings = function( n, elem ) {\\n\\tvar matched = [];\\n\\n\\tfor ( ; n; n = n.nextSibling ) {\\n\\t\\tif ( n.nodeType === 1 && n !== elem ) {\\n\\t\\t\\tmatched.push( n );\\n\\t\\t}\\n\\t}\\n\\n\\treturn matched;\\n};\\n\\n\\nvar rneedsContext = jQuery.expr.match.needsContext;\\n\\nvar rsingleTag = ( /^<([a-z][^\\\\/\\\\0>:\\\\x20\\\\t\\\\r\\\\n\\\\f]*)[\\\\x20\\\\t\\\\r\\\\n\\\\f]*\\\\/?>(?:<\\\\/\\\\1>|)$/i );\\n\\n\\n\\nvar risSimple = /^.[^:#\\\\[\\\\.,]*$/;\\n\\n// Implement the identical functionality for filter and not\\nfunction winnow( elements, qualifier, not ) {\\n\\tif ( jQuery.isFunction( qualifier ) ) {\\n\\t\\treturn jQuery.grep( elements, function( elem, i ) {\\n\\t\\t\\treturn !!qualifier.call( elem, i, elem ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Single element\\n\\tif ( qualifier.nodeType ) {\\n\\t\\treturn jQuery.grep( elements, function( elem ) {\\n\\t\\t\\treturn ( elem === qualifier ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Arraylike of elements (jQuery, arguments, Array)\\n\\tif ( typeof qualifier !== \\\"string\\\" ) {\\n\\t\\treturn jQuery.grep( elements, function( elem ) {\\n\\t\\t\\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Simple selector that can be filtered directly, removing non-Elements\\n\\tif ( risSimple.test( qualifier ) ) {\\n\\t\\treturn jQuery.filter( qualifier, elements, not );\\n\\t}\\n\\n\\t// Complex selector, compare the two sets, removing non-Elements\\n\\tqualifier = jQuery.filter( qualifier, elements );\\n\\treturn jQuery.grep( elements, function( elem ) {\\n\\t\\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;\\n\\t} );\\n}\\n\\njQuery.filter = function( expr, elems, not ) {\\n\\tvar elem = elems[ 0 ];\\n\\n\\tif ( not ) {\\n\\t\\texpr = \\\":not(\\\" + expr + \\\")\\\";\\n\\t}\\n\\n\\tif ( elems.length === 1 && elem.nodeType === 1 ) {\\n\\t\\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\\n\\t}\\n\\n\\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\\n\\t\\treturn elem.nodeType === 1;\\n\\t} ) );\\n};\\n\\njQuery.fn.extend( {\\n\\tfind: function( selector ) {\\n\\t\\tvar i, ret,\\n\\t\\t\\tlen = this.length,\\n\\t\\t\\tself = this;\\n\\n\\t\\tif ( typeof selector !== \\\"string\\\" ) {\\n\\t\\t\\treturn this.pushStack( jQuery( selector ).filter( function() {\\n\\t\\t\\t\\tfor ( i = 0; i < len; i++ ) {\\n\\t\\t\\t\\t\\tif ( jQuery.contains( self[ i ], this ) ) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} ) );\\n\\t\\t}\\n\\n\\t\\tret = this.pushStack( [] );\\n\\n\\t\\tfor ( i = 0; i < len; i++ ) {\\n\\t\\t\\tjQuery.find( selector, self[ i ], ret );\\n\\t\\t}\\n\\n\\t\\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\\n\\t},\\n\\tfilter: function( selector ) {\\n\\t\\treturn this.pushStack( winnow( this, selector || [], false ) );\\n\\t},\\n\\tnot: function( selector ) {\\n\\t\\treturn this.pushStack( winnow( this, selector || [], true ) );\\n\\t},\\n\\tis: function( selector ) {\\n\\t\\treturn !!winnow(\\n\\t\\t\\tthis,\\n\\n\\t\\t\\t// If this is a positional/relative selector, check membership in the returned set\\n\\t\\t\\t// so $(\\\"p:first\\\").is(\\\"p:last\\\") won't return true for a doc with two \\\"p\\\".\\n\\t\\t\\ttypeof selector === \\\"string\\\" && rneedsContext.test( selector ) ?\\n\\t\\t\\t\\tjQuery( selector ) :\\n\\t\\t\\t\\tselector || [],\\n\\t\\t\\tfalse\\n\\t\\t).length;\\n\\t}\\n} );\\n\\n\\n// Initialize a jQuery object\\n\\n\\n// A central reference to the root jQuery(document)\\nvar rootjQuery,\\n\\n\\t// A simple way to check for HTML strings\\n\\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\\n\\t// Strict HTML recognition (#11290: must start with <)\\n\\t// Shortcut simple #id case for speed\\n\\trquickExpr = /^(?:\\\\s*(<[\\\\w\\\\W]+>)[^>]*|#([\\\\w-]+))$/,\\n\\n\\tinit = jQuery.fn.init = function( selector, context, root ) {\\n\\t\\tvar match, elem;\\n\\n\\t\\t// HANDLE: $(\\\"\\\"), $(null), $(undefined), $(false)\\n\\t\\tif ( !selector ) {\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\n\\t\\t// Method init() accepts an alternate rootjQuery\\n\\t\\t// so migrate can support jQuery.sub (gh-2101)\\n\\t\\troot = root || rootjQuery;\\n\\n\\t\\t// Handle HTML strings\\n\\t\\tif ( typeof selector === \\\"string\\\" ) {\\n\\t\\t\\tif ( selector[ 0 ] === \\\"<\\\" &&\\n\\t\\t\\t\\tselector[ selector.length - 1 ] === \\\">\\\" &&\\n\\t\\t\\t\\tselector.length >= 3 ) {\\n\\n\\t\\t\\t\\t// Assume that strings that start and end with <> are HTML and skip the regex check\\n\\t\\t\\t\\tmatch = [ null, selector, null ];\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmatch = rquickExpr.exec( selector );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Match html or make sure no context is specified for #id\\n\\t\\t\\tif ( match && ( match[ 1 ] || !context ) ) {\\n\\n\\t\\t\\t\\t// HANDLE: $(html) -> $(array)\\n\\t\\t\\t\\tif ( match[ 1 ] ) {\\n\\t\\t\\t\\t\\tcontext = context instanceof jQuery ? context[ 0 ] : context;\\n\\n\\t\\t\\t\\t\\t// Option to run scripts is true for back-compat\\n\\t\\t\\t\\t\\t// Intentionally let the error be thrown if parseHTML is not present\\n\\t\\t\\t\\t\\tjQuery.merge( this, jQuery.parseHTML(\\n\\t\\t\\t\\t\\t\\tmatch[ 1 ],\\n\\t\\t\\t\\t\\t\\tcontext && context.nodeType ? context.ownerDocument || context : document,\\n\\t\\t\\t\\t\\t\\ttrue\\n\\t\\t\\t\\t\\t) );\\n\\n\\t\\t\\t\\t\\t// HANDLE: $(html, props)\\n\\t\\t\\t\\t\\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\\n\\t\\t\\t\\t\\t\\tfor ( match in context ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Properties of context are called as methods if possible\\n\\t\\t\\t\\t\\t\\t\\tif ( jQuery.isFunction( this[ match ] ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tthis[ match ]( context[ match ] );\\n\\n\\t\\t\\t\\t\\t\\t\\t// ...and otherwise set as attributes\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tthis.attr( match, context[ match ] );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t\\t// HANDLE: $(#id)\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\telem = document.getElementById( match[ 2 ] );\\n\\n\\t\\t\\t\\t\\tif ( elem ) {\\n\\n\\t\\t\\t\\t\\t\\t// Inject the element directly into the jQuery object\\n\\t\\t\\t\\t\\t\\tthis[ 0 ] = elem;\\n\\t\\t\\t\\t\\t\\tthis.length = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t// HANDLE: $(expr, $(...))\\n\\t\\t\\t} else if ( !context || context.jquery ) {\\n\\t\\t\\t\\treturn ( context || root ).find( selector );\\n\\n\\t\\t\\t// HANDLE: $(expr, context)\\n\\t\\t\\t// (which is just equivalent to: $(context).find(expr)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this.constructor( context ).find( selector );\\n\\t\\t\\t}\\n\\n\\t\\t// HANDLE: $(DOMElement)\\n\\t\\t} else if ( selector.nodeType ) {\\n\\t\\t\\tthis[ 0 ] = selector;\\n\\t\\t\\tthis.length = 1;\\n\\t\\t\\treturn this;\\n\\n\\t\\t// HANDLE: $(function)\\n\\t\\t// Shortcut for document ready\\n\\t\\t} else if ( jQuery.isFunction( selector ) ) {\\n\\t\\t\\treturn root.ready !== undefined ?\\n\\t\\t\\t\\troot.ready( selector ) :\\n\\n\\t\\t\\t\\t// Execute immediately if ready is not present\\n\\t\\t\\t\\tselector( jQuery );\\n\\t\\t}\\n\\n\\t\\treturn jQuery.makeArray( selector, this );\\n\\t};\\n\\n// Give the init function the jQuery prototype for later instantiation\\ninit.prototype = jQuery.fn;\\n\\n// Initialize central reference\\nrootjQuery = jQuery( document );\\n\\n\\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\\n\\n\\t// Methods guaranteed to produce a unique set when starting from a unique set\\n\\tguaranteedUnique = {\\n\\t\\tchildren: true,\\n\\t\\tcontents: true,\\n\\t\\tnext: true,\\n\\t\\tprev: true\\n\\t};\\n\\njQuery.fn.extend( {\\n\\thas: function( target ) {\\n\\t\\tvar targets = jQuery( target, this ),\\n\\t\\t\\tl = targets.length;\\n\\n\\t\\treturn this.filter( function() {\\n\\t\\t\\tvar i = 0;\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tif ( jQuery.contains( this, targets[ i ] ) ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tclosest: function( selectors, context ) {\\n\\t\\tvar cur,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tl = this.length,\\n\\t\\t\\tmatched = [],\\n\\t\\t\\ttargets = typeof selectors !== \\\"string\\\" && jQuery( selectors );\\n\\n\\t\\t// Positional selectors never match, since there's no _selection_ context\\n\\t\\tif ( !rneedsContext.test( selectors ) ) {\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\\n\\n\\t\\t\\t\\t\\t// Always skip document fragments\\n\\t\\t\\t\\t\\tif ( cur.nodeType < 11 && ( targets ?\\n\\t\\t\\t\\t\\t\\ttargets.index( cur ) > -1 :\\n\\n\\t\\t\\t\\t\\t\\t// Don't pass non-elements to Sizzle\\n\\t\\t\\t\\t\\t\\tcur.nodeType === 1 &&\\n\\t\\t\\t\\t\\t\\t\\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\tmatched.push( cur );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\\n\\t},\\n\\n\\t// Determine the position of an element within the set\\n\\tindex: function( elem ) {\\n\\n\\t\\t// No argument, return index in parent\\n\\t\\tif ( !elem ) {\\n\\t\\t\\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\\n\\t\\t}\\n\\n\\t\\t// Index in selector\\n\\t\\tif ( typeof elem === \\\"string\\\" ) {\\n\\t\\t\\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\\n\\t\\t}\\n\\n\\t\\t// Locate the position of the desired element\\n\\t\\treturn indexOf.call( this,\\n\\n\\t\\t\\t// If it receives a jQuery object, the first element is used\\n\\t\\t\\telem.jquery ? elem[ 0 ] : elem\\n\\t\\t);\\n\\t},\\n\\n\\tadd: function( selector, context ) {\\n\\t\\treturn this.pushStack(\\n\\t\\t\\tjQuery.uniqueSort(\\n\\t\\t\\t\\tjQuery.merge( this.get(), jQuery( selector, context ) )\\n\\t\\t\\t)\\n\\t\\t);\\n\\t},\\n\\n\\taddBack: function( selector ) {\\n\\t\\treturn this.add( selector == null ?\\n\\t\\t\\tthis.prevObject : this.prevObject.filter( selector )\\n\\t\\t);\\n\\t}\\n} );\\n\\nfunction sibling( cur, dir ) {\\n\\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\\n\\treturn cur;\\n}\\n\\njQuery.each( {\\n\\tparent: function( elem ) {\\n\\t\\tvar parent = elem.parentNode;\\n\\t\\treturn parent && parent.nodeType !== 11 ? parent : null;\\n\\t},\\n\\tparents: function( elem ) {\\n\\t\\treturn dir( elem, \\\"parentNode\\\" );\\n\\t},\\n\\tparentsUntil: function( elem, i, until ) {\\n\\t\\treturn dir( elem, \\\"parentNode\\\", until );\\n\\t},\\n\\tnext: function( elem ) {\\n\\t\\treturn sibling( elem, \\\"nextSibling\\\" );\\n\\t},\\n\\tprev: function( elem ) {\\n\\t\\treturn sibling( elem, \\\"previousSibling\\\" );\\n\\t},\\n\\tnextAll: function( elem ) {\\n\\t\\treturn dir( elem, \\\"nextSibling\\\" );\\n\\t},\\n\\tprevAll: function( elem ) {\\n\\t\\treturn dir( elem, \\\"previousSibling\\\" );\\n\\t},\\n\\tnextUntil: function( elem, i, until ) {\\n\\t\\treturn dir( elem, \\\"nextSibling\\\", until );\\n\\t},\\n\\tprevUntil: function( elem, i, until ) {\\n\\t\\treturn dir( elem, \\\"previousSibling\\\", until );\\n\\t},\\n\\tsiblings: function( elem ) {\\n\\t\\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\\n\\t},\\n\\tchildren: function( elem ) {\\n\\t\\treturn siblings( elem.firstChild );\\n\\t},\\n\\tcontents: function( elem ) {\\n\\t\\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\\n\\t}\\n}, function( name, fn ) {\\n\\tjQuery.fn[ name ] = function( until, selector ) {\\n\\t\\tvar matched = jQuery.map( this, fn, until );\\n\\n\\t\\tif ( name.slice( -5 ) !== \\\"Until\\\" ) {\\n\\t\\t\\tselector = until;\\n\\t\\t}\\n\\n\\t\\tif ( selector && typeof selector === \\\"string\\\" ) {\\n\\t\\t\\tmatched = jQuery.filter( selector, matched );\\n\\t\\t}\\n\\n\\t\\tif ( this.length > 1 ) {\\n\\n\\t\\t\\t// Remove duplicates\\n\\t\\t\\tif ( !guaranteedUnique[ name ] ) {\\n\\t\\t\\t\\tjQuery.uniqueSort( matched );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Reverse order for parents* and prev-derivatives\\n\\t\\t\\tif ( rparentsprev.test( name ) ) {\\n\\t\\t\\t\\tmatched.reverse();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( matched );\\n\\t};\\n} );\\nvar rnothtmlwhite = ( /[^\\\\x20\\\\t\\\\r\\\\n\\\\f]+/g );\\n\\n\\n\\n// Convert String-formatted options into Object-formatted ones\\nfunction createOptions( options ) {\\n\\tvar object = {};\\n\\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\\n\\t\\tobject[ flag ] = true;\\n\\t} );\\n\\treturn object;\\n}\\n\\n/*\\n * Create a callback list using the following parameters:\\n *\\n *\\toptions: an optional list of space-separated options that will change how\\n *\\t\\t\\tthe callback list behaves or a more traditional option object\\n *\\n * By default a callback list will act like an event callback list and can be\\n * \\\"fired\\\" multiple times.\\n *\\n * Possible options:\\n *\\n *\\tonce:\\t\\t\\twill ensure the callback list can only be fired once (like a Deferred)\\n *\\n *\\tmemory:\\t\\t\\twill keep track of previous values and will call any callback added\\n *\\t\\t\\t\\t\\tafter the list has been fired right away with the latest \\\"memorized\\\"\\n *\\t\\t\\t\\t\\tvalues (like a Deferred)\\n *\\n *\\tunique:\\t\\t\\twill ensure a callback can only be added once (no duplicate in the list)\\n *\\n *\\tstopOnFalse:\\tinterrupt callings when a callback returns false\\n *\\n */\\njQuery.Callbacks = function( options ) {\\n\\n\\t// Convert options from String-formatted to Object-formatted if needed\\n\\t// (we check in cache first)\\n\\toptions = typeof options === \\\"string\\\" ?\\n\\t\\tcreateOptions( options ) :\\n\\t\\tjQuery.extend( {}, options );\\n\\n\\tvar // Flag to know if list is currently firing\\n\\t\\tfiring,\\n\\n\\t\\t// Last fire value for non-forgettable lists\\n\\t\\tmemory,\\n\\n\\t\\t// Flag to know if list was already fired\\n\\t\\tfired,\\n\\n\\t\\t// Flag to prevent firing\\n\\t\\tlocked,\\n\\n\\t\\t// Actual callback list\\n\\t\\tlist = [],\\n\\n\\t\\t// Queue of execution data for repeatable lists\\n\\t\\tqueue = [],\\n\\n\\t\\t// Index of currently firing callback (modified by add/remove as needed)\\n\\t\\tfiringIndex = -1,\\n\\n\\t\\t// Fire callbacks\\n\\t\\tfire = function() {\\n\\n\\t\\t\\t// Enforce single-firing\\n\\t\\t\\tlocked = options.once;\\n\\n\\t\\t\\t// Execute callbacks for all pending executions,\\n\\t\\t\\t// respecting firingIndex overrides and runtime changes\\n\\t\\t\\tfired = firing = true;\\n\\t\\t\\tfor ( ; queue.length; firingIndex = -1 ) {\\n\\t\\t\\t\\tmemory = queue.shift();\\n\\t\\t\\t\\twhile ( ++firingIndex < list.length ) {\\n\\n\\t\\t\\t\\t\\t// Run callback and check for early termination\\n\\t\\t\\t\\t\\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\\n\\t\\t\\t\\t\\t\\toptions.stopOnFalse ) {\\n\\n\\t\\t\\t\\t\\t\\t// Jump to end and forget the data so .add doesn't re-fire\\n\\t\\t\\t\\t\\t\\tfiringIndex = list.length;\\n\\t\\t\\t\\t\\t\\tmemory = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Forget the data if we're done with it\\n\\t\\t\\tif ( !options.memory ) {\\n\\t\\t\\t\\tmemory = false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfiring = false;\\n\\n\\t\\t\\t// Clean up if we're done firing for good\\n\\t\\t\\tif ( locked ) {\\n\\n\\t\\t\\t\\t// Keep an empty list if we have data for future add calls\\n\\t\\t\\t\\tif ( memory ) {\\n\\t\\t\\t\\t\\tlist = [];\\n\\n\\t\\t\\t\\t// Otherwise, this object is spent\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tlist = \\\"\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t// Actual Callbacks object\\n\\t\\tself = {\\n\\n\\t\\t\\t// Add a callback or a collection of callbacks to the list\\n\\t\\t\\tadd: function() {\\n\\t\\t\\t\\tif ( list ) {\\n\\n\\t\\t\\t\\t\\t// If we have memory from a past run, we should fire after adding\\n\\t\\t\\t\\t\\tif ( memory && !firing ) {\\n\\t\\t\\t\\t\\t\\tfiringIndex = list.length - 1;\\n\\t\\t\\t\\t\\t\\tqueue.push( memory );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t( function add( args ) {\\n\\t\\t\\t\\t\\t\\tjQuery.each( args, function( _, arg ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( jQuery.isFunction( arg ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( !options.unique || !self.has( arg ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tlist.push( arg );\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} else if ( arg && arg.length && jQuery.type( arg ) !== \\\"string\\\" ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Inspect recursively\\n\\t\\t\\t\\t\\t\\t\\t\\tadd( arg );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t} )( arguments );\\n\\n\\t\\t\\t\\t\\tif ( memory && !firing ) {\\n\\t\\t\\t\\t\\t\\tfire();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Remove a callback from the list\\n\\t\\t\\tremove: function() {\\n\\t\\t\\t\\tjQuery.each( arguments, function( _, arg ) {\\n\\t\\t\\t\\t\\tvar index;\\n\\t\\t\\t\\t\\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\\n\\t\\t\\t\\t\\t\\tlist.splice( index, 1 );\\n\\n\\t\\t\\t\\t\\t\\t// Handle firing indexes\\n\\t\\t\\t\\t\\t\\tif ( index <= firingIndex ) {\\n\\t\\t\\t\\t\\t\\t\\tfiringIndex--;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Check if a given callback is in the list.\\n\\t\\t\\t// If no argument is given, return whether or not list has callbacks attached.\\n\\t\\t\\thas: function( fn ) {\\n\\t\\t\\t\\treturn fn ?\\n\\t\\t\\t\\t\\tjQuery.inArray( fn, list ) > -1 :\\n\\t\\t\\t\\t\\tlist.length > 0;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Remove all callbacks from the list\\n\\t\\t\\tempty: function() {\\n\\t\\t\\t\\tif ( list ) {\\n\\t\\t\\t\\t\\tlist = [];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Disable .fire and .add\\n\\t\\t\\t// Abort any current/pending executions\\n\\t\\t\\t// Clear all callbacks and values\\n\\t\\t\\tdisable: function() {\\n\\t\\t\\t\\tlocked = queue = [];\\n\\t\\t\\t\\tlist = memory = \\\"\\\";\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\t\\t\\tdisabled: function() {\\n\\t\\t\\t\\treturn !list;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Disable .fire\\n\\t\\t\\t// Also disable .add unless we have memory (since it would have no effect)\\n\\t\\t\\t// Abort any pending executions\\n\\t\\t\\tlock: function() {\\n\\t\\t\\t\\tlocked = queue = [];\\n\\t\\t\\t\\tif ( !memory && !firing ) {\\n\\t\\t\\t\\t\\tlist = memory = \\\"\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\t\\t\\tlocked: function() {\\n\\t\\t\\t\\treturn !!locked;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Call all callbacks with the given context and arguments\\n\\t\\t\\tfireWith: function( context, args ) {\\n\\t\\t\\t\\tif ( !locked ) {\\n\\t\\t\\t\\t\\targs = args || [];\\n\\t\\t\\t\\t\\targs = [ context, args.slice ? args.slice() : args ];\\n\\t\\t\\t\\t\\tqueue.push( args );\\n\\t\\t\\t\\t\\tif ( !firing ) {\\n\\t\\t\\t\\t\\t\\tfire();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Call all the callbacks with the given arguments\\n\\t\\t\\tfire: function() {\\n\\t\\t\\t\\tself.fireWith( this, arguments );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// To know if the callbacks have already been called at least once\\n\\t\\t\\tfired: function() {\\n\\t\\t\\t\\treturn !!fired;\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\treturn self;\\n};\\n\\n\\nfunction Identity( v ) {\\n\\treturn v;\\n}\\nfunction Thrower( ex ) {\\n\\tthrow ex;\\n}\\n\\nfunction adoptValue( value, resolve, reject ) {\\n\\tvar method;\\n\\n\\ttry {\\n\\n\\t\\t// Check for promise aspect first to privilege synchronous behavior\\n\\t\\tif ( value && jQuery.isFunction( ( method = value.promise ) ) ) {\\n\\t\\t\\tmethod.call( value ).done( resolve ).fail( reject );\\n\\n\\t\\t// Other thenables\\n\\t\\t} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {\\n\\t\\t\\tmethod.call( value, resolve, reject );\\n\\n\\t\\t// Other non-thenables\\n\\t\\t} else {\\n\\n\\t\\t\\t// Support: Android 4.0 only\\n\\t\\t\\t// Strict mode functions invoked without .call/.apply get global-object context\\n\\t\\t\\tresolve.call( undefined, value );\\n\\t\\t}\\n\\n\\t// For Promises/A+, convert exceptions into rejections\\n\\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\\n\\t// Deferred#then to conditionally suppress rejection.\\n\\t} catch ( value ) {\\n\\n\\t\\t// Support: Android 4.0 only\\n\\t\\t// Strict mode functions invoked without .call/.apply get global-object context\\n\\t\\treject.call( undefined, value );\\n\\t}\\n}\\n\\njQuery.extend( {\\n\\n\\tDeferred: function( func ) {\\n\\t\\tvar tuples = [\\n\\n\\t\\t\\t\\t// action, add listener, callbacks,\\n\\t\\t\\t\\t// ... .then handlers, argument index, [final state]\\n\\t\\t\\t\\t[ \\\"notify\\\", \\\"progress\\\", jQuery.Callbacks( \\\"memory\\\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \\\"memory\\\" ), 2 ],\\n\\t\\t\\t\\t[ \\\"resolve\\\", \\\"done\\\", jQuery.Callbacks( \\\"once memory\\\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \\\"once memory\\\" ), 0, \\\"resolved\\\" ],\\n\\t\\t\\t\\t[ \\\"reject\\\", \\\"fail\\\", jQuery.Callbacks( \\\"once memory\\\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \\\"once memory\\\" ), 1, \\\"rejected\\\" ]\\n\\t\\t\\t],\\n\\t\\t\\tstate = \\\"pending\\\",\\n\\t\\t\\tpromise = {\\n\\t\\t\\t\\tstate: function() {\\n\\t\\t\\t\\t\\treturn state;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\talways: function() {\\n\\t\\t\\t\\t\\tdeferred.done( arguments ).fail( arguments );\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\\"catch\\\": function( fn ) {\\n\\t\\t\\t\\t\\treturn promise.then( null, fn );\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Keep pipe for back-compat\\n\\t\\t\\t\\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\\n\\t\\t\\t\\t\\tvar fns = arguments;\\n\\n\\t\\t\\t\\t\\treturn jQuery.Deferred( function( newDefer ) {\\n\\t\\t\\t\\t\\t\\tjQuery.each( tuples, function( i, tuple ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\\n\\t\\t\\t\\t\\t\\t\\tvar fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\\n\\n\\t\\t\\t\\t\\t\\t\\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\\n\\t\\t\\t\\t\\t\\t\\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\\n\\t\\t\\t\\t\\t\\t\\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\\n\\t\\t\\t\\t\\t\\t\\tdeferred[ tuple[ 1 ] ]( function() {\\n\\t\\t\\t\\t\\t\\t\\t\\tvar returned = fn && fn.apply( this, arguments );\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( returned && jQuery.isFunction( returned.promise ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturned.promise()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.progress( newDefer.notify )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.done( newDefer.resolve )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.fail( newDefer.reject );\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnewDefer[ tuple[ 0 ] + \\\"With\\\" ](\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthis,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfn ? [ returned ] : arguments\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\tfns = null;\\n\\t\\t\\t\\t\\t} ).promise();\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tthen: function( onFulfilled, onRejected, onProgress ) {\\n\\t\\t\\t\\t\\tvar maxDepth = 0;\\n\\t\\t\\t\\t\\tfunction resolve( depth, deferred, handler, special ) {\\n\\t\\t\\t\\t\\t\\treturn function() {\\n\\t\\t\\t\\t\\t\\t\\tvar that = this,\\n\\t\\t\\t\\t\\t\\t\\t\\targs = arguments,\\n\\t\\t\\t\\t\\t\\t\\t\\tmightThrow = function() {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvar returned, then;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.3\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-59\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Ignore double-resolution attempts\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( depth < maxDepth ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturned = handler.apply( that, args );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-48\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( returned === deferred.promise() ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthrow new TypeError( \\\"Thenable self-resolution\\\" );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ sections 2.3.3.1, 3.5\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-54\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-75\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Retrieve `then` only once\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthen = returned &&\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-64\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only check objects and functions for thenability\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t( typeof returned === \\\"object\\\" ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttypeof returned === \\\"function\\\" ) &&\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned.then;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Handle a returned thenable\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( jQuery.isFunction( then ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Special processors (notify) just wait for resolution\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( special ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthen.call(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Thrower, special )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Normal processors (resolve) also hook into progress\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// ...and disregard older resolution values\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmaxDepth++;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthen.call(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Thrower, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tdeferred.notifyWith )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Handle all other returned values\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only substitute handlers pass on context\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// and multiple values (non-spec behavior)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( handler !== Identity ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthat = undefined;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\targs = [ returned ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Process the value(s)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Default process is resolve\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t( special || deferred.resolveWith )( that, args );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Only normal processors (resolve) catch and reject exceptions\\n\\t\\t\\t\\t\\t\\t\\t\\tprocess = special ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tmightThrow :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmightThrow();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( jQuery.Deferred.exceptionHook ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tjQuery.Deferred.exceptionHook( e,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tprocess.stackTrace );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.4.1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-61\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Ignore post-resolution exceptions\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( depth + 1 >= maxDepth ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only substitute handlers pass on context\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// and multiple values (non-spec behavior)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( handler !== Thrower ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthat = undefined;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\targs = [ e ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tdeferred.rejectWith( that, args );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.1\\n\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-57\\n\\t\\t\\t\\t\\t\\t\\t// Re-resolve promises immediately to dodge false rejection from\\n\\t\\t\\t\\t\\t\\t\\t// subsequent errors\\n\\t\\t\\t\\t\\t\\t\\tif ( depth ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tprocess();\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Call an optional hook to record the stack, in case of exception\\n\\t\\t\\t\\t\\t\\t\\t\\t// since it's otherwise lost when execution goes async\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( jQuery.Deferred.getStackHook ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tprocess.stackTrace = jQuery.Deferred.getStackHook();\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\twindow.setTimeout( process );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn jQuery.Deferred( function( newDefer ) {\\n\\n\\t\\t\\t\\t\\t\\t// progress_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 0 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.isFunction( onProgress ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonProgress :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tIdentity,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer.notifyWith\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t// fulfilled_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 1 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.isFunction( onFulfilled ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonFulfilled :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tIdentity\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t// rejected_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 2 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.isFunction( onRejected ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonRejected :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tThrower\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t} ).promise();\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Get a promise for this deferred\\n\\t\\t\\t\\t// If obj is provided, the promise aspect is added to the object\\n\\t\\t\\t\\tpromise: function( obj ) {\\n\\t\\t\\t\\t\\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tdeferred = {};\\n\\n\\t\\t// Add list-specific methods\\n\\t\\tjQuery.each( tuples, function( i, tuple ) {\\n\\t\\t\\tvar list = tuple[ 2 ],\\n\\t\\t\\t\\tstateString = tuple[ 5 ];\\n\\n\\t\\t\\t// promise.progress = list.add\\n\\t\\t\\t// promise.done = list.add\\n\\t\\t\\t// promise.fail = list.add\\n\\t\\t\\tpromise[ tuple[ 1 ] ] = list.add;\\n\\n\\t\\t\\t// Handle state\\n\\t\\t\\tif ( stateString ) {\\n\\t\\t\\t\\tlist.add(\\n\\t\\t\\t\\t\\tfunction() {\\n\\n\\t\\t\\t\\t\\t\\t// state = \\\"resolved\\\" (i.e., fulfilled)\\n\\t\\t\\t\\t\\t\\t// state = \\\"rejected\\\"\\n\\t\\t\\t\\t\\t\\tstate = stateString;\\n\\t\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t\\t// rejected_callbacks.disable\\n\\t\\t\\t\\t\\t// fulfilled_callbacks.disable\\n\\t\\t\\t\\t\\ttuples[ 3 - i ][ 2 ].disable,\\n\\n\\t\\t\\t\\t\\t// progress_callbacks.lock\\n\\t\\t\\t\\t\\ttuples[ 0 ][ 2 ].lock\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// progress_handlers.fire\\n\\t\\t\\t// fulfilled_handlers.fire\\n\\t\\t\\t// rejected_handlers.fire\\n\\t\\t\\tlist.add( tuple[ 3 ].fire );\\n\\n\\t\\t\\t// deferred.notify = function() { deferred.notifyWith(...) }\\n\\t\\t\\t// deferred.resolve = function() { deferred.resolveWith(...) }\\n\\t\\t\\t// deferred.reject = function() { deferred.rejectWith(...) }\\n\\t\\t\\tdeferred[ tuple[ 0 ] ] = function() {\\n\\t\\t\\t\\tdeferred[ tuple[ 0 ] + \\\"With\\\" ]( this === deferred ? undefined : this, arguments );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t};\\n\\n\\t\\t\\t// deferred.notifyWith = list.fireWith\\n\\t\\t\\t// deferred.resolveWith = list.fireWith\\n\\t\\t\\t// deferred.rejectWith = list.fireWith\\n\\t\\t\\tdeferred[ tuple[ 0 ] + \\\"With\\\" ] = list.fireWith;\\n\\t\\t} );\\n\\n\\t\\t// Make the deferred a promise\\n\\t\\tpromise.promise( deferred );\\n\\n\\t\\t// Call given func if any\\n\\t\\tif ( func ) {\\n\\t\\t\\tfunc.call( deferred, deferred );\\n\\t\\t}\\n\\n\\t\\t// All done!\\n\\t\\treturn deferred;\\n\\t},\\n\\n\\t// Deferred helper\\n\\twhen: function( singleValue ) {\\n\\t\\tvar\\n\\n\\t\\t\\t// count of uncompleted subordinates\\n\\t\\t\\tremaining = arguments.length,\\n\\n\\t\\t\\t// count of unprocessed arguments\\n\\t\\t\\ti = remaining,\\n\\n\\t\\t\\t// subordinate fulfillment data\\n\\t\\t\\tresolveContexts = Array( i ),\\n\\t\\t\\tresolveValues = slice.call( arguments ),\\n\\n\\t\\t\\t// the master Deferred\\n\\t\\t\\tmaster = jQuery.Deferred(),\\n\\n\\t\\t\\t// subordinate callback factory\\n\\t\\t\\tupdateFunc = function( i ) {\\n\\t\\t\\t\\treturn function( value ) {\\n\\t\\t\\t\\t\\tresolveContexts[ i ] = this;\\n\\t\\t\\t\\t\\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\\n\\t\\t\\t\\t\\tif ( !( --remaining ) ) {\\n\\t\\t\\t\\t\\t\\tmaster.resolveWith( resolveContexts, resolveValues );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\t\\t\\t};\\n\\n\\t\\t// Single- and empty arguments are adopted like Promise.resolve\\n\\t\\tif ( remaining <= 1 ) {\\n\\t\\t\\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );\\n\\n\\t\\t\\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\\n\\t\\t\\tif ( master.state() === \\\"pending\\\" ||\\n\\t\\t\\t\\tjQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\\n\\n\\t\\t\\t\\treturn master.then();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Multiple arguments are aggregated like Promise.all array elements\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\\n\\t\\t}\\n\\n\\t\\treturn master.promise();\\n\\t}\\n} );\\n\\n\\n// These usually indicate a programmer mistake during development,\\n// warn about them ASAP rather than swallowing them by default.\\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\\n\\njQuery.Deferred.exceptionHook = function( error, stack ) {\\n\\n\\t// Support: IE 8 - 9 only\\n\\t// Console exists when dev tools are open, which can happen at any time\\n\\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\\n\\t\\twindow.console.warn( \\\"jQuery.Deferred exception: \\\" + error.message, error.stack, stack );\\n\\t}\\n};\\n\\n\\n\\n\\njQuery.readyException = function( error ) {\\n\\twindow.setTimeout( function() {\\n\\t\\tthrow error;\\n\\t} );\\n};\\n\\n\\n\\n\\n// The deferred used on DOM ready\\nvar readyList = jQuery.Deferred();\\n\\njQuery.fn.ready = function( fn ) {\\n\\n\\treadyList\\n\\t\\t.then( fn )\\n\\n\\t\\t// Wrap jQuery.readyException in a function so that the lookup\\n\\t\\t// happens at the time of error handling instead of callback\\n\\t\\t// registration.\\n\\t\\t.catch( function( error ) {\\n\\t\\t\\tjQuery.readyException( error );\\n\\t\\t} );\\n\\n\\treturn this;\\n};\\n\\njQuery.extend( {\\n\\n\\t// Is the DOM ready to be used? Set to true once it occurs.\\n\\tisReady: false,\\n\\n\\t// A counter to track how many items to wait for before\\n\\t// the ready event fires. See #6781\\n\\treadyWait: 1,\\n\\n\\t// Hold (or release) the ready event\\n\\tholdReady: function( hold ) {\\n\\t\\tif ( hold ) {\\n\\t\\t\\tjQuery.readyWait++;\\n\\t\\t} else {\\n\\t\\t\\tjQuery.ready( true );\\n\\t\\t}\\n\\t},\\n\\n\\t// Handle when the DOM is ready\\n\\tready: function( wait ) {\\n\\n\\t\\t// Abort if there are pending holds or we're already ready\\n\\t\\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Remember that the DOM is ready\\n\\t\\tjQuery.isReady = true;\\n\\n\\t\\t// If a normal DOM Ready event fired, decrement, and wait if need be\\n\\t\\tif ( wait !== true && --jQuery.readyWait > 0 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// If there are functions bound, to execute\\n\\t\\treadyList.resolveWith( document, [ jQuery ] );\\n\\t}\\n} );\\n\\njQuery.ready.then = readyList.then;\\n\\n// The ready event handler and self cleanup method\\nfunction completed() {\\n\\tdocument.removeEventListener( \\\"DOMContentLoaded\\\", completed );\\n\\twindow.removeEventListener( \\\"load\\\", completed );\\n\\tjQuery.ready();\\n}\\n\\n// Catch cases where $(document).ready() is called\\n// after the browser event has already occurred.\\n// Support: IE <=9 - 10 only\\n// Older IE sometimes signals \\\"interactive\\\" too soon\\nif ( document.readyState === \\\"complete\\\" ||\\n\\t( document.readyState !== \\\"loading\\\" && !document.documentElement.doScroll ) ) {\\n\\n\\t// Handle it asynchronously to allow scripts the opportunity to delay ready\\n\\twindow.setTimeout( jQuery.ready );\\n\\n} else {\\n\\n\\t// Use the handy event callback\\n\\tdocument.addEventListener( \\\"DOMContentLoaded\\\", completed );\\n\\n\\t// A fallback to window.onload, that will always work\\n\\twindow.addEventListener( \\\"load\\\", completed );\\n}\\n\\n\\n\\n\\n// Multifunctional method to get and set values of a collection\\n// The value/s can optionally be executed if it's a function\\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\\n\\tvar i = 0,\\n\\t\\tlen = elems.length,\\n\\t\\tbulk = key == null;\\n\\n\\t// Sets many values\\n\\tif ( jQuery.type( key ) === \\\"object\\\" ) {\\n\\t\\tchainable = true;\\n\\t\\tfor ( i in key ) {\\n\\t\\t\\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\\n\\t\\t}\\n\\n\\t// Sets one value\\n\\t} else if ( value !== undefined ) {\\n\\t\\tchainable = true;\\n\\n\\t\\tif ( !jQuery.isFunction( value ) ) {\\n\\t\\t\\traw = true;\\n\\t\\t}\\n\\n\\t\\tif ( bulk ) {\\n\\n\\t\\t\\t// Bulk operations run against the entire set\\n\\t\\t\\tif ( raw ) {\\n\\t\\t\\t\\tfn.call( elems, value );\\n\\t\\t\\t\\tfn = null;\\n\\n\\t\\t\\t// ...except when executing function values\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbulk = fn;\\n\\t\\t\\t\\tfn = function( elem, key, value ) {\\n\\t\\t\\t\\t\\treturn bulk.call( jQuery( elem ), value );\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( fn ) {\\n\\t\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\t\\tfn(\\n\\t\\t\\t\\t\\telems[ i ], key, raw ?\\n\\t\\t\\t\\t\\tvalue :\\n\\t\\t\\t\\t\\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif ( chainable ) {\\n\\t\\treturn elems;\\n\\t}\\n\\n\\t// Gets\\n\\tif ( bulk ) {\\n\\t\\treturn fn.call( elems );\\n\\t}\\n\\n\\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\\n};\\nvar acceptData = function( owner ) {\\n\\n\\t// Accepts only:\\n\\t//  - Node\\n\\t//    - Node.ELEMENT_NODE\\n\\t//    - Node.DOCUMENT_NODE\\n\\t//  - Object\\n\\t//    - Any\\n\\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\\n};\\n\\n\\n\\n\\nfunction Data() {\\n\\tthis.expando = jQuery.expando + Data.uid++;\\n}\\n\\nData.uid = 1;\\n\\nData.prototype = {\\n\\n\\tcache: function( owner ) {\\n\\n\\t\\t// Check if the owner object already has a cache\\n\\t\\tvar value = owner[ this.expando ];\\n\\n\\t\\t// If not, create one\\n\\t\\tif ( !value ) {\\n\\t\\t\\tvalue = {};\\n\\n\\t\\t\\t// We can accept data for non-element nodes in modern browsers,\\n\\t\\t\\t// but we should not, see #8335.\\n\\t\\t\\t// Always return an empty object.\\n\\t\\t\\tif ( acceptData( owner ) ) {\\n\\n\\t\\t\\t\\t// If it is a node unlikely to be stringify-ed or looped over\\n\\t\\t\\t\\t// use plain assignment\\n\\t\\t\\t\\tif ( owner.nodeType ) {\\n\\t\\t\\t\\t\\towner[ this.expando ] = value;\\n\\n\\t\\t\\t\\t// Otherwise secure it in a non-enumerable property\\n\\t\\t\\t\\t// configurable must be true to allow the property to be\\n\\t\\t\\t\\t// deleted when data is removed\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tObject.defineProperty( owner, this.expando, {\\n\\t\\t\\t\\t\\t\\tvalue: value,\\n\\t\\t\\t\\t\\t\\tconfigurable: true\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn value;\\n\\t},\\n\\tset: function( owner, data, value ) {\\n\\t\\tvar prop,\\n\\t\\t\\tcache = this.cache( owner );\\n\\n\\t\\t// Handle: [ owner, key, value ] args\\n\\t\\t// Always use camelCase key (gh-2257)\\n\\t\\tif ( typeof data === \\\"string\\\" ) {\\n\\t\\t\\tcache[ jQuery.camelCase( data ) ] = value;\\n\\n\\t\\t// Handle: [ owner, { properties } ] args\\n\\t\\t} else {\\n\\n\\t\\t\\t// Copy the properties one-by-one to the cache object\\n\\t\\t\\tfor ( prop in data ) {\\n\\t\\t\\t\\tcache[ jQuery.camelCase( prop ) ] = data[ prop ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cache;\\n\\t},\\n\\tget: function( owner, key ) {\\n\\t\\treturn key === undefined ?\\n\\t\\t\\tthis.cache( owner ) :\\n\\n\\t\\t\\t// Always use camelCase key (gh-2257)\\n\\t\\t\\towner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];\\n\\t},\\n\\taccess: function( owner, key, value ) {\\n\\n\\t\\t// In cases where either:\\n\\t\\t//\\n\\t\\t//   1. No key was specified\\n\\t\\t//   2. A string key was specified, but no value provided\\n\\t\\t//\\n\\t\\t// Take the \\\"read\\\" path and allow the get method to determine\\n\\t\\t// which value to return, respectively either:\\n\\t\\t//\\n\\t\\t//   1. The entire cache object\\n\\t\\t//   2. The data stored at the key\\n\\t\\t//\\n\\t\\tif ( key === undefined ||\\n\\t\\t\\t\\t( ( key && typeof key === \\\"string\\\" ) && value === undefined ) ) {\\n\\n\\t\\t\\treturn this.get( owner, key );\\n\\t\\t}\\n\\n\\t\\t// When the key is not a string, or both a key and value\\n\\t\\t// are specified, set or extend (existing objects) with either:\\n\\t\\t//\\n\\t\\t//   1. An object of properties\\n\\t\\t//   2. A key and value\\n\\t\\t//\\n\\t\\tthis.set( owner, key, value );\\n\\n\\t\\t// Since the \\\"set\\\" path can have two possible entry points\\n\\t\\t// return the expected data based on which path was taken[*]\\n\\t\\treturn value !== undefined ? value : key;\\n\\t},\\n\\tremove: function( owner, key ) {\\n\\t\\tvar i,\\n\\t\\t\\tcache = owner[ this.expando ];\\n\\n\\t\\tif ( cache === undefined ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( key !== undefined ) {\\n\\n\\t\\t\\t// Support array or space separated string of keys\\n\\t\\t\\tif ( jQuery.isArray( key ) ) {\\n\\n\\t\\t\\t\\t// If key is an array of keys...\\n\\t\\t\\t\\t// We always set camelCase keys, so remove that.\\n\\t\\t\\t\\tkey = key.map( jQuery.camelCase );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tkey = jQuery.camelCase( key );\\n\\n\\t\\t\\t\\t// If a key with the spaces exists, use it.\\n\\t\\t\\t\\t// Otherwise, create an array by matching non-whitespace\\n\\t\\t\\t\\tkey = key in cache ?\\n\\t\\t\\t\\t\\t[ key ] :\\n\\t\\t\\t\\t\\t( key.match( rnothtmlwhite ) || [] );\\n\\t\\t\\t}\\n\\n\\t\\t\\ti = key.length;\\n\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tdelete cache[ key[ i ] ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Remove the expando if there's no more data\\n\\t\\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\\n\\n\\t\\t\\t// Support: Chrome <=35 - 45\\n\\t\\t\\t// Webkit & Blink performance suffers when deleting properties\\n\\t\\t\\t// from DOM nodes, so set to undefined instead\\n\\t\\t\\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\\n\\t\\t\\tif ( owner.nodeType ) {\\n\\t\\t\\t\\towner[ this.expando ] = undefined;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdelete owner[ this.expando ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\thasData: function( owner ) {\\n\\t\\tvar cache = owner[ this.expando ];\\n\\t\\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\\n\\t}\\n};\\nvar dataPriv = new Data();\\n\\nvar dataUser = new Data();\\n\\n\\n\\n//\\tImplementation Summary\\n//\\n//\\t1. Enforce API surface and semantic compatibility with 1.9.x branch\\n//\\t2. Improve the module's maintainability by reducing the storage\\n//\\t\\tpaths to a single mechanism.\\n//\\t3. Use the same single mechanism to support \\\"private\\\" and \\\"user\\\" data.\\n//\\t4. _Never_ expose \\\"private\\\" data to user code (TODO: Drop _data, _removeData)\\n//\\t5. Avoid exposing implementation details on user objects (eg. expando properties)\\n//\\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\\n\\nvar rbrace = /^(?:\\\\{[\\\\w\\\\W]*\\\\}|\\\\[[\\\\w\\\\W]*\\\\])$/,\\n\\trmultiDash = /[A-Z]/g;\\n\\nfunction getData( data ) {\\n\\tif ( data === \\\"true\\\" ) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif ( data === \\\"false\\\" ) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif ( data === \\\"null\\\" ) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// Only convert to a number if it doesn't change the string\\n\\tif ( data === +data + \\\"\\\" ) {\\n\\t\\treturn +data;\\n\\t}\\n\\n\\tif ( rbrace.test( data ) ) {\\n\\t\\treturn JSON.parse( data );\\n\\t}\\n\\n\\treturn data;\\n}\\n\\nfunction dataAttr( elem, key, data ) {\\n\\tvar name;\\n\\n\\t// If nothing was found internally, try to fetch any\\n\\t// data from the HTML5 data-* attribute\\n\\tif ( data === undefined && elem.nodeType === 1 ) {\\n\\t\\tname = \\\"data-\\\" + key.replace( rmultiDash, \\\"-$&\\\" ).toLowerCase();\\n\\t\\tdata = elem.getAttribute( name );\\n\\n\\t\\tif ( typeof data === \\\"string\\\" ) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tdata = getData( data );\\n\\t\\t\\t} catch ( e ) {}\\n\\n\\t\\t\\t// Make sure we set the data so it isn't changed later\\n\\t\\t\\tdataUser.set( elem, key, data );\\n\\t\\t} else {\\n\\t\\t\\tdata = undefined;\\n\\t\\t}\\n\\t}\\n\\treturn data;\\n}\\n\\njQuery.extend( {\\n\\thasData: function( elem ) {\\n\\t\\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\\n\\t},\\n\\n\\tdata: function( elem, name, data ) {\\n\\t\\treturn dataUser.access( elem, name, data );\\n\\t},\\n\\n\\tremoveData: function( elem, name ) {\\n\\t\\tdataUser.remove( elem, name );\\n\\t},\\n\\n\\t// TODO: Now that all calls to _data and _removeData have been replaced\\n\\t// with direct calls to dataPriv methods, these can be deprecated.\\n\\t_data: function( elem, name, data ) {\\n\\t\\treturn dataPriv.access( elem, name, data );\\n\\t},\\n\\n\\t_removeData: function( elem, name ) {\\n\\t\\tdataPriv.remove( elem, name );\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tdata: function( key, value ) {\\n\\t\\tvar i, name, data,\\n\\t\\t\\telem = this[ 0 ],\\n\\t\\t\\tattrs = elem && elem.attributes;\\n\\n\\t\\t// Gets all values\\n\\t\\tif ( key === undefined ) {\\n\\t\\t\\tif ( this.length ) {\\n\\t\\t\\t\\tdata = dataUser.get( elem );\\n\\n\\t\\t\\t\\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \\\"hasDataAttrs\\\" ) ) {\\n\\t\\t\\t\\t\\ti = attrs.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE 11 only\\n\\t\\t\\t\\t\\t\\t// The attrs elements can be null (#14894)\\n\\t\\t\\t\\t\\t\\tif ( attrs[ i ] ) {\\n\\t\\t\\t\\t\\t\\t\\tname = attrs[ i ].name;\\n\\t\\t\\t\\t\\t\\t\\tif ( name.indexOf( \\\"data-\\\" ) === 0 ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tname = jQuery.camelCase( name.slice( 5 ) );\\n\\t\\t\\t\\t\\t\\t\\t\\tdataAttr( elem, name, data[ name ] );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdataPriv.set( elem, \\\"hasDataAttrs\\\", true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\t\\t}\\n\\n\\t\\t// Sets multiple values\\n\\t\\tif ( typeof key === \\\"object\\\" ) {\\n\\t\\t\\treturn this.each( function() {\\n\\t\\t\\t\\tdataUser.set( this, key );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\tvar data;\\n\\n\\t\\t\\t// The calling jQuery object (element matches) is not empty\\n\\t\\t\\t// (and therefore has an element appears at this[ 0 ]) and the\\n\\t\\t\\t// `value` parameter was not undefined. An empty jQuery object\\n\\t\\t\\t// will result in `undefined` for elem = this[ 0 ] which will\\n\\t\\t\\t// throw an exception if an attempt to read a data cache is made.\\n\\t\\t\\tif ( elem && value === undefined ) {\\n\\n\\t\\t\\t\\t// Attempt to get data from the cache\\n\\t\\t\\t\\t// The key will always be camelCased in Data\\n\\t\\t\\t\\tdata = dataUser.get( elem, key );\\n\\t\\t\\t\\tif ( data !== undefined ) {\\n\\t\\t\\t\\t\\treturn data;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Attempt to \\\"discover\\\" the data in\\n\\t\\t\\t\\t// HTML5 custom data-* attrs\\n\\t\\t\\t\\tdata = dataAttr( elem, key );\\n\\t\\t\\t\\tif ( data !== undefined ) {\\n\\t\\t\\t\\t\\treturn data;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// We tried really hard, but the data doesn't exist.\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set the data...\\n\\t\\t\\tthis.each( function() {\\n\\n\\t\\t\\t\\t// We always store the camelCased key\\n\\t\\t\\t\\tdataUser.set( this, key, value );\\n\\t\\t\\t} );\\n\\t\\t}, null, value, arguments.length > 1, null, true );\\n\\t},\\n\\n\\tremoveData: function( key ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tdataUser.remove( this, key );\\n\\t\\t} );\\n\\t}\\n} );\\n\\n\\njQuery.extend( {\\n\\tqueue: function( elem, type, data ) {\\n\\t\\tvar queue;\\n\\n\\t\\tif ( elem ) {\\n\\t\\t\\ttype = ( type || \\\"fx\\\" ) + \\\"queue\\\";\\n\\t\\t\\tqueue = dataPriv.get( elem, type );\\n\\n\\t\\t\\t// Speed up dequeue by getting out quickly if this is just a lookup\\n\\t\\t\\tif ( data ) {\\n\\t\\t\\t\\tif ( !queue || jQuery.isArray( data ) ) {\\n\\t\\t\\t\\t\\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tqueue.push( data );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn queue || [];\\n\\t\\t}\\n\\t},\\n\\n\\tdequeue: function( elem, type ) {\\n\\t\\ttype = type || \\\"fx\\\";\\n\\n\\t\\tvar queue = jQuery.queue( elem, type ),\\n\\t\\t\\tstartLength = queue.length,\\n\\t\\t\\tfn = queue.shift(),\\n\\t\\t\\thooks = jQuery._queueHooks( elem, type ),\\n\\t\\t\\tnext = function() {\\n\\t\\t\\t\\tjQuery.dequeue( elem, type );\\n\\t\\t\\t};\\n\\n\\t\\t// If the fx queue is dequeued, always remove the progress sentinel\\n\\t\\tif ( fn === \\\"inprogress\\\" ) {\\n\\t\\t\\tfn = queue.shift();\\n\\t\\t\\tstartLength--;\\n\\t\\t}\\n\\n\\t\\tif ( fn ) {\\n\\n\\t\\t\\t// Add a progress sentinel to prevent the fx queue from being\\n\\t\\t\\t// automatically dequeued\\n\\t\\t\\tif ( type === \\\"fx\\\" ) {\\n\\t\\t\\t\\tqueue.unshift( \\\"inprogress\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Clear up the last queue stop function\\n\\t\\t\\tdelete hooks.stop;\\n\\t\\t\\tfn.call( elem, next, hooks );\\n\\t\\t}\\n\\n\\t\\tif ( !startLength && hooks ) {\\n\\t\\t\\thooks.empty.fire();\\n\\t\\t}\\n\\t},\\n\\n\\t// Not public - generate a queueHooks object, or return the current one\\n\\t_queueHooks: function( elem, type ) {\\n\\t\\tvar key = type + \\\"queueHooks\\\";\\n\\t\\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\\n\\t\\t\\tempty: jQuery.Callbacks( \\\"once memory\\\" ).add( function() {\\n\\t\\t\\t\\tdataPriv.remove( elem, [ type + \\\"queue\\\", key ] );\\n\\t\\t\\t} )\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tqueue: function( type, data ) {\\n\\t\\tvar setter = 2;\\n\\n\\t\\tif ( typeof type !== \\\"string\\\" ) {\\n\\t\\t\\tdata = type;\\n\\t\\t\\ttype = \\\"fx\\\";\\n\\t\\t\\tsetter--;\\n\\t\\t}\\n\\n\\t\\tif ( arguments.length < setter ) {\\n\\t\\t\\treturn jQuery.queue( this[ 0 ], type );\\n\\t\\t}\\n\\n\\t\\treturn data === undefined ?\\n\\t\\t\\tthis :\\n\\t\\t\\tthis.each( function() {\\n\\t\\t\\t\\tvar queue = jQuery.queue( this, type, data );\\n\\n\\t\\t\\t\\t// Ensure a hooks for this queue\\n\\t\\t\\t\\tjQuery._queueHooks( this, type );\\n\\n\\t\\t\\t\\tif ( type === \\\"fx\\\" && queue[ 0 ] !== \\\"inprogress\\\" ) {\\n\\t\\t\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t},\\n\\tdequeue: function( type ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t} );\\n\\t},\\n\\tclearQueue: function( type ) {\\n\\t\\treturn this.queue( type || \\\"fx\\\", [] );\\n\\t},\\n\\n\\t// Get a promise resolved when queues of a certain type\\n\\t// are emptied (fx is the type by default)\\n\\tpromise: function( type, obj ) {\\n\\t\\tvar tmp,\\n\\t\\t\\tcount = 1,\\n\\t\\t\\tdefer = jQuery.Deferred(),\\n\\t\\t\\telements = this,\\n\\t\\t\\ti = this.length,\\n\\t\\t\\tresolve = function() {\\n\\t\\t\\t\\tif ( !( --count ) ) {\\n\\t\\t\\t\\t\\tdefer.resolveWith( elements, [ elements ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\tif ( typeof type !== \\\"string\\\" ) {\\n\\t\\t\\tobj = type;\\n\\t\\t\\ttype = undefined;\\n\\t\\t}\\n\\t\\ttype = type || \\\"fx\\\";\\n\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\ttmp = dataPriv.get( elements[ i ], type + \\\"queueHooks\\\" );\\n\\t\\t\\tif ( tmp && tmp.empty ) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\ttmp.empty.add( resolve );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresolve();\\n\\t\\treturn defer.promise( obj );\\n\\t}\\n} );\\nvar pnum = ( /[+-]?(?:\\\\d*\\\\.|)\\\\d+(?:[eE][+-]?\\\\d+|)/ ).source;\\n\\nvar rcssNum = new RegExp( \\\"^(?:([+-])=|)(\\\" + pnum + \\\")([a-z%]*)$\\\", \\\"i\\\" );\\n\\n\\nvar cssExpand = [ \\\"Top\\\", \\\"Right\\\", \\\"Bottom\\\", \\\"Left\\\" ];\\n\\nvar isHiddenWithinTree = function( elem, el ) {\\n\\n\\t\\t// isHiddenWithinTree might be called from jQuery#filter function;\\n\\t\\t// in that case, element will be second argument\\n\\t\\telem = el || elem;\\n\\n\\t\\t// Inline style trumps all\\n\\t\\treturn elem.style.display === \\\"none\\\" ||\\n\\t\\t\\telem.style.display === \\\"\\\" &&\\n\\n\\t\\t\\t// Otherwise, check computed style\\n\\t\\t\\t// Support: Firefox <=43 - 45\\n\\t\\t\\t// Disconnected elements can have computed display: none, so first confirm that elem is\\n\\t\\t\\t// in the document.\\n\\t\\t\\tjQuery.contains( elem.ownerDocument, elem ) &&\\n\\n\\t\\t\\tjQuery.css( elem, \\\"display\\\" ) === \\\"none\\\";\\n\\t};\\n\\nvar swap = function( elem, options, callback, args ) {\\n\\tvar ret, name,\\n\\t\\told = {};\\n\\n\\t// Remember the old values, and insert the new ones\\n\\tfor ( name in options ) {\\n\\t\\told[ name ] = elem.style[ name ];\\n\\t\\telem.style[ name ] = options[ name ];\\n\\t}\\n\\n\\tret = callback.apply( elem, args || [] );\\n\\n\\t// Revert the old values\\n\\tfor ( name in options ) {\\n\\t\\telem.style[ name ] = old[ name ];\\n\\t}\\n\\n\\treturn ret;\\n};\\n\\n\\n\\n\\nfunction adjustCSS( elem, prop, valueParts, tween ) {\\n\\tvar adjusted,\\n\\t\\tscale = 1,\\n\\t\\tmaxIterations = 20,\\n\\t\\tcurrentValue = tween ?\\n\\t\\t\\tfunction() {\\n\\t\\t\\t\\treturn tween.cur();\\n\\t\\t\\t} :\\n\\t\\t\\tfunction() {\\n\\t\\t\\t\\treturn jQuery.css( elem, prop, \\\"\\\" );\\n\\t\\t\\t},\\n\\t\\tinitial = currentValue(),\\n\\t\\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \\\"\\\" : \\\"px\\\" ),\\n\\n\\t\\t// Starting value computation is required for potential unit mismatches\\n\\t\\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \\\"px\\\" && +initial ) &&\\n\\t\\t\\trcssNum.exec( jQuery.css( elem, prop ) );\\n\\n\\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\\n\\n\\t\\t// Trust units reported by jQuery.css\\n\\t\\tunit = unit || initialInUnit[ 3 ];\\n\\n\\t\\t// Make sure we update the tween properties later on\\n\\t\\tvalueParts = valueParts || [];\\n\\n\\t\\t// Iteratively approximate from a nonzero starting point\\n\\t\\tinitialInUnit = +initial || 1;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\t// If previous iteration zeroed out, double until we get *something*.\\n\\t\\t\\t// Use string for doubling so we don't accidentally see scale as unchanged below\\n\\t\\t\\tscale = scale || \\\".5\\\";\\n\\n\\t\\t\\t// Adjust and apply\\n\\t\\t\\tinitialInUnit = initialInUnit / scale;\\n\\t\\t\\tjQuery.style( elem, prop, initialInUnit + unit );\\n\\n\\t\\t// Update scale, tolerating zero or NaN from tween.cur()\\n\\t\\t// Break the loop if scale is unchanged or perfect, or if we've just had enough.\\n\\t\\t} while (\\n\\t\\t\\tscale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\\n\\t\\t);\\n\\t}\\n\\n\\tif ( valueParts ) {\\n\\t\\tinitialInUnit = +initialInUnit || +initial || 0;\\n\\n\\t\\t// Apply relative offset (+=/-=) if specified\\n\\t\\tadjusted = valueParts[ 1 ] ?\\n\\t\\t\\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\\n\\t\\t\\t+valueParts[ 2 ];\\n\\t\\tif ( tween ) {\\n\\t\\t\\ttween.unit = unit;\\n\\t\\t\\ttween.start = initialInUnit;\\n\\t\\t\\ttween.end = adjusted;\\n\\t\\t}\\n\\t}\\n\\treturn adjusted;\\n}\\n\\n\\nvar defaultDisplayMap = {};\\n\\nfunction getDefaultDisplay( elem ) {\\n\\tvar temp,\\n\\t\\tdoc = elem.ownerDocument,\\n\\t\\tnodeName = elem.nodeName,\\n\\t\\tdisplay = defaultDisplayMap[ nodeName ];\\n\\n\\tif ( display ) {\\n\\t\\treturn display;\\n\\t}\\n\\n\\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\\n\\tdisplay = jQuery.css( temp, \\\"display\\\" );\\n\\n\\ttemp.parentNode.removeChild( temp );\\n\\n\\tif ( display === \\\"none\\\" ) {\\n\\t\\tdisplay = \\\"block\\\";\\n\\t}\\n\\tdefaultDisplayMap[ nodeName ] = display;\\n\\n\\treturn display;\\n}\\n\\nfunction showHide( elements, show ) {\\n\\tvar display, elem,\\n\\t\\tvalues = [],\\n\\t\\tindex = 0,\\n\\t\\tlength = elements.length;\\n\\n\\t// Determine new display value for elements that need to change\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\telem = elements[ index ];\\n\\t\\tif ( !elem.style ) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tdisplay = elem.style.display;\\n\\t\\tif ( show ) {\\n\\n\\t\\t\\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\\n\\t\\t\\t// check is required in this first loop unless we have a nonempty display value (either\\n\\t\\t\\t// inline or about-to-be-restored)\\n\\t\\t\\tif ( display === \\\"none\\\" ) {\\n\\t\\t\\t\\tvalues[ index ] = dataPriv.get( elem, \\\"display\\\" ) || null;\\n\\t\\t\\t\\tif ( !values[ index ] ) {\\n\\t\\t\\t\\t\\telem.style.display = \\\"\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif ( elem.style.display === \\\"\\\" && isHiddenWithinTree( elem ) ) {\\n\\t\\t\\t\\tvalues[ index ] = getDefaultDisplay( elem );\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif ( display !== \\\"none\\\" ) {\\n\\t\\t\\t\\tvalues[ index ] = \\\"none\\\";\\n\\n\\t\\t\\t\\t// Remember what we're overwriting\\n\\t\\t\\t\\tdataPriv.set( elem, \\\"display\\\", display );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Set the display of the elements in a second loop to avoid constant reflow\\n\\tfor ( index = 0; index < length; index++ ) {\\n\\t\\tif ( values[ index ] != null ) {\\n\\t\\t\\telements[ index ].style.display = values[ index ];\\n\\t\\t}\\n\\t}\\n\\n\\treturn elements;\\n}\\n\\njQuery.fn.extend( {\\n\\tshow: function() {\\n\\t\\treturn showHide( this, true );\\n\\t},\\n\\thide: function() {\\n\\t\\treturn showHide( this );\\n\\t},\\n\\ttoggle: function( state ) {\\n\\t\\tif ( typeof state === \\\"boolean\\\" ) {\\n\\t\\t\\treturn state ? this.show() : this.hide();\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tif ( isHiddenWithinTree( this ) ) {\\n\\t\\t\\t\\tjQuery( this ).show();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tjQuery( this ).hide();\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t}\\n} );\\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\\n\\nvar rtagName = ( /<([a-z][^\\\\/\\\\0>\\\\x20\\\\t\\\\r\\\\n\\\\f]+)/i );\\n\\nvar rscriptType = ( /^$|\\\\/(?:java|ecma)script/i );\\n\\n\\n\\n// We have to close these tags to support XHTML (#13200)\\nvar wrapMap = {\\n\\n\\t// Support: IE <=9 only\\n\\toption: [ 1, \\\"<select multiple='multiple'>\\\", \\\"</select>\\\" ],\\n\\n\\t// XHTML parsers do not magically insert elements in the\\n\\t// same way that tag soup parsers do. So we cannot shorten\\n\\t// this by omitting <tbody> or other required elements.\\n\\tthead: [ 1, \\\"<table>\\\", \\\"</table>\\\" ],\\n\\tcol: [ 2, \\\"<table><colgroup>\\\", \\\"</colgroup></table>\\\" ],\\n\\ttr: [ 2, \\\"<table><tbody>\\\", \\\"</tbody></table>\\\" ],\\n\\ttd: [ 3, \\\"<table><tbody><tr>\\\", \\\"</tr></tbody></table>\\\" ],\\n\\n\\t_default: [ 0, \\\"\\\", \\\"\\\" ]\\n};\\n\\n// Support: IE <=9 only\\nwrapMap.optgroup = wrapMap.option;\\n\\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\\nwrapMap.th = wrapMap.td;\\n\\n\\nfunction getAll( context, tag ) {\\n\\n\\t// Support: IE <=9 - 11 only\\n\\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\\n\\tvar ret;\\n\\n\\tif ( typeof context.getElementsByTagName !== \\\"undefined\\\" ) {\\n\\t\\tret = context.getElementsByTagName( tag || \\\"*\\\" );\\n\\n\\t} else if ( typeof context.querySelectorAll !== \\\"undefined\\\" ) {\\n\\t\\tret = context.querySelectorAll( tag || \\\"*\\\" );\\n\\n\\t} else {\\n\\t\\tret = [];\\n\\t}\\n\\n\\tif ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {\\n\\t\\treturn jQuery.merge( [ context ], ret );\\n\\t}\\n\\n\\treturn ret;\\n}\\n\\n\\n// Mark scripts as having already been evaluated\\nfunction setGlobalEval( elems, refElements ) {\\n\\tvar i = 0,\\n\\t\\tl = elems.length;\\n\\n\\tfor ( ; i < l; i++ ) {\\n\\t\\tdataPriv.set(\\n\\t\\t\\telems[ i ],\\n\\t\\t\\t\\\"globalEval\\\",\\n\\t\\t\\t!refElements || dataPriv.get( refElements[ i ], \\\"globalEval\\\" )\\n\\t\\t);\\n\\t}\\n}\\n\\n\\nvar rhtml = /<|&#?\\\\w+;/;\\n\\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\\n\\tvar elem, tmp, tag, wrap, contains, j,\\n\\t\\tfragment = context.createDocumentFragment(),\\n\\t\\tnodes = [],\\n\\t\\ti = 0,\\n\\t\\tl = elems.length;\\n\\n\\tfor ( ; i < l; i++ ) {\\n\\t\\telem = elems[ i ];\\n\\n\\t\\tif ( elem || elem === 0 ) {\\n\\n\\t\\t\\t// Add nodes directly\\n\\t\\t\\tif ( jQuery.type( elem ) === \\\"object\\\" ) {\\n\\n\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\\n\\n\\t\\t\\t// Convert non-html into a text node\\n\\t\\t\\t} else if ( !rhtml.test( elem ) ) {\\n\\t\\t\\t\\tnodes.push( context.createTextNode( elem ) );\\n\\n\\t\\t\\t// Convert html into DOM nodes\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttmp = tmp || fragment.appendChild( context.createElement( \\\"div\\\" ) );\\n\\n\\t\\t\\t\\t// Deserialize a standard representation\\n\\t\\t\\t\\ttag = ( rtagName.exec( elem ) || [ \\\"\\\", \\\"\\\" ] )[ 1 ].toLowerCase();\\n\\t\\t\\t\\twrap = wrapMap[ tag ] || wrapMap._default;\\n\\t\\t\\t\\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\\n\\n\\t\\t\\t\\t// Descend through wrappers to the right content\\n\\t\\t\\t\\tj = wrap[ 0 ];\\n\\t\\t\\t\\twhile ( j-- ) {\\n\\t\\t\\t\\t\\ttmp = tmp.lastChild;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\tjQuery.merge( nodes, tmp.childNodes );\\n\\n\\t\\t\\t\\t// Remember the top-level container\\n\\t\\t\\t\\ttmp = fragment.firstChild;\\n\\n\\t\\t\\t\\t// Ensure the created nodes are orphaned (#12392)\\n\\t\\t\\t\\ttmp.textContent = \\\"\\\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Remove wrapper from fragment\\n\\tfragment.textContent = \\\"\\\";\\n\\n\\ti = 0;\\n\\twhile ( ( elem = nodes[ i++ ] ) ) {\\n\\n\\t\\t// Skip elements already in the context collection (trac-4087)\\n\\t\\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\\n\\t\\t\\tif ( ignored ) {\\n\\t\\t\\t\\tignored.push( elem );\\n\\t\\t\\t}\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tcontains = jQuery.contains( elem.ownerDocument, elem );\\n\\n\\t\\t// Append to fragment\\n\\t\\ttmp = getAll( fragment.appendChild( elem ), \\\"script\\\" );\\n\\n\\t\\t// Preserve script evaluation history\\n\\t\\tif ( contains ) {\\n\\t\\t\\tsetGlobalEval( tmp );\\n\\t\\t}\\n\\n\\t\\t// Capture executables\\n\\t\\tif ( scripts ) {\\n\\t\\t\\tj = 0;\\n\\t\\t\\twhile ( ( elem = tmp[ j++ ] ) ) {\\n\\t\\t\\t\\tif ( rscriptType.test( elem.type || \\\"\\\" ) ) {\\n\\t\\t\\t\\t\\tscripts.push( elem );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn fragment;\\n}\\n\\n\\n( function() {\\n\\tvar fragment = document.createDocumentFragment(),\\n\\t\\tdiv = fragment.appendChild( document.createElement( \\\"div\\\" ) ),\\n\\t\\tinput = document.createElement( \\\"input\\\" );\\n\\n\\t// Support: Android 4.0 - 4.3 only\\n\\t// Check state lost if the name is set (#11217)\\n\\t// Support: Windows Web Apps (WWA)\\n\\t// `name` and `type` must use .setAttribute for WWA (#14901)\\n\\tinput.setAttribute( \\\"type\\\", \\\"radio\\\" );\\n\\tinput.setAttribute( \\\"checked\\\", \\\"checked\\\" );\\n\\tinput.setAttribute( \\\"name\\\", \\\"t\\\" );\\n\\n\\tdiv.appendChild( input );\\n\\n\\t// Support: Android <=4.1 only\\n\\t// Older WebKit doesn't clone checked state correctly in fragments\\n\\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\\n\\n\\t// Support: IE <=11 only\\n\\t// Make sure textarea (and checkbox) defaultValue is properly cloned\\n\\tdiv.innerHTML = \\\"<textarea>x</textarea>\\\";\\n\\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\\n} )();\\nvar documentElement = document.documentElement;\\n\\n\\n\\nvar\\n\\trkeyEvent = /^key/,\\n\\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\\n\\trtypenamespace = /^([^.]*)(?:\\\\.(.+)|)/;\\n\\nfunction returnTrue() {\\n\\treturn true;\\n}\\n\\nfunction returnFalse() {\\n\\treturn false;\\n}\\n\\n// Support: IE <=9 only\\n// See #13393 for more info\\nfunction safeActiveElement() {\\n\\ttry {\\n\\t\\treturn document.activeElement;\\n\\t} catch ( err ) { }\\n}\\n\\nfunction on( elem, types, selector, data, fn, one ) {\\n\\tvar origFn, type;\\n\\n\\t// Types can be a map of types/handlers\\n\\tif ( typeof types === \\\"object\\\" ) {\\n\\n\\t\\t// ( types-Object, selector, data )\\n\\t\\tif ( typeof selector !== \\\"string\\\" ) {\\n\\n\\t\\t\\t// ( types-Object, data )\\n\\t\\t\\tdata = data || selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t\\tfor ( type in types ) {\\n\\t\\t\\ton( elem, type, selector, data, types[ type ], one );\\n\\t\\t}\\n\\t\\treturn elem;\\n\\t}\\n\\n\\tif ( data == null && fn == null ) {\\n\\n\\t\\t// ( types, fn )\\n\\t\\tfn = selector;\\n\\t\\tdata = selector = undefined;\\n\\t} else if ( fn == null ) {\\n\\t\\tif ( typeof selector === \\\"string\\\" ) {\\n\\n\\t\\t\\t// ( types, selector, fn )\\n\\t\\t\\tfn = data;\\n\\t\\t\\tdata = undefined;\\n\\t\\t} else {\\n\\n\\t\\t\\t// ( types, data, fn )\\n\\t\\t\\tfn = data;\\n\\t\\t\\tdata = selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t}\\n\\tif ( fn === false ) {\\n\\t\\tfn = returnFalse;\\n\\t} else if ( !fn ) {\\n\\t\\treturn elem;\\n\\t}\\n\\n\\tif ( one === 1 ) {\\n\\t\\torigFn = fn;\\n\\t\\tfn = function( event ) {\\n\\n\\t\\t\\t// Can use an empty set, since event contains the info\\n\\t\\t\\tjQuery().off( event );\\n\\t\\t\\treturn origFn.apply( this, arguments );\\n\\t\\t};\\n\\n\\t\\t// Use same guid so caller can remove using origFn\\n\\t\\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\\n\\t}\\n\\treturn elem.each( function() {\\n\\t\\tjQuery.event.add( this, types, fn, data, selector );\\n\\t} );\\n}\\n\\n/*\\n * Helper functions for managing events -- not part of the public interface.\\n * Props to Dean Edwards' addEvent library for many of the ideas.\\n */\\njQuery.event = {\\n\\n\\tglobal: {},\\n\\n\\tadd: function( elem, types, handler, data, selector ) {\\n\\n\\t\\tvar handleObjIn, eventHandle, tmp,\\n\\t\\t\\tevents, t, handleObj,\\n\\t\\t\\tspecial, handlers, type, namespaces, origType,\\n\\t\\t\\telemData = dataPriv.get( elem );\\n\\n\\t\\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\\n\\t\\tif ( !elemData ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Caller can pass in an object of custom data in lieu of the handler\\n\\t\\tif ( handler.handler ) {\\n\\t\\t\\thandleObjIn = handler;\\n\\t\\t\\thandler = handleObjIn.handler;\\n\\t\\t\\tselector = handleObjIn.selector;\\n\\t\\t}\\n\\n\\t\\t// Ensure that invalid selectors throw exceptions at attach time\\n\\t\\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\\n\\t\\tif ( selector ) {\\n\\t\\t\\tjQuery.find.matchesSelector( documentElement, selector );\\n\\t\\t}\\n\\n\\t\\t// Make sure that the handler has a unique ID, used to find/remove it later\\n\\t\\tif ( !handler.guid ) {\\n\\t\\t\\thandler.guid = jQuery.guid++;\\n\\t\\t}\\n\\n\\t\\t// Init the element's event structure and main handler, if this is the first\\n\\t\\tif ( !( events = elemData.events ) ) {\\n\\t\\t\\tevents = elemData.events = {};\\n\\t\\t}\\n\\t\\tif ( !( eventHandle = elemData.handle ) ) {\\n\\t\\t\\teventHandle = elemData.handle = function( e ) {\\n\\n\\t\\t\\t\\t// Discard the second event of a jQuery.event.trigger() and\\n\\t\\t\\t\\t// when an event is called after a page has unloaded\\n\\t\\t\\t\\treturn typeof jQuery !== \\\"undefined\\\" && jQuery.event.triggered !== e.type ?\\n\\t\\t\\t\\t\\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\t// Handle multiple events separated by a space\\n\\t\\ttypes = ( types || \\\"\\\" ).match( rnothtmlwhite ) || [ \\\"\\\" ];\\n\\t\\tt = types.length;\\n\\t\\twhile ( t-- ) {\\n\\t\\t\\ttmp = rtypenamespace.exec( types[ t ] ) || [];\\n\\t\\t\\ttype = origType = tmp[ 1 ];\\n\\t\\t\\tnamespaces = ( tmp[ 2 ] || \\\"\\\" ).split( \\\".\\\" ).sort();\\n\\n\\t\\t\\t// There *must* be a type, no attaching namespace-only handlers\\n\\t\\t\\tif ( !type ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If event changes its type, use the special event handlers for the changed type\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\n\\t\\t\\t// If selector defined, determine special event api type, otherwise given type\\n\\t\\t\\ttype = ( selector ? special.delegateType : special.bindType ) || type;\\n\\n\\t\\t\\t// Update special based on newly reset type\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\n\\t\\t\\t// handleObj is passed to all event handlers\\n\\t\\t\\thandleObj = jQuery.extend( {\\n\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\torigType: origType,\\n\\t\\t\\t\\tdata: data,\\n\\t\\t\\t\\thandler: handler,\\n\\t\\t\\t\\tguid: handler.guid,\\n\\t\\t\\t\\tselector: selector,\\n\\t\\t\\t\\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\\n\\t\\t\\t\\tnamespace: namespaces.join( \\\".\\\" )\\n\\t\\t\\t}, handleObjIn );\\n\\n\\t\\t\\t// Init the event handler queue if we're the first\\n\\t\\t\\tif ( !( handlers = events[ type ] ) ) {\\n\\t\\t\\t\\thandlers = events[ type ] = [];\\n\\t\\t\\t\\thandlers.delegateCount = 0;\\n\\n\\t\\t\\t\\t// Only use addEventListener if the special events handler returns false\\n\\t\\t\\t\\tif ( !special.setup ||\\n\\t\\t\\t\\t\\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\\n\\n\\t\\t\\t\\t\\tif ( elem.addEventListener ) {\\n\\t\\t\\t\\t\\t\\telem.addEventListener( type, eventHandle );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( special.add ) {\\n\\t\\t\\t\\tspecial.add.call( elem, handleObj );\\n\\n\\t\\t\\t\\tif ( !handleObj.handler.guid ) {\\n\\t\\t\\t\\t\\thandleObj.handler.guid = handler.guid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add to the element's handler list, delegates in front\\n\\t\\t\\tif ( selector ) {\\n\\t\\t\\t\\thandlers.splice( handlers.delegateCount++, 0, handleObj );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thandlers.push( handleObj );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Keep track of which events have ever been used, for event optimization\\n\\t\\t\\tjQuery.event.global[ type ] = true;\\n\\t\\t}\\n\\n\\t},\\n\\n\\t// Detach an event or set of events from an element\\n\\tremove: function( elem, types, handler, selector, mappedTypes ) {\\n\\n\\t\\tvar j, origCount, tmp,\\n\\t\\t\\tevents, t, handleObj,\\n\\t\\t\\tspecial, handlers, type, namespaces, origType,\\n\\t\\t\\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\\n\\n\\t\\tif ( !elemData || !( events = elemData.events ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Once for each type.namespace in types; type may be omitted\\n\\t\\ttypes = ( types || \\\"\\\" ).match( rnothtmlwhite ) || [ \\\"\\\" ];\\n\\t\\tt = types.length;\\n\\t\\twhile ( t-- ) {\\n\\t\\t\\ttmp = rtypenamespace.exec( types[ t ] ) || [];\\n\\t\\t\\ttype = origType = tmp[ 1 ];\\n\\t\\t\\tnamespaces = ( tmp[ 2 ] || \\\"\\\" ).split( \\\".\\\" ).sort();\\n\\n\\t\\t\\t// Unbind all events (on this namespace, if provided) for the element\\n\\t\\t\\tif ( !type ) {\\n\\t\\t\\t\\tfor ( type in events ) {\\n\\t\\t\\t\\t\\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\t\\t\\ttype = ( selector ? special.delegateType : special.bindType ) || type;\\n\\t\\t\\thandlers = events[ type ] || [];\\n\\t\\t\\ttmp = tmp[ 2 ] &&\\n\\t\\t\\t\\tnew RegExp( \\\"(^|\\\\\\\\.)\\\" + namespaces.join( \\\"\\\\\\\\.(?:.*\\\\\\\\.|)\\\" ) + \\\"(\\\\\\\\.|$)\\\" );\\n\\n\\t\\t\\t// Remove matching events\\n\\t\\t\\torigCount = j = handlers.length;\\n\\t\\t\\twhile ( j-- ) {\\n\\t\\t\\t\\thandleObj = handlers[ j ];\\n\\n\\t\\t\\t\\tif ( ( mappedTypes || origType === handleObj.origType ) &&\\n\\t\\t\\t\\t\\t( !handler || handler.guid === handleObj.guid ) &&\\n\\t\\t\\t\\t\\t( !tmp || tmp.test( handleObj.namespace ) ) &&\\n\\t\\t\\t\\t\\t( !selector || selector === handleObj.selector ||\\n\\t\\t\\t\\t\\t\\tselector === \\\"**\\\" && handleObj.selector ) ) {\\n\\t\\t\\t\\t\\thandlers.splice( j, 1 );\\n\\n\\t\\t\\t\\t\\tif ( handleObj.selector ) {\\n\\t\\t\\t\\t\\t\\thandlers.delegateCount--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( special.remove ) {\\n\\t\\t\\t\\t\\t\\tspecial.remove.call( elem, handleObj );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Remove generic event handler if we removed something and no more handlers exist\\n\\t\\t\\t// (avoids potential for endless recursion during removal of special event handlers)\\n\\t\\t\\tif ( origCount && !handlers.length ) {\\n\\t\\t\\t\\tif ( !special.teardown ||\\n\\t\\t\\t\\t\\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\\n\\n\\t\\t\\t\\t\\tjQuery.removeEvent( elem, type, elemData.handle );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdelete events[ type ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Remove data and the expando if it's no longer used\\n\\t\\tif ( jQuery.isEmptyObject( events ) ) {\\n\\t\\t\\tdataPriv.remove( elem, \\\"handle events\\\" );\\n\\t\\t}\\n\\t},\\n\\n\\tdispatch: function( nativeEvent ) {\\n\\n\\t\\t// Make a writable jQuery.Event from the native event object\\n\\t\\tvar event = jQuery.event.fix( nativeEvent );\\n\\n\\t\\tvar i, j, ret, matched, handleObj, handlerQueue,\\n\\t\\t\\targs = new Array( arguments.length ),\\n\\t\\t\\thandlers = ( dataPriv.get( this, \\\"events\\\" ) || {} )[ event.type ] || [],\\n\\t\\t\\tspecial = jQuery.event.special[ event.type ] || {};\\n\\n\\t\\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\\n\\t\\targs[ 0 ] = event;\\n\\n\\t\\tfor ( i = 1; i < arguments.length; i++ ) {\\n\\t\\t\\targs[ i ] = arguments[ i ];\\n\\t\\t}\\n\\n\\t\\tevent.delegateTarget = this;\\n\\n\\t\\t// Call the preDispatch hook for the mapped type, and let it bail if desired\\n\\t\\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Determine handlers\\n\\t\\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\\n\\n\\t\\t// Run delegates first; they may want to stop propagation beneath us\\n\\t\\ti = 0;\\n\\t\\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\\n\\t\\t\\tevent.currentTarget = matched.elem;\\n\\n\\t\\t\\tj = 0;\\n\\t\\t\\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\\n\\t\\t\\t\\t!event.isImmediatePropagationStopped() ) {\\n\\n\\t\\t\\t\\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\\n\\t\\t\\t\\t// a subset or equal to those in the bound event (both can have no namespace).\\n\\t\\t\\t\\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\\n\\n\\t\\t\\t\\t\\tevent.handleObj = handleObj;\\n\\t\\t\\t\\t\\tevent.data = handleObj.data;\\n\\n\\t\\t\\t\\t\\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\\n\\t\\t\\t\\t\\t\\thandleObj.handler ).apply( matched.elem, args );\\n\\n\\t\\t\\t\\t\\tif ( ret !== undefined ) {\\n\\t\\t\\t\\t\\t\\tif ( ( event.result = ret ) === false ) {\\n\\t\\t\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\t\\t\\tevent.stopPropagation();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Call the postDispatch hook for the mapped type\\n\\t\\tif ( special.postDispatch ) {\\n\\t\\t\\tspecial.postDispatch.call( this, event );\\n\\t\\t}\\n\\n\\t\\treturn event.result;\\n\\t},\\n\\n\\thandlers: function( event, handlers ) {\\n\\t\\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\\n\\t\\t\\thandlerQueue = [],\\n\\t\\t\\tdelegateCount = handlers.delegateCount,\\n\\t\\t\\tcur = event.target;\\n\\n\\t\\t// Find delegate handlers\\n\\t\\tif ( delegateCount &&\\n\\n\\t\\t\\t// Support: IE <=9\\n\\t\\t\\t// Black-hole SVG <use> instance trees (trac-13180)\\n\\t\\t\\tcur.nodeType &&\\n\\n\\t\\t\\t// Support: Firefox <=42\\n\\t\\t\\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\\n\\t\\t\\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\\n\\t\\t\\t// Support: IE 11 only\\n\\t\\t\\t// ...but not arrow key \\\"clicks\\\" of radio inputs, which can have `button` -1 (gh-2343)\\n\\t\\t\\t!( event.type === \\\"click\\\" && event.button >= 1 ) ) {\\n\\n\\t\\t\\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\\n\\n\\t\\t\\t\\t// Don't check non-elements (#13208)\\n\\t\\t\\t\\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\\n\\t\\t\\t\\tif ( cur.nodeType === 1 && !( event.type === \\\"click\\\" && cur.disabled === true ) ) {\\n\\t\\t\\t\\t\\tmatchedHandlers = [];\\n\\t\\t\\t\\t\\tmatchedSelectors = {};\\n\\t\\t\\t\\t\\tfor ( i = 0; i < delegateCount; i++ ) {\\n\\t\\t\\t\\t\\t\\thandleObj = handlers[ i ];\\n\\n\\t\\t\\t\\t\\t\\t// Don't conflict with Object.prototype properties (#13203)\\n\\t\\t\\t\\t\\t\\tsel = handleObj.selector + \\\" \\\";\\n\\n\\t\\t\\t\\t\\t\\tif ( matchedSelectors[ sel ] === undefined ) {\\n\\t\\t\\t\\t\\t\\t\\tmatchedSelectors[ sel ] = handleObj.needsContext ?\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery( sel, this ).index( cur ) > -1 :\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.find( sel, this, null, [ cur ] ).length;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif ( matchedSelectors[ sel ] ) {\\n\\t\\t\\t\\t\\t\\t\\tmatchedHandlers.push( handleObj );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( matchedHandlers.length ) {\\n\\t\\t\\t\\t\\t\\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Add the remaining (directly-bound) handlers\\n\\t\\tcur = this;\\n\\t\\tif ( delegateCount < handlers.length ) {\\n\\t\\t\\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\\n\\t\\t}\\n\\n\\t\\treturn handlerQueue;\\n\\t},\\n\\n\\taddProp: function( name, hook ) {\\n\\t\\tObject.defineProperty( jQuery.Event.prototype, name, {\\n\\t\\t\\tenumerable: true,\\n\\t\\t\\tconfigurable: true,\\n\\n\\t\\t\\tget: jQuery.isFunction( hook ) ?\\n\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\tif ( this.originalEvent ) {\\n\\t\\t\\t\\t\\t\\t\\treturn hook( this.originalEvent );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} :\\n\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\tif ( this.originalEvent ) {\\n\\t\\t\\t\\t\\t\\t\\treturn this.originalEvent[ name ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\tset: function( value ) {\\n\\t\\t\\t\\tObject.defineProperty( this, name, {\\n\\t\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\t\\tconfigurable: true,\\n\\t\\t\\t\\t\\twritable: true,\\n\\t\\t\\t\\t\\tvalue: value\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tfix: function( originalEvent ) {\\n\\t\\treturn originalEvent[ jQuery.expando ] ?\\n\\t\\t\\toriginalEvent :\\n\\t\\t\\tnew jQuery.Event( originalEvent );\\n\\t},\\n\\n\\tspecial: {\\n\\t\\tload: {\\n\\n\\t\\t\\t// Prevent triggered image.load events from bubbling to window.load\\n\\t\\t\\tnoBubble: true\\n\\t\\t},\\n\\t\\tfocus: {\\n\\n\\t\\t\\t// Fire native event if possible so blur/focus sequence is correct\\n\\t\\t\\ttrigger: function() {\\n\\t\\t\\t\\tif ( this !== safeActiveElement() && this.focus ) {\\n\\t\\t\\t\\t\\tthis.focus();\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tdelegateType: \\\"focusin\\\"\\n\\t\\t},\\n\\t\\tblur: {\\n\\t\\t\\ttrigger: function() {\\n\\t\\t\\t\\tif ( this === safeActiveElement() && this.blur ) {\\n\\t\\t\\t\\t\\tthis.blur();\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tdelegateType: \\\"focusout\\\"\\n\\t\\t},\\n\\t\\tclick: {\\n\\n\\t\\t\\t// For checkbox, fire native event so checked state will be right\\n\\t\\t\\ttrigger: function() {\\n\\t\\t\\t\\tif ( this.type === \\\"checkbox\\\" && this.click && jQuery.nodeName( this, \\\"input\\\" ) ) {\\n\\t\\t\\t\\t\\tthis.click();\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\t// For cross-browser consistency, don't fire native .click() on links\\n\\t\\t\\t_default: function( event ) {\\n\\t\\t\\t\\treturn jQuery.nodeName( event.target, \\\"a\\\" );\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tbeforeunload: {\\n\\t\\t\\tpostDispatch: function( event ) {\\n\\n\\t\\t\\t\\t// Support: Firefox 20+\\n\\t\\t\\t\\t// Firefox doesn't alert if the returnValue field is not set.\\n\\t\\t\\t\\tif ( event.result !== undefined && event.originalEvent ) {\\n\\t\\t\\t\\t\\tevent.originalEvent.returnValue = event.result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.removeEvent = function( elem, type, handle ) {\\n\\n\\t// This \\\"if\\\" is needed for plain objects\\n\\tif ( elem.removeEventListener ) {\\n\\t\\telem.removeEventListener( type, handle );\\n\\t}\\n};\\n\\njQuery.Event = function( src, props ) {\\n\\n\\t// Allow instantiation without the 'new' keyword\\n\\tif ( !( this instanceof jQuery.Event ) ) {\\n\\t\\treturn new jQuery.Event( src, props );\\n\\t}\\n\\n\\t// Event object\\n\\tif ( src && src.type ) {\\n\\t\\tthis.originalEvent = src;\\n\\t\\tthis.type = src.type;\\n\\n\\t\\t// Events bubbling up the document may have been marked as prevented\\n\\t\\t// by a handler lower down the tree; reflect the correct value.\\n\\t\\tthis.isDefaultPrevented = src.defaultPrevented ||\\n\\t\\t\\t\\tsrc.defaultPrevented === undefined &&\\n\\n\\t\\t\\t\\t// Support: Android <=2.3 only\\n\\t\\t\\t\\tsrc.returnValue === false ?\\n\\t\\t\\treturnTrue :\\n\\t\\t\\treturnFalse;\\n\\n\\t\\t// Create target properties\\n\\t\\t// Support: Safari <=6 - 7 only\\n\\t\\t// Target should not be a text node (#504, #13143)\\n\\t\\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\\n\\t\\t\\tsrc.target.parentNode :\\n\\t\\t\\tsrc.target;\\n\\n\\t\\tthis.currentTarget = src.currentTarget;\\n\\t\\tthis.relatedTarget = src.relatedTarget;\\n\\n\\t// Event type\\n\\t} else {\\n\\t\\tthis.type = src;\\n\\t}\\n\\n\\t// Put explicitly provided properties onto the event object\\n\\tif ( props ) {\\n\\t\\tjQuery.extend( this, props );\\n\\t}\\n\\n\\t// Create a timestamp if incoming event doesn't have one\\n\\tthis.timeStamp = src && src.timeStamp || jQuery.now();\\n\\n\\t// Mark it as fixed\\n\\tthis[ jQuery.expando ] = true;\\n};\\n\\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\\njQuery.Event.prototype = {\\n\\tconstructor: jQuery.Event,\\n\\tisDefaultPrevented: returnFalse,\\n\\tisPropagationStopped: returnFalse,\\n\\tisImmediatePropagationStopped: returnFalse,\\n\\tisSimulated: false,\\n\\n\\tpreventDefault: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isDefaultPrevented = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.preventDefault();\\n\\t\\t}\\n\\t},\\n\\tstopPropagation: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isPropagationStopped = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.stopPropagation();\\n\\t\\t}\\n\\t},\\n\\tstopImmediatePropagation: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isImmediatePropagationStopped = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.stopImmediatePropagation();\\n\\t\\t}\\n\\n\\t\\tthis.stopPropagation();\\n\\t}\\n};\\n\\n// Includes all common event props including KeyEvent and MouseEvent specific props\\njQuery.each( {\\n\\taltKey: true,\\n\\tbubbles: true,\\n\\tcancelable: true,\\n\\tchangedTouches: true,\\n\\tctrlKey: true,\\n\\tdetail: true,\\n\\teventPhase: true,\\n\\tmetaKey: true,\\n\\tpageX: true,\\n\\tpageY: true,\\n\\tshiftKey: true,\\n\\tview: true,\\n\\t\\\"char\\\": true,\\n\\tcharCode: true,\\n\\tkey: true,\\n\\tkeyCode: true,\\n\\tbutton: true,\\n\\tbuttons: true,\\n\\tclientX: true,\\n\\tclientY: true,\\n\\toffsetX: true,\\n\\toffsetY: true,\\n\\tpointerId: true,\\n\\tpointerType: true,\\n\\tscreenX: true,\\n\\tscreenY: true,\\n\\ttargetTouches: true,\\n\\ttoElement: true,\\n\\ttouches: true,\\n\\n\\twhich: function( event ) {\\n\\t\\tvar button = event.button;\\n\\n\\t\\t// Add which for key events\\n\\t\\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\\n\\t\\t\\treturn event.charCode != null ? event.charCode : event.keyCode;\\n\\t\\t}\\n\\n\\t\\t// Add which for click: 1 === left; 2 === middle; 3 === right\\n\\t\\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\\n\\t\\t\\tif ( button & 1 ) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( button & 2 ) {\\n\\t\\t\\t\\treturn 3;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( button & 4 ) {\\n\\t\\t\\t\\treturn 2;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\treturn event.which;\\n\\t}\\n}, jQuery.event.addProp );\\n\\n// Create mouseenter/leave events using mouseover/out and event-time checks\\n// so that event delegation works in jQuery.\\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\\n//\\n// Support: Safari 7 only\\n// Safari sends mouseenter too often; see:\\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\\n// for the description of the bug (it existed in older Chrome versions as well).\\njQuery.each( {\\n\\tmouseenter: \\\"mouseover\\\",\\n\\tmouseleave: \\\"mouseout\\\",\\n\\tpointerenter: \\\"pointerover\\\",\\n\\tpointerleave: \\\"pointerout\\\"\\n}, function( orig, fix ) {\\n\\tjQuery.event.special[ orig ] = {\\n\\t\\tdelegateType: fix,\\n\\t\\tbindType: fix,\\n\\n\\t\\thandle: function( event ) {\\n\\t\\t\\tvar ret,\\n\\t\\t\\t\\ttarget = this,\\n\\t\\t\\t\\trelated = event.relatedTarget,\\n\\t\\t\\t\\thandleObj = event.handleObj;\\n\\n\\t\\t\\t// For mouseenter/leave call the handler if related is outside the target.\\n\\t\\t\\t// NB: No relatedTarget if the mouse left/entered the browser window\\n\\t\\t\\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\\n\\t\\t\\t\\tevent.type = handleObj.origType;\\n\\t\\t\\t\\tret = handleObj.handler.apply( this, arguments );\\n\\t\\t\\t\\tevent.type = fix;\\n\\t\\t\\t}\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\t};\\n} );\\n\\njQuery.fn.extend( {\\n\\n\\ton: function( types, selector, data, fn ) {\\n\\t\\treturn on( this, types, selector, data, fn );\\n\\t},\\n\\tone: function( types, selector, data, fn ) {\\n\\t\\treturn on( this, types, selector, data, fn, 1 );\\n\\t},\\n\\toff: function( types, selector, fn ) {\\n\\t\\tvar handleObj, type;\\n\\t\\tif ( types && types.preventDefault && types.handleObj ) {\\n\\n\\t\\t\\t// ( event )  dispatched jQuery.Event\\n\\t\\t\\thandleObj = types.handleObj;\\n\\t\\t\\tjQuery( types.delegateTarget ).off(\\n\\t\\t\\t\\thandleObj.namespace ?\\n\\t\\t\\t\\t\\thandleObj.origType + \\\".\\\" + handleObj.namespace :\\n\\t\\t\\t\\t\\thandleObj.origType,\\n\\t\\t\\t\\thandleObj.selector,\\n\\t\\t\\t\\thandleObj.handler\\n\\t\\t\\t);\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t\\tif ( typeof types === \\\"object\\\" ) {\\n\\n\\t\\t\\t// ( types-object [, selector] )\\n\\t\\t\\tfor ( type in types ) {\\n\\t\\t\\t\\tthis.off( type, selector, types[ type ] );\\n\\t\\t\\t}\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t\\tif ( selector === false || typeof selector === \\\"function\\\" ) {\\n\\n\\t\\t\\t// ( types [, fn] )\\n\\t\\t\\tfn = selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t\\tif ( fn === false ) {\\n\\t\\t\\tfn = returnFalse;\\n\\t\\t}\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.event.remove( this, types, fn, selector );\\n\\t\\t} );\\n\\t}\\n} );\\n\\n\\nvar\\n\\n\\t/* eslint-disable max-len */\\n\\n\\t// See https://github.com/eslint/eslint/issues/3229\\n\\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\\\/\\\\0>\\\\x20\\\\t\\\\r\\\\n\\\\f]*)[^>]*)\\\\/>/gi,\\n\\n\\t/* eslint-enable */\\n\\n\\t// Support: IE <=10 - 11, Edge 12 - 13\\n\\t// In IE/Edge using regex groups here causes severe slowdowns.\\n\\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\\n\\trnoInnerhtml = /<script|<style|<link/i,\\n\\n\\t// checked=\\\"checked\\\" or checked\\n\\trchecked = /checked\\\\s*(?:[^=]|=\\\\s*.checked.)/i,\\n\\trscriptTypeMasked = /^true\\\\/(.*)/,\\n\\trcleanScript = /^\\\\s*<!(?:\\\\[CDATA\\\\[|--)|(?:\\\\]\\\\]|--)>\\\\s*$/g;\\n\\nfunction manipulationTarget( elem, content ) {\\n\\tif ( jQuery.nodeName( elem, \\\"table\\\" ) &&\\n\\t\\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \\\"tr\\\" ) ) {\\n\\n\\t\\treturn elem.getElementsByTagName( \\\"tbody\\\" )[ 0 ] || elem;\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\n// Replace/restore the type attribute of script elements for safe DOM manipulation\\nfunction disableScript( elem ) {\\n\\telem.type = ( elem.getAttribute( \\\"type\\\" ) !== null ) + \\\"/\\\" + elem.type;\\n\\treturn elem;\\n}\\nfunction restoreScript( elem ) {\\n\\tvar match = rscriptTypeMasked.exec( elem.type );\\n\\n\\tif ( match ) {\\n\\t\\telem.type = match[ 1 ];\\n\\t} else {\\n\\t\\telem.removeAttribute( \\\"type\\\" );\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\nfunction cloneCopyEvent( src, dest ) {\\n\\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\\n\\n\\tif ( dest.nodeType !== 1 ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// 1. Copy private data: events, handlers, etc.\\n\\tif ( dataPriv.hasData( src ) ) {\\n\\t\\tpdataOld = dataPriv.access( src );\\n\\t\\tpdataCur = dataPriv.set( dest, pdataOld );\\n\\t\\tevents = pdataOld.events;\\n\\n\\t\\tif ( events ) {\\n\\t\\t\\tdelete pdataCur.handle;\\n\\t\\t\\tpdataCur.events = {};\\n\\n\\t\\t\\tfor ( type in events ) {\\n\\t\\t\\t\\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\\n\\t\\t\\t\\t\\tjQuery.event.add( dest, type, events[ type ][ i ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// 2. Copy user data\\n\\tif ( dataUser.hasData( src ) ) {\\n\\t\\tudataOld = dataUser.access( src );\\n\\t\\tudataCur = jQuery.extend( {}, udataOld );\\n\\n\\t\\tdataUser.set( dest, udataCur );\\n\\t}\\n}\\n\\n// Fix IE bugs, see support tests\\nfunction fixInput( src, dest ) {\\n\\tvar nodeName = dest.nodeName.toLowerCase();\\n\\n\\t// Fails to persist the checked state of a cloned checkbox or radio button.\\n\\tif ( nodeName === \\\"input\\\" && rcheckableType.test( src.type ) ) {\\n\\t\\tdest.checked = src.checked;\\n\\n\\t// Fails to return the selected option to the default selected state when cloning options\\n\\t} else if ( nodeName === \\\"input\\\" || nodeName === \\\"textarea\\\" ) {\\n\\t\\tdest.defaultValue = src.defaultValue;\\n\\t}\\n}\\n\\nfunction domManip( collection, args, callback, ignored ) {\\n\\n\\t// Flatten any nested arrays\\n\\targs = concat.apply( [], args );\\n\\n\\tvar fragment, first, scripts, hasScripts, node, doc,\\n\\t\\ti = 0,\\n\\t\\tl = collection.length,\\n\\t\\tiNoClone = l - 1,\\n\\t\\tvalue = args[ 0 ],\\n\\t\\tisFunction = jQuery.isFunction( value );\\n\\n\\t// We can't cloneNode fragments that contain checked, in WebKit\\n\\tif ( isFunction ||\\n\\t\\t\\t( l > 1 && typeof value === \\\"string\\\" &&\\n\\t\\t\\t\\t!support.checkClone && rchecked.test( value ) ) ) {\\n\\t\\treturn collection.each( function( index ) {\\n\\t\\t\\tvar self = collection.eq( index );\\n\\t\\t\\tif ( isFunction ) {\\n\\t\\t\\t\\targs[ 0 ] = value.call( this, index, self.html() );\\n\\t\\t\\t}\\n\\t\\t\\tdomManip( self, args, callback, ignored );\\n\\t\\t} );\\n\\t}\\n\\n\\tif ( l ) {\\n\\t\\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\\n\\t\\tfirst = fragment.firstChild;\\n\\n\\t\\tif ( fragment.childNodes.length === 1 ) {\\n\\t\\t\\tfragment = first;\\n\\t\\t}\\n\\n\\t\\t// Require either new content or an interest in ignored elements to invoke the callback\\n\\t\\tif ( first || ignored ) {\\n\\t\\t\\tscripts = jQuery.map( getAll( fragment, \\\"script\\\" ), disableScript );\\n\\t\\t\\thasScripts = scripts.length;\\n\\n\\t\\t\\t// Use the original fragment for the last item\\n\\t\\t\\t// instead of the first because it can end up\\n\\t\\t\\t// being emptied incorrectly in certain situations (#8070).\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tnode = fragment;\\n\\n\\t\\t\\t\\tif ( i !== iNoClone ) {\\n\\t\\t\\t\\t\\tnode = jQuery.clone( node, true, true );\\n\\n\\t\\t\\t\\t\\t// Keep references to cloned scripts for later restoration\\n\\t\\t\\t\\t\\tif ( hasScripts ) {\\n\\n\\t\\t\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\t\\t\\tjQuery.merge( scripts, getAll( node, \\\"script\\\" ) );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcallback.call( collection[ i ], node, i );\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( hasScripts ) {\\n\\t\\t\\t\\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\\n\\n\\t\\t\\t\\t// Reenable scripts\\n\\t\\t\\t\\tjQuery.map( scripts, restoreScript );\\n\\n\\t\\t\\t\\t// Evaluate executable scripts on first document insertion\\n\\t\\t\\t\\tfor ( i = 0; i < hasScripts; i++ ) {\\n\\t\\t\\t\\t\\tnode = scripts[ i ];\\n\\t\\t\\t\\t\\tif ( rscriptType.test( node.type || \\\"\\\" ) &&\\n\\t\\t\\t\\t\\t\\t!dataPriv.access( node, \\\"globalEval\\\" ) &&\\n\\t\\t\\t\\t\\t\\tjQuery.contains( doc, node ) ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( node.src ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Optional AJAX dependency, but won't run scripts if not present\\n\\t\\t\\t\\t\\t\\t\\tif ( jQuery._evalUrl ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery._evalUrl( node.src );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tDOMEval( node.textContent.replace( rcleanScript, \\\"\\\" ), doc );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn collection;\\n}\\n\\nfunction remove( elem, selector, keepData ) {\\n\\tvar node,\\n\\t\\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\\n\\t\\ti = 0;\\n\\n\\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\\n\\t\\tif ( !keepData && node.nodeType === 1 ) {\\n\\t\\t\\tjQuery.cleanData( getAll( node ) );\\n\\t\\t}\\n\\n\\t\\tif ( node.parentNode ) {\\n\\t\\t\\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\\n\\t\\t\\t\\tsetGlobalEval( getAll( node, \\\"script\\\" ) );\\n\\t\\t\\t}\\n\\t\\t\\tnode.parentNode.removeChild( node );\\n\\t\\t}\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\njQuery.extend( {\\n\\thtmlPrefilter: function( html ) {\\n\\t\\treturn html.replace( rxhtmlTag, \\\"<$1></$2>\\\" );\\n\\t},\\n\\n\\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\\n\\t\\tvar i, l, srcElements, destElements,\\n\\t\\t\\tclone = elem.cloneNode( true ),\\n\\t\\t\\tinPage = jQuery.contains( elem.ownerDocument, elem );\\n\\n\\t\\t// Fix IE cloning issues\\n\\t\\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\\n\\t\\t\\t\\t!jQuery.isXMLDoc( elem ) ) {\\n\\n\\t\\t\\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\\n\\t\\t\\tdestElements = getAll( clone );\\n\\t\\t\\tsrcElements = getAll( elem );\\n\\n\\t\\t\\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\\n\\t\\t\\t\\tfixInput( srcElements[ i ], destElements[ i ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Copy the events from the original to the clone\\n\\t\\tif ( dataAndEvents ) {\\n\\t\\t\\tif ( deepDataAndEvents ) {\\n\\t\\t\\t\\tsrcElements = srcElements || getAll( elem );\\n\\t\\t\\t\\tdestElements = destElements || getAll( clone );\\n\\n\\t\\t\\t\\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcloneCopyEvent( elem, clone );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Preserve script evaluation history\\n\\t\\tdestElements = getAll( clone, \\\"script\\\" );\\n\\t\\tif ( destElements.length > 0 ) {\\n\\t\\t\\tsetGlobalEval( destElements, !inPage && getAll( elem, \\\"script\\\" ) );\\n\\t\\t}\\n\\n\\t\\t// Return the cloned set\\n\\t\\treturn clone;\\n\\t},\\n\\n\\tcleanData: function( elems ) {\\n\\t\\tvar data, elem, type,\\n\\t\\t\\tspecial = jQuery.event.special,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\\n\\t\\t\\tif ( acceptData( elem ) ) {\\n\\t\\t\\t\\tif ( ( data = elem[ dataPriv.expando ] ) ) {\\n\\t\\t\\t\\t\\tif ( data.events ) {\\n\\t\\t\\t\\t\\t\\tfor ( type in data.events ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( special[ type ] ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.event.remove( elem, type );\\n\\n\\t\\t\\t\\t\\t\\t\\t// This is a shortcut to avoid jQuery.event.remove's overhead\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.removeEvent( elem, type, data.handle );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Support: Chrome <=35 - 45+\\n\\t\\t\\t\\t\\t// Assign undefined instead of using delete, see Data#remove\\n\\t\\t\\t\\t\\telem[ dataPriv.expando ] = undefined;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( elem[ dataUser.expando ] ) {\\n\\n\\t\\t\\t\\t\\t// Support: Chrome <=35 - 45+\\n\\t\\t\\t\\t\\t// Assign undefined instead of using delete, see Data#remove\\n\\t\\t\\t\\t\\telem[ dataUser.expando ] = undefined;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tdetach: function( selector ) {\\n\\t\\treturn remove( this, selector, true );\\n\\t},\\n\\n\\tremove: function( selector ) {\\n\\t\\treturn remove( this, selector );\\n\\t},\\n\\n\\ttext: function( value ) {\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\treturn value === undefined ?\\n\\t\\t\\t\\tjQuery.text( this ) :\\n\\t\\t\\t\\tthis.empty().each( function() {\\n\\t\\t\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\t\\t\\tthis.textContent = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} );\\n\\t\\t}, null, value, arguments.length );\\n\\t},\\n\\n\\tappend: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\tvar target = manipulationTarget( this, elem );\\n\\t\\t\\t\\ttarget.appendChild( elem );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tprepend: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\tvar target = manipulationTarget( this, elem );\\n\\t\\t\\t\\ttarget.insertBefore( elem, target.firstChild );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tbefore: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.parentNode ) {\\n\\t\\t\\t\\tthis.parentNode.insertBefore( elem, this );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tafter: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.parentNode ) {\\n\\t\\t\\t\\tthis.parentNode.insertBefore( elem, this.nextSibling );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tempty: function() {\\n\\t\\tvar elem,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\\n\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\n\\t\\t\\t\\t// Prevent memory leaks\\n\\t\\t\\t\\tjQuery.cleanData( getAll( elem, false ) );\\n\\n\\t\\t\\t\\t// Remove any remaining nodes\\n\\t\\t\\t\\telem.textContent = \\\"\\\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\tclone: function( dataAndEvents, deepDataAndEvents ) {\\n\\t\\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\\n\\t\\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\\n\\n\\t\\treturn this.map( function() {\\n\\t\\t\\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\\n\\t\\t} );\\n\\t},\\n\\n\\thtml: function( value ) {\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\tvar elem = this[ 0 ] || {},\\n\\t\\t\\t\\ti = 0,\\n\\t\\t\\t\\tl = this.length;\\n\\n\\t\\t\\tif ( value === undefined && elem.nodeType === 1 ) {\\n\\t\\t\\t\\treturn elem.innerHTML;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// See if we can take a shortcut and just use innerHTML\\n\\t\\t\\tif ( typeof value === \\\"string\\\" && !rnoInnerhtml.test( value ) &&\\n\\t\\t\\t\\t!wrapMap[ ( rtagName.exec( value ) || [ \\\"\\\", \\\"\\\" ] )[ 1 ].toLowerCase() ] ) {\\n\\n\\t\\t\\t\\tvalue = jQuery.htmlPrefilter( value );\\n\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\t\\t\\telem = this[ i ] || {};\\n\\n\\t\\t\\t\\t\\t\\t// Remove element nodes and prevent memory leaks\\n\\t\\t\\t\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\t\\t\\t\\t\\tjQuery.cleanData( getAll( elem, false ) );\\n\\t\\t\\t\\t\\t\\t\\telem.innerHTML = value;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telem = 0;\\n\\n\\t\\t\\t\\t// If using innerHTML throws an exception, use the fallback method\\n\\t\\t\\t\\t} catch ( e ) {}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( elem ) {\\n\\t\\t\\t\\tthis.empty().append( value );\\n\\t\\t\\t}\\n\\t\\t}, null, value, arguments.length );\\n\\t},\\n\\n\\treplaceWith: function() {\\n\\t\\tvar ignored = [];\\n\\n\\t\\t// Make the changes, replacing each non-ignored context element with the new content\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tvar parent = this.parentNode;\\n\\n\\t\\t\\tif ( jQuery.inArray( this, ignored ) < 0 ) {\\n\\t\\t\\t\\tjQuery.cleanData( getAll( this ) );\\n\\t\\t\\t\\tif ( parent ) {\\n\\t\\t\\t\\t\\tparent.replaceChild( elem, this );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Force callback invocation\\n\\t\\t}, ignored );\\n\\t}\\n} );\\n\\njQuery.each( {\\n\\tappendTo: \\\"append\\\",\\n\\tprependTo: \\\"prepend\\\",\\n\\tinsertBefore: \\\"before\\\",\\n\\tinsertAfter: \\\"after\\\",\\n\\treplaceAll: \\\"replaceWith\\\"\\n}, function( name, original ) {\\n\\tjQuery.fn[ name ] = function( selector ) {\\n\\t\\tvar elems,\\n\\t\\t\\tret = [],\\n\\t\\t\\tinsert = jQuery( selector ),\\n\\t\\t\\tlast = insert.length - 1,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; i <= last; i++ ) {\\n\\t\\t\\telems = i === last ? this : this.clone( true );\\n\\t\\t\\tjQuery( insert[ i ] )[ original ]( elems );\\n\\n\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\tpush.apply( ret, elems.get() );\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( ret );\\n\\t};\\n} );\\nvar rmargin = ( /^margin/ );\\n\\nvar rnumnonpx = new RegExp( \\\"^(\\\" + pnum + \\\")(?!px)[a-z%]+$\\\", \\\"i\\\" );\\n\\nvar getStyles = function( elem ) {\\n\\n\\t\\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\\n\\t\\t// IE throws on elements created in popups\\n\\t\\t// FF meanwhile throws on frame elements through \\\"defaultView.getComputedStyle\\\"\\n\\t\\tvar view = elem.ownerDocument.defaultView;\\n\\n\\t\\tif ( !view || !view.opener ) {\\n\\t\\t\\tview = window;\\n\\t\\t}\\n\\n\\t\\treturn view.getComputedStyle( elem );\\n\\t};\\n\\n\\n\\n( function() {\\n\\n\\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\\n\\t// so they're executed at the same time to save the second computation.\\n\\tfunction computeStyleTests() {\\n\\n\\t\\t// This is a singleton, we need to execute it only once\\n\\t\\tif ( !div ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tdiv.style.cssText =\\n\\t\\t\\t\\\"box-sizing:border-box;\\\" +\\n\\t\\t\\t\\\"position:relative;display:block;\\\" +\\n\\t\\t\\t\\\"margin:auto;border:1px;padding:1px;\\\" +\\n\\t\\t\\t\\\"top:1%;width:50%\\\";\\n\\t\\tdiv.innerHTML = \\\"\\\";\\n\\t\\tdocumentElement.appendChild( container );\\n\\n\\t\\tvar divStyle = window.getComputedStyle( div );\\n\\t\\tpixelPositionVal = divStyle.top !== \\\"1%\\\";\\n\\n\\t\\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\\n\\t\\treliableMarginLeftVal = divStyle.marginLeft === \\\"2px\\\";\\n\\t\\tboxSizingReliableVal = divStyle.width === \\\"4px\\\";\\n\\n\\t\\t// Support: Android 4.0 - 4.3 only\\n\\t\\t// Some styles come back with percentage values, even though they shouldn't\\n\\t\\tdiv.style.marginRight = \\\"50%\\\";\\n\\t\\tpixelMarginRightVal = divStyle.marginRight === \\\"4px\\\";\\n\\n\\t\\tdocumentElement.removeChild( container );\\n\\n\\t\\t// Nullify the div so it wouldn't be stored in the memory and\\n\\t\\t// it will also be a sign that checks already performed\\n\\t\\tdiv = null;\\n\\t}\\n\\n\\tvar pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,\\n\\t\\tcontainer = document.createElement( \\\"div\\\" ),\\n\\t\\tdiv = document.createElement( \\\"div\\\" );\\n\\n\\t// Finish early in limited (non-browser) environments\\n\\tif ( !div.style ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// Support: IE <=9 - 11 only\\n\\t// Style of cloned element affects source element cloned (#8908)\\n\\tdiv.style.backgroundClip = \\\"content-box\\\";\\n\\tdiv.cloneNode( true ).style.backgroundClip = \\\"\\\";\\n\\tsupport.clearCloneStyle = div.style.backgroundClip === \\\"content-box\\\";\\n\\n\\tcontainer.style.cssText = \\\"border:0;width:8px;height:0;top:0;left:-9999px;\\\" +\\n\\t\\t\\\"padding:0;margin-top:1px;position:absolute\\\";\\n\\tcontainer.appendChild( div );\\n\\n\\tjQuery.extend( support, {\\n\\t\\tpixelPosition: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn pixelPositionVal;\\n\\t\\t},\\n\\t\\tboxSizingReliable: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn boxSizingReliableVal;\\n\\t\\t},\\n\\t\\tpixelMarginRight: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn pixelMarginRightVal;\\n\\t\\t},\\n\\t\\treliableMarginLeft: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn reliableMarginLeftVal;\\n\\t\\t}\\n\\t} );\\n} )();\\n\\n\\nfunction curCSS( elem, name, computed ) {\\n\\tvar width, minWidth, maxWidth, ret,\\n\\t\\tstyle = elem.style;\\n\\n\\tcomputed = computed || getStyles( elem );\\n\\n\\t// Support: IE <=9 only\\n\\t// getPropertyValue is only needed for .css('filter') (#12537)\\n\\tif ( computed ) {\\n\\t\\tret = computed.getPropertyValue( name ) || computed[ name ];\\n\\n\\t\\tif ( ret === \\\"\\\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\\n\\t\\t\\tret = jQuery.style( elem, name );\\n\\t\\t}\\n\\n\\t\\t// A tribute to the \\\"awesome hack by Dean Edwards\\\"\\n\\t\\t// Android Browser returns percentage for some values,\\n\\t\\t// but width seems to be reliably pixels.\\n\\t\\t// This is against the CSSOM draft spec:\\n\\t\\t// https://drafts.csswg.org/cssom/#resolved-values\\n\\t\\tif ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\\n\\n\\t\\t\\t// Remember the original values\\n\\t\\t\\twidth = style.width;\\n\\t\\t\\tminWidth = style.minWidth;\\n\\t\\t\\tmaxWidth = style.maxWidth;\\n\\n\\t\\t\\t// Put in the new values to get a computed value out\\n\\t\\t\\tstyle.minWidth = style.maxWidth = style.width = ret;\\n\\t\\t\\tret = computed.width;\\n\\n\\t\\t\\t// Revert the changed values\\n\\t\\t\\tstyle.width = width;\\n\\t\\t\\tstyle.minWidth = minWidth;\\n\\t\\t\\tstyle.maxWidth = maxWidth;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ret !== undefined ?\\n\\n\\t\\t// Support: IE <=9 - 11 only\\n\\t\\t// IE returns zIndex value as an integer.\\n\\t\\tret + \\\"\\\" :\\n\\t\\tret;\\n}\\n\\n\\nfunction addGetHookIf( conditionFn, hookFn ) {\\n\\n\\t// Define the hook, we'll check on the first run if it's really needed.\\n\\treturn {\\n\\t\\tget: function() {\\n\\t\\t\\tif ( conditionFn() ) {\\n\\n\\t\\t\\t\\t// Hook not needed (or it's not possible to use it due\\n\\t\\t\\t\\t// to missing dependency), remove it.\\n\\t\\t\\t\\tdelete this.get;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Hook needed; redefine it so that the support test is not executed again.\\n\\t\\t\\treturn ( this.get = hookFn ).apply( this, arguments );\\n\\t\\t}\\n\\t};\\n}\\n\\n\\nvar\\n\\n\\t// Swappable if display is none or starts with table\\n\\t// except \\\"table\\\", \\\"table-cell\\\", or \\\"table-caption\\\"\\n\\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\\n\\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\\n\\tcssShow = { position: \\\"absolute\\\", visibility: \\\"hidden\\\", display: \\\"block\\\" },\\n\\tcssNormalTransform = {\\n\\t\\tletterSpacing: \\\"0\\\",\\n\\t\\tfontWeight: \\\"400\\\"\\n\\t},\\n\\n\\tcssPrefixes = [ \\\"Webkit\\\", \\\"Moz\\\", \\\"ms\\\" ],\\n\\temptyStyle = document.createElement( \\\"div\\\" ).style;\\n\\n// Return a css property mapped to a potentially vendor prefixed property\\nfunction vendorPropName( name ) {\\n\\n\\t// Shortcut for names that are not vendor prefixed\\n\\tif ( name in emptyStyle ) {\\n\\t\\treturn name;\\n\\t}\\n\\n\\t// Check for vendor prefixed names\\n\\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\\n\\t\\ti = cssPrefixes.length;\\n\\n\\twhile ( i-- ) {\\n\\t\\tname = cssPrefixes[ i ] + capName;\\n\\t\\tif ( name in emptyStyle ) {\\n\\t\\t\\treturn name;\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction setPositiveNumber( elem, value, subtract ) {\\n\\n\\t// Any relative (+/-) values have already been\\n\\t// normalized at this point\\n\\tvar matches = rcssNum.exec( value );\\n\\treturn matches ?\\n\\n\\t\\t// Guard against undefined \\\"subtract\\\", e.g., when used as in cssHooks\\n\\t\\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \\\"px\\\" ) :\\n\\t\\tvalue;\\n}\\n\\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\\n\\tvar i,\\n\\t\\tval = 0;\\n\\n\\t// If we already have the right measurement, avoid augmentation\\n\\tif ( extra === ( isBorderBox ? \\\"border\\\" : \\\"content\\\" ) ) {\\n\\t\\ti = 4;\\n\\n\\t// Otherwise initialize for horizontal or vertical properties\\n\\t} else {\\n\\t\\ti = name === \\\"width\\\" ? 1 : 0;\\n\\t}\\n\\n\\tfor ( ; i < 4; i += 2 ) {\\n\\n\\t\\t// Both box models exclude margin, so add it if we want it\\n\\t\\tif ( extra === \\\"margin\\\" ) {\\n\\t\\t\\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\\n\\t\\t}\\n\\n\\t\\tif ( isBorderBox ) {\\n\\n\\t\\t\\t// border-box includes padding, so remove it if we want content\\n\\t\\t\\tif ( extra === \\\"content\\\" ) {\\n\\t\\t\\t\\tval -= jQuery.css( elem, \\\"padding\\\" + cssExpand[ i ], true, styles );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// At this point, extra isn't border nor margin, so remove border\\n\\t\\t\\tif ( extra !== \\\"margin\\\" ) {\\n\\t\\t\\t\\tval -= jQuery.css( elem, \\\"border\\\" + cssExpand[ i ] + \\\"Width\\\", true, styles );\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\n\\t\\t\\t// At this point, extra isn't content, so add padding\\n\\t\\t\\tval += jQuery.css( elem, \\\"padding\\\" + cssExpand[ i ], true, styles );\\n\\n\\t\\t\\t// At this point, extra isn't content nor padding, so add border\\n\\t\\t\\tif ( extra !== \\\"padding\\\" ) {\\n\\t\\t\\t\\tval += jQuery.css( elem, \\\"border\\\" + cssExpand[ i ] + \\\"Width\\\", true, styles );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn val;\\n}\\n\\nfunction getWidthOrHeight( elem, name, extra ) {\\n\\n\\t// Start with offset property, which is equivalent to the border-box value\\n\\tvar val,\\n\\t\\tvalueIsBorderBox = true,\\n\\t\\tstyles = getStyles( elem ),\\n\\t\\tisBorderBox = jQuery.css( elem, \\\"boxSizing\\\", false, styles ) === \\\"border-box\\\";\\n\\n\\t// Support: IE <=11 only\\n\\t// Running getBoundingClientRect on a disconnected node\\n\\t// in IE throws an error.\\n\\tif ( elem.getClientRects().length ) {\\n\\t\\tval = elem.getBoundingClientRect()[ name ];\\n\\t}\\n\\n\\t// Some non-html elements return undefined for offsetWidth, so check for null/undefined\\n\\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\\n\\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\\n\\tif ( val <= 0 || val == null ) {\\n\\n\\t\\t// Fall back to computed then uncomputed css if necessary\\n\\t\\tval = curCSS( elem, name, styles );\\n\\t\\tif ( val < 0 || val == null ) {\\n\\t\\t\\tval = elem.style[ name ];\\n\\t\\t}\\n\\n\\t\\t// Computed unit is not pixels. Stop here and return.\\n\\t\\tif ( rnumnonpx.test( val ) ) {\\n\\t\\t\\treturn val;\\n\\t\\t}\\n\\n\\t\\t// Check for style in case a browser which returns unreliable values\\n\\t\\t// for getComputedStyle silently falls back to the reliable elem.style\\n\\t\\tvalueIsBorderBox = isBorderBox &&\\n\\t\\t\\t( support.boxSizingReliable() || val === elem.style[ name ] );\\n\\n\\t\\t// Normalize \\\"\\\", auto, and prepare for extra\\n\\t\\tval = parseFloat( val ) || 0;\\n\\t}\\n\\n\\t// Use the active box-sizing model to add/subtract irrelevant styles\\n\\treturn ( val +\\n\\t\\taugmentWidthOrHeight(\\n\\t\\t\\telem,\\n\\t\\t\\tname,\\n\\t\\t\\textra || ( isBorderBox ? \\\"border\\\" : \\\"content\\\" ),\\n\\t\\t\\tvalueIsBorderBox,\\n\\t\\t\\tstyles\\n\\t\\t)\\n\\t) + \\\"px\\\";\\n}\\n\\njQuery.extend( {\\n\\n\\t// Add in style property hooks for overriding the default\\n\\t// behavior of getting and setting a style property\\n\\tcssHooks: {\\n\\t\\topacity: {\\n\\t\\t\\tget: function( elem, computed ) {\\n\\t\\t\\t\\tif ( computed ) {\\n\\n\\t\\t\\t\\t\\t// We should always get a number back from opacity\\n\\t\\t\\t\\t\\tvar ret = curCSS( elem, \\\"opacity\\\" );\\n\\t\\t\\t\\t\\treturn ret === \\\"\\\" ? \\\"1\\\" : ret;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\t// Don't automatically add \\\"px\\\" to these possibly-unitless properties\\n\\tcssNumber: {\\n\\t\\t\\\"animationIterationCount\\\": true,\\n\\t\\t\\\"columnCount\\\": true,\\n\\t\\t\\\"fillOpacity\\\": true,\\n\\t\\t\\\"flexGrow\\\": true,\\n\\t\\t\\\"flexShrink\\\": true,\\n\\t\\t\\\"fontWeight\\\": true,\\n\\t\\t\\\"lineHeight\\\": true,\\n\\t\\t\\\"opacity\\\": true,\\n\\t\\t\\\"order\\\": true,\\n\\t\\t\\\"orphans\\\": true,\\n\\t\\t\\\"widows\\\": true,\\n\\t\\t\\\"zIndex\\\": true,\\n\\t\\t\\\"zoom\\\": true\\n\\t},\\n\\n\\t// Add in properties whose names you wish to fix before\\n\\t// setting or getting the value\\n\\tcssProps: {\\n\\t\\t\\\"float\\\": \\\"cssFloat\\\"\\n\\t},\\n\\n\\t// Get and set the style property on a DOM Node\\n\\tstyle: function( elem, name, value, extra ) {\\n\\n\\t\\t// Don't set styles on text and comment nodes\\n\\t\\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Make sure that we're working with the right name\\n\\t\\tvar ret, type, hooks,\\n\\t\\t\\torigName = jQuery.camelCase( name ),\\n\\t\\t\\tstyle = elem.style;\\n\\n\\t\\tname = jQuery.cssProps[ origName ] ||\\n\\t\\t\\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\\n\\n\\t\\t// Gets hook for the prefixed version, then unprefixed version\\n\\t\\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\\n\\n\\t\\t// Check if we're setting a value\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\ttype = typeof value;\\n\\n\\t\\t\\t// Convert \\\"+=\\\" or \\\"-=\\\" to relative numbers (#7345)\\n\\t\\t\\tif ( type === \\\"string\\\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\\n\\t\\t\\t\\tvalue = adjustCSS( elem, name, ret );\\n\\n\\t\\t\\t\\t// Fixes bug #9237\\n\\t\\t\\t\\ttype = \\\"number\\\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Make sure that null and NaN values aren't set (#7116)\\n\\t\\t\\tif ( value == null || value !== value ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If a number was passed in, add the unit (except for certain CSS properties)\\n\\t\\t\\tif ( type === \\\"number\\\" ) {\\n\\t\\t\\t\\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \\\"\\\" : \\\"px\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// background-* props affect original clone's values\\n\\t\\t\\tif ( !support.clearCloneStyle && value === \\\"\\\" && name.indexOf( \\\"background\\\" ) === 0 ) {\\n\\t\\t\\t\\tstyle[ name ] = \\\"inherit\\\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If a hook was provided, use that value, otherwise just set the specified value\\n\\t\\t\\tif ( !hooks || !( \\\"set\\\" in hooks ) ||\\n\\t\\t\\t\\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\\n\\n\\t\\t\\t\\tstyle[ name ] = value;\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t// If a hook was provided get the non-computed value from there\\n\\t\\t\\tif ( hooks && \\\"get\\\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\\n\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Otherwise just get the value from the style object\\n\\t\\t\\treturn style[ name ];\\n\\t\\t}\\n\\t},\\n\\n\\tcss: function( elem, name, extra, styles ) {\\n\\t\\tvar val, num, hooks,\\n\\t\\t\\torigName = jQuery.camelCase( name );\\n\\n\\t\\t// Make sure that we're working with the right name\\n\\t\\tname = jQuery.cssProps[ origName ] ||\\n\\t\\t\\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\\n\\n\\t\\t// Try prefixed name followed by the unprefixed name\\n\\t\\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\\n\\n\\t\\t// If a hook was provided get the computed value from there\\n\\t\\tif ( hooks && \\\"get\\\" in hooks ) {\\n\\t\\t\\tval = hooks.get( elem, true, extra );\\n\\t\\t}\\n\\n\\t\\t// Otherwise, if a way to get the computed value exists, use that\\n\\t\\tif ( val === undefined ) {\\n\\t\\t\\tval = curCSS( elem, name, styles );\\n\\t\\t}\\n\\n\\t\\t// Convert \\\"normal\\\" to computed value\\n\\t\\tif ( val === \\\"normal\\\" && name in cssNormalTransform ) {\\n\\t\\t\\tval = cssNormalTransform[ name ];\\n\\t\\t}\\n\\n\\t\\t// Make numeric if forced or a qualifier was provided and val looks numeric\\n\\t\\tif ( extra === \\\"\\\" || extra ) {\\n\\t\\t\\tnum = parseFloat( val );\\n\\t\\t\\treturn extra === true || isFinite( num ) ? num || 0 : val;\\n\\t\\t}\\n\\t\\treturn val;\\n\\t}\\n} );\\n\\njQuery.each( [ \\\"height\\\", \\\"width\\\" ], function( i, name ) {\\n\\tjQuery.cssHooks[ name ] = {\\n\\t\\tget: function( elem, computed, extra ) {\\n\\t\\t\\tif ( computed ) {\\n\\n\\t\\t\\t\\t// Certain elements can have dimension info if we invisibly show them\\n\\t\\t\\t\\t// but it must have a current display style that would benefit\\n\\t\\t\\t\\treturn rdisplayswap.test( jQuery.css( elem, \\\"display\\\" ) ) &&\\n\\n\\t\\t\\t\\t\\t// Support: Safari 8+\\n\\t\\t\\t\\t\\t// Table columns in Safari have non-zero offsetWidth & zero\\n\\t\\t\\t\\t\\t// getBoundingClientRect().width unless display is changed.\\n\\t\\t\\t\\t\\t// Support: IE <=11 only\\n\\t\\t\\t\\t\\t// Running getBoundingClientRect on a disconnected node\\n\\t\\t\\t\\t\\t// in IE throws an error.\\n\\t\\t\\t\\t\\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\\n\\t\\t\\t\\t\\t\\tswap( elem, cssShow, function() {\\n\\t\\t\\t\\t\\t\\t\\treturn getWidthOrHeight( elem, name, extra );\\n\\t\\t\\t\\t\\t\\t} ) :\\n\\t\\t\\t\\t\\t\\tgetWidthOrHeight( elem, name, extra );\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tset: function( elem, value, extra ) {\\n\\t\\t\\tvar matches,\\n\\t\\t\\t\\tstyles = extra && getStyles( elem ),\\n\\t\\t\\t\\tsubtract = extra && augmentWidthOrHeight(\\n\\t\\t\\t\\t\\telem,\\n\\t\\t\\t\\t\\tname,\\n\\t\\t\\t\\t\\textra,\\n\\t\\t\\t\\t\\tjQuery.css( elem, \\\"boxSizing\\\", false, styles ) === \\\"border-box\\\",\\n\\t\\t\\t\\t\\tstyles\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t// Convert to pixels if value adjustment is needed\\n\\t\\t\\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\\n\\t\\t\\t\\t( matches[ 3 ] || \\\"px\\\" ) !== \\\"px\\\" ) {\\n\\n\\t\\t\\t\\telem.style[ name ] = value;\\n\\t\\t\\t\\tvalue = jQuery.css( elem, name );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn setPositiveNumber( elem, value, subtract );\\n\\t\\t}\\n\\t};\\n} );\\n\\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\\n\\tfunction( elem, computed ) {\\n\\t\\tif ( computed ) {\\n\\t\\t\\treturn ( parseFloat( curCSS( elem, \\\"marginLeft\\\" ) ) ||\\n\\t\\t\\t\\telem.getBoundingClientRect().left -\\n\\t\\t\\t\\t\\tswap( elem, { marginLeft: 0 }, function() {\\n\\t\\t\\t\\t\\t\\treturn elem.getBoundingClientRect().left;\\n\\t\\t\\t\\t\\t} )\\n\\t\\t\\t\\t) + \\\"px\\\";\\n\\t\\t}\\n\\t}\\n);\\n\\n// These hooks are used by animate to expand properties\\njQuery.each( {\\n\\tmargin: \\\"\\\",\\n\\tpadding: \\\"\\\",\\n\\tborder: \\\"Width\\\"\\n}, function( prefix, suffix ) {\\n\\tjQuery.cssHooks[ prefix + suffix ] = {\\n\\t\\texpand: function( value ) {\\n\\t\\t\\tvar i = 0,\\n\\t\\t\\t\\texpanded = {},\\n\\n\\t\\t\\t\\t// Assumes a single number if not a string\\n\\t\\t\\t\\tparts = typeof value === \\\"string\\\" ? value.split( \\\" \\\" ) : [ value ];\\n\\n\\t\\t\\tfor ( ; i < 4; i++ ) {\\n\\t\\t\\t\\texpanded[ prefix + cssExpand[ i ] + suffix ] =\\n\\t\\t\\t\\t\\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn expanded;\\n\\t\\t}\\n\\t};\\n\\n\\tif ( !rmargin.test( prefix ) ) {\\n\\t\\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tcss: function( name, value ) {\\n\\t\\treturn access( this, function( elem, name, value ) {\\n\\t\\t\\tvar styles, len,\\n\\t\\t\\t\\tmap = {},\\n\\t\\t\\t\\ti = 0;\\n\\n\\t\\t\\tif ( jQuery.isArray( name ) ) {\\n\\t\\t\\t\\tstyles = getStyles( elem );\\n\\t\\t\\t\\tlen = name.length;\\n\\n\\t\\t\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\t\\t\\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn map;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn value !== undefined ?\\n\\t\\t\\t\\tjQuery.style( elem, name, value ) :\\n\\t\\t\\t\\tjQuery.css( elem, name );\\n\\t\\t}, name, value, arguments.length > 1 );\\n\\t}\\n} );\\n\\n\\nfunction Tween( elem, options, prop, end, easing ) {\\n\\treturn new Tween.prototype.init( elem, options, prop, end, easing );\\n}\\njQuery.Tween = Tween;\\n\\nTween.prototype = {\\n\\tconstructor: Tween,\\n\\tinit: function( elem, options, prop, end, easing, unit ) {\\n\\t\\tthis.elem = elem;\\n\\t\\tthis.prop = prop;\\n\\t\\tthis.easing = easing || jQuery.easing._default;\\n\\t\\tthis.options = options;\\n\\t\\tthis.start = this.now = this.cur();\\n\\t\\tthis.end = end;\\n\\t\\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \\\"\\\" : \\\"px\\\" );\\n\\t},\\n\\tcur: function() {\\n\\t\\tvar hooks = Tween.propHooks[ this.prop ];\\n\\n\\t\\treturn hooks && hooks.get ?\\n\\t\\t\\thooks.get( this ) :\\n\\t\\t\\tTween.propHooks._default.get( this );\\n\\t},\\n\\trun: function( percent ) {\\n\\t\\tvar eased,\\n\\t\\t\\thooks = Tween.propHooks[ this.prop ];\\n\\n\\t\\tif ( this.options.duration ) {\\n\\t\\t\\tthis.pos = eased = jQuery.easing[ this.easing ](\\n\\t\\t\\t\\tpercent, this.options.duration * percent, 0, 1, this.options.duration\\n\\t\\t\\t);\\n\\t\\t} else {\\n\\t\\t\\tthis.pos = eased = percent;\\n\\t\\t}\\n\\t\\tthis.now = ( this.end - this.start ) * eased + this.start;\\n\\n\\t\\tif ( this.options.step ) {\\n\\t\\t\\tthis.options.step.call( this.elem, this.now, this );\\n\\t\\t}\\n\\n\\t\\tif ( hooks && hooks.set ) {\\n\\t\\t\\thooks.set( this );\\n\\t\\t} else {\\n\\t\\t\\tTween.propHooks._default.set( this );\\n\\t\\t}\\n\\t\\treturn this;\\n\\t}\\n};\\n\\nTween.prototype.init.prototype = Tween.prototype;\\n\\nTween.propHooks = {\\n\\t_default: {\\n\\t\\tget: function( tween ) {\\n\\t\\t\\tvar result;\\n\\n\\t\\t\\t// Use a property on the element directly when it is not a DOM element,\\n\\t\\t\\t// or when there is no matching style property that exists.\\n\\t\\t\\tif ( tween.elem.nodeType !== 1 ||\\n\\t\\t\\t\\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\\n\\t\\t\\t\\treturn tween.elem[ tween.prop ];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Passing an empty string as a 3rd parameter to .css will automatically\\n\\t\\t\\t// attempt a parseFloat and fallback to a string if the parse fails.\\n\\t\\t\\t// Simple values such as \\\"10px\\\" are parsed to Float;\\n\\t\\t\\t// complex values such as \\\"rotate(1rad)\\\" are returned as-is.\\n\\t\\t\\tresult = jQuery.css( tween.elem, tween.prop, \\\"\\\" );\\n\\n\\t\\t\\t// Empty strings, null, undefined and \\\"auto\\\" are converted to 0.\\n\\t\\t\\treturn !result || result === \\\"auto\\\" ? 0 : result;\\n\\t\\t},\\n\\t\\tset: function( tween ) {\\n\\n\\t\\t\\t// Use step hook for back compat.\\n\\t\\t\\t// Use cssHook if its there.\\n\\t\\t\\t// Use .style if available and use plain properties where available.\\n\\t\\t\\tif ( jQuery.fx.step[ tween.prop ] ) {\\n\\t\\t\\t\\tjQuery.fx.step[ tween.prop ]( tween );\\n\\t\\t\\t} else if ( tween.elem.nodeType === 1 &&\\n\\t\\t\\t\\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\\n\\t\\t\\t\\t\\tjQuery.cssHooks[ tween.prop ] ) ) {\\n\\t\\t\\t\\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttween.elem[ tween.prop ] = tween.now;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\n// Support: IE <=9 only\\n// Panic based approach to setting things on disconnected nodes\\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\\n\\tset: function( tween ) {\\n\\t\\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\\n\\t\\t\\ttween.elem[ tween.prop ] = tween.now;\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.easing = {\\n\\tlinear: function( p ) {\\n\\t\\treturn p;\\n\\t},\\n\\tswing: function( p ) {\\n\\t\\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\\n\\t},\\n\\t_default: \\\"swing\\\"\\n};\\n\\njQuery.fx = Tween.prototype.init;\\n\\n// Back compat <1.8 extension point\\njQuery.fx.step = {};\\n\\n\\n\\n\\nvar\\n\\tfxNow, timerId,\\n\\trfxtypes = /^(?:toggle|show|hide)$/,\\n\\trrun = /queueHooks$/;\\n\\nfunction raf() {\\n\\tif ( timerId ) {\\n\\t\\twindow.requestAnimationFrame( raf );\\n\\t\\tjQuery.fx.tick();\\n\\t}\\n}\\n\\n// Animations created synchronously will run synchronously\\nfunction createFxNow() {\\n\\twindow.setTimeout( function() {\\n\\t\\tfxNow = undefined;\\n\\t} );\\n\\treturn ( fxNow = jQuery.now() );\\n}\\n\\n// Generate parameters to create a standard animation\\nfunction genFx( type, includeWidth ) {\\n\\tvar which,\\n\\t\\ti = 0,\\n\\t\\tattrs = { height: type };\\n\\n\\t// If we include width, step value is 1 to do all cssExpand values,\\n\\t// otherwise step value is 2 to skip over Left and Right\\n\\tincludeWidth = includeWidth ? 1 : 0;\\n\\tfor ( ; i < 4; i += 2 - includeWidth ) {\\n\\t\\twhich = cssExpand[ i ];\\n\\t\\tattrs[ \\\"margin\\\" + which ] = attrs[ \\\"padding\\\" + which ] = type;\\n\\t}\\n\\n\\tif ( includeWidth ) {\\n\\t\\tattrs.opacity = attrs.width = type;\\n\\t}\\n\\n\\treturn attrs;\\n}\\n\\nfunction createTween( value, prop, animation ) {\\n\\tvar tween,\\n\\t\\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \\\"*\\\" ] ),\\n\\t\\tindex = 0,\\n\\t\\tlength = collection.length;\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\\n\\n\\t\\t\\t// We're done with this property\\n\\t\\t\\treturn tween;\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction defaultPrefilter( elem, props, opts ) {\\n\\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\\n\\t\\tisBox = \\\"width\\\" in props || \\\"height\\\" in props,\\n\\t\\tanim = this,\\n\\t\\torig = {},\\n\\t\\tstyle = elem.style,\\n\\t\\thidden = elem.nodeType && isHiddenWithinTree( elem ),\\n\\t\\tdataShow = dataPriv.get( elem, \\\"fxshow\\\" );\\n\\n\\t// Queue-skipping animations hijack the fx hooks\\n\\tif ( !opts.queue ) {\\n\\t\\thooks = jQuery._queueHooks( elem, \\\"fx\\\" );\\n\\t\\tif ( hooks.unqueued == null ) {\\n\\t\\t\\thooks.unqueued = 0;\\n\\t\\t\\toldfire = hooks.empty.fire;\\n\\t\\t\\thooks.empty.fire = function() {\\n\\t\\t\\t\\tif ( !hooks.unqueued ) {\\n\\t\\t\\t\\t\\toldfire();\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\thooks.unqueued++;\\n\\n\\t\\tanim.always( function() {\\n\\n\\t\\t\\t// Ensure the complete handler is called before this completes\\n\\t\\t\\tanim.always( function() {\\n\\t\\t\\t\\thooks.unqueued--;\\n\\t\\t\\t\\tif ( !jQuery.queue( elem, \\\"fx\\\" ).length ) {\\n\\t\\t\\t\\t\\thooks.empty.fire();\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t} );\\n\\t}\\n\\n\\t// Detect show/hide animations\\n\\tfor ( prop in props ) {\\n\\t\\tvalue = props[ prop ];\\n\\t\\tif ( rfxtypes.test( value ) ) {\\n\\t\\t\\tdelete props[ prop ];\\n\\t\\t\\ttoggle = toggle || value === \\\"toggle\\\";\\n\\t\\t\\tif ( value === ( hidden ? \\\"hide\\\" : \\\"show\\\" ) ) {\\n\\n\\t\\t\\t\\t// Pretend to be hidden if this is a \\\"show\\\" and\\n\\t\\t\\t\\t// there is still data from a stopped show/hide\\n\\t\\t\\t\\tif ( value === \\\"show\\\" && dataShow && dataShow[ prop ] !== undefined ) {\\n\\t\\t\\t\\t\\thidden = true;\\n\\n\\t\\t\\t\\t// Ignore all other no-op show/hide data\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\\n\\t\\t}\\n\\t}\\n\\n\\t// Bail out if this is a no-op like .hide().hide()\\n\\tpropTween = !jQuery.isEmptyObject( props );\\n\\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// Restrict \\\"overflow\\\" and \\\"display\\\" styles during box animations\\n\\tif ( isBox && elem.nodeType === 1 ) {\\n\\n\\t\\t// Support: IE <=9 - 11, Edge 12 - 13\\n\\t\\t// Record all 3 overflow attributes because IE does not infer the shorthand\\n\\t\\t// from identically-valued overflowX and overflowY\\n\\t\\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\\n\\n\\t\\t// Identify a display type, preferring old show/hide data over the CSS cascade\\n\\t\\trestoreDisplay = dataShow && dataShow.display;\\n\\t\\tif ( restoreDisplay == null ) {\\n\\t\\t\\trestoreDisplay = dataPriv.get( elem, \\\"display\\\" );\\n\\t\\t}\\n\\t\\tdisplay = jQuery.css( elem, \\\"display\\\" );\\n\\t\\tif ( display === \\\"none\\\" ) {\\n\\t\\t\\tif ( restoreDisplay ) {\\n\\t\\t\\t\\tdisplay = restoreDisplay;\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Get nonempty value(s) by temporarily forcing visibility\\n\\t\\t\\t\\tshowHide( [ elem ], true );\\n\\t\\t\\t\\trestoreDisplay = elem.style.display || restoreDisplay;\\n\\t\\t\\t\\tdisplay = jQuery.css( elem, \\\"display\\\" );\\n\\t\\t\\t\\tshowHide( [ elem ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Animate inline elements as inline-block\\n\\t\\tif ( display === \\\"inline\\\" || display === \\\"inline-block\\\" && restoreDisplay != null ) {\\n\\t\\t\\tif ( jQuery.css( elem, \\\"float\\\" ) === \\\"none\\\" ) {\\n\\n\\t\\t\\t\\t// Restore the original display value at the end of pure show/hide animations\\n\\t\\t\\t\\tif ( !propTween ) {\\n\\t\\t\\t\\t\\tanim.done( function() {\\n\\t\\t\\t\\t\\t\\tstyle.display = restoreDisplay;\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\tif ( restoreDisplay == null ) {\\n\\t\\t\\t\\t\\t\\tdisplay = style.display;\\n\\t\\t\\t\\t\\t\\trestoreDisplay = display === \\\"none\\\" ? \\\"\\\" : display;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstyle.display = \\\"inline-block\\\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif ( opts.overflow ) {\\n\\t\\tstyle.overflow = \\\"hidden\\\";\\n\\t\\tanim.always( function() {\\n\\t\\t\\tstyle.overflow = opts.overflow[ 0 ];\\n\\t\\t\\tstyle.overflowX = opts.overflow[ 1 ];\\n\\t\\t\\tstyle.overflowY = opts.overflow[ 2 ];\\n\\t\\t} );\\n\\t}\\n\\n\\t// Implement show/hide animations\\n\\tpropTween = false;\\n\\tfor ( prop in orig ) {\\n\\n\\t\\t// General show/hide setup for this element animation\\n\\t\\tif ( !propTween ) {\\n\\t\\t\\tif ( dataShow ) {\\n\\t\\t\\t\\tif ( \\\"hidden\\\" in dataShow ) {\\n\\t\\t\\t\\t\\thidden = dataShow.hidden;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdataShow = dataPriv.access( elem, \\\"fxshow\\\", { display: restoreDisplay } );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Store hidden/visible for toggle so `.stop().toggle()` \\\"reverses\\\"\\n\\t\\t\\tif ( toggle ) {\\n\\t\\t\\t\\tdataShow.hidden = !hidden;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Show elements before animating them\\n\\t\\t\\tif ( hidden ) {\\n\\t\\t\\t\\tshowHide( [ elem ], true );\\n\\t\\t\\t}\\n\\n\\t\\t\\t/* eslint-disable no-loop-func */\\n\\n\\t\\t\\tanim.done( function() {\\n\\n\\t\\t\\t/* eslint-enable no-loop-func */\\n\\n\\t\\t\\t\\t// The final step of a \\\"hide\\\" animation is actually hiding the element\\n\\t\\t\\t\\tif ( !hidden ) {\\n\\t\\t\\t\\t\\tshowHide( [ elem ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdataPriv.remove( elem, \\\"fxshow\\\" );\\n\\t\\t\\t\\tfor ( prop in orig ) {\\n\\t\\t\\t\\t\\tjQuery.style( elem, prop, orig[ prop ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\t// Per-property setup\\n\\t\\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\\n\\t\\tif ( !( prop in dataShow ) ) {\\n\\t\\t\\tdataShow[ prop ] = propTween.start;\\n\\t\\t\\tif ( hidden ) {\\n\\t\\t\\t\\tpropTween.end = propTween.start;\\n\\t\\t\\t\\tpropTween.start = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction propFilter( props, specialEasing ) {\\n\\tvar index, name, easing, value, hooks;\\n\\n\\t// camelCase, specialEasing and expand cssHook pass\\n\\tfor ( index in props ) {\\n\\t\\tname = jQuery.camelCase( index );\\n\\t\\teasing = specialEasing[ name ];\\n\\t\\tvalue = props[ index ];\\n\\t\\tif ( jQuery.isArray( value ) ) {\\n\\t\\t\\teasing = value[ 1 ];\\n\\t\\t\\tvalue = props[ index ] = value[ 0 ];\\n\\t\\t}\\n\\n\\t\\tif ( index !== name ) {\\n\\t\\t\\tprops[ name ] = value;\\n\\t\\t\\tdelete props[ index ];\\n\\t\\t}\\n\\n\\t\\thooks = jQuery.cssHooks[ name ];\\n\\t\\tif ( hooks && \\\"expand\\\" in hooks ) {\\n\\t\\t\\tvalue = hooks.expand( value );\\n\\t\\t\\tdelete props[ name ];\\n\\n\\t\\t\\t// Not quite $.extend, this won't overwrite existing keys.\\n\\t\\t\\t// Reusing 'index' because we have the correct \\\"name\\\"\\n\\t\\t\\tfor ( index in value ) {\\n\\t\\t\\t\\tif ( !( index in props ) ) {\\n\\t\\t\\t\\t\\tprops[ index ] = value[ index ];\\n\\t\\t\\t\\t\\tspecialEasing[ index ] = easing;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tspecialEasing[ name ] = easing;\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction Animation( elem, properties, options ) {\\n\\tvar result,\\n\\t\\tstopped,\\n\\t\\tindex = 0,\\n\\t\\tlength = Animation.prefilters.length,\\n\\t\\tdeferred = jQuery.Deferred().always( function() {\\n\\n\\t\\t\\t// Don't match elem in the :animated selector\\n\\t\\t\\tdelete tick.elem;\\n\\t\\t} ),\\n\\t\\ttick = function() {\\n\\t\\t\\tif ( stopped ) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tvar currentTime = fxNow || createFxNow(),\\n\\t\\t\\t\\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\\n\\n\\t\\t\\t\\t// Support: Android 2.3 only\\n\\t\\t\\t\\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\\n\\t\\t\\t\\ttemp = remaining / animation.duration || 0,\\n\\t\\t\\t\\tpercent = 1 - temp,\\n\\t\\t\\t\\tindex = 0,\\n\\t\\t\\t\\tlength = animation.tweens.length;\\n\\n\\t\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\t\\tanimation.tweens[ index ].run( percent );\\n\\t\\t\\t}\\n\\n\\t\\t\\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\\n\\n\\t\\t\\tif ( percent < 1 && length ) {\\n\\t\\t\\t\\treturn remaining;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdeferred.resolveWith( elem, [ animation ] );\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tanimation = deferred.promise( {\\n\\t\\t\\telem: elem,\\n\\t\\t\\tprops: jQuery.extend( {}, properties ),\\n\\t\\t\\topts: jQuery.extend( true, {\\n\\t\\t\\t\\tspecialEasing: {},\\n\\t\\t\\t\\teasing: jQuery.easing._default\\n\\t\\t\\t}, options ),\\n\\t\\t\\toriginalProperties: properties,\\n\\t\\t\\toriginalOptions: options,\\n\\t\\t\\tstartTime: fxNow || createFxNow(),\\n\\t\\t\\tduration: options.duration,\\n\\t\\t\\ttweens: [],\\n\\t\\t\\tcreateTween: function( prop, end ) {\\n\\t\\t\\t\\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\\n\\t\\t\\t\\t\\t\\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\\n\\t\\t\\t\\tanimation.tweens.push( tween );\\n\\t\\t\\t\\treturn tween;\\n\\t\\t\\t},\\n\\t\\t\\tstop: function( gotoEnd ) {\\n\\t\\t\\t\\tvar index = 0,\\n\\n\\t\\t\\t\\t\\t// If we are going to the end, we want to run all the tweens\\n\\t\\t\\t\\t\\t// otherwise we skip this part\\n\\t\\t\\t\\t\\tlength = gotoEnd ? animation.tweens.length : 0;\\n\\t\\t\\t\\tif ( stopped ) {\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstopped = true;\\n\\t\\t\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\t\\t\\tanimation.tweens[ index ].run( 1 );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Resolve when we played the last frame; otherwise, reject\\n\\t\\t\\t\\tif ( gotoEnd ) {\\n\\t\\t\\t\\t\\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\\n\\t\\t\\t\\t\\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t} ),\\n\\t\\tprops = animation.props;\\n\\n\\tpropFilter( props, animation.opts.specialEasing );\\n\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\\n\\t\\tif ( result ) {\\n\\t\\t\\tif ( jQuery.isFunction( result.stop ) ) {\\n\\t\\t\\t\\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\\n\\t\\t\\t\\t\\tjQuery.proxy( result.stop, result );\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\n\\tjQuery.map( props, createTween, animation );\\n\\n\\tif ( jQuery.isFunction( animation.opts.start ) ) {\\n\\t\\tanimation.opts.start.call( elem, animation );\\n\\t}\\n\\n\\tjQuery.fx.timer(\\n\\t\\tjQuery.extend( tick, {\\n\\t\\t\\telem: elem,\\n\\t\\t\\tanim: animation,\\n\\t\\t\\tqueue: animation.opts.queue\\n\\t\\t} )\\n\\t);\\n\\n\\t// attach callbacks from options\\n\\treturn animation.progress( animation.opts.progress )\\n\\t\\t.done( animation.opts.done, animation.opts.complete )\\n\\t\\t.fail( animation.opts.fail )\\n\\t\\t.always( animation.opts.always );\\n}\\n\\njQuery.Animation = jQuery.extend( Animation, {\\n\\n\\ttweeners: {\\n\\t\\t\\\"*\\\": [ function( prop, value ) {\\n\\t\\t\\tvar tween = this.createTween( prop, value );\\n\\t\\t\\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\\n\\t\\t\\treturn tween;\\n\\t\\t} ]\\n\\t},\\n\\n\\ttweener: function( props, callback ) {\\n\\t\\tif ( jQuery.isFunction( props ) ) {\\n\\t\\t\\tcallback = props;\\n\\t\\t\\tprops = [ \\\"*\\\" ];\\n\\t\\t} else {\\n\\t\\t\\tprops = props.match( rnothtmlwhite );\\n\\t\\t}\\n\\n\\t\\tvar prop,\\n\\t\\t\\tindex = 0,\\n\\t\\t\\tlength = props.length;\\n\\n\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\tprop = props[ index ];\\n\\t\\t\\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\\n\\t\\t\\tAnimation.tweeners[ prop ].unshift( callback );\\n\\t\\t}\\n\\t},\\n\\n\\tprefilters: [ defaultPrefilter ],\\n\\n\\tprefilter: function( callback, prepend ) {\\n\\t\\tif ( prepend ) {\\n\\t\\t\\tAnimation.prefilters.unshift( callback );\\n\\t\\t} else {\\n\\t\\t\\tAnimation.prefilters.push( callback );\\n\\t\\t}\\n\\t}\\n} );\\n\\njQuery.speed = function( speed, easing, fn ) {\\n\\tvar opt = speed && typeof speed === \\\"object\\\" ? jQuery.extend( {}, speed ) : {\\n\\t\\tcomplete: fn || !fn && easing ||\\n\\t\\t\\tjQuery.isFunction( speed ) && speed,\\n\\t\\tduration: speed,\\n\\t\\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\\n\\t};\\n\\n\\t// Go to the end state if fx are off or if document is hidden\\n\\tif ( jQuery.fx.off || document.hidden ) {\\n\\t\\topt.duration = 0;\\n\\n\\t} else {\\n\\t\\tif ( typeof opt.duration !== \\\"number\\\" ) {\\n\\t\\t\\tif ( opt.duration in jQuery.fx.speeds ) {\\n\\t\\t\\t\\topt.duration = jQuery.fx.speeds[ opt.duration ];\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\topt.duration = jQuery.fx.speeds._default;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Normalize opt.queue - true/undefined/null -> \\\"fx\\\"\\n\\tif ( opt.queue == null || opt.queue === true ) {\\n\\t\\topt.queue = \\\"fx\\\";\\n\\t}\\n\\n\\t// Queueing\\n\\topt.old = opt.complete;\\n\\n\\topt.complete = function() {\\n\\t\\tif ( jQuery.isFunction( opt.old ) ) {\\n\\t\\t\\topt.old.call( this );\\n\\t\\t}\\n\\n\\t\\tif ( opt.queue ) {\\n\\t\\t\\tjQuery.dequeue( this, opt.queue );\\n\\t\\t}\\n\\t};\\n\\n\\treturn opt;\\n};\\n\\njQuery.fn.extend( {\\n\\tfadeTo: function( speed, to, easing, callback ) {\\n\\n\\t\\t// Show any hidden elements after setting opacity to 0\\n\\t\\treturn this.filter( isHiddenWithinTree ).css( \\\"opacity\\\", 0 ).show()\\n\\n\\t\\t\\t// Animate to the value specified\\n\\t\\t\\t.end().animate( { opacity: to }, speed, easing, callback );\\n\\t},\\n\\tanimate: function( prop, speed, easing, callback ) {\\n\\t\\tvar empty = jQuery.isEmptyObject( prop ),\\n\\t\\t\\toptall = jQuery.speed( speed, easing, callback ),\\n\\t\\t\\tdoAnimation = function() {\\n\\n\\t\\t\\t\\t// Operate on a copy of prop so per-property easing won't be lost\\n\\t\\t\\t\\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\\n\\n\\t\\t\\t\\t// Empty animations, or finishing resolves immediately\\n\\t\\t\\t\\tif ( empty || dataPriv.get( this, \\\"finish\\\" ) ) {\\n\\t\\t\\t\\t\\tanim.stop( true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tdoAnimation.finish = doAnimation;\\n\\n\\t\\treturn empty || optall.queue === false ?\\n\\t\\t\\tthis.each( doAnimation ) :\\n\\t\\t\\tthis.queue( optall.queue, doAnimation );\\n\\t},\\n\\tstop: function( type, clearQueue, gotoEnd ) {\\n\\t\\tvar stopQueue = function( hooks ) {\\n\\t\\t\\tvar stop = hooks.stop;\\n\\t\\t\\tdelete hooks.stop;\\n\\t\\t\\tstop( gotoEnd );\\n\\t\\t};\\n\\n\\t\\tif ( typeof type !== \\\"string\\\" ) {\\n\\t\\t\\tgotoEnd = clearQueue;\\n\\t\\t\\tclearQueue = type;\\n\\t\\t\\ttype = undefined;\\n\\t\\t}\\n\\t\\tif ( clearQueue && type !== false ) {\\n\\t\\t\\tthis.queue( type || \\\"fx\\\", [] );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar dequeue = true,\\n\\t\\t\\t\\tindex = type != null && type + \\\"queueHooks\\\",\\n\\t\\t\\t\\ttimers = jQuery.timers,\\n\\t\\t\\t\\tdata = dataPriv.get( this );\\n\\n\\t\\t\\tif ( index ) {\\n\\t\\t\\t\\tif ( data[ index ] && data[ index ].stop ) {\\n\\t\\t\\t\\t\\tstopQueue( data[ index ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor ( index in data ) {\\n\\t\\t\\t\\t\\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\\n\\t\\t\\t\\t\\t\\tstopQueue( data[ index ] );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( index = timers.length; index--; ) {\\n\\t\\t\\t\\tif ( timers[ index ].elem === this &&\\n\\t\\t\\t\\t\\t( type == null || timers[ index ].queue === type ) ) {\\n\\n\\t\\t\\t\\t\\ttimers[ index ].anim.stop( gotoEnd );\\n\\t\\t\\t\\t\\tdequeue = false;\\n\\t\\t\\t\\t\\ttimers.splice( index, 1 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Start the next in the queue if the last step wasn't forced.\\n\\t\\t\\t// Timers currently will call their complete callbacks, which\\n\\t\\t\\t// will dequeue but only if they were gotoEnd.\\n\\t\\t\\tif ( dequeue || !gotoEnd ) {\\n\\t\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\tfinish: function( type ) {\\n\\t\\tif ( type !== false ) {\\n\\t\\t\\ttype = type || \\\"fx\\\";\\n\\t\\t}\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar index,\\n\\t\\t\\t\\tdata = dataPriv.get( this ),\\n\\t\\t\\t\\tqueue = data[ type + \\\"queue\\\" ],\\n\\t\\t\\t\\thooks = data[ type + \\\"queueHooks\\\" ],\\n\\t\\t\\t\\ttimers = jQuery.timers,\\n\\t\\t\\t\\tlength = queue ? queue.length : 0;\\n\\n\\t\\t\\t// Enable finishing flag on private data\\n\\t\\t\\tdata.finish = true;\\n\\n\\t\\t\\t// Empty the queue first\\n\\t\\t\\tjQuery.queue( this, type, [] );\\n\\n\\t\\t\\tif ( hooks && hooks.stop ) {\\n\\t\\t\\t\\thooks.stop.call( this, true );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Look for any active animations, and finish them\\n\\t\\t\\tfor ( index = timers.length; index--; ) {\\n\\t\\t\\t\\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\\n\\t\\t\\t\\t\\ttimers[ index ].anim.stop( true );\\n\\t\\t\\t\\t\\ttimers.splice( index, 1 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Look for any animations in the old queue and finish them\\n\\t\\t\\tfor ( index = 0; index < length; index++ ) {\\n\\t\\t\\t\\tif ( queue[ index ] && queue[ index ].finish ) {\\n\\t\\t\\t\\t\\tqueue[ index ].finish.call( this );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Turn off finishing flag\\n\\t\\t\\tdelete data.finish;\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.each( [ \\\"toggle\\\", \\\"show\\\", \\\"hide\\\" ], function( i, name ) {\\n\\tvar cssFn = jQuery.fn[ name ];\\n\\tjQuery.fn[ name ] = function( speed, easing, callback ) {\\n\\t\\treturn speed == null || typeof speed === \\\"boolean\\\" ?\\n\\t\\t\\tcssFn.apply( this, arguments ) :\\n\\t\\t\\tthis.animate( genFx( name, true ), speed, easing, callback );\\n\\t};\\n} );\\n\\n// Generate shortcuts for custom animations\\njQuery.each( {\\n\\tslideDown: genFx( \\\"show\\\" ),\\n\\tslideUp: genFx( \\\"hide\\\" ),\\n\\tslideToggle: genFx( \\\"toggle\\\" ),\\n\\tfadeIn: { opacity: \\\"show\\\" },\\n\\tfadeOut: { opacity: \\\"hide\\\" },\\n\\tfadeToggle: { opacity: \\\"toggle\\\" }\\n}, function( name, props ) {\\n\\tjQuery.fn[ name ] = function( speed, easing, callback ) {\\n\\t\\treturn this.animate( props, speed, easing, callback );\\n\\t};\\n} );\\n\\njQuery.timers = [];\\njQuery.fx.tick = function() {\\n\\tvar timer,\\n\\t\\ti = 0,\\n\\t\\ttimers = jQuery.timers;\\n\\n\\tfxNow = jQuery.now();\\n\\n\\tfor ( ; i < timers.length; i++ ) {\\n\\t\\ttimer = timers[ i ];\\n\\n\\t\\t// Checks the timer has not already been removed\\n\\t\\tif ( !timer() && timers[ i ] === timer ) {\\n\\t\\t\\ttimers.splice( i--, 1 );\\n\\t\\t}\\n\\t}\\n\\n\\tif ( !timers.length ) {\\n\\t\\tjQuery.fx.stop();\\n\\t}\\n\\tfxNow = undefined;\\n};\\n\\njQuery.fx.timer = function( timer ) {\\n\\tjQuery.timers.push( timer );\\n\\tif ( timer() ) {\\n\\t\\tjQuery.fx.start();\\n\\t} else {\\n\\t\\tjQuery.timers.pop();\\n\\t}\\n};\\n\\njQuery.fx.interval = 13;\\njQuery.fx.start = function() {\\n\\tif ( !timerId ) {\\n\\t\\ttimerId = window.requestAnimationFrame ?\\n\\t\\t\\twindow.requestAnimationFrame( raf ) :\\n\\t\\t\\twindow.setInterval( jQuery.fx.tick, jQuery.fx.interval );\\n\\t}\\n};\\n\\njQuery.fx.stop = function() {\\n\\tif ( window.cancelAnimationFrame ) {\\n\\t\\twindow.cancelAnimationFrame( timerId );\\n\\t} else {\\n\\t\\twindow.clearInterval( timerId );\\n\\t}\\n\\n\\ttimerId = null;\\n};\\n\\njQuery.fx.speeds = {\\n\\tslow: 600,\\n\\tfast: 200,\\n\\n\\t// Default speed\\n\\t_default: 400\\n};\\n\\n\\n// Based off of the plugin by Clint Helfers, with permission.\\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\\njQuery.fn.delay = function( time, type ) {\\n\\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\\n\\ttype = type || \\\"fx\\\";\\n\\n\\treturn this.queue( type, function( next, hooks ) {\\n\\t\\tvar timeout = window.setTimeout( next, time );\\n\\t\\thooks.stop = function() {\\n\\t\\t\\twindow.clearTimeout( timeout );\\n\\t\\t};\\n\\t} );\\n};\\n\\n\\n( function() {\\n\\tvar input = document.createElement( \\\"input\\\" ),\\n\\t\\tselect = document.createElement( \\\"select\\\" ),\\n\\t\\topt = select.appendChild( document.createElement( \\\"option\\\" ) );\\n\\n\\tinput.type = \\\"checkbox\\\";\\n\\n\\t// Support: Android <=4.3 only\\n\\t// Default value for a checkbox should be \\\"on\\\"\\n\\tsupport.checkOn = input.value !== \\\"\\\";\\n\\n\\t// Support: IE <=11 only\\n\\t// Must access selectedIndex to make default options select\\n\\tsupport.optSelected = opt.selected;\\n\\n\\t// Support: IE <=11 only\\n\\t// An input loses its value after becoming a radio\\n\\tinput = document.createElement( \\\"input\\\" );\\n\\tinput.value = \\\"t\\\";\\n\\tinput.type = \\\"radio\\\";\\n\\tsupport.radioValue = input.value === \\\"t\\\";\\n} )();\\n\\n\\nvar boolHook,\\n\\tattrHandle = jQuery.expr.attrHandle;\\n\\njQuery.fn.extend( {\\n\\tattr: function( name, value ) {\\n\\t\\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\\n\\t},\\n\\n\\tremoveAttr: function( name ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.removeAttr( this, name );\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tattr: function( elem, name, value ) {\\n\\t\\tvar ret, hooks,\\n\\t\\t\\tnType = elem.nodeType;\\n\\n\\t\\t// Don't get/set attributes on text, comment and attribute nodes\\n\\t\\tif ( nType === 3 || nType === 8 || nType === 2 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Fallback to prop when attributes are not supported\\n\\t\\tif ( typeof elem.getAttribute === \\\"undefined\\\" ) {\\n\\t\\t\\treturn jQuery.prop( elem, name, value );\\n\\t\\t}\\n\\n\\t\\t// Attribute hooks are determined by the lowercase version\\n\\t\\t// Grab necessary hook if one is defined\\n\\t\\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\\n\\t\\t\\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\\n\\t\\t\\t\\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\\n\\t\\t}\\n\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\tif ( value === null ) {\\n\\t\\t\\t\\tjQuery.removeAttr( elem, name );\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( hooks && \\\"set\\\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\telem.setAttribute( name, value + \\\"\\\" );\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\n\\t\\tif ( hooks && \\\"get\\\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\n\\t\\tret = jQuery.find.attr( elem, name );\\n\\n\\t\\t// Non-existent attributes return null, we normalize to undefined\\n\\t\\treturn ret == null ? undefined : ret;\\n\\t},\\n\\n\\tattrHooks: {\\n\\t\\ttype: {\\n\\t\\t\\tset: function( elem, value ) {\\n\\t\\t\\t\\tif ( !support.radioValue && value === \\\"radio\\\" &&\\n\\t\\t\\t\\t\\tjQuery.nodeName( elem, \\\"input\\\" ) ) {\\n\\t\\t\\t\\t\\tvar val = elem.value;\\n\\t\\t\\t\\t\\telem.setAttribute( \\\"type\\\", value );\\n\\t\\t\\t\\t\\tif ( val ) {\\n\\t\\t\\t\\t\\t\\telem.value = val;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\tremoveAttr: function( elem, value ) {\\n\\t\\tvar name,\\n\\t\\t\\ti = 0,\\n\\n\\t\\t\\t// Attribute names can contain non-HTML whitespace characters\\n\\t\\t\\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\\n\\t\\t\\tattrNames = value && value.match( rnothtmlwhite );\\n\\n\\t\\tif ( attrNames && elem.nodeType === 1 ) {\\n\\t\\t\\twhile ( ( name = attrNames[ i++ ] ) ) {\\n\\t\\t\\t\\telem.removeAttribute( name );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Hooks for boolean attributes\\nboolHook = {\\n\\tset: function( elem, value, name ) {\\n\\t\\tif ( value === false ) {\\n\\n\\t\\t\\t// Remove boolean attributes when set to false\\n\\t\\t\\tjQuery.removeAttr( elem, name );\\n\\t\\t} else {\\n\\t\\t\\telem.setAttribute( name, name );\\n\\t\\t}\\n\\t\\treturn name;\\n\\t}\\n};\\n\\njQuery.each( jQuery.expr.match.bool.source.match( /\\\\w+/g ), function( i, name ) {\\n\\tvar getter = attrHandle[ name ] || jQuery.find.attr;\\n\\n\\tattrHandle[ name ] = function( elem, name, isXML ) {\\n\\t\\tvar ret, handle,\\n\\t\\t\\tlowercaseName = name.toLowerCase();\\n\\n\\t\\tif ( !isXML ) {\\n\\n\\t\\t\\t// Avoid an infinite loop by temporarily removing this function from the getter\\n\\t\\t\\thandle = attrHandle[ lowercaseName ];\\n\\t\\t\\tattrHandle[ lowercaseName ] = ret;\\n\\t\\t\\tret = getter( elem, name, isXML ) != null ?\\n\\t\\t\\t\\tlowercaseName :\\n\\t\\t\\t\\tnull;\\n\\t\\t\\tattrHandle[ lowercaseName ] = handle;\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t};\\n} );\\n\\n\\n\\n\\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\\n\\trclickable = /^(?:a|area)$/i;\\n\\njQuery.fn.extend( {\\n\\tprop: function( name, value ) {\\n\\t\\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\\n\\t},\\n\\n\\tremoveProp: function( name ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tdelete this[ jQuery.propFix[ name ] || name ];\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tprop: function( elem, name, value ) {\\n\\t\\tvar ret, hooks,\\n\\t\\t\\tnType = elem.nodeType;\\n\\n\\t\\t// Don't get/set properties on text, comment and attribute nodes\\n\\t\\tif ( nType === 3 || nType === 8 || nType === 2 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\\n\\n\\t\\t\\t// Fix name and attach hooks\\n\\t\\t\\tname = jQuery.propFix[ name ] || name;\\n\\t\\t\\thooks = jQuery.propHooks[ name ];\\n\\t\\t}\\n\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\tif ( hooks && \\\"set\\\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ( elem[ name ] = value );\\n\\t\\t}\\n\\n\\t\\tif ( hooks && \\\"get\\\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\n\\t\\treturn elem[ name ];\\n\\t},\\n\\n\\tpropHooks: {\\n\\t\\ttabIndex: {\\n\\t\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t\\t// Support: IE <=9 - 11 only\\n\\t\\t\\t\\t// elem.tabIndex doesn't always return the\\n\\t\\t\\t\\t// correct value when it hasn't been explicitly set\\n\\t\\t\\t\\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\\n\\t\\t\\t\\t// Use proper attribute retrieval(#12072)\\n\\t\\t\\t\\tvar tabindex = jQuery.find.attr( elem, \\\"tabindex\\\" );\\n\\n\\t\\t\\t\\tif ( tabindex ) {\\n\\t\\t\\t\\t\\treturn parseInt( tabindex, 10 );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\trfocusable.test( elem.nodeName ) ||\\n\\t\\t\\t\\t\\trclickable.test( elem.nodeName ) &&\\n\\t\\t\\t\\t\\telem.href\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\tpropFix: {\\n\\t\\t\\\"for\\\": \\\"htmlFor\\\",\\n\\t\\t\\\"class\\\": \\\"className\\\"\\n\\t}\\n} );\\n\\n// Support: IE <=11 only\\n// Accessing the selectedIndex property\\n// forces the browser to respect setting selected\\n// on the option\\n// The getter ensures a default option is selected\\n// when in an optgroup\\n// eslint rule \\\"no-unused-expressions\\\" is disabled for this code\\n// since it considers such accessions noop\\nif ( !support.optSelected ) {\\n\\tjQuery.propHooks.selected = {\\n\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t/* eslint no-unused-expressions: \\\"off\\\" */\\n\\n\\t\\t\\tvar parent = elem.parentNode;\\n\\t\\t\\tif ( parent && parent.parentNode ) {\\n\\t\\t\\t\\tparent.parentNode.selectedIndex;\\n\\t\\t\\t}\\n\\t\\t\\treturn null;\\n\\t\\t},\\n\\t\\tset: function( elem ) {\\n\\n\\t\\t\\t/* eslint no-unused-expressions: \\\"off\\\" */\\n\\n\\t\\t\\tvar parent = elem.parentNode;\\n\\t\\t\\tif ( parent ) {\\n\\t\\t\\t\\tparent.selectedIndex;\\n\\n\\t\\t\\t\\tif ( parent.parentNode ) {\\n\\t\\t\\t\\t\\tparent.parentNode.selectedIndex;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n}\\n\\njQuery.each( [\\n\\t\\\"tabIndex\\\",\\n\\t\\\"readOnly\\\",\\n\\t\\\"maxLength\\\",\\n\\t\\\"cellSpacing\\\",\\n\\t\\\"cellPadding\\\",\\n\\t\\\"rowSpan\\\",\\n\\t\\\"colSpan\\\",\\n\\t\\\"useMap\\\",\\n\\t\\\"frameBorder\\\",\\n\\t\\\"contentEditable\\\"\\n], function() {\\n\\tjQuery.propFix[ this.toLowerCase() ] = this;\\n} );\\n\\n\\n\\n\\n\\t// Strip and collapse whitespace according to HTML spec\\n\\t// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\\n\\tfunction stripAndCollapse( value ) {\\n\\t\\tvar tokens = value.match( rnothtmlwhite ) || [];\\n\\t\\treturn tokens.join( \\\" \\\" );\\n\\t}\\n\\n\\nfunction getClass( elem ) {\\n\\treturn elem.getAttribute && elem.getAttribute( \\\"class\\\" ) || \\\"\\\";\\n}\\n\\njQuery.fn.extend( {\\n\\taddClass: function( value ) {\\n\\t\\tvar classes, elem, cur, curValue, clazz, j, finalValue,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tif ( jQuery.isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( j ) {\\n\\t\\t\\t\\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tif ( typeof value === \\\"string\\\" && value ) {\\n\\t\\t\\tclasses = value.match( rnothtmlwhite ) || [];\\n\\n\\t\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\t\\tcurValue = getClass( elem );\\n\\t\\t\\t\\tcur = elem.nodeType === 1 && ( \\\" \\\" + stripAndCollapse( curValue ) + \\\" \\\" );\\n\\n\\t\\t\\t\\tif ( cur ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\twhile ( ( clazz = classes[ j++ ] ) ) {\\n\\t\\t\\t\\t\\t\\tif ( cur.indexOf( \\\" \\\" + clazz + \\\" \\\" ) < 0 ) {\\n\\t\\t\\t\\t\\t\\t\\tcur += clazz + \\\" \\\";\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Only assign if different to avoid unneeded rendering.\\n\\t\\t\\t\\t\\tfinalValue = stripAndCollapse( cur );\\n\\t\\t\\t\\t\\tif ( curValue !== finalValue ) {\\n\\t\\t\\t\\t\\t\\telem.setAttribute( \\\"class\\\", finalValue );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\tremoveClass: function( value ) {\\n\\t\\tvar classes, elem, cur, curValue, clazz, j, finalValue,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tif ( jQuery.isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( j ) {\\n\\t\\t\\t\\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tif ( !arguments.length ) {\\n\\t\\t\\treturn this.attr( \\\"class\\\", \\\"\\\" );\\n\\t\\t}\\n\\n\\t\\tif ( typeof value === \\\"string\\\" && value ) {\\n\\t\\t\\tclasses = value.match( rnothtmlwhite ) || [];\\n\\n\\t\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\t\\tcurValue = getClass( elem );\\n\\n\\t\\t\\t\\t// This expression is here for better compressibility (see addClass)\\n\\t\\t\\t\\tcur = elem.nodeType === 1 && ( \\\" \\\" + stripAndCollapse( curValue ) + \\\" \\\" );\\n\\n\\t\\t\\t\\tif ( cur ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\twhile ( ( clazz = classes[ j++ ] ) ) {\\n\\n\\t\\t\\t\\t\\t\\t// Remove *all* instances\\n\\t\\t\\t\\t\\t\\twhile ( cur.indexOf( \\\" \\\" + clazz + \\\" \\\" ) > -1 ) {\\n\\t\\t\\t\\t\\t\\t\\tcur = cur.replace( \\\" \\\" + clazz + \\\" \\\", \\\" \\\" );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Only assign if different to avoid unneeded rendering.\\n\\t\\t\\t\\t\\tfinalValue = stripAndCollapse( cur );\\n\\t\\t\\t\\t\\tif ( curValue !== finalValue ) {\\n\\t\\t\\t\\t\\t\\telem.setAttribute( \\\"class\\\", finalValue );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\ttoggleClass: function( value, stateVal ) {\\n\\t\\tvar type = typeof value;\\n\\n\\t\\tif ( typeof stateVal === \\\"boolean\\\" && type === \\\"string\\\" ) {\\n\\t\\t\\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\\n\\t\\t}\\n\\n\\t\\tif ( jQuery.isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( i ) {\\n\\t\\t\\t\\tjQuery( this ).toggleClass(\\n\\t\\t\\t\\t\\tvalue.call( this, i, getClass( this ), stateVal ),\\n\\t\\t\\t\\t\\tstateVal\\n\\t\\t\\t\\t);\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar className, i, self, classNames;\\n\\n\\t\\t\\tif ( type === \\\"string\\\" ) {\\n\\n\\t\\t\\t\\t// Toggle individual class names\\n\\t\\t\\t\\ti = 0;\\n\\t\\t\\t\\tself = jQuery( this );\\n\\t\\t\\t\\tclassNames = value.match( rnothtmlwhite ) || [];\\n\\n\\t\\t\\t\\twhile ( ( className = classNames[ i++ ] ) ) {\\n\\n\\t\\t\\t\\t\\t// Check each className given, space separated list\\n\\t\\t\\t\\t\\tif ( self.hasClass( className ) ) {\\n\\t\\t\\t\\t\\t\\tself.removeClass( className );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tself.addClass( className );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t// Toggle whole class name\\n\\t\\t\\t} else if ( value === undefined || type === \\\"boolean\\\" ) {\\n\\t\\t\\t\\tclassName = getClass( this );\\n\\t\\t\\t\\tif ( className ) {\\n\\n\\t\\t\\t\\t\\t// Store className if set\\n\\t\\t\\t\\t\\tdataPriv.set( this, \\\"__className__\\\", className );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// If the element has a class name or if we're passed `false`,\\n\\t\\t\\t\\t// then remove the whole classname (if there was one, the above saved it).\\n\\t\\t\\t\\t// Otherwise bring back whatever was previously saved (if anything),\\n\\t\\t\\t\\t// falling back to the empty string if nothing was stored.\\n\\t\\t\\t\\tif ( this.setAttribute ) {\\n\\t\\t\\t\\t\\tthis.setAttribute( \\\"class\\\",\\n\\t\\t\\t\\t\\t\\tclassName || value === false ?\\n\\t\\t\\t\\t\\t\\t\\\"\\\" :\\n\\t\\t\\t\\t\\t\\tdataPriv.get( this, \\\"__className__\\\" ) || \\\"\\\"\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\thasClass: function( selector ) {\\n\\t\\tvar className, elem,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tclassName = \\\" \\\" + selector + \\\" \\\";\\n\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\tif ( elem.nodeType === 1 &&\\n\\t\\t\\t\\t( \\\" \\\" + stripAndCollapse( getClass( elem ) ) + \\\" \\\" ).indexOf( className ) > -1 ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n} );\\n\\n\\n\\n\\nvar rreturn = /\\\\r/g;\\n\\njQuery.fn.extend( {\\n\\tval: function( value ) {\\n\\t\\tvar hooks, ret, isFunction,\\n\\t\\t\\telem = this[ 0 ];\\n\\n\\t\\tif ( !arguments.length ) {\\n\\t\\t\\tif ( elem ) {\\n\\t\\t\\t\\thooks = jQuery.valHooks[ elem.type ] ||\\n\\t\\t\\t\\t\\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\\n\\n\\t\\t\\t\\tif ( hooks &&\\n\\t\\t\\t\\t\\t\\\"get\\\" in hooks &&\\n\\t\\t\\t\\t\\t( ret = hooks.get( elem, \\\"value\\\" ) ) !== undefined\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\treturn ret;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tret = elem.value;\\n\\n\\t\\t\\t\\t// Handle most common string cases\\n\\t\\t\\t\\tif ( typeof ret === \\\"string\\\" ) {\\n\\t\\t\\t\\t\\treturn ret.replace( rreturn, \\\"\\\" );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Handle cases where value is null/undef or number\\n\\t\\t\\t\\treturn ret == null ? \\\"\\\" : ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tisFunction = jQuery.isFunction( value );\\n\\n\\t\\treturn this.each( function( i ) {\\n\\t\\t\\tvar val;\\n\\n\\t\\t\\tif ( this.nodeType !== 1 ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( isFunction ) {\\n\\t\\t\\t\\tval = value.call( this, i, jQuery( this ).val() );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tval = value;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Treat null/undefined as \\\"\\\"; convert numbers to string\\n\\t\\t\\tif ( val == null ) {\\n\\t\\t\\t\\tval = \\\"\\\";\\n\\n\\t\\t\\t} else if ( typeof val === \\\"number\\\" ) {\\n\\t\\t\\t\\tval += \\\"\\\";\\n\\n\\t\\t\\t} else if ( jQuery.isArray( val ) ) {\\n\\t\\t\\t\\tval = jQuery.map( val, function( value ) {\\n\\t\\t\\t\\t\\treturn value == null ? \\\"\\\" : value + \\\"\\\";\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\n\\t\\t\\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\\n\\n\\t\\t\\t// If set returns undefined, fall back to normal setting\\n\\t\\t\\tif ( !hooks || !( \\\"set\\\" in hooks ) || hooks.set( this, val, \\\"value\\\" ) === undefined ) {\\n\\t\\t\\t\\tthis.value = val;\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tvalHooks: {\\n\\t\\toption: {\\n\\t\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t\\tvar val = jQuery.find.attr( elem, \\\"value\\\" );\\n\\t\\t\\t\\treturn val != null ?\\n\\t\\t\\t\\t\\tval :\\n\\n\\t\\t\\t\\t\\t// Support: IE <=10 - 11 only\\n\\t\\t\\t\\t\\t// option.text throws exceptions (#14686, #14858)\\n\\t\\t\\t\\t\\t// Strip and collapse whitespace\\n\\t\\t\\t\\t\\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\\n\\t\\t\\t\\t\\tstripAndCollapse( jQuery.text( elem ) );\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tselect: {\\n\\t\\t\\tget: function( elem ) {\\n\\t\\t\\t\\tvar value, option, i,\\n\\t\\t\\t\\t\\toptions = elem.options,\\n\\t\\t\\t\\t\\tindex = elem.selectedIndex,\\n\\t\\t\\t\\t\\tone = elem.type === \\\"select-one\\\",\\n\\t\\t\\t\\t\\tvalues = one ? null : [],\\n\\t\\t\\t\\t\\tmax = one ? index + 1 : options.length;\\n\\n\\t\\t\\t\\tif ( index < 0 ) {\\n\\t\\t\\t\\t\\ti = max;\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ti = one ? index : 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Loop through all the selected options\\n\\t\\t\\t\\tfor ( ; i < max; i++ ) {\\n\\t\\t\\t\\t\\toption = options[ i ];\\n\\n\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t// IE8-9 doesn't update selected after form reset (#2551)\\n\\t\\t\\t\\t\\tif ( ( option.selected || i === index ) &&\\n\\n\\t\\t\\t\\t\\t\\t\\t// Don't return options that are disabled or in a disabled optgroup\\n\\t\\t\\t\\t\\t\\t\\t!option.disabled &&\\n\\t\\t\\t\\t\\t\\t\\t( !option.parentNode.disabled ||\\n\\t\\t\\t\\t\\t\\t\\t\\t!jQuery.nodeName( option.parentNode, \\\"optgroup\\\" ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\t// Get the specific value for the option\\n\\t\\t\\t\\t\\t\\tvalue = jQuery( option ).val();\\n\\n\\t\\t\\t\\t\\t\\t// We don't need an array for one selects\\n\\t\\t\\t\\t\\t\\tif ( one ) {\\n\\t\\t\\t\\t\\t\\t\\treturn value;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Multi-Selects return an array\\n\\t\\t\\t\\t\\t\\tvalues.push( value );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn values;\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function( elem, value ) {\\n\\t\\t\\t\\tvar optionSet, option,\\n\\t\\t\\t\\t\\toptions = elem.options,\\n\\t\\t\\t\\t\\tvalues = jQuery.makeArray( value ),\\n\\t\\t\\t\\t\\ti = options.length;\\n\\n\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\toption = options[ i ];\\n\\n\\t\\t\\t\\t\\t/* eslint-disable no-cond-assign */\\n\\n\\t\\t\\t\\t\\tif ( option.selected =\\n\\t\\t\\t\\t\\t\\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\\n\\t\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t\\toptionSet = true;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t/* eslint-enable no-cond-assign */\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Force browsers to behave consistently when non-matching value is set\\n\\t\\t\\t\\tif ( !optionSet ) {\\n\\t\\t\\t\\t\\telem.selectedIndex = -1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn values;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Radios and checkboxes getter/setter\\njQuery.each( [ \\\"radio\\\", \\\"checkbox\\\" ], function() {\\n\\tjQuery.valHooks[ this ] = {\\n\\t\\tset: function( elem, value ) {\\n\\t\\t\\tif ( jQuery.isArray( value ) ) {\\n\\t\\t\\t\\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\tif ( !support.checkOn ) {\\n\\t\\tjQuery.valHooks[ this ].get = function( elem ) {\\n\\t\\t\\treturn elem.getAttribute( \\\"value\\\" ) === null ? \\\"on\\\" : elem.value;\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\n// Return jQuery for attributes-only inclusion\\n\\n\\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\\n\\njQuery.extend( jQuery.event, {\\n\\n\\ttrigger: function( event, data, elem, onlyHandlers ) {\\n\\n\\t\\tvar i, cur, tmp, bubbleType, ontype, handle, special,\\n\\t\\t\\teventPath = [ elem || document ],\\n\\t\\t\\ttype = hasOwn.call( event, \\\"type\\\" ) ? event.type : event,\\n\\t\\t\\tnamespaces = hasOwn.call( event, \\\"namespace\\\" ) ? event.namespace.split( \\\".\\\" ) : [];\\n\\n\\t\\tcur = tmp = elem = elem || document;\\n\\n\\t\\t// Don't do events on text and comment nodes\\n\\t\\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\\n\\t\\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( type.indexOf( \\\".\\\" ) > -1 ) {\\n\\n\\t\\t\\t// Namespaced trigger; create a regexp to match event type in handle()\\n\\t\\t\\tnamespaces = type.split( \\\".\\\" );\\n\\t\\t\\ttype = namespaces.shift();\\n\\t\\t\\tnamespaces.sort();\\n\\t\\t}\\n\\t\\tontype = type.indexOf( \\\":\\\" ) < 0 && \\\"on\\\" + type;\\n\\n\\t\\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\\n\\t\\tevent = event[ jQuery.expando ] ?\\n\\t\\t\\tevent :\\n\\t\\t\\tnew jQuery.Event( type, typeof event === \\\"object\\\" && event );\\n\\n\\t\\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\\n\\t\\tevent.isTrigger = onlyHandlers ? 2 : 3;\\n\\t\\tevent.namespace = namespaces.join( \\\".\\\" );\\n\\t\\tevent.rnamespace = event.namespace ?\\n\\t\\t\\tnew RegExp( \\\"(^|\\\\\\\\.)\\\" + namespaces.join( \\\"\\\\\\\\.(?:.*\\\\\\\\.|)\\\" ) + \\\"(\\\\\\\\.|$)\\\" ) :\\n\\t\\t\\tnull;\\n\\n\\t\\t// Clean up the event in case it is being reused\\n\\t\\tevent.result = undefined;\\n\\t\\tif ( !event.target ) {\\n\\t\\t\\tevent.target = elem;\\n\\t\\t}\\n\\n\\t\\t// Clone any incoming data and prepend the event, creating the handler arg list\\n\\t\\tdata = data == null ?\\n\\t\\t\\t[ event ] :\\n\\t\\t\\tjQuery.makeArray( data, [ event ] );\\n\\n\\t\\t// Allow special events to draw outside the lines\\n\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\t\\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Determine event propagation path in advance, per W3C events spec (#9951)\\n\\t\\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\\n\\t\\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\\n\\n\\t\\t\\tbubbleType = special.delegateType || type;\\n\\t\\t\\tif ( !rfocusMorph.test( bubbleType + type ) ) {\\n\\t\\t\\t\\tcur = cur.parentNode;\\n\\t\\t\\t}\\n\\t\\t\\tfor ( ; cur; cur = cur.parentNode ) {\\n\\t\\t\\t\\teventPath.push( cur );\\n\\t\\t\\t\\ttmp = cur;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\\n\\t\\t\\tif ( tmp === ( elem.ownerDocument || document ) ) {\\n\\t\\t\\t\\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Fire handlers on the event path\\n\\t\\ti = 0;\\n\\t\\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\\n\\n\\t\\t\\tevent.type = i > 1 ?\\n\\t\\t\\t\\tbubbleType :\\n\\t\\t\\t\\tspecial.bindType || type;\\n\\n\\t\\t\\t// jQuery handler\\n\\t\\t\\thandle = ( dataPriv.get( cur, \\\"events\\\" ) || {} )[ event.type ] &&\\n\\t\\t\\t\\tdataPriv.get( cur, \\\"handle\\\" );\\n\\t\\t\\tif ( handle ) {\\n\\t\\t\\t\\thandle.apply( cur, data );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Native handler\\n\\t\\t\\thandle = ontype && cur[ ontype ];\\n\\t\\t\\tif ( handle && handle.apply && acceptData( cur ) ) {\\n\\t\\t\\t\\tevent.result = handle.apply( cur, data );\\n\\t\\t\\t\\tif ( event.result === false ) {\\n\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tevent.type = type;\\n\\n\\t\\t// If nobody prevented the default action, do it now\\n\\t\\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\\n\\n\\t\\t\\tif ( ( !special._default ||\\n\\t\\t\\t\\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\\n\\t\\t\\t\\tacceptData( elem ) ) {\\n\\n\\t\\t\\t\\t// Call a native DOM method on the target with the same name as the event.\\n\\t\\t\\t\\t// Don't do default actions on window, that's where global variables be (#6170)\\n\\t\\t\\t\\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\\n\\n\\t\\t\\t\\t\\t// Don't re-trigger an onFOO event when we call its FOO() method\\n\\t\\t\\t\\t\\ttmp = elem[ ontype ];\\n\\n\\t\\t\\t\\t\\tif ( tmp ) {\\n\\t\\t\\t\\t\\t\\telem[ ontype ] = null;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Prevent re-triggering of the same event, since we already bubbled it above\\n\\t\\t\\t\\t\\tjQuery.event.triggered = type;\\n\\t\\t\\t\\t\\telem[ type ]();\\n\\t\\t\\t\\t\\tjQuery.event.triggered = undefined;\\n\\n\\t\\t\\t\\t\\tif ( tmp ) {\\n\\t\\t\\t\\t\\t\\telem[ ontype ] = tmp;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn event.result;\\n\\t},\\n\\n\\t// Piggyback on a donor event to simulate a different one\\n\\t// Used only for `focus(in | out)` events\\n\\tsimulate: function( type, elem, event ) {\\n\\t\\tvar e = jQuery.extend(\\n\\t\\t\\tnew jQuery.Event(),\\n\\t\\t\\tevent,\\n\\t\\t\\t{\\n\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\tisSimulated: true\\n\\t\\t\\t}\\n\\t\\t);\\n\\n\\t\\tjQuery.event.trigger( e, null, elem );\\n\\t}\\n\\n} );\\n\\njQuery.fn.extend( {\\n\\n\\ttrigger: function( type, data ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.event.trigger( type, data, this );\\n\\t\\t} );\\n\\t},\\n\\ttriggerHandler: function( type, data ) {\\n\\t\\tvar elem = this[ 0 ];\\n\\t\\tif ( elem ) {\\n\\t\\t\\treturn jQuery.event.trigger( type, data, elem, true );\\n\\t\\t}\\n\\t}\\n} );\\n\\n\\njQuery.each( ( \\\"blur focus focusin focusout resize scroll click dblclick \\\" +\\n\\t\\\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \\\" +\\n\\t\\\"change select submit keydown keypress keyup contextmenu\\\" ).split( \\\" \\\" ),\\n\\tfunction( i, name ) {\\n\\n\\t// Handle event binding\\n\\tjQuery.fn[ name ] = function( data, fn ) {\\n\\t\\treturn arguments.length > 0 ?\\n\\t\\t\\tthis.on( name, null, data, fn ) :\\n\\t\\t\\tthis.trigger( name );\\n\\t};\\n} );\\n\\njQuery.fn.extend( {\\n\\thover: function( fnOver, fnOut ) {\\n\\t\\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\\n\\t}\\n} );\\n\\n\\n\\n\\nsupport.focusin = \\\"onfocusin\\\" in window;\\n\\n\\n// Support: Firefox <=44\\n// Firefox doesn't have focus(in | out) events\\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\\n//\\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\\n// focus(in | out) events fire after focus & blur events,\\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\\nif ( !support.focusin ) {\\n\\tjQuery.each( { focus: \\\"focusin\\\", blur: \\\"focusout\\\" }, function( orig, fix ) {\\n\\n\\t\\t// Attach a single capturing handler on the document while someone wants focusin/focusout\\n\\t\\tvar handler = function( event ) {\\n\\t\\t\\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\\n\\t\\t};\\n\\n\\t\\tjQuery.event.special[ fix ] = {\\n\\t\\t\\tsetup: function() {\\n\\t\\t\\t\\tvar doc = this.ownerDocument || this,\\n\\t\\t\\t\\t\\tattaches = dataPriv.access( doc, fix );\\n\\n\\t\\t\\t\\tif ( !attaches ) {\\n\\t\\t\\t\\t\\tdoc.addEventListener( orig, handler, true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\\n\\t\\t\\t},\\n\\t\\t\\tteardown: function() {\\n\\t\\t\\t\\tvar doc = this.ownerDocument || this,\\n\\t\\t\\t\\t\\tattaches = dataPriv.access( doc, fix ) - 1;\\n\\n\\t\\t\\t\\tif ( !attaches ) {\\n\\t\\t\\t\\t\\tdoc.removeEventListener( orig, handler, true );\\n\\t\\t\\t\\t\\tdataPriv.remove( doc, fix );\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdataPriv.access( doc, fix, attaches );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t} );\\n}\\nvar location = window.location;\\n\\nvar nonce = jQuery.now();\\n\\nvar rquery = ( /\\\\?/ );\\n\\n\\n\\n// Cross-browser xml parsing\\njQuery.parseXML = function( data ) {\\n\\tvar xml;\\n\\tif ( !data || typeof data !== \\\"string\\\" ) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// Support: IE 9 - 11 only\\n\\t// IE throws on parseFromString with invalid input.\\n\\ttry {\\n\\t\\txml = ( new window.DOMParser() ).parseFromString( data, \\\"text/xml\\\" );\\n\\t} catch ( e ) {\\n\\t\\txml = undefined;\\n\\t}\\n\\n\\tif ( !xml || xml.getElementsByTagName( \\\"parsererror\\\" ).length ) {\\n\\t\\tjQuery.error( \\\"Invalid XML: \\\" + data );\\n\\t}\\n\\treturn xml;\\n};\\n\\n\\nvar\\n\\trbracket = /\\\\[\\\\]$/,\\n\\trCRLF = /\\\\r?\\\\n/g,\\n\\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\\n\\trsubmittable = /^(?:input|select|textarea|keygen)/i;\\n\\nfunction buildParams( prefix, obj, traditional, add ) {\\n\\tvar name;\\n\\n\\tif ( jQuery.isArray( obj ) ) {\\n\\n\\t\\t// Serialize array item.\\n\\t\\tjQuery.each( obj, function( i, v ) {\\n\\t\\t\\tif ( traditional || rbracket.test( prefix ) ) {\\n\\n\\t\\t\\t\\t// Treat each array item as a scalar.\\n\\t\\t\\t\\tadd( prefix, v );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Item is non-scalar (array or object), encode its numeric index.\\n\\t\\t\\t\\tbuildParams(\\n\\t\\t\\t\\t\\tprefix + \\\"[\\\" + ( typeof v === \\\"object\\\" && v != null ? i : \\\"\\\" ) + \\\"]\\\",\\n\\t\\t\\t\\t\\tv,\\n\\t\\t\\t\\t\\ttraditional,\\n\\t\\t\\t\\t\\tadd\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t} else if ( !traditional && jQuery.type( obj ) === \\\"object\\\" ) {\\n\\n\\t\\t// Serialize object item.\\n\\t\\tfor ( name in obj ) {\\n\\t\\t\\tbuildParams( prefix + \\\"[\\\" + name + \\\"]\\\", obj[ name ], traditional, add );\\n\\t\\t}\\n\\n\\t} else {\\n\\n\\t\\t// Serialize scalar item.\\n\\t\\tadd( prefix, obj );\\n\\t}\\n}\\n\\n// Serialize an array of form elements or a set of\\n// key/values into a query string\\njQuery.param = function( a, traditional ) {\\n\\tvar prefix,\\n\\t\\ts = [],\\n\\t\\tadd = function( key, valueOrFunction ) {\\n\\n\\t\\t\\t// If value is a function, invoke it and use its return value\\n\\t\\t\\tvar value = jQuery.isFunction( valueOrFunction ) ?\\n\\t\\t\\t\\tvalueOrFunction() :\\n\\t\\t\\t\\tvalueOrFunction;\\n\\n\\t\\t\\ts[ s.length ] = encodeURIComponent( key ) + \\\"=\\\" +\\n\\t\\t\\t\\tencodeURIComponent( value == null ? \\\"\\\" : value );\\n\\t\\t};\\n\\n\\t// If an array was passed in, assume that it is an array of form elements.\\n\\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\\n\\n\\t\\t// Serialize the form elements\\n\\t\\tjQuery.each( a, function() {\\n\\t\\t\\tadd( this.name, this.value );\\n\\t\\t} );\\n\\n\\t} else {\\n\\n\\t\\t// If traditional, encode the \\\"old\\\" way (the way 1.3.2 or older\\n\\t\\t// did it), otherwise encode params recursively.\\n\\t\\tfor ( prefix in a ) {\\n\\t\\t\\tbuildParams( prefix, a[ prefix ], traditional, add );\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the resulting serialization\\n\\treturn s.join( \\\"&\\\" );\\n};\\n\\njQuery.fn.extend( {\\n\\tserialize: function() {\\n\\t\\treturn jQuery.param( this.serializeArray() );\\n\\t},\\n\\tserializeArray: function() {\\n\\t\\treturn this.map( function() {\\n\\n\\t\\t\\t// Can add propHook for \\\"elements\\\" to filter or add form elements\\n\\t\\t\\tvar elements = jQuery.prop( this, \\\"elements\\\" );\\n\\t\\t\\treturn elements ? jQuery.makeArray( elements ) : this;\\n\\t\\t} )\\n\\t\\t.filter( function() {\\n\\t\\t\\tvar type = this.type;\\n\\n\\t\\t\\t// Use .is( \\\":disabled\\\" ) so that fieldset[disabled] works\\n\\t\\t\\treturn this.name && !jQuery( this ).is( \\\":disabled\\\" ) &&\\n\\t\\t\\t\\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\\n\\t\\t\\t\\t( this.checked || !rcheckableType.test( type ) );\\n\\t\\t} )\\n\\t\\t.map( function( i, elem ) {\\n\\t\\t\\tvar val = jQuery( this ).val();\\n\\n\\t\\t\\tif ( val == null ) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( jQuery.isArray( val ) ) {\\n\\t\\t\\t\\treturn jQuery.map( val, function( val ) {\\n\\t\\t\\t\\t\\treturn { name: elem.name, value: val.replace( rCRLF, \\\"\\\\r\\\\n\\\" ) };\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn { name: elem.name, value: val.replace( rCRLF, \\\"\\\\r\\\\n\\\" ) };\\n\\t\\t} ).get();\\n\\t}\\n} );\\n\\n\\nvar\\n\\tr20 = /%20/g,\\n\\trhash = /#.*$/,\\n\\trantiCache = /([?&])_=[^&]*/,\\n\\trheaders = /^(.*?):[ \\\\t]*([^\\\\r\\\\n]*)$/mg,\\n\\n\\t// #7653, #8125, #8152: local protocol detection\\n\\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\\n\\trnoContent = /^(?:GET|HEAD)$/,\\n\\trprotocol = /^\\\\/\\\\//,\\n\\n\\t/* Prefilters\\n\\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\\n\\t * 2) These are called:\\n\\t *    - BEFORE asking for a transport\\n\\t *    - AFTER param serialization (s.data is a string if s.processData is true)\\n\\t * 3) key is the dataType\\n\\t * 4) the catchall symbol \\\"*\\\" can be used\\n\\t * 5) execution will start with transport dataType and THEN continue down to \\\"*\\\" if needed\\n\\t */\\n\\tprefilters = {},\\n\\n\\t/* Transports bindings\\n\\t * 1) key is the dataType\\n\\t * 2) the catchall symbol \\\"*\\\" can be used\\n\\t * 3) selection will start with transport dataType and THEN go to \\\"*\\\" if needed\\n\\t */\\n\\ttransports = {},\\n\\n\\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\\n\\tallTypes = \\\"*/\\\".concat( \\\"*\\\" ),\\n\\n\\t// Anchor tag for parsing the document origin\\n\\toriginAnchor = document.createElement( \\\"a\\\" );\\n\\toriginAnchor.href = location.href;\\n\\n// Base \\\"constructor\\\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\\nfunction addToPrefiltersOrTransports( structure ) {\\n\\n\\t// dataTypeExpression is optional and defaults to \\\"*\\\"\\n\\treturn function( dataTypeExpression, func ) {\\n\\n\\t\\tif ( typeof dataTypeExpression !== \\\"string\\\" ) {\\n\\t\\t\\tfunc = dataTypeExpression;\\n\\t\\t\\tdataTypeExpression = \\\"*\\\";\\n\\t\\t}\\n\\n\\t\\tvar dataType,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\\n\\n\\t\\tif ( jQuery.isFunction( func ) ) {\\n\\n\\t\\t\\t// For each dataType in the dataTypeExpression\\n\\t\\t\\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\\n\\n\\t\\t\\t\\t// Prepend if requested\\n\\t\\t\\t\\tif ( dataType[ 0 ] === \\\"+\\\" ) {\\n\\t\\t\\t\\t\\tdataType = dataType.slice( 1 ) || \\\"*\\\";\\n\\t\\t\\t\\t\\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\\n\\n\\t\\t\\t\\t// Otherwise append\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n}\\n\\n// Base inspection function for prefilters and transports\\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\\n\\n\\tvar inspected = {},\\n\\t\\tseekingTransport = ( structure === transports );\\n\\n\\tfunction inspect( dataType ) {\\n\\t\\tvar selected;\\n\\t\\tinspected[ dataType ] = true;\\n\\t\\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\\n\\t\\t\\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\\n\\t\\t\\tif ( typeof dataTypeOrTransport === \\\"string\\\" &&\\n\\t\\t\\t\\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\\n\\n\\t\\t\\t\\toptions.dataTypes.unshift( dataTypeOrTransport );\\n\\t\\t\\t\\tinspect( dataTypeOrTransport );\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t} else if ( seekingTransport ) {\\n\\t\\t\\t\\treturn !( selected = dataTypeOrTransport );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t\\treturn selected;\\n\\t}\\n\\n\\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \\\"*\\\" ] && inspect( \\\"*\\\" );\\n}\\n\\n// A special extend for ajax options\\n// that takes \\\"flat\\\" options (not to be deep extended)\\n// Fixes #9887\\nfunction ajaxExtend( target, src ) {\\n\\tvar key, deep,\\n\\t\\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\\n\\n\\tfor ( key in src ) {\\n\\t\\tif ( src[ key ] !== undefined ) {\\n\\t\\t\\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\\n\\t\\t}\\n\\t}\\n\\tif ( deep ) {\\n\\t\\tjQuery.extend( true, target, deep );\\n\\t}\\n\\n\\treturn target;\\n}\\n\\n/* Handles responses to an ajax request:\\n * - finds the right dataType (mediates between content-type and expected dataType)\\n * - returns the corresponding response\\n */\\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\\n\\n\\tvar ct, type, finalDataType, firstDataType,\\n\\t\\tcontents = s.contents,\\n\\t\\tdataTypes = s.dataTypes;\\n\\n\\t// Remove auto dataType and get content-type in the process\\n\\twhile ( dataTypes[ 0 ] === \\\"*\\\" ) {\\n\\t\\tdataTypes.shift();\\n\\t\\tif ( ct === undefined ) {\\n\\t\\t\\tct = s.mimeType || jqXHR.getResponseHeader( \\\"Content-Type\\\" );\\n\\t\\t}\\n\\t}\\n\\n\\t// Check if we're dealing with a known content-type\\n\\tif ( ct ) {\\n\\t\\tfor ( type in contents ) {\\n\\t\\t\\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\\n\\t\\t\\t\\tdataTypes.unshift( type );\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Check to see if we have a response for the expected dataType\\n\\tif ( dataTypes[ 0 ] in responses ) {\\n\\t\\tfinalDataType = dataTypes[ 0 ];\\n\\t} else {\\n\\n\\t\\t// Try convertible dataTypes\\n\\t\\tfor ( type in responses ) {\\n\\t\\t\\tif ( !dataTypes[ 0 ] || s.converters[ type + \\\" \\\" + dataTypes[ 0 ] ] ) {\\n\\t\\t\\t\\tfinalDataType = type;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif ( !firstDataType ) {\\n\\t\\t\\t\\tfirstDataType = type;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Or just use first one\\n\\t\\tfinalDataType = finalDataType || firstDataType;\\n\\t}\\n\\n\\t// If we found a dataType\\n\\t// We add the dataType to the list if needed\\n\\t// and return the corresponding response\\n\\tif ( finalDataType ) {\\n\\t\\tif ( finalDataType !== dataTypes[ 0 ] ) {\\n\\t\\t\\tdataTypes.unshift( finalDataType );\\n\\t\\t}\\n\\t\\treturn responses[ finalDataType ];\\n\\t}\\n}\\n\\n/* Chain conversions given the request and the original response\\n * Also sets the responseXXX fields on the jqXHR instance\\n */\\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\\n\\tvar conv2, current, conv, tmp, prev,\\n\\t\\tconverters = {},\\n\\n\\t\\t// Work with a copy of dataTypes in case we need to modify it for conversion\\n\\t\\tdataTypes = s.dataTypes.slice();\\n\\n\\t// Create converters map with lowercased keys\\n\\tif ( dataTypes[ 1 ] ) {\\n\\t\\tfor ( conv in s.converters ) {\\n\\t\\t\\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\\n\\t\\t}\\n\\t}\\n\\n\\tcurrent = dataTypes.shift();\\n\\n\\t// Convert to each sequential dataType\\n\\twhile ( current ) {\\n\\n\\t\\tif ( s.responseFields[ current ] ) {\\n\\t\\t\\tjqXHR[ s.responseFields[ current ] ] = response;\\n\\t\\t}\\n\\n\\t\\t// Apply the dataFilter if provided\\n\\t\\tif ( !prev && isSuccess && s.dataFilter ) {\\n\\t\\t\\tresponse = s.dataFilter( response, s.dataType );\\n\\t\\t}\\n\\n\\t\\tprev = current;\\n\\t\\tcurrent = dataTypes.shift();\\n\\n\\t\\tif ( current ) {\\n\\n\\t\\t\\t// There's only work to do if current dataType is non-auto\\n\\t\\t\\tif ( current === \\\"*\\\" ) {\\n\\n\\t\\t\\t\\tcurrent = prev;\\n\\n\\t\\t\\t// Convert response if prev dataType is non-auto and differs from current\\n\\t\\t\\t} else if ( prev !== \\\"*\\\" && prev !== current ) {\\n\\n\\t\\t\\t\\t// Seek a direct converter\\n\\t\\t\\t\\tconv = converters[ prev + \\\" \\\" + current ] || converters[ \\\"* \\\" + current ];\\n\\n\\t\\t\\t\\t// If none found, seek a pair\\n\\t\\t\\t\\tif ( !conv ) {\\n\\t\\t\\t\\t\\tfor ( conv2 in converters ) {\\n\\n\\t\\t\\t\\t\\t\\t// If conv2 outputs current\\n\\t\\t\\t\\t\\t\\ttmp = conv2.split( \\\" \\\" );\\n\\t\\t\\t\\t\\t\\tif ( tmp[ 1 ] === current ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// If prev can be converted to accepted input\\n\\t\\t\\t\\t\\t\\t\\tconv = converters[ prev + \\\" \\\" + tmp[ 0 ] ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\tconverters[ \\\"* \\\" + tmp[ 0 ] ];\\n\\t\\t\\t\\t\\t\\t\\tif ( conv ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Condense equivalence converters\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( conv === true ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tconv = converters[ conv2 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Otherwise, insert the intermediate dataType\\n\\t\\t\\t\\t\\t\\t\\t\\t} else if ( converters[ conv2 ] !== true ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcurrent = tmp[ 0 ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdataTypes.unshift( tmp[ 1 ] );\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Apply converter (if not an equivalence)\\n\\t\\t\\t\\tif ( conv !== true ) {\\n\\n\\t\\t\\t\\t\\t// Unless errors are allowed to bubble, catch and return them\\n\\t\\t\\t\\t\\tif ( conv && s.throws ) {\\n\\t\\t\\t\\t\\t\\tresponse = conv( response );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\tresponse = conv( response );\\n\\t\\t\\t\\t\\t\\t} catch ( e ) {\\n\\t\\t\\t\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\t\\t\\t\\tstate: \\\"parsererror\\\",\\n\\t\\t\\t\\t\\t\\t\\t\\terror: conv ? e : \\\"No conversion from \\\" + prev + \\\" to \\\" + current\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn { state: \\\"success\\\", data: response };\\n}\\n\\njQuery.extend( {\\n\\n\\t// Counter for holding the number of active queries\\n\\tactive: 0,\\n\\n\\t// Last-Modified header cache for next request\\n\\tlastModified: {},\\n\\tetag: {},\\n\\n\\tajaxSettings: {\\n\\t\\turl: location.href,\\n\\t\\ttype: \\\"GET\\\",\\n\\t\\tisLocal: rlocalProtocol.test( location.protocol ),\\n\\t\\tglobal: true,\\n\\t\\tprocessData: true,\\n\\t\\tasync: true,\\n\\t\\tcontentType: \\\"application/x-www-form-urlencoded; charset=UTF-8\\\",\\n\\n\\t\\t/*\\n\\t\\ttimeout: 0,\\n\\t\\tdata: null,\\n\\t\\tdataType: null,\\n\\t\\tusername: null,\\n\\t\\tpassword: null,\\n\\t\\tcache: null,\\n\\t\\tthrows: false,\\n\\t\\ttraditional: false,\\n\\t\\theaders: {},\\n\\t\\t*/\\n\\n\\t\\taccepts: {\\n\\t\\t\\t\\\"*\\\": allTypes,\\n\\t\\t\\ttext: \\\"text/plain\\\",\\n\\t\\t\\thtml: \\\"text/html\\\",\\n\\t\\t\\txml: \\\"application/xml, text/xml\\\",\\n\\t\\t\\tjson: \\\"application/json, text/javascript\\\"\\n\\t\\t},\\n\\n\\t\\tcontents: {\\n\\t\\t\\txml: /\\\\bxml\\\\b/,\\n\\t\\t\\thtml: /\\\\bhtml/,\\n\\t\\t\\tjson: /\\\\bjson\\\\b/\\n\\t\\t},\\n\\n\\t\\tresponseFields: {\\n\\t\\t\\txml: \\\"responseXML\\\",\\n\\t\\t\\ttext: \\\"responseText\\\",\\n\\t\\t\\tjson: \\\"responseJSON\\\"\\n\\t\\t},\\n\\n\\t\\t// Data converters\\n\\t\\t// Keys separate source (or catchall \\\"*\\\") and destination types with a single space\\n\\t\\tconverters: {\\n\\n\\t\\t\\t// Convert anything to text\\n\\t\\t\\t\\\"* text\\\": String,\\n\\n\\t\\t\\t// Text to html (true = no transformation)\\n\\t\\t\\t\\\"text html\\\": true,\\n\\n\\t\\t\\t// Evaluate text as a json expression\\n\\t\\t\\t\\\"text json\\\": JSON.parse,\\n\\n\\t\\t\\t// Parse text as xml\\n\\t\\t\\t\\\"text xml\\\": jQuery.parseXML\\n\\t\\t},\\n\\n\\t\\t// For options that shouldn't be deep extended:\\n\\t\\t// you can add your own custom options here if\\n\\t\\t// and when you create one that shouldn't be\\n\\t\\t// deep extended (see ajaxExtend)\\n\\t\\tflatOptions: {\\n\\t\\t\\turl: true,\\n\\t\\t\\tcontext: true\\n\\t\\t}\\n\\t},\\n\\n\\t// Creates a full fledged settings object into target\\n\\t// with both ajaxSettings and settings fields.\\n\\t// If target is omitted, writes into ajaxSettings.\\n\\tajaxSetup: function( target, settings ) {\\n\\t\\treturn settings ?\\n\\n\\t\\t\\t// Building a settings object\\n\\t\\t\\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\\n\\n\\t\\t\\t// Extending ajaxSettings\\n\\t\\t\\tajaxExtend( jQuery.ajaxSettings, target );\\n\\t},\\n\\n\\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\\n\\tajaxTransport: addToPrefiltersOrTransports( transports ),\\n\\n\\t// Main method\\n\\tajax: function( url, options ) {\\n\\n\\t\\t// If url is an object, simulate pre-1.5 signature\\n\\t\\tif ( typeof url === \\\"object\\\" ) {\\n\\t\\t\\toptions = url;\\n\\t\\t\\turl = undefined;\\n\\t\\t}\\n\\n\\t\\t// Force options to be an object\\n\\t\\toptions = options || {};\\n\\n\\t\\tvar transport,\\n\\n\\t\\t\\t// URL without anti-cache param\\n\\t\\t\\tcacheURL,\\n\\n\\t\\t\\t// Response headers\\n\\t\\t\\tresponseHeadersString,\\n\\t\\t\\tresponseHeaders,\\n\\n\\t\\t\\t// timeout handle\\n\\t\\t\\ttimeoutTimer,\\n\\n\\t\\t\\t// Url cleanup var\\n\\t\\t\\turlAnchor,\\n\\n\\t\\t\\t// Request state (becomes false upon send and true upon completion)\\n\\t\\t\\tcompleted,\\n\\n\\t\\t\\t// To know if global events are to be dispatched\\n\\t\\t\\tfireGlobals,\\n\\n\\t\\t\\t// Loop variable\\n\\t\\t\\ti,\\n\\n\\t\\t\\t// uncached part of the url\\n\\t\\t\\tuncached,\\n\\n\\t\\t\\t// Create the final options object\\n\\t\\t\\ts = jQuery.ajaxSetup( {}, options ),\\n\\n\\t\\t\\t// Callbacks context\\n\\t\\t\\tcallbackContext = s.context || s,\\n\\n\\t\\t\\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\\n\\t\\t\\tglobalEventContext = s.context &&\\n\\t\\t\\t\\t( callbackContext.nodeType || callbackContext.jquery ) ?\\n\\t\\t\\t\\t\\tjQuery( callbackContext ) :\\n\\t\\t\\t\\t\\tjQuery.event,\\n\\n\\t\\t\\t// Deferreds\\n\\t\\t\\tdeferred = jQuery.Deferred(),\\n\\t\\t\\tcompleteDeferred = jQuery.Callbacks( \\\"once memory\\\" ),\\n\\n\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\tstatusCode = s.statusCode || {},\\n\\n\\t\\t\\t// Headers (they are sent all at once)\\n\\t\\t\\trequestHeaders = {},\\n\\t\\t\\trequestHeadersNames = {},\\n\\n\\t\\t\\t// Default abort message\\n\\t\\t\\tstrAbort = \\\"canceled\\\",\\n\\n\\t\\t\\t// Fake xhr\\n\\t\\t\\tjqXHR = {\\n\\t\\t\\t\\treadyState: 0,\\n\\n\\t\\t\\t\\t// Builds headers hashtable if needed\\n\\t\\t\\t\\tgetResponseHeader: function( key ) {\\n\\t\\t\\t\\t\\tvar match;\\n\\t\\t\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\t\\t\\tif ( !responseHeaders ) {\\n\\t\\t\\t\\t\\t\\t\\tresponseHeaders = {};\\n\\t\\t\\t\\t\\t\\t\\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tmatch = responseHeaders[ key.toLowerCase() ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn match == null ? null : match;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Raw string\\n\\t\\t\\t\\tgetAllResponseHeaders: function() {\\n\\t\\t\\t\\t\\treturn completed ? responseHeadersString : null;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Caches the header\\n\\t\\t\\t\\tsetRequestHeader: function( name, value ) {\\n\\t\\t\\t\\t\\tif ( completed == null ) {\\n\\t\\t\\t\\t\\t\\tname = requestHeadersNames[ name.toLowerCase() ] =\\n\\t\\t\\t\\t\\t\\t\\trequestHeadersNames[ name.toLowerCase() ] || name;\\n\\t\\t\\t\\t\\t\\trequestHeaders[ name ] = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Overrides response content-type header\\n\\t\\t\\t\\toverrideMimeType: function( type ) {\\n\\t\\t\\t\\t\\tif ( completed == null ) {\\n\\t\\t\\t\\t\\t\\ts.mimeType = type;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\t\\tstatusCode: function( map ) {\\n\\t\\t\\t\\t\\tvar code;\\n\\t\\t\\t\\t\\tif ( map ) {\\n\\t\\t\\t\\t\\t\\tif ( completed ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Execute the appropriate callbacks\\n\\t\\t\\t\\t\\t\\t\\tjqXHR.always( map[ jqXHR.status ] );\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Lazy-add the new callbacks in a way that preserves old ones\\n\\t\\t\\t\\t\\t\\t\\tfor ( code in map ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Cancel the request\\n\\t\\t\\t\\tabort: function( statusText ) {\\n\\t\\t\\t\\t\\tvar finalText = statusText || strAbort;\\n\\t\\t\\t\\t\\tif ( transport ) {\\n\\t\\t\\t\\t\\t\\ttransport.abort( finalText );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdone( 0, finalText );\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t// Attach deferreds\\n\\t\\tdeferred.promise( jqXHR );\\n\\n\\t\\t// Add protocol if not provided (prefilters might expect it)\\n\\t\\t// Handle falsy url in the settings object (#10093: consistency with old signature)\\n\\t\\t// We also use the url parameter if available\\n\\t\\ts.url = ( ( url || s.url || location.href ) + \\\"\\\" )\\n\\t\\t\\t.replace( rprotocol, location.protocol + \\\"//\\\" );\\n\\n\\t\\t// Alias method option to type as per ticket #12004\\n\\t\\ts.type = options.method || options.type || s.method || s.type;\\n\\n\\t\\t// Extract dataTypes list\\n\\t\\ts.dataTypes = ( s.dataType || \\\"*\\\" ).toLowerCase().match( rnothtmlwhite ) || [ \\\"\\\" ];\\n\\n\\t\\t// A cross-domain request is in order when the origin doesn't match the current origin.\\n\\t\\tif ( s.crossDomain == null ) {\\n\\t\\t\\turlAnchor = document.createElement( \\\"a\\\" );\\n\\n\\t\\t\\t// Support: IE <=8 - 11, Edge 12 - 13\\n\\t\\t\\t// IE throws exception on accessing the href property if url is malformed,\\n\\t\\t\\t// e.g. http://example.com:80x/\\n\\t\\t\\ttry {\\n\\t\\t\\t\\turlAnchor.href = s.url;\\n\\n\\t\\t\\t\\t// Support: IE <=8 - 11 only\\n\\t\\t\\t\\t// Anchor's host property isn't correctly set when s.url is relative\\n\\t\\t\\t\\turlAnchor.href = urlAnchor.href;\\n\\t\\t\\t\\ts.crossDomain = originAnchor.protocol + \\\"//\\\" + originAnchor.host !==\\n\\t\\t\\t\\t\\turlAnchor.protocol + \\\"//\\\" + urlAnchor.host;\\n\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t// If there is an error parsing the URL, assume it is crossDomain,\\n\\t\\t\\t\\t// it can be rejected by the transport if it is invalid\\n\\t\\t\\t\\ts.crossDomain = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Convert data if not already a string\\n\\t\\tif ( s.data && s.processData && typeof s.data !== \\\"string\\\" ) {\\n\\t\\t\\ts.data = jQuery.param( s.data, s.traditional );\\n\\t\\t}\\n\\n\\t\\t// Apply prefilters\\n\\t\\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\\n\\n\\t\\t// If request was aborted inside a prefilter, stop there\\n\\t\\tif ( completed ) {\\n\\t\\t\\treturn jqXHR;\\n\\t\\t}\\n\\n\\t\\t// We can fire global events as of now if asked to\\n\\t\\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\\n\\t\\tfireGlobals = jQuery.event && s.global;\\n\\n\\t\\t// Watch for a new set of requests\\n\\t\\tif ( fireGlobals && jQuery.active++ === 0 ) {\\n\\t\\t\\tjQuery.event.trigger( \\\"ajaxStart\\\" );\\n\\t\\t}\\n\\n\\t\\t// Uppercase the type\\n\\t\\ts.type = s.type.toUpperCase();\\n\\n\\t\\t// Determine if request has content\\n\\t\\ts.hasContent = !rnoContent.test( s.type );\\n\\n\\t\\t// Save the URL in case we're toying with the If-Modified-Since\\n\\t\\t// and/or If-None-Match header later on\\n\\t\\t// Remove hash to simplify url manipulation\\n\\t\\tcacheURL = s.url.replace( rhash, \\\"\\\" );\\n\\n\\t\\t// More options handling for requests with no content\\n\\t\\tif ( !s.hasContent ) {\\n\\n\\t\\t\\t// Remember the hash so we can put it back\\n\\t\\t\\tuncached = s.url.slice( cacheURL.length );\\n\\n\\t\\t\\t// If data is available, append data to url\\n\\t\\t\\tif ( s.data ) {\\n\\t\\t\\t\\tcacheURL += ( rquery.test( cacheURL ) ? \\\"&\\\" : \\\"?\\\" ) + s.data;\\n\\n\\t\\t\\t\\t// #9682: remove data so that it's not used in an eventual retry\\n\\t\\t\\t\\tdelete s.data;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add or update anti-cache param if needed\\n\\t\\t\\tif ( s.cache === false ) {\\n\\t\\t\\t\\tcacheURL = cacheURL.replace( rantiCache, \\\"$1\\\" );\\n\\t\\t\\t\\tuncached = ( rquery.test( cacheURL ) ? \\\"&\\\" : \\\"?\\\" ) + \\\"_=\\\" + ( nonce++ ) + uncached;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\\n\\t\\t\\ts.url = cacheURL + uncached;\\n\\n\\t\\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\\n\\t\\t} else if ( s.data && s.processData &&\\n\\t\\t\\t( s.contentType || \\\"\\\" ).indexOf( \\\"application/x-www-form-urlencoded\\\" ) === 0 ) {\\n\\t\\t\\ts.data = s.data.replace( r20, \\\"+\\\" );\\n\\t\\t}\\n\\n\\t\\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\\n\\t\\tif ( s.ifModified ) {\\n\\t\\t\\tif ( jQuery.lastModified[ cacheURL ] ) {\\n\\t\\t\\t\\tjqXHR.setRequestHeader( \\\"If-Modified-Since\\\", jQuery.lastModified[ cacheURL ] );\\n\\t\\t\\t}\\n\\t\\t\\tif ( jQuery.etag[ cacheURL ] ) {\\n\\t\\t\\t\\tjqXHR.setRequestHeader( \\\"If-None-Match\\\", jQuery.etag[ cacheURL ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Set the correct header, if data is being sent\\n\\t\\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\\n\\t\\t\\tjqXHR.setRequestHeader( \\\"Content-Type\\\", s.contentType );\\n\\t\\t}\\n\\n\\t\\t// Set the Accepts header for the server, depending on the dataType\\n\\t\\tjqXHR.setRequestHeader(\\n\\t\\t\\t\\\"Accept\\\",\\n\\t\\t\\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\\n\\t\\t\\t\\ts.accepts[ s.dataTypes[ 0 ] ] +\\n\\t\\t\\t\\t\\t( s.dataTypes[ 0 ] !== \\\"*\\\" ? \\\", \\\" + allTypes + \\\"; q=0.01\\\" : \\\"\\\" ) :\\n\\t\\t\\t\\ts.accepts[ \\\"*\\\" ]\\n\\t\\t);\\n\\n\\t\\t// Check for headers option\\n\\t\\tfor ( i in s.headers ) {\\n\\t\\t\\tjqXHR.setRequestHeader( i, s.headers[ i ] );\\n\\t\\t}\\n\\n\\t\\t// Allow custom headers/mimetypes and early abort\\n\\t\\tif ( s.beforeSend &&\\n\\t\\t\\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\\n\\n\\t\\t\\t// Abort if not done already and return\\n\\t\\t\\treturn jqXHR.abort();\\n\\t\\t}\\n\\n\\t\\t// Aborting is no longer a cancellation\\n\\t\\tstrAbort = \\\"abort\\\";\\n\\n\\t\\t// Install callbacks on deferreds\\n\\t\\tcompleteDeferred.add( s.complete );\\n\\t\\tjqXHR.done( s.success );\\n\\t\\tjqXHR.fail( s.error );\\n\\n\\t\\t// Get transport\\n\\t\\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\\n\\n\\t\\t// If no transport, we auto-abort\\n\\t\\tif ( !transport ) {\\n\\t\\t\\tdone( -1, \\\"No Transport\\\" );\\n\\t\\t} else {\\n\\t\\t\\tjqXHR.readyState = 1;\\n\\n\\t\\t\\t// Send global event\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( \\\"ajaxSend\\\", [ jqXHR, s ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If request was aborted inside ajaxSend, stop there\\n\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\treturn jqXHR;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Timeout\\n\\t\\t\\tif ( s.async && s.timeout > 0 ) {\\n\\t\\t\\t\\ttimeoutTimer = window.setTimeout( function() {\\n\\t\\t\\t\\t\\tjqXHR.abort( \\\"timeout\\\" );\\n\\t\\t\\t\\t}, s.timeout );\\n\\t\\t\\t}\\n\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tcompleted = false;\\n\\t\\t\\t\\ttransport.send( requestHeaders, done );\\n\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t// Rethrow post-completion exceptions\\n\\t\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\t\\tthrow e;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Propagate others as results\\n\\t\\t\\t\\tdone( -1, e );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Callback for when everything is done\\n\\t\\tfunction done( status, nativeStatusText, responses, headers ) {\\n\\t\\t\\tvar isSuccess, success, error, response, modified,\\n\\t\\t\\t\\tstatusText = nativeStatusText;\\n\\n\\t\\t\\t// Ignore repeat invocations\\n\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcompleted = true;\\n\\n\\t\\t\\t// Clear timeout if it exists\\n\\t\\t\\tif ( timeoutTimer ) {\\n\\t\\t\\t\\twindow.clearTimeout( timeoutTimer );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Dereference transport for early garbage collection\\n\\t\\t\\t// (no matter how long the jqXHR object will be used)\\n\\t\\t\\ttransport = undefined;\\n\\n\\t\\t\\t// Cache response headers\\n\\t\\t\\tresponseHeadersString = headers || \\\"\\\";\\n\\n\\t\\t\\t// Set readyState\\n\\t\\t\\tjqXHR.readyState = status > 0 ? 4 : 0;\\n\\n\\t\\t\\t// Determine if successful\\n\\t\\t\\tisSuccess = status >= 200 && status < 300 || status === 304;\\n\\n\\t\\t\\t// Get response data\\n\\t\\t\\tif ( responses ) {\\n\\t\\t\\t\\tresponse = ajaxHandleResponses( s, jqXHR, responses );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Convert no matter what (that way responseXXX fields are always set)\\n\\t\\t\\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\\n\\n\\t\\t\\t// If successful, handle type chaining\\n\\t\\t\\tif ( isSuccess ) {\\n\\n\\t\\t\\t\\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\\n\\t\\t\\t\\tif ( s.ifModified ) {\\n\\t\\t\\t\\t\\tmodified = jqXHR.getResponseHeader( \\\"Last-Modified\\\" );\\n\\t\\t\\t\\t\\tif ( modified ) {\\n\\t\\t\\t\\t\\t\\tjQuery.lastModified[ cacheURL ] = modified;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmodified = jqXHR.getResponseHeader( \\\"etag\\\" );\\n\\t\\t\\t\\t\\tif ( modified ) {\\n\\t\\t\\t\\t\\t\\tjQuery.etag[ cacheURL ] = modified;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if no content\\n\\t\\t\\t\\tif ( status === 204 || s.type === \\\"HEAD\\\" ) {\\n\\t\\t\\t\\t\\tstatusText = \\\"nocontent\\\";\\n\\n\\t\\t\\t\\t// if not modified\\n\\t\\t\\t\\t} else if ( status === 304 ) {\\n\\t\\t\\t\\t\\tstatusText = \\\"notmodified\\\";\\n\\n\\t\\t\\t\\t// If we have data, let's convert it\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tstatusText = response.state;\\n\\t\\t\\t\\t\\tsuccess = response.data;\\n\\t\\t\\t\\t\\terror = response.error;\\n\\t\\t\\t\\t\\tisSuccess = !error;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Extract error from statusText and normalize for non-aborts\\n\\t\\t\\t\\terror = statusText;\\n\\t\\t\\t\\tif ( status || !statusText ) {\\n\\t\\t\\t\\t\\tstatusText = \\\"error\\\";\\n\\t\\t\\t\\t\\tif ( status < 0 ) {\\n\\t\\t\\t\\t\\t\\tstatus = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set data for the fake xhr object\\n\\t\\t\\tjqXHR.status = status;\\n\\t\\t\\tjqXHR.statusText = ( nativeStatusText || statusText ) + \\\"\\\";\\n\\n\\t\\t\\t// Success/Error\\n\\t\\t\\tif ( isSuccess ) {\\n\\t\\t\\t\\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\tjqXHR.statusCode( statusCode );\\n\\t\\t\\tstatusCode = undefined;\\n\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( isSuccess ? \\\"ajaxSuccess\\\" : \\\"ajaxError\\\",\\n\\t\\t\\t\\t\\t[ jqXHR, s, isSuccess ? success : error ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Complete\\n\\t\\t\\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\\n\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( \\\"ajaxComplete\\\", [ jqXHR, s ] );\\n\\n\\t\\t\\t\\t// Handle the global AJAX counter\\n\\t\\t\\t\\tif ( !( --jQuery.active ) ) {\\n\\t\\t\\t\\t\\tjQuery.event.trigger( \\\"ajaxStop\\\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn jqXHR;\\n\\t},\\n\\n\\tgetJSON: function( url, data, callback ) {\\n\\t\\treturn jQuery.get( url, data, callback, \\\"json\\\" );\\n\\t},\\n\\n\\tgetScript: function( url, callback ) {\\n\\t\\treturn jQuery.get( url, undefined, callback, \\\"script\\\" );\\n\\t}\\n} );\\n\\njQuery.each( [ \\\"get\\\", \\\"post\\\" ], function( i, method ) {\\n\\tjQuery[ method ] = function( url, data, callback, type ) {\\n\\n\\t\\t// Shift arguments if data argument was omitted\\n\\t\\tif ( jQuery.isFunction( data ) ) {\\n\\t\\t\\ttype = type || callback;\\n\\t\\t\\tcallback = data;\\n\\t\\t\\tdata = undefined;\\n\\t\\t}\\n\\n\\t\\t// The url can be an options object (which then must have .url)\\n\\t\\treturn jQuery.ajax( jQuery.extend( {\\n\\t\\t\\turl: url,\\n\\t\\t\\ttype: method,\\n\\t\\t\\tdataType: type,\\n\\t\\t\\tdata: data,\\n\\t\\t\\tsuccess: callback\\n\\t\\t}, jQuery.isPlainObject( url ) && url ) );\\n\\t};\\n} );\\n\\n\\njQuery._evalUrl = function( url ) {\\n\\treturn jQuery.ajax( {\\n\\t\\turl: url,\\n\\n\\t\\t// Make this explicit, since user can override this through ajaxSetup (#11264)\\n\\t\\ttype: \\\"GET\\\",\\n\\t\\tdataType: \\\"script\\\",\\n\\t\\tcache: true,\\n\\t\\tasync: false,\\n\\t\\tglobal: false,\\n\\t\\t\\\"throws\\\": true\\n\\t} );\\n};\\n\\n\\njQuery.fn.extend( {\\n\\twrapAll: function( html ) {\\n\\t\\tvar wrap;\\n\\n\\t\\tif ( this[ 0 ] ) {\\n\\t\\t\\tif ( jQuery.isFunction( html ) ) {\\n\\t\\t\\t\\thtml = html.call( this[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// The elements to wrap the target around\\n\\t\\t\\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\\n\\n\\t\\t\\tif ( this[ 0 ].parentNode ) {\\n\\t\\t\\t\\twrap.insertBefore( this[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\twrap.map( function() {\\n\\t\\t\\t\\tvar elem = this;\\n\\n\\t\\t\\t\\twhile ( elem.firstElementChild ) {\\n\\t\\t\\t\\t\\telem = elem.firstElementChild;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn elem;\\n\\t\\t\\t} ).append( this );\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\twrapInner: function( html ) {\\n\\t\\tif ( jQuery.isFunction( html ) ) {\\n\\t\\t\\treturn this.each( function( i ) {\\n\\t\\t\\t\\tjQuery( this ).wrapInner( html.call( this, i ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar self = jQuery( this ),\\n\\t\\t\\t\\tcontents = self.contents();\\n\\n\\t\\t\\tif ( contents.length ) {\\n\\t\\t\\t\\tcontents.wrapAll( html );\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tself.append( html );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\twrap: function( html ) {\\n\\t\\tvar isFunction = jQuery.isFunction( html );\\n\\n\\t\\treturn this.each( function( i ) {\\n\\t\\t\\tjQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\\n\\t\\t} );\\n\\t},\\n\\n\\tunwrap: function( selector ) {\\n\\t\\tthis.parent( selector ).not( \\\"body\\\" ).each( function() {\\n\\t\\t\\tjQuery( this ).replaceWith( this.childNodes );\\n\\t\\t} );\\n\\t\\treturn this;\\n\\t}\\n} );\\n\\n\\njQuery.expr.pseudos.hidden = function( elem ) {\\n\\treturn !jQuery.expr.pseudos.visible( elem );\\n};\\njQuery.expr.pseudos.visible = function( elem ) {\\n\\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\\n};\\n\\n\\n\\n\\njQuery.ajaxSettings.xhr = function() {\\n\\ttry {\\n\\t\\treturn new window.XMLHttpRequest();\\n\\t} catch ( e ) {}\\n};\\n\\nvar xhrSuccessStatus = {\\n\\n\\t\\t// File protocol always yields status code 0, assume 200\\n\\t\\t0: 200,\\n\\n\\t\\t// Support: IE <=9 only\\n\\t\\t// #1450: sometimes IE returns 1223 when it should be 204\\n\\t\\t1223: 204\\n\\t},\\n\\txhrSupported = jQuery.ajaxSettings.xhr();\\n\\nsupport.cors = !!xhrSupported && ( \\\"withCredentials\\\" in xhrSupported );\\nsupport.ajax = xhrSupported = !!xhrSupported;\\n\\njQuery.ajaxTransport( function( options ) {\\n\\tvar callback, errorCallback;\\n\\n\\t// Cross domain only allowed if supported through XMLHttpRequest\\n\\tif ( support.cors || xhrSupported && !options.crossDomain ) {\\n\\t\\treturn {\\n\\t\\t\\tsend: function( headers, complete ) {\\n\\t\\t\\t\\tvar i,\\n\\t\\t\\t\\t\\txhr = options.xhr();\\n\\n\\t\\t\\t\\txhr.open(\\n\\t\\t\\t\\t\\toptions.type,\\n\\t\\t\\t\\t\\toptions.url,\\n\\t\\t\\t\\t\\toptions.async,\\n\\t\\t\\t\\t\\toptions.username,\\n\\t\\t\\t\\t\\toptions.password\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t// Apply custom fields if provided\\n\\t\\t\\t\\tif ( options.xhrFields ) {\\n\\t\\t\\t\\t\\tfor ( i in options.xhrFields ) {\\n\\t\\t\\t\\t\\t\\txhr[ i ] = options.xhrFields[ i ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Override mime type if needed\\n\\t\\t\\t\\tif ( options.mimeType && xhr.overrideMimeType ) {\\n\\t\\t\\t\\t\\txhr.overrideMimeType( options.mimeType );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// X-Requested-With header\\n\\t\\t\\t\\t// For cross-domain requests, seeing as conditions for a preflight are\\n\\t\\t\\t\\t// akin to a jigsaw puzzle, we simply never set it to be sure.\\n\\t\\t\\t\\t// (it can always be set on a per-request basis or even using ajaxSetup)\\n\\t\\t\\t\\t// For same-domain requests, won't change header if already provided.\\n\\t\\t\\t\\tif ( !options.crossDomain && !headers[ \\\"X-Requested-With\\\" ] ) {\\n\\t\\t\\t\\t\\theaders[ \\\"X-Requested-With\\\" ] = \\\"XMLHttpRequest\\\";\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Set headers\\n\\t\\t\\t\\tfor ( i in headers ) {\\n\\t\\t\\t\\t\\txhr.setRequestHeader( i, headers[ i ] );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Callback\\n\\t\\t\\t\\tcallback = function( type ) {\\n\\t\\t\\t\\t\\treturn function() {\\n\\t\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\t\\tcallback = errorCallback = xhr.onload =\\n\\t\\t\\t\\t\\t\\t\\t\\txhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( type === \\\"abort\\\" ) {\\n\\t\\t\\t\\t\\t\\t\\t\\txhr.abort();\\n\\t\\t\\t\\t\\t\\t\\t} else if ( type === \\\"error\\\" ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t// On a manual native abort, IE9 throws\\n\\t\\t\\t\\t\\t\\t\\t\\t// errors on any property access that is not readyState\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( typeof xhr.status !== \\\"number\\\" ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcomplete( 0, \\\"error\\\" );\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcomplete(\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// File: protocol always yields status 0; see #8605, #14207\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.status,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.statusText\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tcomplete(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhrSuccessStatus[ xhr.status ] || xhr.status,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.statusText,\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// IE9 has no XHR2 but throws on binary (trac-11426)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// For XHR2 non-text, let the caller handle it (gh-2498)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t( xhr.responseType || \\\"text\\\" ) !== \\\"text\\\"  ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ttypeof xhr.responseText !== \\\"string\\\" ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{ binary: xhr.response } :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{ text: xhr.responseText },\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.getAllResponseHeaders()\\n\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t// Listen to events\\n\\t\\t\\t\\txhr.onload = callback();\\n\\t\\t\\t\\terrorCallback = xhr.onerror = callback( \\\"error\\\" );\\n\\n\\t\\t\\t\\t// Support: IE 9 only\\n\\t\\t\\t\\t// Use onreadystatechange to replace onabort\\n\\t\\t\\t\\t// to handle uncaught aborts\\n\\t\\t\\t\\tif ( xhr.onabort !== undefined ) {\\n\\t\\t\\t\\t\\txhr.onabort = errorCallback;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\txhr.onreadystatechange = function() {\\n\\n\\t\\t\\t\\t\\t\\t// Check readyState before timeout as it changes\\n\\t\\t\\t\\t\\t\\tif ( xhr.readyState === 4 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Allow onerror to be called first,\\n\\t\\t\\t\\t\\t\\t\\t// but that will not handle a native abort\\n\\t\\t\\t\\t\\t\\t\\t// Also, save errorCallback to a variable\\n\\t\\t\\t\\t\\t\\t\\t// as xhr.onerror cannot be accessed\\n\\t\\t\\t\\t\\t\\t\\twindow.setTimeout( function() {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\terrorCallback();\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Create the abort callback\\n\\t\\t\\t\\tcallback = callback( \\\"abort\\\" );\\n\\n\\t\\t\\t\\ttry {\\n\\n\\t\\t\\t\\t\\t// Do send the request (this may raise an exception)\\n\\t\\t\\t\\t\\txhr.send( options.hasContent && options.data || null );\\n\\t\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t\\t// #14683: Only rethrow if this hasn't been notified as an error yet\\n\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\tthrow e;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\tabort: function() {\\n\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\tcallback();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\\njQuery.ajaxPrefilter( function( s ) {\\n\\tif ( s.crossDomain ) {\\n\\t\\ts.contents.script = false;\\n\\t}\\n} );\\n\\n// Install script dataType\\njQuery.ajaxSetup( {\\n\\taccepts: {\\n\\t\\tscript: \\\"text/javascript, application/javascript, \\\" +\\n\\t\\t\\t\\\"application/ecmascript, application/x-ecmascript\\\"\\n\\t},\\n\\tcontents: {\\n\\t\\tscript: /\\\\b(?:java|ecma)script\\\\b/\\n\\t},\\n\\tconverters: {\\n\\t\\t\\\"text script\\\": function( text ) {\\n\\t\\t\\tjQuery.globalEval( text );\\n\\t\\t\\treturn text;\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Handle cache's special case and crossDomain\\njQuery.ajaxPrefilter( \\\"script\\\", function( s ) {\\n\\tif ( s.cache === undefined ) {\\n\\t\\ts.cache = false;\\n\\t}\\n\\tif ( s.crossDomain ) {\\n\\t\\ts.type = \\\"GET\\\";\\n\\t}\\n} );\\n\\n// Bind script tag hack transport\\njQuery.ajaxTransport( \\\"script\\\", function( s ) {\\n\\n\\t// This transport only deals with cross domain requests\\n\\tif ( s.crossDomain ) {\\n\\t\\tvar script, callback;\\n\\t\\treturn {\\n\\t\\t\\tsend: function( _, complete ) {\\n\\t\\t\\t\\tscript = jQuery( \\\"<script>\\\" ).prop( {\\n\\t\\t\\t\\t\\tcharset: s.scriptCharset,\\n\\t\\t\\t\\t\\tsrc: s.url\\n\\t\\t\\t\\t} ).on(\\n\\t\\t\\t\\t\\t\\\"load error\\\",\\n\\t\\t\\t\\t\\tcallback = function( evt ) {\\n\\t\\t\\t\\t\\t\\tscript.remove();\\n\\t\\t\\t\\t\\t\\tcallback = null;\\n\\t\\t\\t\\t\\t\\tif ( evt ) {\\n\\t\\t\\t\\t\\t\\t\\tcomplete( evt.type === \\\"error\\\" ? 404 : 200, evt.type );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t// Use native DOM manipulation to avoid our domManip AJAX trickery\\n\\t\\t\\t\\tdocument.head.appendChild( script[ 0 ] );\\n\\t\\t\\t},\\n\\t\\t\\tabort: function() {\\n\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\tcallback();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\nvar oldCallbacks = [],\\n\\trjsonp = /(=)\\\\?(?=&|$)|\\\\?\\\\?/;\\n\\n// Default jsonp settings\\njQuery.ajaxSetup( {\\n\\tjsonp: \\\"callback\\\",\\n\\tjsonpCallback: function() {\\n\\t\\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \\\"_\\\" + ( nonce++ ) );\\n\\t\\tthis[ callback ] = true;\\n\\t\\treturn callback;\\n\\t}\\n} );\\n\\n// Detect, normalize options and install callbacks for jsonp requests\\njQuery.ajaxPrefilter( \\\"json jsonp\\\", function( s, originalSettings, jqXHR ) {\\n\\n\\tvar callbackName, overwritten, responseContainer,\\n\\t\\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\\n\\t\\t\\t\\\"url\\\" :\\n\\t\\t\\ttypeof s.data === \\\"string\\\" &&\\n\\t\\t\\t\\t( s.contentType || \\\"\\\" )\\n\\t\\t\\t\\t\\t.indexOf( \\\"application/x-www-form-urlencoded\\\" ) === 0 &&\\n\\t\\t\\t\\trjsonp.test( s.data ) && \\\"data\\\"\\n\\t\\t);\\n\\n\\t// Handle iff the expected data type is \\\"jsonp\\\" or we have a parameter to set\\n\\tif ( jsonProp || s.dataTypes[ 0 ] === \\\"jsonp\\\" ) {\\n\\n\\t\\t// Get callback name, remembering preexisting value associated with it\\n\\t\\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\\n\\t\\t\\ts.jsonpCallback() :\\n\\t\\t\\ts.jsonpCallback;\\n\\n\\t\\t// Insert callback into url or form data\\n\\t\\tif ( jsonProp ) {\\n\\t\\t\\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \\\"$1\\\" + callbackName );\\n\\t\\t} else if ( s.jsonp !== false ) {\\n\\t\\t\\ts.url += ( rquery.test( s.url ) ? \\\"&\\\" : \\\"?\\\" ) + s.jsonp + \\\"=\\\" + callbackName;\\n\\t\\t}\\n\\n\\t\\t// Use data converter to retrieve json after script execution\\n\\t\\ts.converters[ \\\"script json\\\" ] = function() {\\n\\t\\t\\tif ( !responseContainer ) {\\n\\t\\t\\t\\tjQuery.error( callbackName + \\\" was not called\\\" );\\n\\t\\t\\t}\\n\\t\\t\\treturn responseContainer[ 0 ];\\n\\t\\t};\\n\\n\\t\\t// Force json dataType\\n\\t\\ts.dataTypes[ 0 ] = \\\"json\\\";\\n\\n\\t\\t// Install callback\\n\\t\\toverwritten = window[ callbackName ];\\n\\t\\twindow[ callbackName ] = function() {\\n\\t\\t\\tresponseContainer = arguments;\\n\\t\\t};\\n\\n\\t\\t// Clean-up function (fires after converters)\\n\\t\\tjqXHR.always( function() {\\n\\n\\t\\t\\t// If previous value didn't exist - remove it\\n\\t\\t\\tif ( overwritten === undefined ) {\\n\\t\\t\\t\\tjQuery( window ).removeProp( callbackName );\\n\\n\\t\\t\\t// Otherwise restore preexisting value\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twindow[ callbackName ] = overwritten;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Save back as free\\n\\t\\t\\tif ( s[ callbackName ] ) {\\n\\n\\t\\t\\t\\t// Make sure that re-using the options doesn't screw things around\\n\\t\\t\\t\\ts.jsonpCallback = originalSettings.jsonpCallback;\\n\\n\\t\\t\\t\\t// Save the callback name for future use\\n\\t\\t\\t\\toldCallbacks.push( callbackName );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Call if it was a function and we have a response\\n\\t\\t\\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\\n\\t\\t\\t\\toverwritten( responseContainer[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\tresponseContainer = overwritten = undefined;\\n\\t\\t} );\\n\\n\\t\\t// Delegate to script\\n\\t\\treturn \\\"script\\\";\\n\\t}\\n} );\\n\\n\\n\\n\\n// Support: Safari 8 only\\n// In Safari 8 documents created via document.implementation.createHTMLDocument\\n// collapse sibling forms: the second one becomes a child of the first one.\\n// Because of that, this security measure has to be disabled in Safari 8.\\n// https://bugs.webkit.org/show_bug.cgi?id=137337\\nsupport.createHTMLDocument = ( function() {\\n\\tvar body = document.implementation.createHTMLDocument( \\\"\\\" ).body;\\n\\tbody.innerHTML = \\\"<form></form><form></form>\\\";\\n\\treturn body.childNodes.length === 2;\\n} )();\\n\\n\\n// Argument \\\"data\\\" should be string of html\\n// context (optional): If specified, the fragment will be created in this context,\\n// defaults to document\\n// keepScripts (optional): If true, will include scripts passed in the html string\\njQuery.parseHTML = function( data, context, keepScripts ) {\\n\\tif ( typeof data !== \\\"string\\\" ) {\\n\\t\\treturn [];\\n\\t}\\n\\tif ( typeof context === \\\"boolean\\\" ) {\\n\\t\\tkeepScripts = context;\\n\\t\\tcontext = false;\\n\\t}\\n\\n\\tvar base, parsed, scripts;\\n\\n\\tif ( !context ) {\\n\\n\\t\\t// Stop scripts or inline event handlers from being executed immediately\\n\\t\\t// by using document.implementation\\n\\t\\tif ( support.createHTMLDocument ) {\\n\\t\\t\\tcontext = document.implementation.createHTMLDocument( \\\"\\\" );\\n\\n\\t\\t\\t// Set the base href for the created document\\n\\t\\t\\t// so any parsed elements with URLs\\n\\t\\t\\t// are based on the document's URL (gh-2965)\\n\\t\\t\\tbase = context.createElement( \\\"base\\\" );\\n\\t\\t\\tbase.href = document.location.href;\\n\\t\\t\\tcontext.head.appendChild( base );\\n\\t\\t} else {\\n\\t\\t\\tcontext = document;\\n\\t\\t}\\n\\t}\\n\\n\\tparsed = rsingleTag.exec( data );\\n\\tscripts = !keepScripts && [];\\n\\n\\t// Single tag\\n\\tif ( parsed ) {\\n\\t\\treturn [ context.createElement( parsed[ 1 ] ) ];\\n\\t}\\n\\n\\tparsed = buildFragment( [ data ], context, scripts );\\n\\n\\tif ( scripts && scripts.length ) {\\n\\t\\tjQuery( scripts ).remove();\\n\\t}\\n\\n\\treturn jQuery.merge( [], parsed.childNodes );\\n};\\n\\n\\n/**\\n * Load a url into a page\\n */\\njQuery.fn.load = function( url, params, callback ) {\\n\\tvar selector, type, response,\\n\\t\\tself = this,\\n\\t\\toff = url.indexOf( \\\" \\\" );\\n\\n\\tif ( off > -1 ) {\\n\\t\\tselector = stripAndCollapse( url.slice( off ) );\\n\\t\\turl = url.slice( 0, off );\\n\\t}\\n\\n\\t// If it's a function\\n\\tif ( jQuery.isFunction( params ) ) {\\n\\n\\t\\t// We assume that it's the callback\\n\\t\\tcallback = params;\\n\\t\\tparams = undefined;\\n\\n\\t// Otherwise, build a param string\\n\\t} else if ( params && typeof params === \\\"object\\\" ) {\\n\\t\\ttype = \\\"POST\\\";\\n\\t}\\n\\n\\t// If we have elements to modify, make the request\\n\\tif ( self.length > 0 ) {\\n\\t\\tjQuery.ajax( {\\n\\t\\t\\turl: url,\\n\\n\\t\\t\\t// If \\\"type\\\" variable is undefined, then \\\"GET\\\" method will be used.\\n\\t\\t\\t// Make value of this field explicit since\\n\\t\\t\\t// user can override it through ajaxSetup method\\n\\t\\t\\ttype: type || \\\"GET\\\",\\n\\t\\t\\tdataType: \\\"html\\\",\\n\\t\\t\\tdata: params\\n\\t\\t} ).done( function( responseText ) {\\n\\n\\t\\t\\t// Save response for use in complete callback\\n\\t\\t\\tresponse = arguments;\\n\\n\\t\\t\\tself.html( selector ?\\n\\n\\t\\t\\t\\t// If a selector was specified, locate the right elements in a dummy div\\n\\t\\t\\t\\t// Exclude scripts to avoid IE 'Permission Denied' errors\\n\\t\\t\\t\\tjQuery( \\\"<div>\\\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\\n\\n\\t\\t\\t\\t// Otherwise use the full result\\n\\t\\t\\t\\tresponseText );\\n\\n\\t\\t// If the request succeeds, this function gets \\\"data\\\", \\\"status\\\", \\\"jqXHR\\\"\\n\\t\\t// but they are ignored because response was set above.\\n\\t\\t// If it fails, this function gets \\\"jqXHR\\\", \\\"status\\\", \\\"error\\\"\\n\\t\\t} ).always( callback && function( jqXHR, status ) {\\n\\t\\t\\tself.each( function() {\\n\\t\\t\\t\\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\\n\\t\\t\\t} );\\n\\t\\t} );\\n\\t}\\n\\n\\treturn this;\\n};\\n\\n\\n\\n\\n// Attach a bunch of functions for handling common AJAX events\\njQuery.each( [\\n\\t\\\"ajaxStart\\\",\\n\\t\\\"ajaxStop\\\",\\n\\t\\\"ajaxComplete\\\",\\n\\t\\\"ajaxError\\\",\\n\\t\\\"ajaxSuccess\\\",\\n\\t\\\"ajaxSend\\\"\\n], function( i, type ) {\\n\\tjQuery.fn[ type ] = function( fn ) {\\n\\t\\treturn this.on( type, fn );\\n\\t};\\n} );\\n\\n\\n\\n\\njQuery.expr.pseudos.animated = function( elem ) {\\n\\treturn jQuery.grep( jQuery.timers, function( fn ) {\\n\\t\\treturn elem === fn.elem;\\n\\t} ).length;\\n};\\n\\n\\n\\n\\n/**\\n * Gets a window from an element\\n */\\nfunction getWindow( elem ) {\\n\\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\\n}\\n\\njQuery.offset = {\\n\\tsetOffset: function( elem, options, i ) {\\n\\t\\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\\n\\t\\t\\tposition = jQuery.css( elem, \\\"position\\\" ),\\n\\t\\t\\tcurElem = jQuery( elem ),\\n\\t\\t\\tprops = {};\\n\\n\\t\\t// Set position first, in-case top/left are set even on static elem\\n\\t\\tif ( position === \\\"static\\\" ) {\\n\\t\\t\\telem.style.position = \\\"relative\\\";\\n\\t\\t}\\n\\n\\t\\tcurOffset = curElem.offset();\\n\\t\\tcurCSSTop = jQuery.css( elem, \\\"top\\\" );\\n\\t\\tcurCSSLeft = jQuery.css( elem, \\\"left\\\" );\\n\\t\\tcalculatePosition = ( position === \\\"absolute\\\" || position === \\\"fixed\\\" ) &&\\n\\t\\t\\t( curCSSTop + curCSSLeft ).indexOf( \\\"auto\\\" ) > -1;\\n\\n\\t\\t// Need to be able to calculate position if either\\n\\t\\t// top or left is auto and position is either absolute or fixed\\n\\t\\tif ( calculatePosition ) {\\n\\t\\t\\tcurPosition = curElem.position();\\n\\t\\t\\tcurTop = curPosition.top;\\n\\t\\t\\tcurLeft = curPosition.left;\\n\\n\\t\\t} else {\\n\\t\\t\\tcurTop = parseFloat( curCSSTop ) || 0;\\n\\t\\t\\tcurLeft = parseFloat( curCSSLeft ) || 0;\\n\\t\\t}\\n\\n\\t\\tif ( jQuery.isFunction( options ) ) {\\n\\n\\t\\t\\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\\n\\t\\t\\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\\n\\t\\t}\\n\\n\\t\\tif ( options.top != null ) {\\n\\t\\t\\tprops.top = ( options.top - curOffset.top ) + curTop;\\n\\t\\t}\\n\\t\\tif ( options.left != null ) {\\n\\t\\t\\tprops.left = ( options.left - curOffset.left ) + curLeft;\\n\\t\\t}\\n\\n\\t\\tif ( \\\"using\\\" in options ) {\\n\\t\\t\\toptions.using.call( elem, props );\\n\\n\\t\\t} else {\\n\\t\\t\\tcurElem.css( props );\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.fn.extend( {\\n\\toffset: function( options ) {\\n\\n\\t\\t// Preserve chaining for setter\\n\\t\\tif ( arguments.length ) {\\n\\t\\t\\treturn options === undefined ?\\n\\t\\t\\t\\tthis :\\n\\t\\t\\t\\tthis.each( function( i ) {\\n\\t\\t\\t\\t\\tjQuery.offset.setOffset( this, options, i );\\n\\t\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tvar docElem, win, rect, doc,\\n\\t\\t\\telem = this[ 0 ];\\n\\n\\t\\tif ( !elem ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Support: IE <=11 only\\n\\t\\t// Running getBoundingClientRect on a\\n\\t\\t// disconnected node in IE throws an error\\n\\t\\tif ( !elem.getClientRects().length ) {\\n\\t\\t\\treturn { top: 0, left: 0 };\\n\\t\\t}\\n\\n\\t\\trect = elem.getBoundingClientRect();\\n\\n\\t\\t// Make sure element is not hidden (display: none)\\n\\t\\tif ( rect.width || rect.height ) {\\n\\t\\t\\tdoc = elem.ownerDocument;\\n\\t\\t\\twin = getWindow( doc );\\n\\t\\t\\tdocElem = doc.documentElement;\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\ttop: rect.top + win.pageYOffset - docElem.clientTop,\\n\\t\\t\\t\\tleft: rect.left + win.pageXOffset - docElem.clientLeft\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\t// Return zeros for disconnected and hidden elements (gh-2310)\\n\\t\\treturn rect;\\n\\t},\\n\\n\\tposition: function() {\\n\\t\\tif ( !this[ 0 ] ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvar offsetParent, offset,\\n\\t\\t\\telem = this[ 0 ],\\n\\t\\t\\tparentOffset = { top: 0, left: 0 };\\n\\n\\t\\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\\n\\t\\t// because it is its only offset parent\\n\\t\\tif ( jQuery.css( elem, \\\"position\\\" ) === \\\"fixed\\\" ) {\\n\\n\\t\\t\\t// Assume getBoundingClientRect is there when computed position is fixed\\n\\t\\t\\toffset = elem.getBoundingClientRect();\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t// Get *real* offsetParent\\n\\t\\t\\toffsetParent = this.offsetParent();\\n\\n\\t\\t\\t// Get correct offsets\\n\\t\\t\\toffset = this.offset();\\n\\t\\t\\tif ( !jQuery.nodeName( offsetParent[ 0 ], \\\"html\\\" ) ) {\\n\\t\\t\\t\\tparentOffset = offsetParent.offset();\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add offsetParent borders\\n\\t\\t\\tparentOffset = {\\n\\t\\t\\t\\ttop: parentOffset.top + jQuery.css( offsetParent[ 0 ], \\\"borderTopWidth\\\", true ),\\n\\t\\t\\t\\tleft: parentOffset.left + jQuery.css( offsetParent[ 0 ], \\\"borderLeftWidth\\\", true )\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\t// Subtract parent offsets and element margins\\n\\t\\treturn {\\n\\t\\t\\ttop: offset.top - parentOffset.top - jQuery.css( elem, \\\"marginTop\\\", true ),\\n\\t\\t\\tleft: offset.left - parentOffset.left - jQuery.css( elem, \\\"marginLeft\\\", true )\\n\\t\\t};\\n\\t},\\n\\n\\t// This method will return documentElement in the following cases:\\n\\t// 1) For the element inside the iframe without offsetParent, this method will return\\n\\t//    documentElement of the parent window\\n\\t// 2) For the hidden or detached element\\n\\t// 3) For body or html element, i.e. in case of the html node - it will return itself\\n\\t//\\n\\t// but those exceptions were never presented as a real life use-cases\\n\\t// and might be considered as more preferable results.\\n\\t//\\n\\t// This logic, however, is not guaranteed and can change at any point in the future\\n\\toffsetParent: function() {\\n\\t\\treturn this.map( function() {\\n\\t\\t\\tvar offsetParent = this.offsetParent;\\n\\n\\t\\t\\twhile ( offsetParent && jQuery.css( offsetParent, \\\"position\\\" ) === \\\"static\\\" ) {\\n\\t\\t\\t\\toffsetParent = offsetParent.offsetParent;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn offsetParent || documentElement;\\n\\t\\t} );\\n\\t}\\n} );\\n\\n// Create scrollLeft and scrollTop methods\\njQuery.each( { scrollLeft: \\\"pageXOffset\\\", scrollTop: \\\"pageYOffset\\\" }, function( method, prop ) {\\n\\tvar top = \\\"pageYOffset\\\" === prop;\\n\\n\\tjQuery.fn[ method ] = function( val ) {\\n\\t\\treturn access( this, function( elem, method, val ) {\\n\\t\\t\\tvar win = getWindow( elem );\\n\\n\\t\\t\\tif ( val === undefined ) {\\n\\t\\t\\t\\treturn win ? win[ prop ] : elem[ method ];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( win ) {\\n\\t\\t\\t\\twin.scrollTo(\\n\\t\\t\\t\\t\\t!top ? val : win.pageXOffset,\\n\\t\\t\\t\\t\\ttop ? val : win.pageYOffset\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\telem[ method ] = val;\\n\\t\\t\\t}\\n\\t\\t}, method, val, arguments.length );\\n\\t};\\n} );\\n\\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\\n// Add the top/left cssHooks using jQuery.fn.position\\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\\n// getComputedStyle returns percent when specified for top/left/bottom/right;\\n// rather than make the css module depend on the offset module, just check for it here\\njQuery.each( [ \\\"top\\\", \\\"left\\\" ], function( i, prop ) {\\n\\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\\n\\t\\tfunction( elem, computed ) {\\n\\t\\t\\tif ( computed ) {\\n\\t\\t\\t\\tcomputed = curCSS( elem, prop );\\n\\n\\t\\t\\t\\t// If curCSS returns percentage, fallback to offset\\n\\t\\t\\t\\treturn rnumnonpx.test( computed ) ?\\n\\t\\t\\t\\t\\tjQuery( elem ).position()[ prop ] + \\\"px\\\" :\\n\\t\\t\\t\\t\\tcomputed;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t);\\n} );\\n\\n\\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\\njQuery.each( { Height: \\\"height\\\", Width: \\\"width\\\" }, function( name, type ) {\\n\\tjQuery.each( { padding: \\\"inner\\\" + name, content: type, \\\"\\\": \\\"outer\\\" + name },\\n\\t\\tfunction( defaultExtra, funcName ) {\\n\\n\\t\\t// Margin is only for outerHeight, outerWidth\\n\\t\\tjQuery.fn[ funcName ] = function( margin, value ) {\\n\\t\\t\\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \\\"boolean\\\" ),\\n\\t\\t\\t\\textra = defaultExtra || ( margin === true || value === true ? \\\"margin\\\" : \\\"border\\\" );\\n\\n\\t\\t\\treturn access( this, function( elem, type, value ) {\\n\\t\\t\\t\\tvar doc;\\n\\n\\t\\t\\t\\tif ( jQuery.isWindow( elem ) ) {\\n\\n\\t\\t\\t\\t\\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\\n\\t\\t\\t\\t\\treturn funcName.indexOf( \\\"outer\\\" ) === 0 ?\\n\\t\\t\\t\\t\\t\\telem[ \\\"inner\\\" + name ] :\\n\\t\\t\\t\\t\\t\\telem.document.documentElement[ \\\"client\\\" + name ];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Get document width or height\\n\\t\\t\\t\\tif ( elem.nodeType === 9 ) {\\n\\t\\t\\t\\t\\tdoc = elem.documentElement;\\n\\n\\t\\t\\t\\t\\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\\n\\t\\t\\t\\t\\t// whichever is greatest\\n\\t\\t\\t\\t\\treturn Math.max(\\n\\t\\t\\t\\t\\t\\telem.body[ \\\"scroll\\\" + name ], doc[ \\\"scroll\\\" + name ],\\n\\t\\t\\t\\t\\t\\telem.body[ \\\"offset\\\" + name ], doc[ \\\"offset\\\" + name ],\\n\\t\\t\\t\\t\\t\\tdoc[ \\\"client\\\" + name ]\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn value === undefined ?\\n\\n\\t\\t\\t\\t\\t// Get width or height on the element, requesting but not forcing parseFloat\\n\\t\\t\\t\\t\\tjQuery.css( elem, type, extra ) :\\n\\n\\t\\t\\t\\t\\t// Set width or height on the element\\n\\t\\t\\t\\t\\tjQuery.style( elem, type, value, extra );\\n\\t\\t\\t}, type, chainable ? margin : undefined, chainable );\\n\\t\\t};\\n\\t} );\\n} );\\n\\n\\njQuery.fn.extend( {\\n\\n\\tbind: function( types, data, fn ) {\\n\\t\\treturn this.on( types, null, data, fn );\\n\\t},\\n\\tunbind: function( types, fn ) {\\n\\t\\treturn this.off( types, null, fn );\\n\\t},\\n\\n\\tdelegate: function( selector, types, data, fn ) {\\n\\t\\treturn this.on( types, selector, data, fn );\\n\\t},\\n\\tundelegate: function( selector, types, fn ) {\\n\\n\\t\\t// ( namespace ) or ( selector, types [, fn] )\\n\\t\\treturn arguments.length === 1 ?\\n\\t\\t\\tthis.off( selector, \\\"**\\\" ) :\\n\\t\\t\\tthis.off( types, selector || \\\"**\\\", fn );\\n\\t}\\n} );\\n\\njQuery.parseJSON = JSON.parse;\\n\\n\\n\\n\\n// Register as a named AMD module, since jQuery can be concatenated with other\\n// files that may use define, but not via a proper concatenation script that\\n// understands anonymous AMD modules. A named AMD is safest and most robust\\n// way to register. Lowercase jquery is used because AMD module names are\\n// derived from file names, and jQuery is normally delivered in a lowercase\\n// file name. Do this after creating the global so that if an AMD module wants\\n// to call noConflict to hide this version of jQuery, it will work.\\n\\n// Note that for maximum portability, libraries that are not jQuery should\\n// declare themselves as anonymous modules, and avoid setting a global if an\\n// AMD loader is present. jQuery is a special case. For more information, see\\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\\n\\nif ( typeof define === \\\"function\\\" && define.amd ) {\\n\\tdefine( \\\"jquery\\\", [], function() {\\n\\t\\treturn jQuery;\\n\\t} );\\n}\\n\\n\\n\\n\\nvar\\n\\n\\t// Map over jQuery in case of overwrite\\n\\t_jQuery = window.jQuery,\\n\\n\\t// Map over the $ in case of overwrite\\n\\t_$ = window.$;\\n\\njQuery.noConflict = function( deep ) {\\n\\tif ( window.$ === jQuery ) {\\n\\t\\twindow.$ = _$;\\n\\t}\\n\\n\\tif ( deep && window.jQuery === jQuery ) {\\n\\t\\twindow.jQuery = _jQuery;\\n\\t}\\n\\n\\treturn jQuery;\\n};\\n\\n// Expose jQuery and $ identifiers, even in AMD\\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\\n// and CommonJS for browser emulators (#13566)\\nif ( !noGlobal ) {\\n\\twindow.jQuery = window.$ = jQuery;\\n}\\n\\n\\n\\n\\n\\nreturn jQuery;\\n} );\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/francoisdagostini/Projects/infiniteUx-prototype/~/raw-loader!/Users/francoisdagostini/Projects/infiniteUx-prototype/~/jquery/dist/jquery.js\n// module id = 809\n// module chunks = 3","module.exports = \"/**\\n * @license\\n * Video.js 5.11.6 <http://videojs.com/>\\n * Copyright Brightcove, Inc. <https://www.brightcove.com/>\\n * Available under Apache License Version 2.0\\n * <https://github.com/videojs/video.js/blob/master/LICENSE>\\n *\\n * Includes vtt.js <https://github.com/mozilla/vtt.js>\\n * Available under Apache License Version 2.0\\n * <https://github.com/mozilla/vtt.js/blob/master/LICENSE>\\n */\\n\\n(function(f){if(typeof exports===\\\"object\\\"&&typeof module!==\\\"undefined\\\"){module.exports=f()}else if(typeof define===\\\"function\\\"&&define.amd){define([],f)}else{var g;if(typeof window!==\\\"undefined\\\"){g=window}else if(typeof global!==\\\"undefined\\\"){g=global}else if(typeof self!==\\\"undefined\\\"){g=self}else{g=this}g.videojs = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\\\"function\\\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\\\"Cannot find module '\\\"+o+\\\"'\\\");throw f.code=\\\"MODULE_NOT_FOUND\\\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\\\"function\\\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\\n(function (global){\\nvar topLevel = typeof global !== 'undefined' ? global :\\n    typeof window !== 'undefined' ? window : {}\\nvar minDoc = _dereq_('min-document');\\n\\nif (typeof document !== 'undefined') {\\n    module.exports = document;\\n} else {\\n    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\\n\\n    if (!doccy) {\\n        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\\n    }\\n\\n    module.exports = doccy;\\n}\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9nbG9iYWwvZG9jdW1lbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdG9wTGV2ZWwgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB7fVxudmFyIG1pbkRvYyA9IHJlcXVpcmUoJ21pbi1kb2N1bWVudCcpO1xuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQ7XG59IGVsc2Uge1xuICAgIHZhciBkb2NjeSA9IHRvcExldmVsWydfX0dMT0JBTF9ET0NVTUVOVF9DQUNIRUA0J107XG5cbiAgICBpZiAoIWRvY2N5KSB7XG4gICAgICAgIGRvY2N5ID0gdG9wTGV2ZWxbJ19fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDQnXSA9IG1pbkRvYztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRvY2N5O1xufVxuIl19\\n},{\\\"min-document\\\":3}],2:[function(_dereq_,module,exports){\\n(function (global){\\nif (typeof window !== \\\"undefined\\\") {\\n    module.exports = window;\\n} else if (typeof global !== \\\"undefined\\\") {\\n    module.exports = global;\\n} else if (typeof self !== \\\"undefined\\\"){\\n    module.exports = self;\\n} else {\\n    module.exports = {};\\n}\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9nbG9iYWwvd2luZG93LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzZWxmO1xufSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHt9O1xufVxuIl19\\n},{}],3:[function(_dereq_,module,exports){\\n\\n},{}],4:[function(_dereq_,module,exports){\\nvar getNative = _dereq_('../internal/getNative');\\n\\n/* Native method references for those with the same name as other `lodash` methods. */\\nvar nativeNow = getNative(Date, 'now');\\n\\n/**\\n * Gets the number of milliseconds that have elapsed since the Unix epoch\\n * (1 January 1970 00:00:00 UTC).\\n *\\n * @static\\n * @memberOf _\\n * @category Date\\n * @example\\n *\\n * _.defer(function(stamp) {\\n *   console.log(_.now() - stamp);\\n * }, _.now());\\n * // => logs the number of milliseconds it took for the deferred function to be invoked\\n */\\nvar now = nativeNow || function() {\\n  return new Date().getTime();\\n};\\n\\nmodule.exports = now;\\n\\n},{\\\"../internal/getNative\\\":20}],5:[function(_dereq_,module,exports){\\nvar isObject = _dereq_('../lang/isObject'),\\n    now = _dereq_('../date/now');\\n\\n/** Used as the `TypeError` message for \\\"Functions\\\" methods. */\\nvar FUNC_ERROR_TEXT = 'Expected a function';\\n\\n/* Native method references for those with the same name as other `lodash` methods. */\\nvar nativeMax = Math.max;\\n\\n/**\\n * Creates a debounced function that delays invoking `func` until after `wait`\\n * milliseconds have elapsed since the last time the debounced function was\\n * invoked. The debounced function comes with a `cancel` method to cancel\\n * delayed invocations. Provide an options object to indicate that `func`\\n * should be invoked on the leading and/or trailing edge of the `wait` timeout.\\n * Subsequent calls to the debounced function return the result of the last\\n * `func` invocation.\\n *\\n * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\\n * on the trailing edge of the timeout only if the the debounced function is\\n * invoked more than once during the `wait` timeout.\\n *\\n * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\\n * for details over the differences between `_.debounce` and `_.throttle`.\\n *\\n * @static\\n * @memberOf _\\n * @category Function\\n * @param {Function} func The function to debounce.\\n * @param {number} [wait=0] The number of milliseconds to delay.\\n * @param {Object} [options] The options object.\\n * @param {boolean} [options.leading=false] Specify invoking on the leading\\n *  edge of the timeout.\\n * @param {number} [options.maxWait] The maximum time `func` is allowed to be\\n *  delayed before it's invoked.\\n * @param {boolean} [options.trailing=true] Specify invoking on the trailing\\n *  edge of the timeout.\\n * @returns {Function} Returns the new debounced function.\\n * @example\\n *\\n * // avoid costly calculations while the window size is in flux\\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\\n *\\n * // invoke `sendMail` when the click event is fired, debouncing subsequent calls\\n * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {\\n *   'leading': true,\\n *   'trailing': false\\n * }));\\n *\\n * // ensure `batchLog` is invoked once after 1 second of debounced calls\\n * var source = new EventSource('/stream');\\n * jQuery(source).on('message', _.debounce(batchLog, 250, {\\n *   'maxWait': 1000\\n * }));\\n *\\n * // cancel a debounced call\\n * var todoChanges = _.debounce(batchLog, 1000);\\n * Object.observe(models.todo, todoChanges);\\n *\\n * Object.observe(models, function(changes) {\\n *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {\\n *     todoChanges.cancel();\\n *   }\\n * }, ['delete']);\\n *\\n * // ...at some point `models.todo` is changed\\n * models.todo.completed = true;\\n *\\n * // ...before 1 second has passed `models.todo` is deleted\\n * // which cancels the debounced `todoChanges` call\\n * delete models.todo;\\n */\\nfunction debounce(func, wait, options) {\\n  var args,\\n      maxTimeoutId,\\n      result,\\n      stamp,\\n      thisArg,\\n      timeoutId,\\n      trailingCall,\\n      lastCalled = 0,\\n      maxWait = false,\\n      trailing = true;\\n\\n  if (typeof func != 'function') {\\n    throw new TypeError(FUNC_ERROR_TEXT);\\n  }\\n  wait = wait < 0 ? 0 : (+wait || 0);\\n  if (options === true) {\\n    var leading = true;\\n    trailing = false;\\n  } else if (isObject(options)) {\\n    leading = !!options.leading;\\n    maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);\\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\\n  }\\n\\n  function cancel() {\\n    if (timeoutId) {\\n      clearTimeout(timeoutId);\\n    }\\n    if (maxTimeoutId) {\\n      clearTimeout(maxTimeoutId);\\n    }\\n    lastCalled = 0;\\n    maxTimeoutId = timeoutId = trailingCall = undefined;\\n  }\\n\\n  function complete(isCalled, id) {\\n    if (id) {\\n      clearTimeout(id);\\n    }\\n    maxTimeoutId = timeoutId = trailingCall = undefined;\\n    if (isCalled) {\\n      lastCalled = now();\\n      result = func.apply(thisArg, args);\\n      if (!timeoutId && !maxTimeoutId) {\\n        args = thisArg = undefined;\\n      }\\n    }\\n  }\\n\\n  function delayed() {\\n    var remaining = wait - (now() - stamp);\\n    if (remaining <= 0 || remaining > wait) {\\n      complete(trailingCall, maxTimeoutId);\\n    } else {\\n      timeoutId = setTimeout(delayed, remaining);\\n    }\\n  }\\n\\n  function maxDelayed() {\\n    complete(trailing, timeoutId);\\n  }\\n\\n  function debounced() {\\n    args = arguments;\\n    stamp = now();\\n    thisArg = this;\\n    trailingCall = trailing && (timeoutId || !leading);\\n\\n    if (maxWait === false) {\\n      var leadingCall = leading && !timeoutId;\\n    } else {\\n      if (!maxTimeoutId && !leading) {\\n        lastCalled = stamp;\\n      }\\n      var remaining = maxWait - (stamp - lastCalled),\\n          isCalled = remaining <= 0 || remaining > maxWait;\\n\\n      if (isCalled) {\\n        if (maxTimeoutId) {\\n          maxTimeoutId = clearTimeout(maxTimeoutId);\\n        }\\n        lastCalled = stamp;\\n        result = func.apply(thisArg, args);\\n      }\\n      else if (!maxTimeoutId) {\\n        maxTimeoutId = setTimeout(maxDelayed, remaining);\\n      }\\n    }\\n    if (isCalled && timeoutId) {\\n      timeoutId = clearTimeout(timeoutId);\\n    }\\n    else if (!timeoutId && wait !== maxWait) {\\n      timeoutId = setTimeout(delayed, wait);\\n    }\\n    if (leadingCall) {\\n      isCalled = true;\\n      result = func.apply(thisArg, args);\\n    }\\n    if (isCalled && !timeoutId && !maxTimeoutId) {\\n      args = thisArg = undefined;\\n    }\\n    return result;\\n  }\\n  debounced.cancel = cancel;\\n  return debounced;\\n}\\n\\nmodule.exports = debounce;\\n\\n},{\\\"../date/now\\\":4,\\\"../lang/isObject\\\":33}],6:[function(_dereq_,module,exports){\\n/** Used as the `TypeError` message for \\\"Functions\\\" methods. */\\nvar FUNC_ERROR_TEXT = 'Expected a function';\\n\\n/* Native method references for those with the same name as other `lodash` methods. */\\nvar nativeMax = Math.max;\\n\\n/**\\n * Creates a function that invokes `func` with the `this` binding of the\\n * created function and arguments from `start` and beyond provided as an array.\\n *\\n * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/Web/JavaScript/Reference/Functions/rest_parameters).\\n *\\n * @static\\n * @memberOf _\\n * @category Function\\n * @param {Function} func The function to apply a rest parameter to.\\n * @param {number} [start=func.length-1] The start position of the rest parameter.\\n * @returns {Function} Returns the new function.\\n * @example\\n *\\n * var say = _.restParam(function(what, names) {\\n *   return what + ' ' + _.initial(names).join(', ') +\\n *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\\n * });\\n *\\n * say('hello', 'fred', 'barney', 'pebbles');\\n * // => 'hello fred, barney, & pebbles'\\n */\\nfunction restParam(func, start) {\\n  if (typeof func != 'function') {\\n    throw new TypeError(FUNC_ERROR_TEXT);\\n  }\\n  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);\\n  return function() {\\n    var args = arguments,\\n        index = -1,\\n        length = nativeMax(args.length - start, 0),\\n        rest = Array(length);\\n\\n    while (++index < length) {\\n      rest[index] = args[start + index];\\n    }\\n    switch (start) {\\n      case 0: return func.call(this, rest);\\n      case 1: return func.call(this, args[0], rest);\\n      case 2: return func.call(this, args[0], args[1], rest);\\n    }\\n    var otherArgs = Array(start + 1);\\n    index = -1;\\n    while (++index < start) {\\n      otherArgs[index] = args[index];\\n    }\\n    otherArgs[start] = rest;\\n    return func.apply(this, otherArgs);\\n  };\\n}\\n\\nmodule.exports = restParam;\\n\\n},{}],7:[function(_dereq_,module,exports){\\nvar debounce = _dereq_('./debounce'),\\n    isObject = _dereq_('../lang/isObject');\\n\\n/** Used as the `TypeError` message for \\\"Functions\\\" methods. */\\nvar FUNC_ERROR_TEXT = 'Expected a function';\\n\\n/**\\n * Creates a throttled function that only invokes `func` at most once per\\n * every `wait` milliseconds. The throttled function comes with a `cancel`\\n * method to cancel delayed invocations. Provide an options object to indicate\\n * that `func` should be invoked on the leading and/or trailing edge of the\\n * `wait` timeout. Subsequent calls to the throttled function return the\\n * result of the last `func` call.\\n *\\n * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\\n * on the trailing edge of the timeout only if the the throttled function is\\n * invoked more than once during the `wait` timeout.\\n *\\n * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\\n * for details over the differences between `_.throttle` and `_.debounce`.\\n *\\n * @static\\n * @memberOf _\\n * @category Function\\n * @param {Function} func The function to throttle.\\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\\n * @param {Object} [options] The options object.\\n * @param {boolean} [options.leading=true] Specify invoking on the leading\\n *  edge of the timeout.\\n * @param {boolean} [options.trailing=true] Specify invoking on the trailing\\n *  edge of the timeout.\\n * @returns {Function} Returns the new throttled function.\\n * @example\\n *\\n * // avoid excessively updating the position while scrolling\\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\\n *\\n * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes\\n * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {\\n *   'trailing': false\\n * }));\\n *\\n * // cancel a trailing throttled call\\n * jQuery(window).on('popstate', throttled.cancel);\\n */\\nfunction throttle(func, wait, options) {\\n  var leading = true,\\n      trailing = true;\\n\\n  if (typeof func != 'function') {\\n    throw new TypeError(FUNC_ERROR_TEXT);\\n  }\\n  if (options === false) {\\n    leading = false;\\n  } else if (isObject(options)) {\\n    leading = 'leading' in options ? !!options.leading : leading;\\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\\n  }\\n  return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });\\n}\\n\\nmodule.exports = throttle;\\n\\n},{\\\"../lang/isObject\\\":33,\\\"./debounce\\\":5}],8:[function(_dereq_,module,exports){\\n/**\\n * Copies the values of `source` to `array`.\\n *\\n * @private\\n * @param {Array} source The array to copy values from.\\n * @param {Array} [array=[]] The array to copy values to.\\n * @returns {Array} Returns `array`.\\n */\\nfunction arrayCopy(source, array) {\\n  var index = -1,\\n      length = source.length;\\n\\n  array || (array = Array(length));\\n  while (++index < length) {\\n    array[index] = source[index];\\n  }\\n  return array;\\n}\\n\\nmodule.exports = arrayCopy;\\n\\n},{}],9:[function(_dereq_,module,exports){\\n/**\\n * A specialized version of `_.forEach` for arrays without support for callback\\n * shorthands and `this` binding.\\n *\\n * @private\\n * @param {Array} array The array to iterate over.\\n * @param {Function} iteratee The function invoked per iteration.\\n * @returns {Array} Returns `array`.\\n */\\nfunction arrayEach(array, iteratee) {\\n  var index = -1,\\n      length = array.length;\\n\\n  while (++index < length) {\\n    if (iteratee(array[index], index, array) === false) {\\n      break;\\n    }\\n  }\\n  return array;\\n}\\n\\nmodule.exports = arrayEach;\\n\\n},{}],10:[function(_dereq_,module,exports){\\n/**\\n * Copies properties of `source` to `object`.\\n *\\n * @private\\n * @param {Object} source The object to copy properties from.\\n * @param {Array} props The property names to copy.\\n * @param {Object} [object={}] The object to copy properties to.\\n * @returns {Object} Returns `object`.\\n */\\nfunction baseCopy(source, props, object) {\\n  object || (object = {});\\n\\n  var index = -1,\\n      length = props.length;\\n\\n  while (++index < length) {\\n    var key = props[index];\\n    object[key] = source[key];\\n  }\\n  return object;\\n}\\n\\nmodule.exports = baseCopy;\\n\\n},{}],11:[function(_dereq_,module,exports){\\nvar createBaseFor = _dereq_('./createBaseFor');\\n\\n/**\\n * The base implementation of `baseForIn` and `baseForOwn` which iterates\\n * over `object` properties returned by `keysFunc` invoking `iteratee` for\\n * each property. Iteratee functions may exit iteration early by explicitly\\n * returning `false`.\\n *\\n * @private\\n * @param {Object} object The object to iterate over.\\n * @param {Function} iteratee The function invoked per iteration.\\n * @param {Function} keysFunc The function to get the keys of `object`.\\n * @returns {Object} Returns `object`.\\n */\\nvar baseFor = createBaseFor();\\n\\nmodule.exports = baseFor;\\n\\n},{\\\"./createBaseFor\\\":18}],12:[function(_dereq_,module,exports){\\nvar baseFor = _dereq_('./baseFor'),\\n    keysIn = _dereq_('../object/keysIn');\\n\\n/**\\n * The base implementation of `_.forIn` without support for callback\\n * shorthands and `this` binding.\\n *\\n * @private\\n * @param {Object} object The object to iterate over.\\n * @param {Function} iteratee The function invoked per iteration.\\n * @returns {Object} Returns `object`.\\n */\\nfunction baseForIn(object, iteratee) {\\n  return baseFor(object, iteratee, keysIn);\\n}\\n\\nmodule.exports = baseForIn;\\n\\n},{\\\"../object/keysIn\\\":39,\\\"./baseFor\\\":11}],13:[function(_dereq_,module,exports){\\nvar arrayEach = _dereq_('./arrayEach'),\\n    baseMergeDeep = _dereq_('./baseMergeDeep'),\\n    isArray = _dereq_('../lang/isArray'),\\n    isArrayLike = _dereq_('./isArrayLike'),\\n    isObject = _dereq_('../lang/isObject'),\\n    isObjectLike = _dereq_('./isObjectLike'),\\n    isTypedArray = _dereq_('../lang/isTypedArray'),\\n    keys = _dereq_('../object/keys');\\n\\n/**\\n * The base implementation of `_.merge` without support for argument juggling,\\n * multiple sources, and `this` binding `customizer` functions.\\n *\\n * @private\\n * @param {Object} object The destination object.\\n * @param {Object} source The source object.\\n * @param {Function} [customizer] The function to customize merged values.\\n * @param {Array} [stackA=[]] Tracks traversed source objects.\\n * @param {Array} [stackB=[]] Associates values with source counterparts.\\n * @returns {Object} Returns `object`.\\n */\\nfunction baseMerge(object, source, customizer, stackA, stackB) {\\n  if (!isObject(object)) {\\n    return object;\\n  }\\n  var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),\\n      props = isSrcArr ? undefined : keys(source);\\n\\n  arrayEach(props || source, function(srcValue, key) {\\n    if (props) {\\n      key = srcValue;\\n      srcValue = source[key];\\n    }\\n    if (isObjectLike(srcValue)) {\\n      stackA || (stackA = []);\\n      stackB || (stackB = []);\\n      baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);\\n    }\\n    else {\\n      var value = object[key],\\n          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\\n          isCommon = result === undefined;\\n\\n      if (isCommon) {\\n        result = srcValue;\\n      }\\n      if ((result !== undefined || (isSrcArr && !(key in object))) &&\\n          (isCommon || (result === result ? (result !== value) : (value === value)))) {\\n        object[key] = result;\\n      }\\n    }\\n  });\\n  return object;\\n}\\n\\nmodule.exports = baseMerge;\\n\\n},{\\\"../lang/isArray\\\":30,\\\"../lang/isObject\\\":33,\\\"../lang/isTypedArray\\\":36,\\\"../object/keys\\\":38,\\\"./arrayEach\\\":9,\\\"./baseMergeDeep\\\":14,\\\"./isArrayLike\\\":21,\\\"./isObjectLike\\\":26}],14:[function(_dereq_,module,exports){\\nvar arrayCopy = _dereq_('./arrayCopy'),\\n    isArguments = _dereq_('../lang/isArguments'),\\n    isArray = _dereq_('../lang/isArray'),\\n    isArrayLike = _dereq_('./isArrayLike'),\\n    isPlainObject = _dereq_('../lang/isPlainObject'),\\n    isTypedArray = _dereq_('../lang/isTypedArray'),\\n    toPlainObject = _dereq_('../lang/toPlainObject');\\n\\n/**\\n * A specialized version of `baseMerge` for arrays and objects which performs\\n * deep merges and tracks traversed objects enabling objects with circular\\n * references to be merged.\\n *\\n * @private\\n * @param {Object} object The destination object.\\n * @param {Object} source The source object.\\n * @param {string} key The key of the value to merge.\\n * @param {Function} mergeFunc The function to merge values.\\n * @param {Function} [customizer] The function to customize merged values.\\n * @param {Array} [stackA=[]] Tracks traversed source objects.\\n * @param {Array} [stackB=[]] Associates values with source counterparts.\\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\\n */\\nfunction baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {\\n  var length = stackA.length,\\n      srcValue = source[key];\\n\\n  while (length--) {\\n    if (stackA[length] == srcValue) {\\n      object[key] = stackB[length];\\n      return;\\n    }\\n  }\\n  var value = object[key],\\n      result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\\n      isCommon = result === undefined;\\n\\n  if (isCommon) {\\n    result = srcValue;\\n    if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {\\n      result = isArray(value)\\n        ? value\\n        : (isArrayLike(value) ? arrayCopy(value) : []);\\n    }\\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\\n      result = isArguments(value)\\n        ? toPlainObject(value)\\n        : (isPlainObject(value) ? value : {});\\n    }\\n    else {\\n      isCommon = false;\\n    }\\n  }\\n  // Add the source value to the stack of traversed objects and associate\\n  // it with its merged value.\\n  stackA.push(srcValue);\\n  stackB.push(result);\\n\\n  if (isCommon) {\\n    // Recursively merge objects and arrays (susceptible to call stack limits).\\n    object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);\\n  } else if (result === result ? (result !== value) : (value === value)) {\\n    object[key] = result;\\n  }\\n}\\n\\nmodule.exports = baseMergeDeep;\\n\\n},{\\\"../lang/isArguments\\\":29,\\\"../lang/isArray\\\":30,\\\"../lang/isPlainObject\\\":34,\\\"../lang/isTypedArray\\\":36,\\\"../lang/toPlainObject\\\":37,\\\"./arrayCopy\\\":8,\\\"./isArrayLike\\\":21}],15:[function(_dereq_,module,exports){\\nvar toObject = _dereq_('./toObject');\\n\\n/**\\n * The base implementation of `_.property` without support for deep paths.\\n *\\n * @private\\n * @param {string} key The key of the property to get.\\n * @returns {Function} Returns the new function.\\n */\\nfunction baseProperty(key) {\\n  return function(object) {\\n    return object == null ? undefined : toObject(object)[key];\\n  };\\n}\\n\\nmodule.exports = baseProperty;\\n\\n},{\\\"./toObject\\\":28}],16:[function(_dereq_,module,exports){\\nvar identity = _dereq_('../utility/identity');\\n\\n/**\\n * A specialized version of `baseCallback` which only supports `this` binding\\n * and specifying the number of arguments to provide to `func`.\\n *\\n * @private\\n * @param {Function} func The function to bind.\\n * @param {*} thisArg The `this` binding of `func`.\\n * @param {number} [argCount] The number of arguments to provide to `func`.\\n * @returns {Function} Returns the callback.\\n */\\nfunction bindCallback(func, thisArg, argCount) {\\n  if (typeof func != 'function') {\\n    return identity;\\n  }\\n  if (thisArg === undefined) {\\n    return func;\\n  }\\n  switch (argCount) {\\n    case 1: return function(value) {\\n      return func.call(thisArg, value);\\n    };\\n    case 3: return function(value, index, collection) {\\n      return func.call(thisArg, value, index, collection);\\n    };\\n    case 4: return function(accumulator, value, index, collection) {\\n      return func.call(thisArg, accumulator, value, index, collection);\\n    };\\n    case 5: return function(value, other, key, object, source) {\\n      return func.call(thisArg, value, other, key, object, source);\\n    };\\n  }\\n  return function() {\\n    return func.apply(thisArg, arguments);\\n  };\\n}\\n\\nmodule.exports = bindCallback;\\n\\n},{\\\"../utility/identity\\\":42}],17:[function(_dereq_,module,exports){\\nvar bindCallback = _dereq_('./bindCallback'),\\n    isIterateeCall = _dereq_('./isIterateeCall'),\\n    restParam = _dereq_('../function/restParam');\\n\\n/**\\n * Creates a `_.assign`, `_.defaults`, or `_.merge` function.\\n *\\n * @private\\n * @param {Function} assigner The function to assign values.\\n * @returns {Function} Returns the new assigner function.\\n */\\nfunction createAssigner(assigner) {\\n  return restParam(function(object, sources) {\\n    var index = -1,\\n        length = object == null ? 0 : sources.length,\\n        customizer = length > 2 ? sources[length - 2] : undefined,\\n        guard = length > 2 ? sources[2] : undefined,\\n        thisArg = length > 1 ? sources[length - 1] : undefined;\\n\\n    if (typeof customizer == 'function') {\\n      customizer = bindCallback(customizer, thisArg, 5);\\n      length -= 2;\\n    } else {\\n      customizer = typeof thisArg == 'function' ? thisArg : undefined;\\n      length -= (customizer ? 1 : 0);\\n    }\\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\\n      customizer = length < 3 ? undefined : customizer;\\n      length = 1;\\n    }\\n    while (++index < length) {\\n      var source = sources[index];\\n      if (source) {\\n        assigner(object, source, customizer);\\n      }\\n    }\\n    return object;\\n  });\\n}\\n\\nmodule.exports = createAssigner;\\n\\n},{\\\"../function/restParam\\\":6,\\\"./bindCallback\\\":16,\\\"./isIterateeCall\\\":24}],18:[function(_dereq_,module,exports){\\nvar toObject = _dereq_('./toObject');\\n\\n/**\\n * Creates a base function for `_.forIn` or `_.forInRight`.\\n *\\n * @private\\n * @param {boolean} [fromRight] Specify iterating from right to left.\\n * @returns {Function} Returns the new base function.\\n */\\nfunction createBaseFor(fromRight) {\\n  return function(object, iteratee, keysFunc) {\\n    var iterable = toObject(object),\\n        props = keysFunc(object),\\n        length = props.length,\\n        index = fromRight ? length : -1;\\n\\n    while ((fromRight ? index-- : ++index < length)) {\\n      var key = props[index];\\n      if (iteratee(iterable[key], key, iterable) === false) {\\n        break;\\n      }\\n    }\\n    return object;\\n  };\\n}\\n\\nmodule.exports = createBaseFor;\\n\\n},{\\\"./toObject\\\":28}],19:[function(_dereq_,module,exports){\\nvar baseProperty = _dereq_('./baseProperty');\\n\\n/**\\n * Gets the \\\"length\\\" property value of `object`.\\n *\\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\\n * that affects Safari on at least iOS 8.1-8.3 ARM64.\\n *\\n * @private\\n * @param {Object} object The object to query.\\n * @returns {*} Returns the \\\"length\\\" value.\\n */\\nvar getLength = baseProperty('length');\\n\\nmodule.exports = getLength;\\n\\n},{\\\"./baseProperty\\\":15}],20:[function(_dereq_,module,exports){\\nvar isNative = _dereq_('../lang/isNative');\\n\\n/**\\n * Gets the native function at `key` of `object`.\\n *\\n * @private\\n * @param {Object} object The object to query.\\n * @param {string} key The key of the method to get.\\n * @returns {*} Returns the function if it's native, else `undefined`.\\n */\\nfunction getNative(object, key) {\\n  var value = object == null ? undefined : object[key];\\n  return isNative(value) ? value : undefined;\\n}\\n\\nmodule.exports = getNative;\\n\\n},{\\\"../lang/isNative\\\":32}],21:[function(_dereq_,module,exports){\\nvar getLength = _dereq_('./getLength'),\\n    isLength = _dereq_('./isLength');\\n\\n/**\\n * Checks if `value` is array-like.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\\n */\\nfunction isArrayLike(value) {\\n  return value != null && isLength(getLength(value));\\n}\\n\\nmodule.exports = isArrayLike;\\n\\n},{\\\"./getLength\\\":19,\\\"./isLength\\\":25}],22:[function(_dereq_,module,exports){\\n/**\\n * Checks if `value` is a host object in IE < 9.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\\n */\\nvar isHostObject = (function() {\\n  try {\\n    Object({ 'toString': 0 } + '');\\n  } catch(e) {\\n    return function() { return false; };\\n  }\\n  return function(value) {\\n    // IE < 9 presents many host objects as `Object` objects that can coerce\\n    // to strings despite having improperly defined `toString` methods.\\n    return typeof value.toString != 'function' && typeof (value + '') == 'string';\\n  };\\n}());\\n\\nmodule.exports = isHostObject;\\n\\n},{}],23:[function(_dereq_,module,exports){\\n/** Used to detect unsigned integer values. */\\nvar reIsUint = /^\\\\d+$/;\\n\\n/**\\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\\n * of an array-like value.\\n */\\nvar MAX_SAFE_INTEGER = 9007199254740991;\\n\\n/**\\n * Checks if `value` is a valid array-like index.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\\n */\\nfunction isIndex(value, length) {\\n  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\\n  length = length == null ? MAX_SAFE_INTEGER : length;\\n  return value > -1 && value % 1 == 0 && value < length;\\n}\\n\\nmodule.exports = isIndex;\\n\\n},{}],24:[function(_dereq_,module,exports){\\nvar isArrayLike = _dereq_('./isArrayLike'),\\n    isIndex = _dereq_('./isIndex'),\\n    isObject = _dereq_('../lang/isObject');\\n\\n/**\\n * Checks if the provided arguments are from an iteratee call.\\n *\\n * @private\\n * @param {*} value The potential iteratee value argument.\\n * @param {*} index The potential iteratee index or key argument.\\n * @param {*} object The potential iteratee object argument.\\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\\n */\\nfunction isIterateeCall(value, index, object) {\\n  if (!isObject(object)) {\\n    return false;\\n  }\\n  var type = typeof index;\\n  if (type == 'number'\\n      ? (isArrayLike(object) && isIndex(index, object.length))\\n      : (type == 'string' && index in object)) {\\n    var other = object[index];\\n    return value === value ? (value === other) : (other !== other);\\n  }\\n  return false;\\n}\\n\\nmodule.exports = isIterateeCall;\\n\\n},{\\\"../lang/isObject\\\":33,\\\"./isArrayLike\\\":21,\\\"./isIndex\\\":23}],25:[function(_dereq_,module,exports){\\n/**\\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\\n * of an array-like value.\\n */\\nvar MAX_SAFE_INTEGER = 9007199254740991;\\n\\n/**\\n * Checks if `value` is a valid array-like length.\\n *\\n * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\\n */\\nfunction isLength(value) {\\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\\n}\\n\\nmodule.exports = isLength;\\n\\n},{}],26:[function(_dereq_,module,exports){\\n/**\\n * Checks if `value` is object-like.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\\n */\\nfunction isObjectLike(value) {\\n  return !!value && typeof value == 'object';\\n}\\n\\nmodule.exports = isObjectLike;\\n\\n},{}],27:[function(_dereq_,module,exports){\\nvar isArguments = _dereq_('../lang/isArguments'),\\n    isArray = _dereq_('../lang/isArray'),\\n    isIndex = _dereq_('./isIndex'),\\n    isLength = _dereq_('./isLength'),\\n    isString = _dereq_('../lang/isString'),\\n    keysIn = _dereq_('../object/keysIn');\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/** Used to check objects for own properties. */\\nvar hasOwnProperty = objectProto.hasOwnProperty;\\n\\n/**\\n * A fallback implementation of `Object.keys` which creates an array of the\\n * own enumerable property names of `object`.\\n *\\n * @private\\n * @param {Object} object The object to query.\\n * @returns {Array} Returns the array of property names.\\n */\\nfunction shimKeys(object) {\\n  var props = keysIn(object),\\n      propsLength = props.length,\\n      length = propsLength && object.length;\\n\\n  var allowIndexes = !!length && isLength(length) &&\\n    (isArray(object) || isArguments(object) || isString(object));\\n\\n  var index = -1,\\n      result = [];\\n\\n  while (++index < propsLength) {\\n    var key = props[index];\\n    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\\n      result.push(key);\\n    }\\n  }\\n  return result;\\n}\\n\\nmodule.exports = shimKeys;\\n\\n},{\\\"../lang/isArguments\\\":29,\\\"../lang/isArray\\\":30,\\\"../lang/isString\\\":35,\\\"../object/keysIn\\\":39,\\\"./isIndex\\\":23,\\\"./isLength\\\":25}],28:[function(_dereq_,module,exports){\\nvar isObject = _dereq_('../lang/isObject'),\\n    isString = _dereq_('../lang/isString'),\\n    support = _dereq_('../support');\\n\\n/**\\n * Converts `value` to an object if it's not one.\\n *\\n * @private\\n * @param {*} value The value to process.\\n * @returns {Object} Returns the object.\\n */\\nfunction toObject(value) {\\n  if (support.unindexedChars && isString(value)) {\\n    var index = -1,\\n        length = value.length,\\n        result = Object(value);\\n\\n    while (++index < length) {\\n      result[index] = value.charAt(index);\\n    }\\n    return result;\\n  }\\n  return isObject(value) ? value : Object(value);\\n}\\n\\nmodule.exports = toObject;\\n\\n},{\\\"../lang/isObject\\\":33,\\\"../lang/isString\\\":35,\\\"../support\\\":41}],29:[function(_dereq_,module,exports){\\nvar isArrayLike = _dereq_('../internal/isArrayLike'),\\n    isObjectLike = _dereq_('../internal/isObjectLike');\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/** Used to check objects for own properties. */\\nvar hasOwnProperty = objectProto.hasOwnProperty;\\n\\n/** Native method references. */\\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\\n\\n/**\\n * Checks if `value` is classified as an `arguments` object.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\\n * @example\\n *\\n * _.isArguments(function() { return arguments; }());\\n * // => true\\n *\\n * _.isArguments([1, 2, 3]);\\n * // => false\\n */\\nfunction isArguments(value) {\\n  return isObjectLike(value) && isArrayLike(value) &&\\n    hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\\n}\\n\\nmodule.exports = isArguments;\\n\\n},{\\\"../internal/isArrayLike\\\":21,\\\"../internal/isObjectLike\\\":26}],30:[function(_dereq_,module,exports){\\nvar getNative = _dereq_('../internal/getNative'),\\n    isLength = _dereq_('../internal/isLength'),\\n    isObjectLike = _dereq_('../internal/isObjectLike');\\n\\n/** `Object#toString` result references. */\\nvar arrayTag = '[object Array]';\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/* Native method references for those with the same name as other `lodash` methods. */\\nvar nativeIsArray = getNative(Array, 'isArray');\\n\\n/**\\n * Checks if `value` is classified as an `Array` object.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\\n * @example\\n *\\n * _.isArray([1, 2, 3]);\\n * // => true\\n *\\n * _.isArray(function() { return arguments; }());\\n * // => false\\n */\\nvar isArray = nativeIsArray || function(value) {\\n  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\\n};\\n\\nmodule.exports = isArray;\\n\\n},{\\\"../internal/getNative\\\":20,\\\"../internal/isLength\\\":25,\\\"../internal/isObjectLike\\\":26}],31:[function(_dereq_,module,exports){\\nvar isObject = _dereq_('./isObject');\\n\\n/** `Object#toString` result references. */\\nvar funcTag = '[object Function]';\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/**\\n * Checks if `value` is classified as a `Function` object.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\\n * @example\\n *\\n * _.isFunction(_);\\n * // => true\\n *\\n * _.isFunction(/abc/);\\n * // => false\\n */\\nfunction isFunction(value) {\\n  // The use of `Object#toString` avoids issues with the `typeof` operator\\n  // in older versions of Chrome and Safari which return 'function' for regexes\\n  // and Safari 8 which returns 'object' for typed array constructors.\\n  return isObject(value) && objToString.call(value) == funcTag;\\n}\\n\\nmodule.exports = isFunction;\\n\\n},{\\\"./isObject\\\":33}],32:[function(_dereq_,module,exports){\\nvar isFunction = _dereq_('./isFunction'),\\n    isHostObject = _dereq_('../internal/isHostObject'),\\n    isObjectLike = _dereq_('../internal/isObjectLike');\\n\\n/** Used to detect host constructors (Safari > 5). */\\nvar reIsHostCtor = /^\\\\[object .+?Constructor\\\\]$/;\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/** Used to resolve the decompiled source of functions. */\\nvar fnToString = Function.prototype.toString;\\n\\n/** Used to check objects for own properties. */\\nvar hasOwnProperty = objectProto.hasOwnProperty;\\n\\n/** Used to detect if a method is native. */\\nvar reIsNative = RegExp('^' +\\n  fnToString.call(hasOwnProperty).replace(/[\\\\\\\\^$.*+?()[\\\\]{}|]/g, '\\\\\\\\$&')\\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\\\\\\\()| for .+?(?=\\\\\\\\\\\\])/g, '$1.*?') + '$'\\n);\\n\\n/**\\n * Checks if `value` is a native function.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\\n * @example\\n *\\n * _.isNative(Array.prototype.push);\\n * // => true\\n *\\n * _.isNative(_);\\n * // => false\\n */\\nfunction isNative(value) {\\n  if (value == null) {\\n    return false;\\n  }\\n  if (isFunction(value)) {\\n    return reIsNative.test(fnToString.call(value));\\n  }\\n  return isObjectLike(value) && (isHostObject(value) ? reIsNative : reIsHostCtor).test(value);\\n}\\n\\nmodule.exports = isNative;\\n\\n},{\\\"../internal/isHostObject\\\":22,\\\"../internal/isObjectLike\\\":26,\\\"./isFunction\\\":31}],33:[function(_dereq_,module,exports){\\n/**\\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\\n * @example\\n *\\n * _.isObject({});\\n * // => true\\n *\\n * _.isObject([1, 2, 3]);\\n * // => true\\n *\\n * _.isObject(1);\\n * // => false\\n */\\nfunction isObject(value) {\\n  // Avoid a V8 JIT bug in Chrome 19-20.\\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\\n  var type = typeof value;\\n  return !!value && (type == 'object' || type == 'function');\\n}\\n\\nmodule.exports = isObject;\\n\\n},{}],34:[function(_dereq_,module,exports){\\nvar baseForIn = _dereq_('../internal/baseForIn'),\\n    isArguments = _dereq_('./isArguments'),\\n    isHostObject = _dereq_('../internal/isHostObject'),\\n    isObjectLike = _dereq_('../internal/isObjectLike'),\\n    support = _dereq_('../support');\\n\\n/** `Object#toString` result references. */\\nvar objectTag = '[object Object]';\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/** Used to check objects for own properties. */\\nvar hasOwnProperty = objectProto.hasOwnProperty;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/**\\n * Checks if `value` is a plain object, that is, an object created by the\\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\\n *\\n * **Note:** This method assumes objects created by the `Object` constructor\\n * have no inherited enumerable properties.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\\n * @example\\n *\\n * function Foo() {\\n *   this.a = 1;\\n * }\\n *\\n * _.isPlainObject(new Foo);\\n * // => false\\n *\\n * _.isPlainObject([1, 2, 3]);\\n * // => false\\n *\\n * _.isPlainObject({ 'x': 0, 'y': 0 });\\n * // => true\\n *\\n * _.isPlainObject(Object.create(null));\\n * // => true\\n */\\nfunction isPlainObject(value) {\\n  var Ctor;\\n\\n  // Exit early for non `Object` objects.\\n  if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isHostObject(value) && !isArguments(value)) ||\\n      (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {\\n    return false;\\n  }\\n  // IE < 9 iterates inherited properties before own properties. If the first\\n  // iterated property is an object's own property then there are no inherited\\n  // enumerable properties.\\n  var result;\\n  if (support.ownLast) {\\n    baseForIn(value, function(subValue, key, object) {\\n      result = hasOwnProperty.call(object, key);\\n      return false;\\n    });\\n    return result !== false;\\n  }\\n  // In most environments an object's own properties are iterated before\\n  // its inherited properties. If the last iterated property is an object's\\n  // own property then there are no inherited enumerable properties.\\n  baseForIn(value, function(subValue, key) {\\n    result = key;\\n  });\\n  return result === undefined || hasOwnProperty.call(value, result);\\n}\\n\\nmodule.exports = isPlainObject;\\n\\n},{\\\"../internal/baseForIn\\\":12,\\\"../internal/isHostObject\\\":22,\\\"../internal/isObjectLike\\\":26,\\\"../support\\\":41,\\\"./isArguments\\\":29}],35:[function(_dereq_,module,exports){\\nvar isObjectLike = _dereq_('../internal/isObjectLike');\\n\\n/** `Object#toString` result references. */\\nvar stringTag = '[object String]';\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/**\\n * Checks if `value` is classified as a `String` primitive or object.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\\n * @example\\n *\\n * _.isString('abc');\\n * // => true\\n *\\n * _.isString(1);\\n * // => false\\n */\\nfunction isString(value) {\\n  return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);\\n}\\n\\nmodule.exports = isString;\\n\\n},{\\\"../internal/isObjectLike\\\":26}],36:[function(_dereq_,module,exports){\\nvar isLength = _dereq_('../internal/isLength'),\\n    isObjectLike = _dereq_('../internal/isObjectLike');\\n\\n/** `Object#toString` result references. */\\nvar argsTag = '[object Arguments]',\\n    arrayTag = '[object Array]',\\n    boolTag = '[object Boolean]',\\n    dateTag = '[object Date]',\\n    errorTag = '[object Error]',\\n    funcTag = '[object Function]',\\n    mapTag = '[object Map]',\\n    numberTag = '[object Number]',\\n    objectTag = '[object Object]',\\n    regexpTag = '[object RegExp]',\\n    setTag = '[object Set]',\\n    stringTag = '[object String]',\\n    weakMapTag = '[object WeakMap]';\\n\\nvar arrayBufferTag = '[object ArrayBuffer]',\\n    float32Tag = '[object Float32Array]',\\n    float64Tag = '[object Float64Array]',\\n    int8Tag = '[object Int8Array]',\\n    int16Tag = '[object Int16Array]',\\n    int32Tag = '[object Int32Array]',\\n    uint8Tag = '[object Uint8Array]',\\n    uint8ClampedTag = '[object Uint8ClampedArray]',\\n    uint16Tag = '[object Uint16Array]',\\n    uint32Tag = '[object Uint32Array]';\\n\\n/** Used to identify `toStringTag` values of typed arrays. */\\nvar typedArrayTags = {};\\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\\ntypedArrayTags[uint32Tag] = true;\\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\\ntypedArrayTags[dateTag] = typedArrayTags[errorTag] =\\ntypedArrayTags[funcTag] = typedArrayTags[mapTag] =\\ntypedArrayTags[numberTag] = typedArrayTags[objectTag] =\\ntypedArrayTags[regexpTag] = typedArrayTags[setTag] =\\ntypedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/**\\n * Checks if `value` is classified as a typed array.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\\n * @example\\n *\\n * _.isTypedArray(new Uint8Array);\\n * // => true\\n *\\n * _.isTypedArray([]);\\n * // => false\\n */\\nfunction isTypedArray(value) {\\n  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];\\n}\\n\\nmodule.exports = isTypedArray;\\n\\n},{\\\"../internal/isLength\\\":25,\\\"../internal/isObjectLike\\\":26}],37:[function(_dereq_,module,exports){\\nvar baseCopy = _dereq_('../internal/baseCopy'),\\n    keysIn = _dereq_('../object/keysIn');\\n\\n/**\\n * Converts `value` to a plain object flattening inherited enumerable\\n * properties of `value` to own properties of the plain object.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to convert.\\n * @returns {Object} Returns the converted plain object.\\n * @example\\n *\\n * function Foo() {\\n *   this.b = 2;\\n * }\\n *\\n * Foo.prototype.c = 3;\\n *\\n * _.assign({ 'a': 1 }, new Foo);\\n * // => { 'a': 1, 'b': 2 }\\n *\\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\\n * // => { 'a': 1, 'b': 2, 'c': 3 }\\n */\\nfunction toPlainObject(value) {\\n  return baseCopy(value, keysIn(value));\\n}\\n\\nmodule.exports = toPlainObject;\\n\\n},{\\\"../internal/baseCopy\\\":10,\\\"../object/keysIn\\\":39}],38:[function(_dereq_,module,exports){\\nvar getNative = _dereq_('../internal/getNative'),\\n    isArrayLike = _dereq_('../internal/isArrayLike'),\\n    isObject = _dereq_('../lang/isObject'),\\n    shimKeys = _dereq_('../internal/shimKeys'),\\n    support = _dereq_('../support');\\n\\n/* Native method references for those with the same name as other `lodash` methods. */\\nvar nativeKeys = getNative(Object, 'keys');\\n\\n/**\\n * Creates an array of the own enumerable property names of `object`.\\n *\\n * **Note:** Non-object values are coerced to objects. See the\\n * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\\n * for more details.\\n *\\n * @static\\n * @memberOf _\\n * @category Object\\n * @param {Object} object The object to query.\\n * @returns {Array} Returns the array of property names.\\n * @example\\n *\\n * function Foo() {\\n *   this.a = 1;\\n *   this.b = 2;\\n * }\\n *\\n * Foo.prototype.c = 3;\\n *\\n * _.keys(new Foo);\\n * // => ['a', 'b'] (iteration order is not guaranteed)\\n *\\n * _.keys('hi');\\n * // => ['0', '1']\\n */\\nvar keys = !nativeKeys ? shimKeys : function(object) {\\n  var Ctor = object == null ? undefined : object.constructor;\\n  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\\n      (typeof object == 'function' ? support.enumPrototypes : isArrayLike(object))) {\\n    return shimKeys(object);\\n  }\\n  return isObject(object) ? nativeKeys(object) : [];\\n};\\n\\nmodule.exports = keys;\\n\\n},{\\\"../internal/getNative\\\":20,\\\"../internal/isArrayLike\\\":21,\\\"../internal/shimKeys\\\":27,\\\"../lang/isObject\\\":33,\\\"../support\\\":41}],39:[function(_dereq_,module,exports){\\nvar arrayEach = _dereq_('../internal/arrayEach'),\\n    isArguments = _dereq_('../lang/isArguments'),\\n    isArray = _dereq_('../lang/isArray'),\\n    isFunction = _dereq_('../lang/isFunction'),\\n    isIndex = _dereq_('../internal/isIndex'),\\n    isLength = _dereq_('../internal/isLength'),\\n    isObject = _dereq_('../lang/isObject'),\\n    isString = _dereq_('../lang/isString'),\\n    support = _dereq_('../support');\\n\\n/** `Object#toString` result references. */\\nvar arrayTag = '[object Array]',\\n    boolTag = '[object Boolean]',\\n    dateTag = '[object Date]',\\n    errorTag = '[object Error]',\\n    funcTag = '[object Function]',\\n    numberTag = '[object Number]',\\n    objectTag = '[object Object]',\\n    regexpTag = '[object RegExp]',\\n    stringTag = '[object String]';\\n\\n/** Used to fix the JScript `[[DontEnum]]` bug. */\\nvar shadowProps = [\\n  'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',\\n  'toLocaleString', 'toString', 'valueOf'\\n];\\n\\n/** Used for native method references. */\\nvar errorProto = Error.prototype,\\n    objectProto = Object.prototype,\\n    stringProto = String.prototype;\\n\\n/** Used to check objects for own properties. */\\nvar hasOwnProperty = objectProto.hasOwnProperty;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/** Used to avoid iterating over non-enumerable properties in IE < 9. */\\nvar nonEnumProps = {};\\nnonEnumProps[arrayTag] = nonEnumProps[dateTag] = nonEnumProps[numberTag] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };\\nnonEnumProps[boolTag] = nonEnumProps[stringTag] = { 'constructor': true, 'toString': true, 'valueOf': true };\\nnonEnumProps[errorTag] = nonEnumProps[funcTag] = nonEnumProps[regexpTag] = { 'constructor': true, 'toString': true };\\nnonEnumProps[objectTag] = { 'constructor': true };\\n\\narrayEach(shadowProps, function(key) {\\n  for (var tag in nonEnumProps) {\\n    if (hasOwnProperty.call(nonEnumProps, tag)) {\\n      var props = nonEnumProps[tag];\\n      props[key] = hasOwnProperty.call(props, key);\\n    }\\n  }\\n});\\n\\n/**\\n * Creates an array of the own and inherited enumerable property names of `object`.\\n *\\n * **Note:** Non-object values are coerced to objects.\\n *\\n * @static\\n * @memberOf _\\n * @category Object\\n * @param {Object} object The object to query.\\n * @returns {Array} Returns the array of property names.\\n * @example\\n *\\n * function Foo() {\\n *   this.a = 1;\\n *   this.b = 2;\\n * }\\n *\\n * Foo.prototype.c = 3;\\n *\\n * _.keysIn(new Foo);\\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\\n */\\nfunction keysIn(object) {\\n  if (object == null) {\\n    return [];\\n  }\\n  if (!isObject(object)) {\\n    object = Object(object);\\n  }\\n  var length = object.length;\\n\\n  length = (length && isLength(length) &&\\n    (isArray(object) || isArguments(object) || isString(object)) && length) || 0;\\n\\n  var Ctor = object.constructor,\\n      index = -1,\\n      proto = (isFunction(Ctor) && Ctor.prototype) || objectProto,\\n      isProto = proto === object,\\n      result = Array(length),\\n      skipIndexes = length > 0,\\n      skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error),\\n      skipProto = support.enumPrototypes && isFunction(object);\\n\\n  while (++index < length) {\\n    result[index] = (index + '');\\n  }\\n  // lodash skips the `constructor` property when it infers it's iterating\\n  // over a `prototype` object because IE < 9 can't set the `[[Enumerable]]`\\n  // attribute of an existing property and the `constructor` property of a\\n  // prototype defaults to non-enumerable.\\n  for (var key in object) {\\n    if (!(skipProto && key == 'prototype') &&\\n        !(skipErrorProps && (key == 'message' || key == 'name')) &&\\n        !(skipIndexes && isIndex(key, length)) &&\\n        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\\n      result.push(key);\\n    }\\n  }\\n  if (support.nonEnumShadows && object !== objectProto) {\\n    var tag = object === stringProto ? stringTag : (object === errorProto ? errorTag : objToString.call(object)),\\n        nonEnums = nonEnumProps[tag] || nonEnumProps[objectTag];\\n\\n    if (tag == objectTag) {\\n      proto = objectProto;\\n    }\\n    length = shadowProps.length;\\n    while (length--) {\\n      key = shadowProps[length];\\n      var nonEnum = nonEnums[key];\\n      if (!(isProto && nonEnum) &&\\n          (nonEnum ? hasOwnProperty.call(object, key) : object[key] !== proto[key])) {\\n        result.push(key);\\n      }\\n    }\\n  }\\n  return result;\\n}\\n\\nmodule.exports = keysIn;\\n\\n},{\\\"../internal/arrayEach\\\":9,\\\"../internal/isIndex\\\":23,\\\"../internal/isLength\\\":25,\\\"../lang/isArguments\\\":29,\\\"../lang/isArray\\\":30,\\\"../lang/isFunction\\\":31,\\\"../lang/isObject\\\":33,\\\"../lang/isString\\\":35,\\\"../support\\\":41}],40:[function(_dereq_,module,exports){\\nvar baseMerge = _dereq_('../internal/baseMerge'),\\n    createAssigner = _dereq_('../internal/createAssigner');\\n\\n/**\\n * Recursively merges own enumerable properties of the source object(s), that\\n * don't resolve to `undefined` into the destination object. Subsequent sources\\n * overwrite property assignments of previous sources. If `customizer` is\\n * provided it's invoked to produce the merged values of the destination and\\n * source properties. If `customizer` returns `undefined` merging is handled\\n * by the method instead. The `customizer` is bound to `thisArg` and invoked\\n * with five arguments: (objectValue, sourceValue, key, object, source).\\n *\\n * @static\\n * @memberOf _\\n * @category Object\\n * @param {Object} object The destination object.\\n * @param {...Object} [sources] The source objects.\\n * @param {Function} [customizer] The function to customize assigned values.\\n * @param {*} [thisArg] The `this` binding of `customizer`.\\n * @returns {Object} Returns `object`.\\n * @example\\n *\\n * var users = {\\n *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]\\n * };\\n *\\n * var ages = {\\n *   'data': [{ 'age': 36 }, { 'age': 40 }]\\n * };\\n *\\n * _.merge(users, ages);\\n * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }\\n *\\n * // using a customizer callback\\n * var object = {\\n *   'fruits': ['apple'],\\n *   'vegetables': ['beet']\\n * };\\n *\\n * var other = {\\n *   'fruits': ['banana'],\\n *   'vegetables': ['carrot']\\n * };\\n *\\n * _.merge(object, other, function(a, b) {\\n *   if (_.isArray(a)) {\\n *     return a.concat(b);\\n *   }\\n * });\\n * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }\\n */\\nvar merge = createAssigner(baseMerge);\\n\\nmodule.exports = merge;\\n\\n},{\\\"../internal/baseMerge\\\":13,\\\"../internal/createAssigner\\\":17}],41:[function(_dereq_,module,exports){\\n/** Used for native method references. */\\nvar arrayProto = Array.prototype,\\n    errorProto = Error.prototype,\\n    objectProto = Object.prototype;\\n\\n/** Native method references. */\\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable,\\n    splice = arrayProto.splice;\\n\\n/**\\n * An object environment feature flags.\\n *\\n * @static\\n * @memberOf _\\n * @type Object\\n */\\nvar support = {};\\n\\n(function(x) {\\n  var Ctor = function() { this.x = x; },\\n      object = { '0': x, 'length': x },\\n      props = [];\\n\\n  Ctor.prototype = { 'valueOf': x, 'y': x };\\n  for (var key in new Ctor) { props.push(key); }\\n\\n  /**\\n   * Detect if `name` or `message` properties of `Error.prototype` are\\n   * enumerable by default (IE < 9, Safari < 5.1).\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') ||\\n    propertyIsEnumerable.call(errorProto, 'name');\\n\\n  /**\\n   * Detect if `prototype` properties are enumerable by default.\\n   *\\n   * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1\\n   * (if the prototype or a property on the prototype has been set)\\n   * incorrectly set the `[[Enumerable]]` value of a function's `prototype`\\n   * property to `true`.\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.enumPrototypes = propertyIsEnumerable.call(Ctor, 'prototype');\\n\\n  /**\\n   * Detect if properties shadowing those on `Object.prototype` are non-enumerable.\\n   *\\n   * In IE < 9 an object's own properties, shadowing non-enumerable ones,\\n   * are made non-enumerable as well (a.k.a the JScript `[[DontEnum]]` bug).\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.nonEnumShadows = !/valueOf/.test(props);\\n\\n  /**\\n   * Detect if own properties are iterated after inherited properties (IE < 9).\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.ownLast = props[0] != 'x';\\n\\n  /**\\n   * Detect if `Array#shift` and `Array#splice` augment array-like objects\\n   * correctly.\\n   *\\n   * Firefox < 10, compatibility modes of IE 8, and IE < 9 have buggy Array\\n   * `shift()` and `splice()` functions that fail to remove the last element,\\n   * `value[0]`, of array-like objects even though the \\\"length\\\" property is\\n   * set to `0`. The `shift()` method is buggy in compatibility modes of IE 8,\\n   * while `splice()` is buggy regardless of mode in IE < 9.\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.spliceObjects = (splice.call(object, 0, 1), !object[0]);\\n\\n  /**\\n   * Detect lack of support for accessing string characters by index.\\n   *\\n   * IE < 8 can't access characters by index. IE 8 can only access characters\\n   * by index on string literals, not string objects.\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.unindexedChars = ('x'[0] + Object('x')[0]) != 'xx';\\n}(1, 0));\\n\\nmodule.exports = support;\\n\\n},{}],42:[function(_dereq_,module,exports){\\n/**\\n * This method returns the first argument provided to it.\\n *\\n * @static\\n * @memberOf _\\n * @category Utility\\n * @param {*} value Any value.\\n * @returns {*} Returns `value`.\\n * @example\\n *\\n * var object = { 'user': 'fred' };\\n *\\n * _.identity(object) === object;\\n * // => true\\n */\\nfunction identity(value) {\\n  return value;\\n}\\n\\nmodule.exports = identity;\\n\\n},{}],43:[function(_dereq_,module,exports){\\n'use strict';\\n\\nvar keys = _dereq_('object-keys');\\n\\nmodule.exports = function hasSymbols() {\\n\\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\\n\\tif (typeof Symbol.iterator === 'symbol') { return true; }\\n\\n\\tvar obj = {};\\n\\tvar sym = Symbol('test');\\n\\tif (typeof sym === 'string') { return false; }\\n\\n\\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\\n\\t// if (sym instanceof Symbol) { return false; }\\n\\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\\n\\t// if (!(Object(sym) instanceof Symbol)) { return false; }\\n\\n\\tvar symVal = 42;\\n\\tobj[sym] = symVal;\\n\\tfor (sym in obj) { return false; }\\n\\tif (keys(obj).length !== 0) { return false; }\\n\\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\\n\\n\\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\\n\\n\\tvar syms = Object.getOwnPropertySymbols(obj);\\n\\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\\n\\n\\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\\n\\n\\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\\n\\t\\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\\n\\t\\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\\n\\t}\\n\\n\\treturn true;\\n};\\n\\n},{\\\"object-keys\\\":50}],44:[function(_dereq_,module,exports){\\n'use strict';\\n\\n// modified from https://github.com/es-shims/es6-shim\\nvar keys = _dereq_('object-keys');\\nvar bind = _dereq_('function-bind');\\nvar canBeObject = function (obj) {\\n\\treturn typeof obj !== 'undefined' && obj !== null;\\n};\\nvar hasSymbols = _dereq_('./hasSymbols')();\\nvar toObject = Object;\\nvar push = bind.call(Function.call, Array.prototype.push);\\nvar propIsEnumerable = bind.call(Function.call, Object.prototype.propertyIsEnumerable);\\n\\nmodule.exports = function assign(target, source1) {\\n\\tif (!canBeObject(target)) { throw new TypeError('target must be an object'); }\\n\\tvar objTarget = toObject(target);\\n\\tvar s, source, i, props, syms, value, key;\\n\\tfor (s = 1; s < arguments.length; ++s) {\\n\\t\\tsource = toObject(arguments[s]);\\n\\t\\tprops = keys(source);\\n\\t\\tif (hasSymbols && Object.getOwnPropertySymbols) {\\n\\t\\t\\tsyms = Object.getOwnPropertySymbols(source);\\n\\t\\t\\tfor (i = 0; i < syms.length; ++i) {\\n\\t\\t\\t\\tkey = syms[i];\\n\\t\\t\\t\\tif (propIsEnumerable(source, key)) {\\n\\t\\t\\t\\t\\tpush(props, key);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (i = 0; i < props.length; ++i) {\\n\\t\\t\\tkey = props[i];\\n\\t\\t\\tvalue = source[key];\\n\\t\\t\\tif (propIsEnumerable(source, key)) {\\n\\t\\t\\t\\tobjTarget[key] = value;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn objTarget;\\n};\\n\\n},{\\\"./hasSymbols\\\":43,\\\"function-bind\\\":49,\\\"object-keys\\\":50}],45:[function(_dereq_,module,exports){\\n'use strict';\\n\\nvar defineProperties = _dereq_('define-properties');\\n\\nvar implementation = _dereq_('./implementation');\\nvar getPolyfill = _dereq_('./polyfill');\\nvar shim = _dereq_('./shim');\\n\\ndefineProperties(implementation, {\\n\\timplementation: implementation,\\n\\tgetPolyfill: getPolyfill,\\n\\tshim: shim\\n});\\n\\nmodule.exports = implementation;\\n\\n},{\\\"./implementation\\\":44,\\\"./polyfill\\\":52,\\\"./shim\\\":53,\\\"define-properties\\\":46}],46:[function(_dereq_,module,exports){\\n'use strict';\\n\\nvar keys = _dereq_('object-keys');\\nvar foreach = _dereq_('foreach');\\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';\\n\\nvar toStr = Object.prototype.toString;\\n\\nvar isFunction = function (fn) {\\n\\treturn typeof fn === 'function' && toStr.call(fn) === '[object Function]';\\n};\\n\\nvar arePropertyDescriptorsSupported = function () {\\n\\tvar obj = {};\\n\\ttry {\\n\\t\\tObject.defineProperty(obj, 'x', { enumerable: false, value: obj });\\n        /* eslint-disable no-unused-vars, no-restricted-syntax */\\n        for (var _ in obj) { return false; }\\n        /* eslint-enable no-unused-vars, no-restricted-syntax */\\n\\t\\treturn obj.x === obj;\\n\\t} catch (e) { /* this is IE 8. */\\n\\t\\treturn false;\\n\\t}\\n};\\nvar supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();\\n\\nvar defineProperty = function (object, name, value, predicate) {\\n\\tif (name in object && (!isFunction(predicate) || !predicate())) {\\n\\t\\treturn;\\n\\t}\\n\\tif (supportsDescriptors) {\\n\\t\\tObject.defineProperty(object, name, {\\n\\t\\t\\tconfigurable: true,\\n\\t\\t\\tenumerable: false,\\n\\t\\t\\tvalue: value,\\n\\t\\t\\twritable: true\\n\\t\\t});\\n\\t} else {\\n\\t\\tobject[name] = value;\\n\\t}\\n};\\n\\nvar defineProperties = function (object, map) {\\n\\tvar predicates = arguments.length > 2 ? arguments[2] : {};\\n\\tvar props = keys(map);\\n\\tif (hasSymbols) {\\n\\t\\tprops = props.concat(Object.getOwnPropertySymbols(map));\\n\\t}\\n\\tforeach(props, function (name) {\\n\\t\\tdefineProperty(object, name, map[name], predicates[name]);\\n\\t});\\n};\\n\\ndefineProperties.supportsDescriptors = !!supportsDescriptors;\\n\\nmodule.exports = defineProperties;\\n\\n},{\\\"foreach\\\":47,\\\"object-keys\\\":50}],47:[function(_dereq_,module,exports){\\n\\nvar hasOwn = Object.prototype.hasOwnProperty;\\nvar toString = Object.prototype.toString;\\n\\nmodule.exports = function forEach (obj, fn, ctx) {\\n    if (toString.call(fn) !== '[object Function]') {\\n        throw new TypeError('iterator must be a function');\\n    }\\n    var l = obj.length;\\n    if (l === +l) {\\n        for (var i = 0; i < l; i++) {\\n            fn.call(ctx, obj[i], i, obj);\\n        }\\n    } else {\\n        for (var k in obj) {\\n            if (hasOwn.call(obj, k)) {\\n                fn.call(ctx, obj[k], k, obj);\\n            }\\n        }\\n    }\\n};\\n\\n\\n},{}],48:[function(_dereq_,module,exports){\\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\\nvar slice = Array.prototype.slice;\\nvar toStr = Object.prototype.toString;\\nvar funcType = '[object Function]';\\n\\nmodule.exports = function bind(that) {\\n    var target = this;\\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\\n        throw new TypeError(ERROR_MESSAGE + target);\\n    }\\n    var args = slice.call(arguments, 1);\\n\\n    var bound;\\n    var binder = function () {\\n        if (this instanceof bound) {\\n            var result = target.apply(\\n                this,\\n                args.concat(slice.call(arguments))\\n            );\\n            if (Object(result) === result) {\\n                return result;\\n            }\\n            return this;\\n        } else {\\n            return target.apply(\\n                that,\\n                args.concat(slice.call(arguments))\\n            );\\n        }\\n    };\\n\\n    var boundLength = Math.max(0, target.length - args.length);\\n    var boundArgs = [];\\n    for (var i = 0; i < boundLength; i++) {\\n        boundArgs.push('$' + i);\\n    }\\n\\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\\n\\n    if (target.prototype) {\\n        var Empty = function Empty() {};\\n        Empty.prototype = target.prototype;\\n        bound.prototype = new Empty();\\n        Empty.prototype = null;\\n    }\\n\\n    return bound;\\n};\\n\\n},{}],49:[function(_dereq_,module,exports){\\nvar implementation = _dereq_('./implementation');\\n\\nmodule.exports = Function.prototype.bind || implementation;\\n\\n},{\\\"./implementation\\\":48}],50:[function(_dereq_,module,exports){\\n'use strict';\\n\\n// modified from https://github.com/es-shims/es5-shim\\nvar has = Object.prototype.hasOwnProperty;\\nvar toStr = Object.prototype.toString;\\nvar slice = Array.prototype.slice;\\nvar isArgs = _dereq_('./isArguments');\\nvar isEnumerable = Object.prototype.propertyIsEnumerable;\\nvar hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');\\nvar hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');\\nvar dontEnums = [\\n\\t'toString',\\n\\t'toLocaleString',\\n\\t'valueOf',\\n\\t'hasOwnProperty',\\n\\t'isPrototypeOf',\\n\\t'propertyIsEnumerable',\\n\\t'constructor'\\n];\\nvar equalsConstructorPrototype = function (o) {\\n\\tvar ctor = o.constructor;\\n\\treturn ctor && ctor.prototype === o;\\n};\\nvar excludedKeys = {\\n\\t$console: true,\\n\\t$external: true,\\n\\t$frame: true,\\n\\t$frameElement: true,\\n\\t$frames: true,\\n\\t$innerHeight: true,\\n\\t$innerWidth: true,\\n\\t$outerHeight: true,\\n\\t$outerWidth: true,\\n\\t$pageXOffset: true,\\n\\t$pageYOffset: true,\\n\\t$parent: true,\\n\\t$scrollLeft: true,\\n\\t$scrollTop: true,\\n\\t$scrollX: true,\\n\\t$scrollY: true,\\n\\t$self: true,\\n\\t$webkitIndexedDB: true,\\n\\t$webkitStorageInfo: true,\\n\\t$window: true\\n};\\nvar hasAutomationEqualityBug = (function () {\\n\\t/* global window */\\n\\tif (typeof window === 'undefined') { return false; }\\n\\tfor (var k in window) {\\n\\t\\ttry {\\n\\t\\t\\tif (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tequalsConstructorPrototype(window[k]);\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}());\\nvar equalsConstructorPrototypeIfNotBuggy = function (o) {\\n\\t/* global window */\\n\\tif (typeof window === 'undefined' || !hasAutomationEqualityBug) {\\n\\t\\treturn equalsConstructorPrototype(o);\\n\\t}\\n\\ttry {\\n\\t\\treturn equalsConstructorPrototype(o);\\n\\t} catch (e) {\\n\\t\\treturn false;\\n\\t}\\n};\\n\\nvar keysShim = function keys(object) {\\n\\tvar isObject = object !== null && typeof object === 'object';\\n\\tvar isFunction = toStr.call(object) === '[object Function]';\\n\\tvar isArguments = isArgs(object);\\n\\tvar isString = isObject && toStr.call(object) === '[object String]';\\n\\tvar theKeys = [];\\n\\n\\tif (!isObject && !isFunction && !isArguments) {\\n\\t\\tthrow new TypeError('Object.keys called on a non-object');\\n\\t}\\n\\n\\tvar skipProto = hasProtoEnumBug && isFunction;\\n\\tif (isString && object.length > 0 && !has.call(object, 0)) {\\n\\t\\tfor (var i = 0; i < object.length; ++i) {\\n\\t\\t\\ttheKeys.push(String(i));\\n\\t\\t}\\n\\t}\\n\\n\\tif (isArguments && object.length > 0) {\\n\\t\\tfor (var j = 0; j < object.length; ++j) {\\n\\t\\t\\ttheKeys.push(String(j));\\n\\t\\t}\\n\\t} else {\\n\\t\\tfor (var name in object) {\\n\\t\\t\\tif (!(skipProto && name === 'prototype') && has.call(object, name)) {\\n\\t\\t\\t\\ttheKeys.push(String(name));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif (hasDontEnumBug) {\\n\\t\\tvar skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\\n\\n\\t\\tfor (var k = 0; k < dontEnums.length; ++k) {\\n\\t\\t\\tif (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {\\n\\t\\t\\t\\ttheKeys.push(dontEnums[k]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn theKeys;\\n};\\n\\nkeysShim.shim = function shimObjectKeys() {\\n\\tif (Object.keys) {\\n\\t\\tvar keysWorksWithArguments = (function () {\\n\\t\\t\\t// Safari 5.0 bug\\n\\t\\t\\treturn (Object.keys(arguments) || '').length === 2;\\n\\t\\t}(1, 2));\\n\\t\\tif (!keysWorksWithArguments) {\\n\\t\\t\\tvar originalKeys = Object.keys;\\n\\t\\t\\tObject.keys = function keys(object) {\\n\\t\\t\\t\\tif (isArgs(object)) {\\n\\t\\t\\t\\t\\treturn originalKeys(slice.call(object));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn originalKeys(object);\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t}\\n\\t} else {\\n\\t\\tObject.keys = keysShim;\\n\\t}\\n\\treturn Object.keys || keysShim;\\n};\\n\\nmodule.exports = keysShim;\\n\\n},{\\\"./isArguments\\\":51}],51:[function(_dereq_,module,exports){\\n'use strict';\\n\\nvar toStr = Object.prototype.toString;\\n\\nmodule.exports = function isArguments(value) {\\n\\tvar str = toStr.call(value);\\n\\tvar isArgs = str === '[object Arguments]';\\n\\tif (!isArgs) {\\n\\t\\tisArgs = str !== '[object Array]' &&\\n\\t\\t\\tvalue !== null &&\\n\\t\\t\\ttypeof value === 'object' &&\\n\\t\\t\\ttypeof value.length === 'number' &&\\n\\t\\t\\tvalue.length >= 0 &&\\n\\t\\t\\ttoStr.call(value.callee) === '[object Function]';\\n\\t}\\n\\treturn isArgs;\\n};\\n\\n},{}],52:[function(_dereq_,module,exports){\\n'use strict';\\n\\nvar implementation = _dereq_('./implementation');\\n\\nvar lacksProperEnumerationOrder = function () {\\n\\tif (!Object.assign) {\\n\\t\\treturn false;\\n\\t}\\n\\t// v8, specifically in node 4.x, has a bug with incorrect property enumeration order\\n\\t// note: this does not detect the bug unless there's 20 characters\\n\\tvar str = 'abcdefghijklmnopqrst';\\n\\tvar letters = str.split('');\\n\\tvar map = {};\\n\\tfor (var i = 0; i < letters.length; ++i) {\\n\\t\\tmap[letters[i]] = letters[i];\\n\\t}\\n\\tvar obj = Object.assign({}, map);\\n\\tvar actual = '';\\n\\tfor (var k in obj) {\\n\\t\\tactual += k;\\n\\t}\\n\\treturn str !== actual;\\n};\\n\\nvar assignHasPendingExceptions = function () {\\n\\tif (!Object.assign || !Object.preventExtensions) {\\n\\t\\treturn false;\\n\\t}\\n\\t// Firefox 37 still has \\\"pending exception\\\" logic in its Object.assign implementation,\\n\\t// which is 72% slower than our shim, and Firefox 40's native implementation.\\n\\tvar thrower = Object.preventExtensions({ 1: 2 });\\n\\ttry {\\n\\t\\tObject.assign(thrower, 'xy');\\n\\t} catch (e) {\\n\\t\\treturn thrower[1] === 'y';\\n\\t}\\n};\\n\\nmodule.exports = function getPolyfill() {\\n\\tif (!Object.assign) {\\n\\t\\treturn implementation;\\n\\t}\\n\\tif (lacksProperEnumerationOrder()) {\\n\\t\\treturn implementation;\\n\\t}\\n\\tif (assignHasPendingExceptions()) {\\n\\t\\treturn implementation;\\n\\t}\\n\\treturn Object.assign;\\n};\\n\\n},{\\\"./implementation\\\":44}],53:[function(_dereq_,module,exports){\\n'use strict';\\n\\nvar define = _dereq_('define-properties');\\nvar getPolyfill = _dereq_('./polyfill');\\n\\nmodule.exports = function shimAssign() {\\n\\tvar polyfill = getPolyfill();\\n\\tdefine(\\n\\t\\tObject,\\n\\t\\t{ assign: polyfill },\\n\\t\\t{ assign: function () { return Object.assign !== polyfill; } }\\n\\t);\\n\\treturn polyfill;\\n};\\n\\n},{\\\"./polyfill\\\":52,\\\"define-properties\\\":46}],54:[function(_dereq_,module,exports){\\nmodule.exports = SafeParseTuple\\n\\nfunction SafeParseTuple(obj, reviver) {\\n    var json\\n    var error = null\\n\\n    try {\\n        json = JSON.parse(obj, reviver)\\n    } catch (err) {\\n        error = err\\n    }\\n\\n    return [error, json]\\n}\\n\\n},{}],55:[function(_dereq_,module,exports){\\nfunction clean (s) {\\n  return s.replace(/\\\\n\\\\r?\\\\s*/g, '')\\n}\\n\\n\\nmodule.exports = function tsml (sa) {\\n  var s = ''\\n    , i = 0\\n\\n  for (; i < arguments.length; i++)\\n    s += clean(sa[i]) + (arguments[i + 1] || '')\\n\\n  return s\\n}\\n},{}],56:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nvar window = _dereq_(\\\"global/window\\\")\\nvar once = _dereq_(\\\"once\\\")\\nvar isFunction = _dereq_(\\\"is-function\\\")\\nvar parseHeaders = _dereq_(\\\"parse-headers\\\")\\nvar xtend = _dereq_(\\\"xtend\\\")\\n\\nmodule.exports = createXHR\\ncreateXHR.XMLHttpRequest = window.XMLHttpRequest || noop\\ncreateXHR.XDomainRequest = \\\"withCredentials\\\" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest\\n\\nforEachArray([\\\"get\\\", \\\"put\\\", \\\"post\\\", \\\"patch\\\", \\\"head\\\", \\\"delete\\\"], function(method) {\\n    createXHR[method === \\\"delete\\\" ? \\\"del\\\" : method] = function(uri, options, callback) {\\n        options = initParams(uri, options, callback)\\n        options.method = method.toUpperCase()\\n        return _createXHR(options)\\n    }\\n})\\n\\nfunction forEachArray(array, iterator) {\\n    for (var i = 0; i < array.length; i++) {\\n        iterator(array[i])\\n    }\\n}\\n\\nfunction isEmpty(obj){\\n    for(var i in obj){\\n        if(obj.hasOwnProperty(i)) return false\\n    }\\n    return true\\n}\\n\\nfunction initParams(uri, options, callback) {\\n    var params = uri\\n\\n    if (isFunction(options)) {\\n        callback = options\\n        if (typeof uri === \\\"string\\\") {\\n            params = {uri:uri}\\n        }\\n    } else {\\n        params = xtend(options, {uri: uri})\\n    }\\n\\n    params.callback = callback\\n    return params\\n}\\n\\nfunction createXHR(uri, options, callback) {\\n    options = initParams(uri, options, callback)\\n    return _createXHR(options)\\n}\\n\\nfunction _createXHR(options) {\\n    var callback = options.callback\\n    if(typeof callback === \\\"undefined\\\"){\\n        throw new Error(\\\"callback argument missing\\\")\\n    }\\n    callback = once(callback)\\n\\n    function readystatechange() {\\n        if (xhr.readyState === 4) {\\n            loadFunc()\\n        }\\n    }\\n\\n    function getBody() {\\n        // Chrome with requestType=blob throws errors arround when even testing access to responseText\\n        var body = undefined\\n\\n        if (xhr.response) {\\n            body = xhr.response\\n        } else if (xhr.responseType === \\\"text\\\" || !xhr.responseType) {\\n            body = xhr.responseText || xhr.responseXML\\n        }\\n\\n        if (isJson) {\\n            try {\\n                body = JSON.parse(body)\\n            } catch (e) {}\\n        }\\n\\n        return body\\n    }\\n\\n    var failureResponse = {\\n                body: undefined,\\n                headers: {},\\n                statusCode: 0,\\n                method: method,\\n                url: uri,\\n                rawRequest: xhr\\n            }\\n\\n    function errorFunc(evt) {\\n        clearTimeout(timeoutTimer)\\n        if(!(evt instanceof Error)){\\n            evt = new Error(\\\"\\\" + (evt || \\\"Unknown XMLHttpRequest Error\\\") )\\n        }\\n        evt.statusCode = 0\\n        callback(evt, failureResponse)\\n    }\\n\\n    // will load the data & process the response in a special response object\\n    function loadFunc() {\\n        if (aborted) return\\n        var status\\n        clearTimeout(timeoutTimer)\\n        if(options.useXDR && xhr.status===undefined) {\\n            //IE8 CORS GET successful response doesn't have a status field, but body is fine\\n            status = 200\\n        } else {\\n            status = (xhr.status === 1223 ? 204 : xhr.status)\\n        }\\n        var response = failureResponse\\n        var err = null\\n\\n        if (status !== 0){\\n            response = {\\n                body: getBody(),\\n                statusCode: status,\\n                method: method,\\n                headers: {},\\n                url: uri,\\n                rawRequest: xhr\\n            }\\n            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE\\n                response.headers = parseHeaders(xhr.getAllResponseHeaders())\\n            }\\n        } else {\\n            err = new Error(\\\"Internal XMLHttpRequest Error\\\")\\n        }\\n        callback(err, response, response.body)\\n\\n    }\\n\\n    var xhr = options.xhr || null\\n\\n    if (!xhr) {\\n        if (options.cors || options.useXDR) {\\n            xhr = new createXHR.XDomainRequest()\\n        }else{\\n            xhr = new createXHR.XMLHttpRequest()\\n        }\\n    }\\n\\n    var key\\n    var aborted\\n    var uri = xhr.url = options.uri || options.url\\n    var method = xhr.method = options.method || \\\"GET\\\"\\n    var body = options.body || options.data || null\\n    var headers = xhr.headers = options.headers || {}\\n    var sync = !!options.sync\\n    var isJson = false\\n    var timeoutTimer\\n\\n    if (\\\"json\\\" in options) {\\n        isJson = true\\n        headers[\\\"accept\\\"] || headers[\\\"Accept\\\"] || (headers[\\\"Accept\\\"] = \\\"application/json\\\") //Don't override existing accept header declared by user\\n        if (method !== \\\"GET\\\" && method !== \\\"HEAD\\\") {\\n            headers[\\\"content-type\\\"] || headers[\\\"Content-Type\\\"] || (headers[\\\"Content-Type\\\"] = \\\"application/json\\\") //Don't override existing accept header declared by user\\n            body = JSON.stringify(options.json)\\n        }\\n    }\\n\\n    xhr.onreadystatechange = readystatechange\\n    xhr.onload = loadFunc\\n    xhr.onerror = errorFunc\\n    // IE9 must have onprogress be set to a unique function.\\n    xhr.onprogress = function () {\\n        // IE must die\\n    }\\n    xhr.ontimeout = errorFunc\\n    xhr.open(method, uri, !sync, options.username, options.password)\\n    //has to be after open\\n    if(!sync) {\\n        xhr.withCredentials = !!options.withCredentials\\n    }\\n    // Cannot set timeout with sync request\\n    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\\n    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent\\n    if (!sync && options.timeout > 0 ) {\\n        timeoutTimer = setTimeout(function(){\\n            aborted=true//IE9 may still call readystatechange\\n            xhr.abort(\\\"timeout\\\")\\n            var e = new Error(\\\"XMLHttpRequest timeout\\\")\\n            e.code = \\\"ETIMEDOUT\\\"\\n            errorFunc(e)\\n        }, options.timeout )\\n    }\\n\\n    if (xhr.setRequestHeader) {\\n        for(key in headers){\\n            if(headers.hasOwnProperty(key)){\\n                xhr.setRequestHeader(key, headers[key])\\n            }\\n        }\\n    } else if (options.headers && !isEmpty(options.headers)) {\\n        throw new Error(\\\"Headers cannot be set on an XDomainRequest object\\\")\\n    }\\n\\n    if (\\\"responseType\\\" in options) {\\n        xhr.responseType = options.responseType\\n    }\\n\\n    if (\\\"beforeSend\\\" in options &&\\n        typeof options.beforeSend === \\\"function\\\"\\n    ) {\\n        options.beforeSend(xhr)\\n    }\\n\\n    xhr.send(body)\\n\\n    return xhr\\n\\n\\n}\\n\\nfunction noop() {}\\n\\n},{\\\"global/window\\\":2,\\\"is-function\\\":57,\\\"once\\\":58,\\\"parse-headers\\\":61,\\\"xtend\\\":62}],57:[function(_dereq_,module,exports){\\nmodule.exports = isFunction\\n\\nvar toString = Object.prototype.toString\\n\\nfunction isFunction (fn) {\\n  var string = toString.call(fn)\\n  return string === '[object Function]' ||\\n    (typeof fn === 'function' && string !== '[object RegExp]') ||\\n    (typeof window !== 'undefined' &&\\n     // IE8 and below\\n     (fn === window.setTimeout ||\\n      fn === window.alert ||\\n      fn === window.confirm ||\\n      fn === window.prompt))\\n};\\n\\n},{}],58:[function(_dereq_,module,exports){\\nmodule.exports = once\\n\\nonce.proto = once(function () {\\n  Object.defineProperty(Function.prototype, 'once', {\\n    value: function () {\\n      return once(this)\\n    },\\n    configurable: true\\n  })\\n})\\n\\nfunction once (fn) {\\n  var called = false\\n  return function () {\\n    if (called) return\\n    called = true\\n    return fn.apply(this, arguments)\\n  }\\n}\\n\\n},{}],59:[function(_dereq_,module,exports){\\nvar isFunction = _dereq_('is-function')\\n\\nmodule.exports = forEach\\n\\nvar toString = Object.prototype.toString\\nvar hasOwnProperty = Object.prototype.hasOwnProperty\\n\\nfunction forEach(list, iterator, context) {\\n    if (!isFunction(iterator)) {\\n        throw new TypeError('iterator must be a function')\\n    }\\n\\n    if (arguments.length < 3) {\\n        context = this\\n    }\\n    \\n    if (toString.call(list) === '[object Array]')\\n        forEachArray(list, iterator, context)\\n    else if (typeof list === 'string')\\n        forEachString(list, iterator, context)\\n    else\\n        forEachObject(list, iterator, context)\\n}\\n\\nfunction forEachArray(array, iterator, context) {\\n    for (var i = 0, len = array.length; i < len; i++) {\\n        if (hasOwnProperty.call(array, i)) {\\n            iterator.call(context, array[i], i, array)\\n        }\\n    }\\n}\\n\\nfunction forEachString(string, iterator, context) {\\n    for (var i = 0, len = string.length; i < len; i++) {\\n        // no such thing as a sparse string.\\n        iterator.call(context, string.charAt(i), i, string)\\n    }\\n}\\n\\nfunction forEachObject(object, iterator, context) {\\n    for (var k in object) {\\n        if (hasOwnProperty.call(object, k)) {\\n            iterator.call(context, object[k], k, object)\\n        }\\n    }\\n}\\n\\n},{\\\"is-function\\\":57}],60:[function(_dereq_,module,exports){\\n\\nexports = module.exports = trim;\\n\\nfunction trim(str){\\n  return str.replace(/^\\\\s*|\\\\s*$/g, '');\\n}\\n\\nexports.left = function(str){\\n  return str.replace(/^\\\\s*/, '');\\n};\\n\\nexports.right = function(str){\\n  return str.replace(/\\\\s*$/, '');\\n};\\n\\n},{}],61:[function(_dereq_,module,exports){\\nvar trim = _dereq_('trim')\\n  , forEach = _dereq_('for-each')\\n  , isArray = function(arg) {\\n      return Object.prototype.toString.call(arg) === '[object Array]';\\n    }\\n\\nmodule.exports = function (headers) {\\n  if (!headers)\\n    return {}\\n\\n  var result = {}\\n\\n  forEach(\\n      trim(headers).split('\\\\n')\\n    , function (row) {\\n        var index = row.indexOf(':')\\n          , key = trim(row.slice(0, index)).toLowerCase()\\n          , value = trim(row.slice(index + 1))\\n\\n        if (typeof(result[key]) === 'undefined') {\\n          result[key] = value\\n        } else if (isArray(result[key])) {\\n          result[key].push(value)\\n        } else {\\n          result[key] = [ result[key], value ]\\n        }\\n      }\\n  )\\n\\n  return result\\n}\\n},{\\\"for-each\\\":59,\\\"trim\\\":60}],62:[function(_dereq_,module,exports){\\nmodule.exports = extend\\n\\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\\n\\nfunction extend() {\\n    var target = {}\\n\\n    for (var i = 0; i < arguments.length; i++) {\\n        var source = arguments[i]\\n\\n        for (var key in source) {\\n            if (hasOwnProperty.call(source, key)) {\\n                target[key] = source[key]\\n            }\\n        }\\n    }\\n\\n    return target\\n}\\n\\n},{}],63:[function(_dereq_,module,exports){\\n/**\\n * @file big-play-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _buttonJs = _dereq_('./button.js');\\n\\nvar _buttonJs2 = _interopRequireDefault(_buttonJs);\\n\\nvar _componentJs = _dereq_('./component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n/**\\n * Initial play button. Shows before the video has played. The hiding of the\\n * big play button is done via CSS and player states.\\n *\\n * @param {Object} player  Main Player\\n * @param {Object=} options Object of option names and values\\n * @extends Button\\n * @class BigPlayButton\\n */\\n\\nvar BigPlayButton = (function (_Button) {\\n  _inherits(BigPlayButton, _Button);\\n\\n  function BigPlayButton(player, options) {\\n    _classCallCheck(this, BigPlayButton);\\n\\n    _Button.call(this, player, options);\\n  }\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  BigPlayButton.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-big-play-button';\\n  };\\n\\n  /**\\n   * Handles click for play\\n   *\\n   * @method handleClick\\n   */\\n\\n  BigPlayButton.prototype.handleClick = function handleClick() {\\n    this.player_.play();\\n  };\\n\\n  return BigPlayButton;\\n})(_buttonJs2['default']);\\n\\nBigPlayButton.prototype.controlText_ = 'Play Video';\\n\\n_componentJs2['default'].registerComponent('BigPlayButton', BigPlayButton);\\nexports['default'] = BigPlayButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./button.js\\\":64,\\\"./component.js\\\":67}],64:[function(_dereq_,module,exports){\\n/**\\n * @file button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _clickableComponentJs = _dereq_('./clickable-component.js');\\n\\nvar _clickableComponentJs2 = _interopRequireDefault(_clickableComponentJs);\\n\\nvar _component = _dereq_('./component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _utilsEventsJs = _dereq_('./utils/events.js');\\n\\nvar Events = _interopRequireWildcard(_utilsEventsJs);\\n\\nvar _utilsFnJs = _dereq_('./utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsLogJs = _dereq_('./utils/log.js');\\n\\nvar _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _objectAssign = _dereq_('object.assign');\\n\\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\\n\\n/**\\n * Base class for all buttons\\n *\\n * @param {Object} player  Main Player\\n * @param {Object=} options Object of option names and values\\n * @extends ClickableComponent\\n * @class Button\\n */\\n\\nvar Button = (function (_ClickableComponent) {\\n  _inherits(Button, _ClickableComponent);\\n\\n  function Button(player, options) {\\n    _classCallCheck(this, Button);\\n\\n    _ClickableComponent.call(this, player, options);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @param {String=} type Element's node type. e.g. 'div'\\n   * @param {Object=} props An object of properties that should be set on the element\\n   * @param {Object=} attributes An object of attributes that should be set on the element\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  Button.prototype.createEl = function createEl() {\\n    var tag = arguments.length <= 0 || arguments[0] === undefined ? 'button' : arguments[0];\\n    var props = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n    var attributes = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\\n\\n    props = _objectAssign2['default']({\\n      className: this.buildCSSClass()\\n    }, props);\\n\\n    if (tag !== 'button') {\\n      _utilsLogJs2['default'].warn('Creating a Button with an HTML element of ' + tag + ' is deprecated; use ClickableComponent instead.');\\n\\n      // Add properties for clickable element which is not a native HTML button\\n      props = _objectAssign2['default']({\\n        tabIndex: 0\\n      }, props);\\n\\n      // Add ARIA attributes for clickable element which is not a native HTML button\\n      attributes = _objectAssign2['default']({\\n        role: 'button'\\n      }, attributes);\\n    }\\n\\n    // Add attributes for button element\\n    attributes = _objectAssign2['default']({\\n      type: 'button', // Necessary since the default button type is \\\"submit\\\"\\n      'aria-live': 'polite' // let the screen reader user know that the text of the button may change\\n    }, attributes);\\n\\n    var el = _component2['default'].prototype.createEl.call(this, tag, props, attributes);\\n\\n    this.createControlTextEl(el);\\n\\n    return el;\\n  };\\n\\n  /**\\n   * Adds a child component inside this button\\n   *\\n   * @param {String|Component} child The class name or instance of a child to add\\n   * @param {Object=} options Options, including options to be passed to children of the child.\\n   * @return {Component} The child component (created by this process if a string was used)\\n   * @deprecated\\n   * @method addChild\\n   */\\n\\n  Button.prototype.addChild = function addChild(child) {\\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n\\n    var className = this.constructor.name;\\n    _utilsLogJs2['default'].warn('Adding an actionable (user controllable) child to a Button (' + className + ') is not supported; use a ClickableComponent instead.');\\n\\n    // Avoid the error message generated by ClickableComponent's addChild method\\n    return _component2['default'].prototype.addChild.call(this, child, options);\\n  };\\n\\n  /**\\n   * Handle KeyPress (document level) - Extend with specific functionality for button\\n   *\\n   * @method handleKeyPress\\n   */\\n\\n  Button.prototype.handleKeyPress = function handleKeyPress(event) {\\n    // Ignore Space (32) or Enter (13) key operation, which is handled by the browser for a button.\\n    if (event.which === 32 || event.which === 13) {} else {\\n      _ClickableComponent.prototype.handleKeyPress.call(this, event); // Pass keypress handling up for unsupported keys\\n    }\\n  };\\n\\n  return Button;\\n})(_clickableComponentJs2['default']);\\n\\n_component2['default'].registerComponent('Button', Button);\\nexports['default'] = Button;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./clickable-component.js\\\":65,\\\"./component\\\":67,\\\"./utils/events.js\\\":143,\\\"./utils/fn.js\\\":144,\\\"./utils/log.js\\\":147,\\\"global/document\\\":1,\\\"object.assign\\\":45}],65:[function(_dereq_,module,exports){\\n/**\\n * @file button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _component = _dereq_('./component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _utilsDomJs = _dereq_('./utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsEventsJs = _dereq_('./utils/events.js');\\n\\nvar Events = _interopRequireWildcard(_utilsEventsJs);\\n\\nvar _utilsFnJs = _dereq_('./utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsLogJs = _dereq_('./utils/log.js');\\n\\nvar _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _objectAssign = _dereq_('object.assign');\\n\\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\\n\\n/**\\n * Clickable Component which is clickable or keyboard actionable, but is not a native HTML button\\n *\\n * @param {Object} player  Main Player\\n * @param {Object=} options Object of option names and values\\n * @extends Component\\n * @class ClickableComponent\\n */\\n\\nvar ClickableComponent = (function (_Component) {\\n  _inherits(ClickableComponent, _Component);\\n\\n  function ClickableComponent(player, options) {\\n    _classCallCheck(this, ClickableComponent);\\n\\n    _Component.call(this, player, options);\\n\\n    this.emitTapEvents();\\n\\n    this.on('tap', this.handleClick);\\n    this.on('click', this.handleClick);\\n    this.on('focus', this.handleFocus);\\n    this.on('blur', this.handleBlur);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @param {String=} type Element's node type. e.g. 'div'\\n   * @param {Object=} props An object of properties that should be set on the element\\n   * @param {Object=} attributes An object of attributes that should be set on the element\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  ClickableComponent.prototype.createEl = function createEl() {\\n    var tag = arguments.length <= 0 || arguments[0] === undefined ? 'div' : arguments[0];\\n    var props = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n    var attributes = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\\n\\n    props = _objectAssign2['default']({\\n      className: this.buildCSSClass(),\\n      tabIndex: 0\\n    }, props);\\n\\n    if (tag === 'button') {\\n      _utilsLogJs2['default'].error('Creating a ClickableComponent with an HTML element of ' + tag + ' is not supported; use a Button instead.');\\n    }\\n\\n    // Add ARIA attributes for clickable element which is not a native HTML button\\n    attributes = _objectAssign2['default']({\\n      role: 'button',\\n      'aria-live': 'polite' // let the screen reader user know that the text of the element may change\\n    }, attributes);\\n\\n    var el = _Component.prototype.createEl.call(this, tag, props, attributes);\\n\\n    this.createControlTextEl(el);\\n\\n    return el;\\n  };\\n\\n  /**\\n   * create control text\\n   *\\n   * @param {Element} el Parent element for the control text\\n   * @return {Element}\\n   * @method controlText\\n   */\\n\\n  ClickableComponent.prototype.createControlTextEl = function createControlTextEl(el) {\\n    this.controlTextEl_ = Dom.createEl('span', {\\n      className: 'vjs-control-text'\\n    });\\n\\n    if (el) {\\n      el.appendChild(this.controlTextEl_);\\n    }\\n\\n    this.controlText(this.controlText_, el);\\n\\n    return this.controlTextEl_;\\n  };\\n\\n  /**\\n   * Controls text - both request and localize\\n   *\\n   * @param {String}  text Text for element\\n   * @param {Element=} el Element to set the title on\\n   * @return {String}\\n   * @method controlText\\n   */\\n\\n  ClickableComponent.prototype.controlText = function controlText(text) {\\n    var el = arguments.length <= 1 || arguments[1] === undefined ? this.el() : arguments[1];\\n\\n    if (!text) return this.controlText_ || 'Need Text';\\n\\n    var localizedText = this.localize(text);\\n\\n    this.controlText_ = text;\\n    this.controlTextEl_.innerHTML = localizedText;\\n    el.setAttribute('title', localizedText);\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Allows sub components to stack CSS class names\\n   *\\n   * @return {String}\\n   * @method buildCSSClass\\n   */\\n\\n  ClickableComponent.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-control vjs-button ' + _Component.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Adds a child component inside this clickable-component\\n   *\\n   * @param {String|Component} child The class name or instance of a child to add\\n   * @param {Object=} options Options, including options to be passed to children of the child.\\n   * @return {Component} The child component (created by this process if a string was used)\\n   * @method addChild\\n   */\\n\\n  ClickableComponent.prototype.addChild = function addChild(child) {\\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n\\n    // TODO: Fix adding an actionable child to a ClickableComponent; currently\\n    // it will cause issues with assistive technology (e.g. screen readers)\\n    // which support ARIA, since an element with role=\\\"button\\\" cannot have\\n    // actionable child elements.\\n\\n    //let className = this.constructor.name;\\n    //log.warn(`Adding a child to a ClickableComponent (${className}) can cause issues with assistive technology which supports ARIA, since an element with role=\\\"button\\\" cannot have actionable child elements.`);\\n\\n    return _Component.prototype.addChild.call(this, child, options);\\n  };\\n\\n  /**\\n   * Enable the component element\\n   *\\n   * @return {Component}\\n   * @method enable\\n   */\\n\\n  ClickableComponent.prototype.enable = function enable() {\\n    this.removeClass('vjs-disabled');\\n    this.el_.setAttribute('aria-disabled', 'false');\\n    return this;\\n  };\\n\\n  /**\\n   * Disable the component element\\n   *\\n   * @return {Component}\\n   * @method disable\\n   */\\n\\n  ClickableComponent.prototype.disable = function disable() {\\n    this.addClass('vjs-disabled');\\n    this.el_.setAttribute('aria-disabled', 'true');\\n    return this;\\n  };\\n\\n  /**\\n   * Handle Click - Override with specific functionality for component\\n   *\\n   * @method handleClick\\n   */\\n\\n  ClickableComponent.prototype.handleClick = function handleClick() {};\\n\\n  /**\\n   * Handle Focus - Add keyboard functionality to element\\n   *\\n   * @method handleFocus\\n   */\\n\\n  ClickableComponent.prototype.handleFocus = function handleFocus() {\\n    Events.on(_globalDocument2['default'], 'keydown', Fn.bind(this, this.handleKeyPress));\\n  };\\n\\n  /**\\n   * Handle KeyPress (document level) - Trigger click when Space or Enter key is pressed\\n   *\\n   * @method handleKeyPress\\n   */\\n\\n  ClickableComponent.prototype.handleKeyPress = function handleKeyPress(event) {\\n    // Support Space (32) or Enter (13) key operation to fire a click event\\n    if (event.which === 32 || event.which === 13) {\\n      event.preventDefault();\\n      this.handleClick(event);\\n    } else if (_Component.prototype.handleKeyPress) {\\n      _Component.prototype.handleKeyPress.call(this, event); // Pass keypress handling up for unsupported keys\\n    }\\n  };\\n\\n  /**\\n   * Handle Blur - Remove keyboard triggers\\n   *\\n   * @method handleBlur\\n   */\\n\\n  ClickableComponent.prototype.handleBlur = function handleBlur() {\\n    Events.off(_globalDocument2['default'], 'keydown', Fn.bind(this, this.handleKeyPress));\\n  };\\n\\n  return ClickableComponent;\\n})(_component2['default']);\\n\\n_component2['default'].registerComponent('ClickableComponent', ClickableComponent);\\nexports['default'] = ClickableComponent;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./component\\\":67,\\\"./utils/dom.js\\\":142,\\\"./utils/events.js\\\":143,\\\"./utils/fn.js\\\":144,\\\"./utils/log.js\\\":147,\\\"global/document\\\":1,\\\"object.assign\\\":45}],66:[function(_dereq_,module,exports){\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _button = _dereq_('./button');\\n\\nvar _button2 = _interopRequireDefault(_button);\\n\\nvar _component = _dereq_('./component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\n/**\\n * The `CloseButton` component is a button which fires a \\\"close\\\" event\\n * when it is activated.\\n *\\n * @extends Button\\n * @class CloseButton\\n */\\n\\nvar CloseButton = (function (_Button) {\\n  _inherits(CloseButton, _Button);\\n\\n  function CloseButton(player, options) {\\n    _classCallCheck(this, CloseButton);\\n\\n    _Button.call(this, player, options);\\n    this.controlText(options && options.controlText || this.localize('Close'));\\n  }\\n\\n  CloseButton.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-close-button ' + _Button.prototype.buildCSSClass.call(this);\\n  };\\n\\n  CloseButton.prototype.handleClick = function handleClick() {\\n    this.trigger({ type: 'close', bubbles: false });\\n  };\\n\\n  return CloseButton;\\n})(_button2['default']);\\n\\n_component2['default'].registerComponent('CloseButton', CloseButton);\\nexports['default'] = CloseButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./button\\\":64,\\\"./component\\\":67}],67:[function(_dereq_,module,exports){\\n/**\\n * @file component.js\\n *\\n * Player Component - Base class for all UI objects\\n */\\n\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _utilsDomJs = _dereq_('./utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFnJs = _dereq_('./utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsGuidJs = _dereq_('./utils/guid.js');\\n\\nvar Guid = _interopRequireWildcard(_utilsGuidJs);\\n\\nvar _utilsEventsJs = _dereq_('./utils/events.js');\\n\\nvar Events = _interopRequireWildcard(_utilsEventsJs);\\n\\nvar _utilsLogJs = _dereq_('./utils/log.js');\\n\\nvar _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);\\n\\nvar _utilsToTitleCaseJs = _dereq_('./utils/to-title-case.js');\\n\\nvar _utilsToTitleCaseJs2 = _interopRequireDefault(_utilsToTitleCaseJs);\\n\\nvar _utilsMergeOptionsJs = _dereq_('./utils/merge-options.js');\\n\\nvar _utilsMergeOptionsJs2 = _interopRequireDefault(_utilsMergeOptionsJs);\\n\\n/**\\n * Base UI Component class\\n * Components are embeddable UI objects that are represented by both a\\n * javascript object and an element in the DOM. They can be children of other\\n * components, and can have many children themselves.\\n * ```js\\n *     // adding a button to the player\\n *     var button = player.addChild('button');\\n *     button.el(); // -> button element\\n * ```\\n * ```html\\n *     <div class=\\\"video-js\\\">\\n *       <div class=\\\"vjs-button\\\">Button</div>\\n *     </div>\\n * ```\\n * Components are also event targets.\\n * ```js\\n *     button.on('click', function(){\\n *       console.log('Button Clicked!');\\n *     });\\n *     button.trigger('customevent');\\n * ```\\n *\\n * @param {Object} player  Main Player\\n * @param {Object=} options Object of option names and values\\n * @param {Function=} ready    Ready callback function\\n * @class Component\\n */\\n\\nvar Component = (function () {\\n  function Component(player, options, ready) {\\n    _classCallCheck(this, Component);\\n\\n    // The component might be the player itself and we can't pass `this` to super\\n    if (!player && this.play) {\\n      this.player_ = player = this; // eslint-disable-line\\n    } else {\\n        this.player_ = player;\\n      }\\n\\n    // Make a copy of prototype.options_ to protect against overriding defaults\\n    this.options_ = _utilsMergeOptionsJs2['default']({}, this.options_);\\n\\n    // Updated options with supplied options\\n    options = this.options_ = _utilsMergeOptionsJs2['default'](this.options_, options);\\n\\n    // Get ID from options or options element if one is supplied\\n    this.id_ = options.id || options.el && options.el.id;\\n\\n    // If there was no ID from the options, generate one\\n    if (!this.id_) {\\n      // Don't require the player ID function in the case of mock players\\n      var id = player && player.id && player.id() || 'no_player';\\n\\n      this.id_ = id + '_component_' + Guid.newGUID();\\n    }\\n\\n    this.name_ = options.name || null;\\n\\n    // Create element if one wasn't provided in options\\n    if (options.el) {\\n      this.el_ = options.el;\\n    } else if (options.createEl !== false) {\\n      this.el_ = this.createEl();\\n    }\\n\\n    this.children_ = [];\\n    this.childIndex_ = {};\\n    this.childNameIndex_ = {};\\n\\n    // Add any child components in options\\n    if (options.initChildren !== false) {\\n      this.initChildren();\\n    }\\n\\n    this.ready(ready);\\n    // Don't want to trigger ready here or it will before init is actually\\n    // finished for all children that run this constructor\\n\\n    if (options.reportTouchActivity !== false) {\\n      this.enableTouchActivity();\\n    }\\n  }\\n\\n  /**\\n   * Dispose of the component and all child components\\n   *\\n   * @method dispose\\n   */\\n\\n  Component.prototype.dispose = function dispose() {\\n    this.trigger({ type: 'dispose', bubbles: false });\\n\\n    // Dispose all children.\\n    if (this.children_) {\\n      for (var i = this.children_.length - 1; i >= 0; i--) {\\n        if (this.children_[i].dispose) {\\n          this.children_[i].dispose();\\n        }\\n      }\\n    }\\n\\n    // Delete child references\\n    this.children_ = null;\\n    this.childIndex_ = null;\\n    this.childNameIndex_ = null;\\n\\n    // Remove all event listeners.\\n    this.off();\\n\\n    // Remove element from DOM\\n    if (this.el_.parentNode) {\\n      this.el_.parentNode.removeChild(this.el_);\\n    }\\n\\n    Dom.removeElData(this.el_);\\n    this.el_ = null;\\n  };\\n\\n  /**\\n   * Return the component's player\\n   *\\n   * @return {Player}\\n   * @method player\\n   */\\n\\n  Component.prototype.player = function player() {\\n    return this.player_;\\n  };\\n\\n  /**\\n   * Deep merge of options objects\\n   * Whenever a property is an object on both options objects\\n   * the two properties will be merged using mergeOptions.\\n   *\\n   * ```js\\n   *     Parent.prototype.options_ = {\\n   *       optionSet: {\\n   *         'childOne': { 'foo': 'bar', 'asdf': 'fdsa' },\\n   *         'childTwo': {},\\n   *         'childThree': {}\\n   *       }\\n   *     }\\n   *     newOptions = {\\n   *       optionSet: {\\n   *         'childOne': { 'foo': 'baz', 'abc': '123' }\\n   *         'childTwo': null,\\n   *         'childFour': {}\\n   *       }\\n   *     }\\n   *\\n   *     this.options(newOptions);\\n   * ```\\n   * RESULT\\n   * ```js\\n   *     {\\n   *       optionSet: {\\n   *         'childOne': { 'foo': 'baz', 'asdf': 'fdsa', 'abc': '123' },\\n   *         'childTwo': null, // Disabled. Won't be initialized.\\n   *         'childThree': {},\\n   *         'childFour': {}\\n   *       }\\n   *     }\\n   * ```\\n   *\\n   * @param  {Object} obj Object of new option values\\n   * @return {Object}     A NEW object of this.options_ and obj merged\\n   * @method options\\n   */\\n\\n  Component.prototype.options = function options(obj) {\\n    _utilsLogJs2['default'].warn('this.options() has been deprecated and will be moved to the constructor in 6.0');\\n\\n    if (!obj) {\\n      return this.options_;\\n    }\\n\\n    this.options_ = _utilsMergeOptionsJs2['default'](this.options_, obj);\\n    return this.options_;\\n  };\\n\\n  /**\\n   * Get the component's DOM element\\n   * ```js\\n   *     var domEl = myComponent.el();\\n   * ```\\n   *\\n   * @return {Element}\\n   * @method el\\n   */\\n\\n  Component.prototype.el = function el() {\\n    return this.el_;\\n  };\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @param  {String=} tagName  Element's node type. e.g. 'div'\\n   * @param  {Object=} properties An object of properties that should be set\\n   * @param  {Object=} attributes An object of attributes that should be set\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  Component.prototype.createEl = function createEl(tagName, properties, attributes) {\\n    return Dom.createEl(tagName, properties, attributes);\\n  };\\n\\n  Component.prototype.localize = function localize(string) {\\n    var code = this.player_.language && this.player_.language();\\n    var languages = this.player_.languages && this.player_.languages();\\n\\n    if (!code || !languages) {\\n      return string;\\n    }\\n\\n    var language = languages[code];\\n\\n    if (language && language[string]) {\\n      return language[string];\\n    }\\n\\n    var primaryCode = code.split('-')[0];\\n    var primaryLang = languages[primaryCode];\\n\\n    if (primaryLang && primaryLang[string]) {\\n      return primaryLang[string];\\n    }\\n\\n    return string;\\n  };\\n\\n  /**\\n   * Return the component's DOM element where children are inserted.\\n   * Will either be the same as el() or a new element defined in createEl().\\n   *\\n   * @return {Element}\\n   * @method contentEl\\n   */\\n\\n  Component.prototype.contentEl = function contentEl() {\\n    return this.contentEl_ || this.el_;\\n  };\\n\\n  /**\\n   * Get the component's ID\\n   * ```js\\n   *     var id = myComponent.id();\\n   * ```\\n   *\\n   * @return {String}\\n   * @method id\\n   */\\n\\n  Component.prototype.id = function id() {\\n    return this.id_;\\n  };\\n\\n  /**\\n   * Get the component's name. The name is often used to reference the component.\\n   * ```js\\n   *     var name = myComponent.name();\\n   * ```\\n   *\\n   * @return {String}\\n   * @method name\\n   */\\n\\n  Component.prototype.name = function name() {\\n    return this.name_;\\n  };\\n\\n  /**\\n   * Get an array of all child components\\n   * ```js\\n   *     var kids = myComponent.children();\\n   * ```\\n   *\\n   * @return {Array} The children\\n   * @method children\\n   */\\n\\n  Component.prototype.children = function children() {\\n    return this.children_;\\n  };\\n\\n  /**\\n   * Returns a child component with the provided ID\\n   *\\n   * @return {Component}\\n   * @method getChildById\\n   */\\n\\n  Component.prototype.getChildById = function getChildById(id) {\\n    return this.childIndex_[id];\\n  };\\n\\n  /**\\n   * Returns a child component with the provided name\\n   *\\n   * @return {Component}\\n   * @method getChild\\n   */\\n\\n  Component.prototype.getChild = function getChild(name) {\\n    return this.childNameIndex_[name];\\n  };\\n\\n  /**\\n   * Adds a child component inside this component\\n   * ```js\\n   *     myComponent.el();\\n   *     // -> <div class='my-component'></div>\\n   *     myComponent.children();\\n   *     // [empty array]\\n   *\\n   *     var myButton = myComponent.addChild('MyButton');\\n   *     // -> <div class='my-component'><div class=\\\"my-button\\\">myButton<div></div>\\n   *     // -> myButton === myComponent.children()[0];\\n   * ```\\n   * Pass in options for child constructors and options for children of the child\\n   * ```js\\n   *     var myButton = myComponent.addChild('MyButton', {\\n   *       text: 'Press Me',\\n   *       buttonChildExample: {\\n   *         buttonChildOption: true\\n   *       }\\n   *     });\\n   * ```\\n   *\\n   * @param {String|Component} child The class name or instance of a child to add\\n   * @param {Object=} options Options, including options to be passed to children of the child.\\n   * @param {Number} index into our children array to attempt to add the child\\n   * @return {Component} The child component (created by this process if a string was used)\\n   * @method addChild\\n   */\\n\\n  Component.prototype.addChild = function addChild(child) {\\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n    var index = arguments.length <= 2 || arguments[2] === undefined ? this.children_.length : arguments[2];\\n\\n    var component = undefined;\\n    var componentName = undefined;\\n\\n    // If child is a string, create nt with options\\n    if (typeof child === 'string') {\\n      componentName = child;\\n\\n      // Options can also be specified as a boolean, so convert to an empty object if false.\\n      if (!options) {\\n        options = {};\\n      }\\n\\n      // Same as above, but true is deprecated so show a warning.\\n      if (options === true) {\\n        _utilsLogJs2['default'].warn('Initializing a child component with `true` is deprecated. Children should be defined in an array when possible, but if necessary use an object instead of `true`.');\\n        options = {};\\n      }\\n\\n      // If no componentClass in options, assume componentClass is the name lowercased\\n      // (e.g. playButton)\\n      var componentClassName = options.componentClass || _utilsToTitleCaseJs2['default'](componentName);\\n\\n      // Set name through options\\n      options.name = componentName;\\n\\n      // Create a new object & element for this controls set\\n      // If there's no .player_, this is a player\\n      var ComponentClass = Component.getComponent(componentClassName);\\n\\n      if (!ComponentClass) {\\n        throw new Error('Component ' + componentClassName + ' does not exist');\\n      }\\n\\n      // data stored directly on the videojs object may be\\n      // misidentified as a component to retain\\n      // backwards-compatibility with 4.x. check to make sure the\\n      // component class can be instantiated.\\n      if (typeof ComponentClass !== 'function') {\\n        return null;\\n      }\\n\\n      component = new ComponentClass(this.player_ || this, options);\\n\\n      // child is a component instance\\n    } else {\\n        component = child;\\n      }\\n\\n    this.children_.splice(index, 0, component);\\n\\n    if (typeof component.id === 'function') {\\n      this.childIndex_[component.id()] = component;\\n    }\\n\\n    // If a name wasn't used to create the component, check if we can use the\\n    // name function of the component\\n    componentName = componentName || component.name && component.name();\\n\\n    if (componentName) {\\n      this.childNameIndex_[componentName] = component;\\n    }\\n\\n    // Add the UI object's element to the container div (box)\\n    // Having an element is not required\\n    if (typeof component.el === 'function' && component.el()) {\\n      var childNodes = this.contentEl().children;\\n      var refNode = childNodes[index] || null;\\n      this.contentEl().insertBefore(component.el(), refNode);\\n    }\\n\\n    // Return so it can stored on parent object if desired.\\n    return component;\\n  };\\n\\n  /**\\n   * Remove a child component from this component's list of children, and the\\n   * child component's element from this component's element\\n   *\\n   * @param  {Component} component Component to remove\\n   * @method removeChild\\n   */\\n\\n  Component.prototype.removeChild = function removeChild(component) {\\n    if (typeof component === 'string') {\\n      component = this.getChild(component);\\n    }\\n\\n    if (!component || !this.children_) {\\n      return;\\n    }\\n\\n    var childFound = false;\\n\\n    for (var i = this.children_.length - 1; i >= 0; i--) {\\n      if (this.children_[i] === component) {\\n        childFound = true;\\n        this.children_.splice(i, 1);\\n        break;\\n      }\\n    }\\n\\n    if (!childFound) {\\n      return;\\n    }\\n\\n    this.childIndex_[component.id()] = null;\\n    this.childNameIndex_[component.name()] = null;\\n\\n    var compEl = component.el();\\n\\n    if (compEl && compEl.parentNode === this.contentEl()) {\\n      this.contentEl().removeChild(component.el());\\n    }\\n  };\\n\\n  /**\\n   * Add and initialize default child components from options\\n   * ```js\\n   *     // when an instance of MyComponent is created, all children in options\\n   *     // will be added to the instance by their name strings and options\\n   *     MyComponent.prototype.options_ = {\\n   *       children: [\\n   *         'myChildComponent'\\n   *       ],\\n   *       myChildComponent: {\\n   *         myChildOption: true\\n   *       }\\n   *     };\\n   *\\n   *     // Or when creating the component\\n   *     var myComp = new MyComponent(player, {\\n   *       children: [\\n   *         'myChildComponent'\\n   *       ],\\n   *       myChildComponent: {\\n   *         myChildOption: true\\n   *       }\\n   *     });\\n   * ```\\n   * The children option can also be an array of\\n   * child options objects (that also include a 'name' key).\\n   * This can be used if you have two child components of the\\n   * same type that need different options.\\n   * ```js\\n   *     var myComp = new MyComponent(player, {\\n   *       children: [\\n   *         'button',\\n   *         {\\n   *           name: 'button',\\n   *           someOtherOption: true\\n   *         },\\n   *         {\\n   *           name: 'button',\\n   *           someOtherOption: false\\n   *         }\\n   *       ]\\n   *     });\\n   * ```\\n   *\\n   * @method initChildren\\n   */\\n\\n  Component.prototype.initChildren = function initChildren() {\\n    var _this = this;\\n\\n    var children = this.options_.children;\\n\\n    if (children) {\\n      (function () {\\n        // `this` is `parent`\\n        var parentOptions = _this.options_;\\n\\n        var handleAdd = function handleAdd(child) {\\n          var name = child.name;\\n          var opts = child.opts;\\n\\n          // Allow options for children to be set at the parent options\\n          // e.g. videojs(id, { controlBar: false });\\n          // instead of videojs(id, { children: { controlBar: false });\\n          if (parentOptions[name] !== undefined) {\\n            opts = parentOptions[name];\\n          }\\n\\n          // Allow for disabling default components\\n          // e.g. options['children']['posterImage'] = false\\n          if (opts === false) {\\n            return;\\n          }\\n\\n          // Allow options to be passed as a simple boolean if no configuration\\n          // is necessary.\\n          if (opts === true) {\\n            opts = {};\\n          }\\n\\n          // We also want to pass the original player options to each component as well so they don't need to\\n          // reach back into the player for options later.\\n          opts.playerOptions = _this.options_.playerOptions;\\n\\n          // Create and add the child component.\\n          // Add a direct reference to the child by name on the parent instance.\\n          // If two of the same component are used, different names should be supplied\\n          // for each\\n          var newChild = _this.addChild(name, opts);\\n          if (newChild) {\\n            _this[name] = newChild;\\n          }\\n        };\\n\\n        // Allow for an array of children details to passed in the options\\n        var workingChildren = undefined;\\n        var Tech = Component.getComponent('Tech');\\n\\n        if (Array.isArray(children)) {\\n          workingChildren = children;\\n        } else {\\n          workingChildren = Object.keys(children);\\n        }\\n\\n        workingChildren\\n        // children that are in this.options_ but also in workingChildren  would\\n        // give us extra children we do not want. So, we want to filter them out.\\n        .concat(Object.keys(_this.options_).filter(function (child) {\\n          return !workingChildren.some(function (wchild) {\\n            if (typeof wchild === 'string') {\\n              return child === wchild;\\n            } else {\\n              return child === wchild.name;\\n            }\\n          });\\n        })).map(function (child) {\\n          var name = undefined,\\n              opts = undefined;\\n\\n          if (typeof child === 'string') {\\n            name = child;\\n            opts = children[name] || _this.options_[name] || {};\\n          } else {\\n            name = child.name;\\n            opts = child;\\n          }\\n\\n          return { name: name, opts: opts };\\n        }).filter(function (child) {\\n          // we have to make sure that child.name isn't in the techOrder since\\n          // techs are registerd as Components but can't aren't compatible\\n          // See https://github.com/videojs/video.js/issues/2772\\n          var c = Component.getComponent(child.opts.componentClass || _utilsToTitleCaseJs2['default'](child.name));\\n          return c && !Tech.isTech(c);\\n        }).forEach(handleAdd);\\n      })();\\n    }\\n  };\\n\\n  /**\\n   * Allows sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  Component.prototype.buildCSSClass = function buildCSSClass() {\\n    // Child classes can include a function that does:\\n    // return 'CLASS NAME' + this._super();\\n    return '';\\n  };\\n\\n  /**\\n   * Add an event listener to this component's element\\n   * ```js\\n   *     var myFunc = function(){\\n   *       var myComponent = this;\\n   *       // Do something when the event is fired\\n   *     };\\n   *\\n   *     myComponent.on('eventType', myFunc);\\n   * ```\\n   * The context of myFunc will be myComponent unless previously bound.\\n   * Alternatively, you can add a listener to another element or component.\\n   * ```js\\n   *     myComponent.on(otherElement, 'eventName', myFunc);\\n   *     myComponent.on(otherComponent, 'eventName', myFunc);\\n   * ```\\n   * The benefit of using this over `VjsEvents.on(otherElement, 'eventName', myFunc)`\\n   * and `otherComponent.on('eventName', myFunc)` is that this way the listeners\\n   * will be automatically cleaned up when either component is disposed.\\n   * It will also bind myComponent as the context of myFunc.\\n   * **NOTE**: When using this on elements in the page other than window\\n   * and document (both permanent), if you remove the element from the DOM\\n   * you need to call `myComponent.trigger(el, 'dispose')` on it to clean up\\n   * references to it and allow the browser to garbage collect it.\\n   *\\n   * @param  {String|Component} first   The event type or other component\\n   * @param  {Function|String}      second  The event handler or event type\\n   * @param  {Function}             third   The event handler\\n   * @return {Component}\\n   * @method on\\n   */\\n\\n  Component.prototype.on = function on(first, second, third) {\\n    var _this2 = this;\\n\\n    if (typeof first === 'string' || Array.isArray(first)) {\\n      Events.on(this.el_, first, Fn.bind(this, second));\\n\\n      // Targeting another component or element\\n    } else {\\n        (function () {\\n          var target = first;\\n          var type = second;\\n          var fn = Fn.bind(_this2, third);\\n\\n          // When this component is disposed, remove the listener from the other component\\n          var removeOnDispose = function removeOnDispose() {\\n            return _this2.off(target, type, fn);\\n          };\\n\\n          // Use the same function ID so we can remove it later it using the ID\\n          // of the original listener\\n          removeOnDispose.guid = fn.guid;\\n          _this2.on('dispose', removeOnDispose);\\n\\n          // If the other component is disposed first we need to clean the reference\\n          // to the other component in this component's removeOnDispose listener\\n          // Otherwise we create a memory leak.\\n          var cleanRemover = function cleanRemover() {\\n            return _this2.off('dispose', removeOnDispose);\\n          };\\n\\n          // Add the same function ID so we can easily remove it later\\n          cleanRemover.guid = fn.guid;\\n\\n          // Check if this is a DOM node\\n          if (first.nodeName) {\\n            // Add the listener to the other element\\n            Events.on(target, type, fn);\\n            Events.on(target, 'dispose', cleanRemover);\\n\\n            // Should be a component\\n            // Not using `instanceof Component` because it makes mock players difficult\\n          } else if (typeof first.on === 'function') {\\n              // Add the listener to the other component\\n              target.on(type, fn);\\n              target.on('dispose', cleanRemover);\\n            }\\n        })();\\n      }\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Remove an event listener from this component's element\\n   * ```js\\n   *     myComponent.off('eventType', myFunc);\\n   * ```\\n   * If myFunc is excluded, ALL listeners for the event type will be removed.\\n   * If eventType is excluded, ALL listeners will be removed from the component.\\n   * Alternatively you can use `off` to remove listeners that were added to other\\n   * elements or components using `myComponent.on(otherComponent...`.\\n   * In this case both the event type and listener function are REQUIRED.\\n   * ```js\\n   *     myComponent.off(otherElement, 'eventType', myFunc);\\n   *     myComponent.off(otherComponent, 'eventType', myFunc);\\n   * ```\\n   *\\n   * @param  {String=|Component}  first  The event type or other component\\n   * @param  {Function=|String}       second The listener function or event type\\n   * @param  {Function=}              third  The listener for other component\\n   * @return {Component}\\n   * @method off\\n   */\\n\\n  Component.prototype.off = function off(first, second, third) {\\n    if (!first || typeof first === 'string' || Array.isArray(first)) {\\n      Events.off(this.el_, first, second);\\n    } else {\\n      var target = first;\\n      var type = second;\\n      // Ensure there's at least a guid, even if the function hasn't been used\\n      var fn = Fn.bind(this, third);\\n\\n      // Remove the dispose listener on this component,\\n      // which was given the same guid as the event listener\\n      this.off('dispose', fn);\\n\\n      if (first.nodeName) {\\n        // Remove the listener\\n        Events.off(target, type, fn);\\n        // Remove the listener for cleaning the dispose listener\\n        Events.off(target, 'dispose', fn);\\n      } else {\\n        target.off(type, fn);\\n        target.off('dispose', fn);\\n      }\\n    }\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Add an event listener to be triggered only once and then removed\\n   * ```js\\n   *     myComponent.one('eventName', myFunc);\\n   * ```\\n   * Alternatively you can add a listener to another element or component\\n   * that will be triggered only once.\\n   * ```js\\n   *     myComponent.one(otherElement, 'eventName', myFunc);\\n   *     myComponent.one(otherComponent, 'eventName', myFunc);\\n   * ```\\n   *\\n   * @param  {String|Component}  first   The event type or other component\\n   * @param  {Function|String}       second  The listener function or event type\\n   * @param  {Function=}             third   The listener function for other component\\n   * @return {Component}\\n   * @method one\\n   */\\n\\n  Component.prototype.one = function one(first, second, third) {\\n    var _this3 = this,\\n        _arguments = arguments;\\n\\n    if (typeof first === 'string' || Array.isArray(first)) {\\n      Events.one(this.el_, first, Fn.bind(this, second));\\n    } else {\\n      (function () {\\n        var target = first;\\n        var type = second;\\n        var fn = Fn.bind(_this3, third);\\n\\n        var newFunc = function newFunc() {\\n          _this3.off(target, type, newFunc);\\n          fn.apply(null, _arguments);\\n        };\\n\\n        // Keep the same function ID so we can remove it later\\n        newFunc.guid = fn.guid;\\n\\n        _this3.on(target, type, newFunc);\\n      })();\\n    }\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Trigger an event on an element\\n   * ```js\\n   *     myComponent.trigger('eventName');\\n   *     myComponent.trigger({'type':'eventName'});\\n   *     myComponent.trigger('eventName', {data: 'some data'});\\n   *     myComponent.trigger({'type':'eventName'}, {data: 'some data'});\\n   * ```\\n   *\\n   * @param  {Event|Object|String} event  A string (the type) or an event object with a type attribute\\n   * @param  {Object} [hash] data hash to pass along with the event\\n   * @return {Component}       self\\n   * @method trigger\\n   */\\n\\n  Component.prototype.trigger = function trigger(event, hash) {\\n    Events.trigger(this.el_, event, hash);\\n    return this;\\n  };\\n\\n  /**\\n   * Bind a listener to the component's ready state.\\n   * Different from event listeners in that if the ready event has already happened\\n   * it will trigger the function immediately.\\n   *\\n   * @param  {Function} fn Ready listener\\n   * @param  {Boolean} sync Exec the listener synchronously if component is ready\\n   * @return {Component}\\n   * @method ready\\n   */\\n\\n  Component.prototype.ready = function ready(fn) {\\n    var sync = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\\n\\n    if (fn) {\\n      if (this.isReady_) {\\n        if (sync) {\\n          fn.call(this);\\n        } else {\\n          // Call the function asynchronously by default for consistency\\n          this.setTimeout(fn, 1);\\n        }\\n      } else {\\n        this.readyQueue_ = this.readyQueue_ || [];\\n        this.readyQueue_.push(fn);\\n      }\\n    }\\n    return this;\\n  };\\n\\n  /**\\n   * Trigger the ready listeners\\n   *\\n   * @return {Component}\\n   * @method triggerReady\\n   */\\n\\n  Component.prototype.triggerReady = function triggerReady() {\\n    this.isReady_ = true;\\n\\n    // Ensure ready is triggerd asynchronously\\n    this.setTimeout(function () {\\n      var readyQueue = this.readyQueue_;\\n\\n      // Reset Ready Queue\\n      this.readyQueue_ = [];\\n\\n      if (readyQueue && readyQueue.length > 0) {\\n        readyQueue.forEach(function (fn) {\\n          fn.call(this);\\n        }, this);\\n      }\\n\\n      // Allow for using event listeners also\\n      this.trigger('ready');\\n    }, 1);\\n  };\\n\\n  /**\\n   * Finds a single DOM element matching `selector` within the component's\\n   * `contentEl` or another custom context.\\n   *\\n   * @method $\\n   * @param  {String} selector\\n   *         A valid CSS selector, which will be passed to `querySelector`.\\n   *\\n   * @param  {Element|String} [context=document]\\n   *         A DOM element within which to query. Can also be a selector\\n   *         string in which case the first matching element will be used\\n   *         as context. If missing (or no element matches selector), falls\\n   *         back to `document`.\\n   *\\n   * @return {Element|null}\\n   */\\n\\n  Component.prototype.$ = function $(selector, context) {\\n    return Dom.$(selector, context || this.contentEl());\\n  };\\n\\n  /**\\n   * Finds a all DOM elements matching `selector` within the component's\\n   * `contentEl` or another custom context.\\n   *\\n   * @method $$\\n   * @param  {String} selector\\n   *         A valid CSS selector, which will be passed to `querySelectorAll`.\\n   *\\n   * @param  {Element|String} [context=document]\\n   *         A DOM element within which to query. Can also be a selector\\n   *         string in which case the first matching element will be used\\n   *         as context. If missing (or no element matches selector), falls\\n   *         back to `document`.\\n   *\\n   * @return {NodeList}\\n   */\\n\\n  Component.prototype.$$ = function $$(selector, context) {\\n    return Dom.$$(selector, context || this.contentEl());\\n  };\\n\\n  /**\\n   * Check if a component's element has a CSS class name\\n   *\\n   * @param {String} classToCheck Classname to check\\n   * @return {Component}\\n   * @method hasClass\\n   */\\n\\n  Component.prototype.hasClass = function hasClass(classToCheck) {\\n    return Dom.hasElClass(this.el_, classToCheck);\\n  };\\n\\n  /**\\n   * Add a CSS class name to the component's element\\n   *\\n   * @param {String} classToAdd Classname to add\\n   * @return {Component}\\n   * @method addClass\\n   */\\n\\n  Component.prototype.addClass = function addClass(classToAdd) {\\n    Dom.addElClass(this.el_, classToAdd);\\n    return this;\\n  };\\n\\n  /**\\n   * Remove a CSS class name from the component's element\\n   *\\n   * @param {String} classToRemove Classname to remove\\n   * @return {Component}\\n   * @method removeClass\\n   */\\n\\n  Component.prototype.removeClass = function removeClass(classToRemove) {\\n    Dom.removeElClass(this.el_, classToRemove);\\n    return this;\\n  };\\n\\n  /**\\n   * Add or remove a CSS class name from the component's element\\n   *\\n   * @param  {String} classToToggle\\n   * @param  {Boolean|Function} [predicate]\\n   *         Can be a function that returns a Boolean. If `true`, the class\\n   *         will be added; if `false`, the class will be removed. If not\\n   *         given, the class will be added if not present and vice versa.\\n   *\\n   * @return {Component}\\n   * @method toggleClass\\n   */\\n\\n  Component.prototype.toggleClass = function toggleClass(classToToggle, predicate) {\\n    Dom.toggleElClass(this.el_, classToToggle, predicate);\\n    return this;\\n  };\\n\\n  /**\\n   * Show the component element if hidden\\n   *\\n   * @return {Component}\\n   * @method show\\n   */\\n\\n  Component.prototype.show = function show() {\\n    this.removeClass('vjs-hidden');\\n    return this;\\n  };\\n\\n  /**\\n   * Hide the component element if currently showing\\n   *\\n   * @return {Component}\\n   * @method hide\\n   */\\n\\n  Component.prototype.hide = function hide() {\\n    this.addClass('vjs-hidden');\\n    return this;\\n  };\\n\\n  /**\\n   * Lock an item in its visible state\\n   * To be used with fadeIn/fadeOut.\\n   *\\n   * @return {Component}\\n   * @private\\n   * @method lockShowing\\n   */\\n\\n  Component.prototype.lockShowing = function lockShowing() {\\n    this.addClass('vjs-lock-showing');\\n    return this;\\n  };\\n\\n  /**\\n   * Unlock an item to be hidden\\n   * To be used with fadeIn/fadeOut.\\n   *\\n   * @return {Component}\\n   * @private\\n   * @method unlockShowing\\n   */\\n\\n  Component.prototype.unlockShowing = function unlockShowing() {\\n    this.removeClass('vjs-lock-showing');\\n    return this;\\n  };\\n\\n  /**\\n   * Set or get the width of the component (CSS values)\\n   * Setting the video tag dimension values only works with values in pixels.\\n   * Percent values will not work.\\n   * Some percents can be used, but width()/height() will return the number + %,\\n   * not the actual computed width/height.\\n   *\\n   * @param  {Number|String=} num   Optional width number\\n   * @param  {Boolean} skipListeners Skip the 'resize' event trigger\\n   * @return {Component} This component, when setting the width\\n   * @return {Number|String} The width, when getting\\n   * @method width\\n   */\\n\\n  Component.prototype.width = function width(num, skipListeners) {\\n    return this.dimension('width', num, skipListeners);\\n  };\\n\\n  /**\\n   * Get or set the height of the component (CSS values)\\n   * Setting the video tag dimension values only works with values in pixels.\\n   * Percent values will not work.\\n   * Some percents can be used, but width()/height() will return the number + %,\\n   * not the actual computed width/height.\\n   *\\n   * @param  {Number|String=} num     New component height\\n   * @param  {Boolean=} skipListeners Skip the resize event trigger\\n   * @return {Component} This component, when setting the height\\n   * @return {Number|String} The height, when getting\\n   * @method height\\n   */\\n\\n  Component.prototype.height = function height(num, skipListeners) {\\n    return this.dimension('height', num, skipListeners);\\n  };\\n\\n  /**\\n   * Set both width and height at the same time\\n   *\\n   * @param  {Number|String} width Width of player\\n   * @param  {Number|String} height Height of player\\n   * @return {Component} The component\\n   * @method dimensions\\n   */\\n\\n  Component.prototype.dimensions = function dimensions(width, height) {\\n    // Skip resize listeners on width for optimization\\n    return this.width(width, true).height(height);\\n  };\\n\\n  /**\\n   * Get or set width or height\\n   * This is the shared code for the width() and height() methods.\\n   * All for an integer, integer + 'px' or integer + '%';\\n   * Known issue: Hidden elements officially have a width of 0. We're defaulting\\n   * to the style.width value and falling back to computedStyle which has the\\n   * hidden element issue. Info, but probably not an efficient fix:\\n   * http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/\\n   *\\n   * @param  {String} widthOrHeight  'width' or 'height'\\n   * @param  {Number|String=} num     New dimension\\n   * @param  {Boolean=} skipListeners Skip resize event trigger\\n   * @return {Component} The component if a dimension was set\\n   * @return {Number|String} The dimension if nothing was set\\n   * @private\\n   * @method dimension\\n   */\\n\\n  Component.prototype.dimension = function dimension(widthOrHeight, num, skipListeners) {\\n    if (num !== undefined) {\\n      // Set to zero if null or literally NaN (NaN !== NaN)\\n      if (num === null || num !== num) {\\n        num = 0;\\n      }\\n\\n      // Check if using css width/height (% or px) and adjust\\n      if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {\\n        this.el_.style[widthOrHeight] = num;\\n      } else if (num === 'auto') {\\n        this.el_.style[widthOrHeight] = '';\\n      } else {\\n        this.el_.style[widthOrHeight] = num + 'px';\\n      }\\n\\n      // skipListeners allows us to avoid triggering the resize event when setting both width and height\\n      if (!skipListeners) {\\n        this.trigger('resize');\\n      }\\n\\n      // Return component\\n      return this;\\n    }\\n\\n    // Not setting a value, so getting it\\n    // Make sure element exists\\n    if (!this.el_) {\\n      return 0;\\n    }\\n\\n    // Get dimension value from style\\n    var val = this.el_.style[widthOrHeight];\\n    var pxIndex = val.indexOf('px');\\n\\n    if (pxIndex !== -1) {\\n      // Return the pixel value with no 'px'\\n      return parseInt(val.slice(0, pxIndex), 10);\\n    }\\n\\n    // No px so using % or no style was set, so falling back to offsetWidth/height\\n    // If component has display:none, offset will return 0\\n    // TODO: handle display:none and no dimension style using px\\n    return parseInt(this.el_['offset' + _utilsToTitleCaseJs2['default'](widthOrHeight)], 10);\\n  };\\n\\n  /**\\n   * Get width or height of computed style\\n   * @param  {String} widthOrHeight  'width' or 'height'\\n   * @return {Number|Boolean} The bolean false if nothing was set\\n   * @method currentDimension\\n   */\\n\\n  Component.prototype.currentDimension = function currentDimension(widthOrHeight) {\\n    var computedWidthOrHeight = 0;\\n\\n    if (widthOrHeight !== 'width' && widthOrHeight !== 'height') {\\n      throw new Error('currentDimension only accepts width or height value');\\n    }\\n\\n    if (typeof _globalWindow2['default'].getComputedStyle === 'function') {\\n      var computedStyle = _globalWindow2['default'].getComputedStyle(this.el_);\\n      computedWidthOrHeight = computedStyle.getPropertyValue(widthOrHeight) || computedStyle[widthOrHeight];\\n    } else if (this.el_.currentStyle) {\\n      // ie 8 doesn't support computed style, shim it\\n      // return clientWidth or clientHeight instead for better accuracy\\n      var rule = 'offset' + _utilsToTitleCaseJs2['default'](widthOrHeight);\\n      computedWidthOrHeight = this.el_[rule];\\n    }\\n\\n    // remove 'px' from variable and parse as integer\\n    computedWidthOrHeight = parseFloat(computedWidthOrHeight);\\n    return computedWidthOrHeight;\\n  };\\n\\n  /**\\n   * Get an object which contains width and height values of computed style\\n   * @return {Object} The dimensions of element\\n   * @method currentDimensions\\n   */\\n\\n  Component.prototype.currentDimensions = function currentDimensions() {\\n    return {\\n      width: this.currentDimension('width'),\\n      height: this.currentDimension('height')\\n    };\\n  };\\n\\n  /**\\n   * Get width of computed style\\n   * @return {Integer}\\n   * @method currentWidth\\n   */\\n\\n  Component.prototype.currentWidth = function currentWidth() {\\n    return this.currentDimension('width');\\n  };\\n\\n  /**\\n   * Get height of computed style\\n   * @return {Integer}\\n   * @method currentHeight\\n   */\\n\\n  Component.prototype.currentHeight = function currentHeight() {\\n    return this.currentDimension('height');\\n  };\\n\\n  /**\\n   * Emit 'tap' events when touch events are supported\\n   * This is used to support toggling the controls through a tap on the video.\\n   * We're requiring them to be enabled because otherwise every component would\\n   * have this extra overhead unnecessarily, on mobile devices where extra\\n   * overhead is especially bad.\\n   *\\n   * @private\\n   * @method emitTapEvents\\n   */\\n\\n  Component.prototype.emitTapEvents = function emitTapEvents() {\\n    // Track the start time so we can determine how long the touch lasted\\n    var touchStart = 0;\\n    var firstTouch = null;\\n\\n    // Maximum movement allowed during a touch event to still be considered a tap\\n    // Other popular libs use anywhere from 2 (hammer.js) to 15, so 10 seems like a nice, round number.\\n    var tapMovementThreshold = 10;\\n\\n    // The maximum length a touch can be while still being considered a tap\\n    var touchTimeThreshold = 200;\\n\\n    var couldBeTap = undefined;\\n\\n    this.on('touchstart', function (event) {\\n      // If more than one finger, don't consider treating this as a click\\n      if (event.touches.length === 1) {\\n        // Copy pageX/pageY from the object\\n        firstTouch = {\\n          pageX: event.touches[0].pageX,\\n          pageY: event.touches[0].pageY\\n        };\\n        // Record start time so we can detect a tap vs. \\\"touch and hold\\\"\\n        touchStart = new Date().getTime();\\n        // Reset couldBeTap tracking\\n        couldBeTap = true;\\n      }\\n    });\\n\\n    this.on('touchmove', function (event) {\\n      // If more than one finger, don't consider treating this as a click\\n      if (event.touches.length > 1) {\\n        couldBeTap = false;\\n      } else if (firstTouch) {\\n        // Some devices will throw touchmoves for all but the slightest of taps.\\n        // So, if we moved only a small distance, this could still be a tap\\n        var xdiff = event.touches[0].pageX - firstTouch.pageX;\\n        var ydiff = event.touches[0].pageY - firstTouch.pageY;\\n        var touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);\\n\\n        if (touchDistance > tapMovementThreshold) {\\n          couldBeTap = false;\\n        }\\n      }\\n    });\\n\\n    var noTap = function noTap() {\\n      couldBeTap = false;\\n    };\\n\\n    // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s\\n    this.on('touchleave', noTap);\\n    this.on('touchcancel', noTap);\\n\\n    // When the touch ends, measure how long it took and trigger the appropriate\\n    // event\\n    this.on('touchend', function (event) {\\n      firstTouch = null;\\n      // Proceed only if the touchmove/leave/cancel event didn't happen\\n      if (couldBeTap === true) {\\n        // Measure how long the touch lasted\\n        var touchTime = new Date().getTime() - touchStart;\\n\\n        // Make sure the touch was less than the threshold to be considered a tap\\n        if (touchTime < touchTimeThreshold) {\\n          // Don't let browser turn this into a click\\n          event.preventDefault();\\n          this.trigger('tap');\\n          // It may be good to copy the touchend event object and change the\\n          // type to tap, if the other event properties aren't exact after\\n          // Events.fixEvent runs (e.g. event.target)\\n        }\\n      }\\n    });\\n  };\\n\\n  /**\\n   * Report user touch activity when touch events occur\\n   * User activity is used to determine when controls should show/hide. It's\\n   * relatively simple when it comes to mouse events, because any mouse event\\n   * should show the controls. So we capture mouse events that bubble up to the\\n   * player and report activity when that happens.\\n   * With touch events it isn't as easy. We can't rely on touch events at the\\n   * player level, because a tap (touchstart + touchend) on the video itself on\\n   * mobile devices is meant to turn controls off (and on). User activity is\\n   * checked asynchronously, so what could happen is a tap event on the video\\n   * turns the controls off, then the touchend event bubbles up to the player,\\n   * which if it reported user activity, would turn the controls right back on.\\n   * (We also don't want to completely block touch events from bubbling up)\\n   * Also a touchmove, touch+hold, and anything other than a tap is not supposed\\n   * to turn the controls back on on a mobile device.\\n   * Here we're setting the default component behavior to report user activity\\n   * whenever touch events happen, and this can be turned off by components that\\n   * want touch events to act differently.\\n   *\\n   * @method enableTouchActivity\\n   */\\n\\n  Component.prototype.enableTouchActivity = function enableTouchActivity() {\\n    // Don't continue if the root player doesn't support reporting user activity\\n    if (!this.player() || !this.player().reportUserActivity) {\\n      return;\\n    }\\n\\n    // listener for reporting that the user is active\\n    var report = Fn.bind(this.player(), this.player().reportUserActivity);\\n\\n    var touchHolding = undefined;\\n\\n    this.on('touchstart', function () {\\n      report();\\n      // For as long as the they are touching the device or have their mouse down,\\n      // we consider them active even if they're not moving their finger or mouse.\\n      // So we want to continue to update that they are active\\n      this.clearInterval(touchHolding);\\n      // report at the same interval as activityCheck\\n      touchHolding = this.setInterval(report, 250);\\n    });\\n\\n    var touchEnd = function touchEnd(event) {\\n      report();\\n      // stop the interval that maintains activity if the touch is holding\\n      this.clearInterval(touchHolding);\\n    };\\n\\n    this.on('touchmove', report);\\n    this.on('touchend', touchEnd);\\n    this.on('touchcancel', touchEnd);\\n  };\\n\\n  /**\\n   * Creates timeout and sets up disposal automatically.\\n   *\\n   * @param {Function} fn The function to run after the timeout.\\n   * @param {Number} timeout Number of ms to delay before executing specified function.\\n   * @return {Number} Returns the timeout ID\\n   * @method setTimeout\\n   */\\n\\n  Component.prototype.setTimeout = function setTimeout(fn, timeout) {\\n    fn = Fn.bind(this, fn);\\n\\n    // window.setTimeout would be preferable here, but due to some bizarre issue with Sinon and/or Phantomjs, we can't.\\n    var timeoutId = _globalWindow2['default'].setTimeout(fn, timeout);\\n\\n    var disposeFn = function disposeFn() {\\n      this.clearTimeout(timeoutId);\\n    };\\n\\n    disposeFn.guid = 'vjs-timeout-' + timeoutId;\\n\\n    this.on('dispose', disposeFn);\\n\\n    return timeoutId;\\n  };\\n\\n  /**\\n   * Clears a timeout and removes the associated dispose listener\\n   *\\n   * @param {Number} timeoutId The id of the timeout to clear\\n   * @return {Number} Returns the timeout ID\\n   * @method clearTimeout\\n   */\\n\\n  Component.prototype.clearTimeout = function clearTimeout(timeoutId) {\\n    _globalWindow2['default'].clearTimeout(timeoutId);\\n\\n    var disposeFn = function disposeFn() {};\\n\\n    disposeFn.guid = 'vjs-timeout-' + timeoutId;\\n\\n    this.off('dispose', disposeFn);\\n\\n    return timeoutId;\\n  };\\n\\n  /**\\n   * Creates an interval and sets up disposal automatically.\\n   *\\n   * @param {Function} fn The function to run every N seconds.\\n   * @param {Number} interval Number of ms to delay before executing specified function.\\n   * @return {Number} Returns the interval ID\\n   * @method setInterval\\n   */\\n\\n  Component.prototype.setInterval = function setInterval(fn, interval) {\\n    fn = Fn.bind(this, fn);\\n\\n    var intervalId = _globalWindow2['default'].setInterval(fn, interval);\\n\\n    var disposeFn = function disposeFn() {\\n      this.clearInterval(intervalId);\\n    };\\n\\n    disposeFn.guid = 'vjs-interval-' + intervalId;\\n\\n    this.on('dispose', disposeFn);\\n\\n    return intervalId;\\n  };\\n\\n  /**\\n   * Clears an interval and removes the associated dispose listener\\n   *\\n   * @param {Number} intervalId The id of the interval to clear\\n   * @return {Number} Returns the interval ID\\n   * @method clearInterval\\n   */\\n\\n  Component.prototype.clearInterval = function clearInterval(intervalId) {\\n    _globalWindow2['default'].clearInterval(intervalId);\\n\\n    var disposeFn = function disposeFn() {};\\n\\n    disposeFn.guid = 'vjs-interval-' + intervalId;\\n\\n    this.off('dispose', disposeFn);\\n\\n    return intervalId;\\n  };\\n\\n  /**\\n   * Registers a component\\n   *\\n   * @param {String} name Name of the component to register\\n   * @param {Object} comp The component to register\\n   * @static\\n   * @method registerComponent\\n   */\\n\\n  Component.registerComponent = function registerComponent(name, comp) {\\n    if (!Component.components_) {\\n      Component.components_ = {};\\n    }\\n\\n    Component.components_[name] = comp;\\n    return comp;\\n  };\\n\\n  /**\\n   * Gets a component by name\\n   *\\n   * @param {String} name Name of the component to get\\n   * @return {Component}\\n   * @static\\n   * @method getComponent\\n   */\\n\\n  Component.getComponent = function getComponent(name) {\\n    if (Component.components_ && Component.components_[name]) {\\n      return Component.components_[name];\\n    }\\n\\n    if (_globalWindow2['default'] && _globalWindow2['default'].videojs && _globalWindow2['default'].videojs[name]) {\\n      _utilsLogJs2['default'].warn('The ' + name + ' component was added to the videojs object when it should be registered using videojs.registerComponent(name, component)');\\n      return _globalWindow2['default'].videojs[name];\\n    }\\n  };\\n\\n  /**\\n   * Sets up the constructor using the supplied init method\\n   * or uses the init of the parent object\\n   *\\n   * @param {Object} props An object of properties\\n   * @static\\n   * @deprecated\\n   * @method extend\\n   */\\n\\n  Component.extend = function extend(props) {\\n    props = props || {};\\n\\n    _utilsLogJs2['default'].warn('Component.extend({}) has been deprecated, use videojs.extend(Component, {}) instead');\\n\\n    // Set up the constructor using the supplied init method\\n    // or using the init of the parent object\\n    // Make sure to check the unobfuscated version for external libs\\n    var init = props.init || props.init || this.prototype.init || this.prototype.init || function () {};\\n    // In Resig's simple class inheritance (previously used) the constructor\\n    //  is a function that calls `this.init.apply(arguments)`\\n    // However that would prevent us from using `ParentObject.call(this);`\\n    //  in a Child constructor because the `this` in `this.init`\\n    //  would still refer to the Child and cause an infinite loop.\\n    // We would instead have to do\\n    //    `ParentObject.prototype.init.apply(this, arguments);`\\n    //  Bleh. We're not creating a _super() function, so it's good to keep\\n    //  the parent constructor reference simple.\\n    var subObj = function subObj() {\\n      init.apply(this, arguments);\\n    };\\n\\n    // Inherit from this object's prototype\\n    subObj.prototype = Object.create(this.prototype);\\n    // Reset the constructor property for subObj otherwise\\n    // instances of subObj would have the constructor of the parent Object\\n    subObj.prototype.constructor = subObj;\\n\\n    // Make the class extendable\\n    subObj.extend = Component.extend;\\n\\n    // Extend subObj's prototype with functions and other properties from props\\n    for (var _name in props) {\\n      if (props.hasOwnProperty(_name)) {\\n        subObj.prototype[_name] = props[_name];\\n      }\\n    }\\n\\n    return subObj;\\n  };\\n\\n  return Component;\\n})();\\n\\nComponent.registerComponent('Component', Component);\\nexports['default'] = Component;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./utils/dom.js\\\":142,\\\"./utils/events.js\\\":143,\\\"./utils/fn.js\\\":144,\\\"./utils/guid.js\\\":146,\\\"./utils/log.js\\\":147,\\\"./utils/merge-options.js\\\":148,\\\"./utils/to-title-case.js\\\":151,\\\"global/window\\\":2}],68:[function(_dereq_,module,exports){\\n/**\\n * @file audio-track-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _trackButtonJs = _dereq_('../track-button.js');\\n\\nvar _trackButtonJs2 = _interopRequireDefault(_trackButtonJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _audioTrackMenuItemJs = _dereq_('./audio-track-menu-item.js');\\n\\nvar _audioTrackMenuItemJs2 = _interopRequireDefault(_audioTrackMenuItemJs);\\n\\n/**\\n * The base class for buttons that toggle specific text track types (e.g. subtitles)\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends TrackButton\\n * @class AudioTrackButton\\n */\\n\\nvar AudioTrackButton = (function (_TrackButton) {\\n  _inherits(AudioTrackButton, _TrackButton);\\n\\n  function AudioTrackButton(player) {\\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n\\n    _classCallCheck(this, AudioTrackButton);\\n\\n    options.tracks = player.audioTracks && player.audioTracks();\\n\\n    _TrackButton.call(this, player, options);\\n\\n    this.el_.setAttribute('aria-label', 'Audio Menu');\\n  }\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  AudioTrackButton.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-audio-button ' + _TrackButton.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Create a menu item for each audio track\\n   *\\n   * @return {Array} Array of menu items\\n   * @method createItems\\n   */\\n\\n  AudioTrackButton.prototype.createItems = function createItems() {\\n    var items = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\\n\\n    var tracks = this.player_.audioTracks && this.player_.audioTracks();\\n\\n    if (!tracks) {\\n      return items;\\n    }\\n\\n    for (var i = 0; i < tracks.length; i++) {\\n      var track = tracks[i];\\n\\n      items.push(new _audioTrackMenuItemJs2['default'](this.player_, {\\n        // MenuItem is selectable\\n        'selectable': true,\\n        'track': track\\n      }));\\n    }\\n\\n    return items;\\n  };\\n\\n  return AudioTrackButton;\\n})(_trackButtonJs2['default']);\\n\\nAudioTrackButton.prototype.controlText_ = 'Audio Track';\\n_componentJs2['default'].registerComponent('AudioTrackButton', AudioTrackButton);\\nexports['default'] = AudioTrackButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../utils/fn.js\\\":144,\\\"../track-button.js\\\":98,\\\"./audio-track-menu-item.js\\\":69}],69:[function(_dereq_,module,exports){\\n/**\\n * @file audio-track-menu-item.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _menuMenuItemJs = _dereq_('../../menu/menu-item.js');\\n\\nvar _menuMenuItemJs2 = _interopRequireDefault(_menuMenuItemJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\n/**\\n * The audio track menu item\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends MenuItem\\n * @class AudioTrackMenuItem\\n */\\n\\nvar AudioTrackMenuItem = (function (_MenuItem) {\\n  _inherits(AudioTrackMenuItem, _MenuItem);\\n\\n  function AudioTrackMenuItem(player, options) {\\n    var _this = this;\\n\\n    _classCallCheck(this, AudioTrackMenuItem);\\n\\n    var track = options.track;\\n    var tracks = player.audioTracks();\\n\\n    // Modify options for parent MenuItem class's init.\\n    options.label = track.label || track.language || 'Unknown';\\n    options.selected = track.enabled;\\n\\n    _MenuItem.call(this, player, options);\\n\\n    this.track = track;\\n\\n    if (tracks) {\\n      (function () {\\n        var changeHandler = Fn.bind(_this, _this.handleTracksChange);\\n\\n        tracks.addEventListener('change', changeHandler);\\n        _this.on('dispose', function () {\\n          tracks.removeEventListener('change', changeHandler);\\n        });\\n      })();\\n    }\\n  }\\n\\n  /**\\n   * Handle click on audio track\\n   *\\n   * @method handleClick\\n   */\\n\\n  AudioTrackMenuItem.prototype.handleClick = function handleClick(event) {\\n    var tracks = this.player_.audioTracks();\\n\\n    _MenuItem.prototype.handleClick.call(this, event);\\n\\n    if (!tracks) return;\\n\\n    for (var i = 0; i < tracks.length; i++) {\\n      var track = tracks[i];\\n\\n      track.enabled = track === this.track;\\n    }\\n  };\\n\\n  /**\\n   * Handle audio track change\\n   *\\n   * @method handleTracksChange\\n   */\\n\\n  AudioTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {\\n    this.selected(this.track.enabled);\\n  };\\n\\n  return AudioTrackMenuItem;\\n})(_menuMenuItemJs2['default']);\\n\\n_componentJs2['default'].registerComponent('AudioTrackMenuItem', AudioTrackMenuItem);\\nexports['default'] = AudioTrackMenuItem;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../menu/menu-item.js\\\":110,\\\"../../utils/fn.js\\\":144}],70:[function(_dereq_,module,exports){\\n/**\\n * @file control-bar.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n// Required children\\n\\nvar _playToggleJs = _dereq_('./play-toggle.js');\\n\\nvar _playToggleJs2 = _interopRequireDefault(_playToggleJs);\\n\\nvar _timeControlsCurrentTimeDisplayJs = _dereq_('./time-controls/current-time-display.js');\\n\\nvar _timeControlsCurrentTimeDisplayJs2 = _interopRequireDefault(_timeControlsCurrentTimeDisplayJs);\\n\\nvar _timeControlsDurationDisplayJs = _dereq_('./time-controls/duration-display.js');\\n\\nvar _timeControlsDurationDisplayJs2 = _interopRequireDefault(_timeControlsDurationDisplayJs);\\n\\nvar _timeControlsTimeDividerJs = _dereq_('./time-controls/time-divider.js');\\n\\nvar _timeControlsTimeDividerJs2 = _interopRequireDefault(_timeControlsTimeDividerJs);\\n\\nvar _timeControlsRemainingTimeDisplayJs = _dereq_('./time-controls/remaining-time-display.js');\\n\\nvar _timeControlsRemainingTimeDisplayJs2 = _interopRequireDefault(_timeControlsRemainingTimeDisplayJs);\\n\\nvar _liveDisplayJs = _dereq_('./live-display.js');\\n\\nvar _liveDisplayJs2 = _interopRequireDefault(_liveDisplayJs);\\n\\nvar _progressControlProgressControlJs = _dereq_('./progress-control/progress-control.js');\\n\\nvar _progressControlProgressControlJs2 = _interopRequireDefault(_progressControlProgressControlJs);\\n\\nvar _fullscreenToggleJs = _dereq_('./fullscreen-toggle.js');\\n\\nvar _fullscreenToggleJs2 = _interopRequireDefault(_fullscreenToggleJs);\\n\\nvar _volumeControlVolumeControlJs = _dereq_('./volume-control/volume-control.js');\\n\\nvar _volumeControlVolumeControlJs2 = _interopRequireDefault(_volumeControlVolumeControlJs);\\n\\nvar _volumeMenuButtonJs = _dereq_('./volume-menu-button.js');\\n\\nvar _volumeMenuButtonJs2 = _interopRequireDefault(_volumeMenuButtonJs);\\n\\nvar _muteToggleJs = _dereq_('./mute-toggle.js');\\n\\nvar _muteToggleJs2 = _interopRequireDefault(_muteToggleJs);\\n\\nvar _textTrackControlsChaptersButtonJs = _dereq_('./text-track-controls/chapters-button.js');\\n\\nvar _textTrackControlsChaptersButtonJs2 = _interopRequireDefault(_textTrackControlsChaptersButtonJs);\\n\\nvar _textTrackControlsDescriptionsButtonJs = _dereq_('./text-track-controls/descriptions-button.js');\\n\\nvar _textTrackControlsDescriptionsButtonJs2 = _interopRequireDefault(_textTrackControlsDescriptionsButtonJs);\\n\\nvar _textTrackControlsSubtitlesButtonJs = _dereq_('./text-track-controls/subtitles-button.js');\\n\\nvar _textTrackControlsSubtitlesButtonJs2 = _interopRequireDefault(_textTrackControlsSubtitlesButtonJs);\\n\\nvar _textTrackControlsCaptionsButtonJs = _dereq_('./text-track-controls/captions-button.js');\\n\\nvar _textTrackControlsCaptionsButtonJs2 = _interopRequireDefault(_textTrackControlsCaptionsButtonJs);\\n\\nvar _audioTrackControlsAudioTrackButtonJs = _dereq_('./audio-track-controls/audio-track-button.js');\\n\\nvar _audioTrackControlsAudioTrackButtonJs2 = _interopRequireDefault(_audioTrackControlsAudioTrackButtonJs);\\n\\nvar _playbackRateMenuPlaybackRateMenuButtonJs = _dereq_('./playback-rate-menu/playback-rate-menu-button.js');\\n\\nvar _playbackRateMenuPlaybackRateMenuButtonJs2 = _interopRequireDefault(_playbackRateMenuPlaybackRateMenuButtonJs);\\n\\nvar _spacerControlsCustomControlSpacerJs = _dereq_('./spacer-controls/custom-control-spacer.js');\\n\\nvar _spacerControlsCustomControlSpacerJs2 = _interopRequireDefault(_spacerControlsCustomControlSpacerJs);\\n\\n/**\\n * Container of main controls\\n *\\n * @extends Component\\n * @class ControlBar\\n */\\n\\nvar ControlBar = (function (_Component) {\\n  _inherits(ControlBar, _Component);\\n\\n  function ControlBar() {\\n    _classCallCheck(this, ControlBar);\\n\\n    _Component.apply(this, arguments);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  ControlBar.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-control-bar',\\n      dir: 'ltr'\\n    }, {\\n      'role': 'group' // The control bar is a group, so it can contain menuitems\\n    });\\n  };\\n\\n  return ControlBar;\\n})(_componentJs2['default']);\\n\\nControlBar.prototype.options_ = {\\n  children: ['playToggle', 'volumeMenuButton', 'currentTimeDisplay', 'timeDivider', 'durationDisplay', 'progressControl', 'liveDisplay', 'remainingTimeDisplay', 'customControlSpacer', 'playbackRateMenuButton', 'chaptersButton', 'descriptionsButton', 'subtitlesButton', 'captionsButton', 'audioTrackButton', 'fullscreenToggle']\\n};\\n\\n_componentJs2['default'].registerComponent('ControlBar', ControlBar);\\nexports['default'] = ControlBar;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component.js\\\":67,\\\"./audio-track-controls/audio-track-button.js\\\":68,\\\"./fullscreen-toggle.js\\\":71,\\\"./live-display.js\\\":72,\\\"./mute-toggle.js\\\":73,\\\"./play-toggle.js\\\":74,\\\"./playback-rate-menu/playback-rate-menu-button.js\\\":75,\\\"./progress-control/progress-control.js\\\":80,\\\"./spacer-controls/custom-control-spacer.js\\\":83,\\\"./text-track-controls/captions-button.js\\\":86,\\\"./text-track-controls/chapters-button.js\\\":87,\\\"./text-track-controls/descriptions-button.js\\\":89,\\\"./text-track-controls/subtitles-button.js\\\":91,\\\"./time-controls/current-time-display.js\\\":94,\\\"./time-controls/duration-display.js\\\":95,\\\"./time-controls/remaining-time-display.js\\\":96,\\\"./time-controls/time-divider.js\\\":97,\\\"./volume-control/volume-control.js\\\":100,\\\"./volume-menu-button.js\\\":102}],71:[function(_dereq_,module,exports){\\n/**\\n * @file fullscreen-toggle.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _buttonJs = _dereq_('../button.js');\\n\\nvar _buttonJs2 = _interopRequireDefault(_buttonJs);\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n/**\\n * Toggle fullscreen video\\n *\\n * @extends Button\\n * @class FullscreenToggle\\n */\\n\\nvar FullscreenToggle = (function (_Button) {\\n  _inherits(FullscreenToggle, _Button);\\n\\n  function FullscreenToggle(player, options) {\\n    _classCallCheck(this, FullscreenToggle);\\n\\n    _Button.call(this, player, options);\\n    this.on(player, 'fullscreenchange', this.handleFullscreenChange);\\n  }\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  FullscreenToggle.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-fullscreen-control ' + _Button.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Handles Fullscreenchange on the component and change control text accordingly\\n   *\\n   * @method handleFullscreenChange\\n   */\\n\\n  FullscreenToggle.prototype.handleFullscreenChange = function handleFullscreenChange() {\\n    if (this.player_.isFullscreen()) {\\n      this.controlText('Non-Fullscreen');\\n    } else {\\n      this.controlText('Fullscreen');\\n    }\\n  };\\n\\n  /**\\n   * Handles click for full screen\\n   *\\n   * @method handleClick\\n   */\\n\\n  FullscreenToggle.prototype.handleClick = function handleClick() {\\n    if (!this.player_.isFullscreen()) {\\n      this.player_.requestFullscreen();\\n    } else {\\n      this.player_.exitFullscreen();\\n    }\\n  };\\n\\n  return FullscreenToggle;\\n})(_buttonJs2['default']);\\n\\nFullscreenToggle.prototype.controlText_ = 'Fullscreen';\\n\\n_componentJs2['default'].registerComponent('FullscreenToggle', FullscreenToggle);\\nexports['default'] = FullscreenToggle;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../button.js\\\":64,\\\"../component.js\\\":67}],72:[function(_dereq_,module,exports){\\n/**\\n * @file live-display.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _component = _dereq_('../component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _utilsDomJs = _dereq_('../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\n/**\\n * Displays the live indicator\\n * TODO - Future make it click to snap to live\\n *\\n * @extends Component\\n * @class LiveDisplay\\n */\\n\\nvar LiveDisplay = (function (_Component) {\\n  _inherits(LiveDisplay, _Component);\\n\\n  function LiveDisplay(player, options) {\\n    _classCallCheck(this, LiveDisplay);\\n\\n    _Component.call(this, player, options);\\n\\n    this.updateShowing();\\n    this.on(this.player(), 'durationchange', this.updateShowing);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  LiveDisplay.prototype.createEl = function createEl() {\\n    var el = _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-live-control vjs-control'\\n    });\\n\\n    this.contentEl_ = Dom.createEl('div', {\\n      className: 'vjs-live-display',\\n      innerHTML: '<span class=\\\"vjs-control-text\\\">' + this.localize('Stream Type') + '</span>' + this.localize('LIVE')\\n    }, {\\n      'aria-live': 'off'\\n    });\\n\\n    el.appendChild(this.contentEl_);\\n    return el;\\n  };\\n\\n  LiveDisplay.prototype.updateShowing = function updateShowing() {\\n    if (this.player().duration() === Infinity) {\\n      this.show();\\n    } else {\\n      this.hide();\\n    }\\n  };\\n\\n  return LiveDisplay;\\n})(_component2['default']);\\n\\n_component2['default'].registerComponent('LiveDisplay', LiveDisplay);\\nexports['default'] = LiveDisplay;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component\\\":67,\\\"../utils/dom.js\\\":142}],73:[function(_dereq_,module,exports){\\n/**\\n * @file mute-toggle.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _button = _dereq_('../button');\\n\\nvar _button2 = _interopRequireDefault(_button);\\n\\nvar _component = _dereq_('../component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _utilsDomJs = _dereq_('../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\n/**\\n * A button component for muting the audio\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Button\\n * @class MuteToggle\\n */\\n\\nvar MuteToggle = (function (_Button) {\\n  _inherits(MuteToggle, _Button);\\n\\n  function MuteToggle(player, options) {\\n    _classCallCheck(this, MuteToggle);\\n\\n    _Button.call(this, player, options);\\n\\n    this.on(player, 'volumechange', this.update);\\n\\n    // hide mute toggle if the current tech doesn't support volume control\\n    if (player.tech_ && player.tech_['featuresVolumeControl'] === false) {\\n      this.addClass('vjs-hidden');\\n    }\\n\\n    this.on(player, 'loadstart', function () {\\n      this.update(); // We need to update the button to account for a default muted state.\\n\\n      if (player.tech_['featuresVolumeControl'] === false) {\\n        this.addClass('vjs-hidden');\\n      } else {\\n        this.removeClass('vjs-hidden');\\n      }\\n    });\\n  }\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  MuteToggle.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-mute-control ' + _Button.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Handle click on mute\\n   *\\n   * @method handleClick\\n   */\\n\\n  MuteToggle.prototype.handleClick = function handleClick() {\\n    this.player_.muted(this.player_.muted() ? false : true);\\n  };\\n\\n  /**\\n   * Update volume\\n   *\\n   * @method update\\n   */\\n\\n  MuteToggle.prototype.update = function update() {\\n    var vol = this.player_.volume(),\\n        level = 3;\\n\\n    if (vol === 0 || this.player_.muted()) {\\n      level = 0;\\n    } else if (vol < 0.33) {\\n      level = 1;\\n    } else if (vol < 0.67) {\\n      level = 2;\\n    }\\n\\n    // Don't rewrite the button text if the actual text doesn't change.\\n    // This causes unnecessary and confusing information for screen reader users.\\n    // This check is needed because this function gets called every time the volume level is changed.\\n    var toMute = this.player_.muted() ? 'Unmute' : 'Mute';\\n    if (this.controlText() !== toMute) {\\n      this.controlText(toMute);\\n    }\\n\\n    /* TODO improve muted icon classes */\\n    for (var i = 0; i < 4; i++) {\\n      Dom.removeElClass(this.el_, 'vjs-vol-' + i);\\n    }\\n    Dom.addElClass(this.el_, 'vjs-vol-' + level);\\n  };\\n\\n  return MuteToggle;\\n})(_button2['default']);\\n\\nMuteToggle.prototype.controlText_ = 'Mute';\\n\\n_component2['default'].registerComponent('MuteToggle', MuteToggle);\\nexports['default'] = MuteToggle;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../button\\\":64,\\\"../component\\\":67,\\\"../utils/dom.js\\\":142}],74:[function(_dereq_,module,exports){\\n/**\\n * @file play-toggle.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _buttonJs = _dereq_('../button.js');\\n\\nvar _buttonJs2 = _interopRequireDefault(_buttonJs);\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n/**\\n * Button to toggle between play and pause\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Button\\n * @class PlayToggle\\n */\\n\\nvar PlayToggle = (function (_Button) {\\n  _inherits(PlayToggle, _Button);\\n\\n  function PlayToggle(player, options) {\\n    _classCallCheck(this, PlayToggle);\\n\\n    _Button.call(this, player, options);\\n\\n    this.on(player, 'play', this.handlePlay);\\n    this.on(player, 'pause', this.handlePause);\\n  }\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  PlayToggle.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-play-control ' + _Button.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Handle click to toggle between play and pause\\n   *\\n   * @method handleClick\\n   */\\n\\n  PlayToggle.prototype.handleClick = function handleClick() {\\n    if (this.player_.paused()) {\\n      this.player_.play();\\n    } else {\\n      this.player_.pause();\\n    }\\n  };\\n\\n  /**\\n   * Add the vjs-playing class to the element so it can change appearance\\n   *\\n   * @method handlePlay\\n   */\\n\\n  PlayToggle.prototype.handlePlay = function handlePlay() {\\n    this.removeClass('vjs-paused');\\n    this.addClass('vjs-playing');\\n    this.controlText('Pause'); // change the button text to \\\"Pause\\\"\\n  };\\n\\n  /**\\n   * Add the vjs-paused class to the element so it can change appearance\\n   *\\n   * @method handlePause\\n   */\\n\\n  PlayToggle.prototype.handlePause = function handlePause() {\\n    this.removeClass('vjs-playing');\\n    this.addClass('vjs-paused');\\n    this.controlText('Play'); // change the button text to \\\"Play\\\"\\n  };\\n\\n  return PlayToggle;\\n})(_buttonJs2['default']);\\n\\nPlayToggle.prototype.controlText_ = 'Play';\\n\\n_componentJs2['default'].registerComponent('PlayToggle', PlayToggle);\\nexports['default'] = PlayToggle;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../button.js\\\":64,\\\"../component.js\\\":67}],75:[function(_dereq_,module,exports){\\n/**\\n * @file playback-rate-menu-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _menuMenuButtonJs = _dereq_('../../menu/menu-button.js');\\n\\nvar _menuMenuButtonJs2 = _interopRequireDefault(_menuMenuButtonJs);\\n\\nvar _menuMenuJs = _dereq_('../../menu/menu.js');\\n\\nvar _menuMenuJs2 = _interopRequireDefault(_menuMenuJs);\\n\\nvar _playbackRateMenuItemJs = _dereq_('./playback-rate-menu-item.js');\\n\\nvar _playbackRateMenuItemJs2 = _interopRequireDefault(_playbackRateMenuItemJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsDomJs = _dereq_('../../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\n/**\\n * The component for controlling the playback rate\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends MenuButton\\n * @class PlaybackRateMenuButton\\n */\\n\\nvar PlaybackRateMenuButton = (function (_MenuButton) {\\n  _inherits(PlaybackRateMenuButton, _MenuButton);\\n\\n  function PlaybackRateMenuButton(player, options) {\\n    _classCallCheck(this, PlaybackRateMenuButton);\\n\\n    _MenuButton.call(this, player, options);\\n\\n    this.updateVisibility();\\n    this.updateLabel();\\n\\n    this.on(player, 'loadstart', this.updateVisibility);\\n    this.on(player, 'ratechange', this.updateLabel);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  PlaybackRateMenuButton.prototype.createEl = function createEl() {\\n    var el = _MenuButton.prototype.createEl.call(this);\\n\\n    this.labelEl_ = Dom.createEl('div', {\\n      className: 'vjs-playback-rate-value',\\n      innerHTML: 1.0\\n    });\\n\\n    el.appendChild(this.labelEl_);\\n\\n    return el;\\n  };\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  PlaybackRateMenuButton.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-playback-rate ' + _MenuButton.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Create the playback rate menu\\n   *\\n   * @return {Menu} Menu object populated with items\\n   * @method createMenu\\n   */\\n\\n  PlaybackRateMenuButton.prototype.createMenu = function createMenu() {\\n    var menu = new _menuMenuJs2['default'](this.player());\\n    var rates = this.playbackRates();\\n\\n    if (rates) {\\n      for (var i = rates.length - 1; i >= 0; i--) {\\n        menu.addChild(new _playbackRateMenuItemJs2['default'](this.player(), { 'rate': rates[i] + 'x' }));\\n      }\\n    }\\n\\n    return menu;\\n  };\\n\\n  /**\\n   * Updates ARIA accessibility attributes\\n   *\\n   * @method updateARIAAttributes\\n   */\\n\\n  PlaybackRateMenuButton.prototype.updateARIAAttributes = function updateARIAAttributes() {\\n    // Current playback rate\\n    this.el().setAttribute('aria-valuenow', this.player().playbackRate());\\n  };\\n\\n  /**\\n   * Handle menu item click\\n   *\\n   * @method handleClick\\n   */\\n\\n  PlaybackRateMenuButton.prototype.handleClick = function handleClick() {\\n    // select next rate option\\n    var currentRate = this.player().playbackRate();\\n    var rates = this.playbackRates();\\n\\n    // this will select first one if the last one currently selected\\n    var newRate = rates[0];\\n    for (var i = 0; i < rates.length; i++) {\\n      if (rates[i] > currentRate) {\\n        newRate = rates[i];\\n        break;\\n      }\\n    }\\n    this.player().playbackRate(newRate);\\n  };\\n\\n  /**\\n   * Get possible playback rates\\n   *\\n   * @return {Array} Possible playback rates\\n   * @method playbackRates\\n   */\\n\\n  PlaybackRateMenuButton.prototype.playbackRates = function playbackRates() {\\n    return this.options_['playbackRates'] || this.options_.playerOptions && this.options_.playerOptions['playbackRates'];\\n  };\\n\\n  /**\\n   * Get whether playback rates is supported by the tech\\n   * and an array of playback rates exists\\n   *\\n   * @return {Boolean} Whether changing playback rate is supported\\n   * @method playbackRateSupported\\n   */\\n\\n  PlaybackRateMenuButton.prototype.playbackRateSupported = function playbackRateSupported() {\\n    return this.player().tech_ && this.player().tech_['featuresPlaybackRate'] && this.playbackRates() && this.playbackRates().length > 0;\\n  };\\n\\n  /**\\n   * Hide playback rate controls when they're no playback rate options to select\\n   *\\n   * @method updateVisibility\\n   */\\n\\n  PlaybackRateMenuButton.prototype.updateVisibility = function updateVisibility() {\\n    if (this.playbackRateSupported()) {\\n      this.removeClass('vjs-hidden');\\n    } else {\\n      this.addClass('vjs-hidden');\\n    }\\n  };\\n\\n  /**\\n   * Update button label when rate changed\\n   *\\n   * @method updateLabel\\n   */\\n\\n  PlaybackRateMenuButton.prototype.updateLabel = function updateLabel() {\\n    if (this.playbackRateSupported()) {\\n      this.labelEl_.innerHTML = this.player().playbackRate() + 'x';\\n    }\\n  };\\n\\n  return PlaybackRateMenuButton;\\n})(_menuMenuButtonJs2['default']);\\n\\nPlaybackRateMenuButton.prototype.controlText_ = 'Playback Rate';\\n\\n_componentJs2['default'].registerComponent('PlaybackRateMenuButton', PlaybackRateMenuButton);\\nexports['default'] = PlaybackRateMenuButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../menu/menu-button.js\\\":109,\\\"../../menu/menu.js\\\":111,\\\"../../utils/dom.js\\\":142,\\\"./playback-rate-menu-item.js\\\":76}],76:[function(_dereq_,module,exports){\\n/**\\n * @file playback-rate-menu-item.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _menuMenuItemJs = _dereq_('../../menu/menu-item.js');\\n\\nvar _menuMenuItemJs2 = _interopRequireDefault(_menuMenuItemJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n/**\\n * The specific menu item type for selecting a playback rate\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends MenuItem\\n * @class PlaybackRateMenuItem\\n */\\n\\nvar PlaybackRateMenuItem = (function (_MenuItem) {\\n  _inherits(PlaybackRateMenuItem, _MenuItem);\\n\\n  function PlaybackRateMenuItem(player, options) {\\n    _classCallCheck(this, PlaybackRateMenuItem);\\n\\n    var label = options['rate'];\\n    var rate = parseFloat(label, 10);\\n\\n    // Modify options for parent MenuItem class's init.\\n    options['label'] = label;\\n    options['selected'] = rate === 1;\\n    _MenuItem.call(this, player, options);\\n\\n    this.label = label;\\n    this.rate = rate;\\n\\n    this.on(player, 'ratechange', this.update);\\n  }\\n\\n  /**\\n   * Handle click on menu item\\n   *\\n   * @method handleClick\\n   */\\n\\n  PlaybackRateMenuItem.prototype.handleClick = function handleClick() {\\n    _MenuItem.prototype.handleClick.call(this);\\n    this.player().playbackRate(this.rate);\\n  };\\n\\n  /**\\n   * Update playback rate with selected rate\\n   *\\n   * @method update\\n   */\\n\\n  PlaybackRateMenuItem.prototype.update = function update() {\\n    this.selected(this.player().playbackRate() === this.rate);\\n  };\\n\\n  return PlaybackRateMenuItem;\\n})(_menuMenuItemJs2['default']);\\n\\nPlaybackRateMenuItem.prototype.contentElType = 'button';\\n\\n_componentJs2['default'].registerComponent('PlaybackRateMenuItem', PlaybackRateMenuItem);\\nexports['default'] = PlaybackRateMenuItem;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../menu/menu-item.js\\\":110}],77:[function(_dereq_,module,exports){\\n/**\\n * @file load-progress-bar.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsDomJs = _dereq_('../../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\n/**\\n * Shows load progress\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class LoadProgressBar\\n */\\n\\nvar LoadProgressBar = (function (_Component) {\\n  _inherits(LoadProgressBar, _Component);\\n\\n  function LoadProgressBar(player, options) {\\n    _classCallCheck(this, LoadProgressBar);\\n\\n    _Component.call(this, player, options);\\n    this.on(player, 'progress', this.update);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  LoadProgressBar.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-load-progress',\\n      innerHTML: '<span class=\\\"vjs-control-text\\\"><span>' + this.localize('Loaded') + '</span>: 0%</span>'\\n    });\\n  };\\n\\n  /**\\n   * Update progress bar\\n   *\\n   * @method update\\n   */\\n\\n  LoadProgressBar.prototype.update = function update() {\\n    var buffered = this.player_.buffered();\\n    var duration = this.player_.duration();\\n    var bufferedEnd = this.player_.bufferedEnd();\\n    var children = this.el_.children;\\n\\n    // get the percent width of a time compared to the total end\\n    var percentify = function percentify(time, end) {\\n      var percent = time / end || 0; // no NaN\\n      return (percent >= 1 ? 1 : percent) * 100 + '%';\\n    };\\n\\n    // update the width of the progress bar\\n    this.el_.style.width = percentify(bufferedEnd, duration);\\n\\n    // add child elements to represent the individual buffered time ranges\\n    for (var i = 0; i < buffered.length; i++) {\\n      var start = buffered.start(i);\\n      var end = buffered.end(i);\\n      var part = children[i];\\n\\n      if (!part) {\\n        part = this.el_.appendChild(Dom.createEl());\\n      }\\n\\n      // set the percent based on the width of the progress bar (bufferedEnd)\\n      part.style.left = percentify(start, bufferedEnd);\\n      part.style.width = percentify(end - start, bufferedEnd);\\n    }\\n\\n    // remove unused buffered range elements\\n    for (var i = children.length; i > buffered.length; i--) {\\n      this.el_.removeChild(children[i - 1]);\\n    }\\n  };\\n\\n  return LoadProgressBar;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('LoadProgressBar', LoadProgressBar);\\nexports['default'] = LoadProgressBar;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../utils/dom.js\\\":142}],78:[function(_dereq_,module,exports){\\n/**\\n * @file mouse-time-display.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsDomJs = _dereq_('../../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsFormatTimeJs = _dereq_('../../utils/format-time.js');\\n\\nvar _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);\\n\\nvar _lodashCompatFunctionThrottle = _dereq_('lodash-compat/function/throttle');\\n\\nvar _lodashCompatFunctionThrottle2 = _interopRequireDefault(_lodashCompatFunctionThrottle);\\n\\n/**\\n * The Mouse Time Display component shows the time you will seek to\\n * when hovering over the progress bar\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class MouseTimeDisplay\\n */\\n\\nvar MouseTimeDisplay = (function (_Component) {\\n  _inherits(MouseTimeDisplay, _Component);\\n\\n  function MouseTimeDisplay(player, options) {\\n    var _this = this;\\n\\n    _classCallCheck(this, MouseTimeDisplay);\\n\\n    _Component.call(this, player, options);\\n\\n    if (options.playerOptions && options.playerOptions.controlBar && options.playerOptions.controlBar.progressControl && options.playerOptions.controlBar.progressControl.keepTooltipsInside) {\\n      this.keepTooltipsInside = options.playerOptions.controlBar.progressControl.keepTooltipsInside;\\n    }\\n\\n    if (this.keepTooltipsInside) {\\n      this.tooltip = Dom.createEl('div', { className: 'vjs-time-tooltip' });\\n      this.el().appendChild(this.tooltip);\\n      this.addClass('vjs-keep-tooltips-inside');\\n    }\\n\\n    this.update(0, 0);\\n\\n    player.on('ready', function () {\\n      _this.on(player.controlBar.progressControl.el(), 'mousemove', _lodashCompatFunctionThrottle2['default'](Fn.bind(_this, _this.handleMouseMove), 25));\\n    });\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  MouseTimeDisplay.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-mouse-display'\\n    });\\n  };\\n\\n  MouseTimeDisplay.prototype.handleMouseMove = function handleMouseMove(event) {\\n    var duration = this.player_.duration();\\n    var newTime = this.calculateDistance(event) * duration;\\n    var position = event.pageX - Dom.findElPosition(this.el().parentNode).left;\\n\\n    this.update(newTime, position);\\n  };\\n\\n  MouseTimeDisplay.prototype.update = function update(newTime, position) {\\n    var time = _utilsFormatTimeJs2['default'](newTime, this.player_.duration());\\n\\n    this.el().style.left = position + 'px';\\n    this.el().setAttribute('data-current-time', time);\\n\\n    if (this.keepTooltipsInside) {\\n      var clampedPosition = this.clampPosition_(position);\\n      var difference = position - clampedPosition + 1;\\n      var tooltipWidth = parseFloat(_globalWindow2['default'].getComputedStyle(this.tooltip).width);\\n      var tooltipWidthHalf = tooltipWidth / 2;\\n\\n      this.tooltip.innerHTML = time;\\n      this.tooltip.style.right = '-' + (tooltipWidthHalf - difference) + 'px';\\n    }\\n  };\\n\\n  MouseTimeDisplay.prototype.calculateDistance = function calculateDistance(event) {\\n    return Dom.getPointerPosition(this.el().parentNode, event).x;\\n  };\\n\\n  /**\\n   * This takes in a horizontal position for the bar and returns a clamped position.\\n   * Clamped position means that it will keep the position greater than half the width\\n   * of the tooltip and smaller than the player width minus half the width o the tooltip.\\n   * It will only clamp the position if `keepTooltipsInside` option is set.\\n   *\\n   * @param {Number} position the position the bar wants to be\\n   * @return {Number} newPosition the (potentially) clamped position\\n   * @method clampPosition_\\n   */\\n\\n  MouseTimeDisplay.prototype.clampPosition_ = function clampPosition_(position) {\\n    if (!this.keepTooltipsInside) {\\n      return position;\\n    }\\n\\n    var playerWidth = parseFloat(_globalWindow2['default'].getComputedStyle(this.player().el()).width);\\n    var tooltipWidth = parseFloat(_globalWindow2['default'].getComputedStyle(this.tooltip).width);\\n    var tooltipWidthHalf = tooltipWidth / 2;\\n    var actualPosition = position;\\n\\n    if (position < tooltipWidthHalf) {\\n      actualPosition = Math.ceil(tooltipWidthHalf);\\n    } else if (position > playerWidth - tooltipWidthHalf) {\\n      actualPosition = Math.floor(playerWidth - tooltipWidthHalf);\\n    }\\n\\n    return actualPosition;\\n  };\\n\\n  return MouseTimeDisplay;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('MouseTimeDisplay', MouseTimeDisplay);\\nexports['default'] = MouseTimeDisplay;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../utils/dom.js\\\":142,\\\"../../utils/fn.js\\\":144,\\\"../../utils/format-time.js\\\":145,\\\"global/window\\\":2,\\\"lodash-compat/function/throttle\\\":7}],79:[function(_dereq_,module,exports){\\n/**\\n * @file play-progress-bar.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsDomJs = _dereq_('../../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFormatTimeJs = _dereq_('../../utils/format-time.js');\\n\\nvar _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);\\n\\n/**\\n * Shows play progress\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class PlayProgressBar\\n */\\n\\nvar PlayProgressBar = (function (_Component) {\\n  _inherits(PlayProgressBar, _Component);\\n\\n  function PlayProgressBar(player, options) {\\n    _classCallCheck(this, PlayProgressBar);\\n\\n    _Component.call(this, player, options);\\n    this.updateDataAttr();\\n    this.on(player, 'timeupdate', this.updateDataAttr);\\n    player.ready(Fn.bind(this, this.updateDataAttr));\\n\\n    if (options.playerOptions && options.playerOptions.controlBar && options.playerOptions.controlBar.progressControl && options.playerOptions.controlBar.progressControl.keepTooltipsInside) {\\n      this.keepTooltipsInside = options.playerOptions.controlBar.progressControl.keepTooltipsInside;\\n    }\\n\\n    if (this.keepTooltipsInside) {\\n      this.addClass('vjs-keep-tooltips-inside');\\n    }\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  PlayProgressBar.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-play-progress vjs-slider-bar',\\n      innerHTML: '<span class=\\\"vjs-control-text\\\"><span>' + this.localize('Progress') + '</span>: 0%</span>'\\n    });\\n  };\\n\\n  PlayProgressBar.prototype.updateDataAttr = function updateDataAttr() {\\n    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\\n    this.el_.setAttribute('data-current-time', _utilsFormatTimeJs2['default'](time, this.player_.duration()));\\n  };\\n\\n  return PlayProgressBar;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('PlayProgressBar', PlayProgressBar);\\nexports['default'] = PlayProgressBar;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../utils/dom.js\\\":142,\\\"../../utils/fn.js\\\":144,\\\"../../utils/format-time.js\\\":145}],80:[function(_dereq_,module,exports){\\n/**\\n * @file progress-control.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _seekBarJs = _dereq_('./seek-bar.js');\\n\\nvar _seekBarJs2 = _interopRequireDefault(_seekBarJs);\\n\\nvar _mouseTimeDisplayJs = _dereq_('./mouse-time-display.js');\\n\\nvar _mouseTimeDisplayJs2 = _interopRequireDefault(_mouseTimeDisplayJs);\\n\\n/**\\n * The Progress Control component contains the seek bar, load progress,\\n * and play progress\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class ProgressControl\\n */\\n\\nvar ProgressControl = (function (_Component) {\\n  _inherits(ProgressControl, _Component);\\n\\n  function ProgressControl() {\\n    _classCallCheck(this, ProgressControl);\\n\\n    _Component.apply(this, arguments);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  ProgressControl.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-progress-control vjs-control'\\n    });\\n  };\\n\\n  return ProgressControl;\\n})(_componentJs2['default']);\\n\\nProgressControl.prototype.options_ = {\\n  children: ['seekBar']\\n};\\n\\n_componentJs2['default'].registerComponent('ProgressControl', ProgressControl);\\nexports['default'] = ProgressControl;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"./mouse-time-display.js\\\":78,\\\"./seek-bar.js\\\":81}],81:[function(_dereq_,module,exports){\\n/**\\n * @file seek-bar.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _sliderSliderJs = _dereq_('../../slider/slider.js');\\n\\nvar _sliderSliderJs2 = _interopRequireDefault(_sliderSliderJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _loadProgressBarJs = _dereq_('./load-progress-bar.js');\\n\\nvar _loadProgressBarJs2 = _interopRequireDefault(_loadProgressBarJs);\\n\\nvar _playProgressBarJs = _dereq_('./play-progress-bar.js');\\n\\nvar _playProgressBarJs2 = _interopRequireDefault(_playProgressBarJs);\\n\\nvar _tooltipProgressBarJs = _dereq_('./tooltip-progress-bar.js');\\n\\nvar _tooltipProgressBarJs2 = _interopRequireDefault(_tooltipProgressBarJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsFormatTimeJs = _dereq_('../../utils/format-time.js');\\n\\nvar _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);\\n\\nvar _objectAssign = _dereq_('object.assign');\\n\\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\\n\\n/**\\n * Seek Bar and holder for the progress bars\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Slider\\n * @class SeekBar\\n */\\n\\nvar SeekBar = (function (_Slider) {\\n  _inherits(SeekBar, _Slider);\\n\\n  function SeekBar(player, options) {\\n    _classCallCheck(this, SeekBar);\\n\\n    _Slider.call(this, player, options);\\n    this.on(player, 'timeupdate', this.updateProgress);\\n    this.on(player, 'ended', this.updateProgress);\\n    player.ready(Fn.bind(this, this.updateProgress));\\n\\n    if (options.playerOptions && options.playerOptions.controlBar && options.playerOptions.controlBar.progressControl && options.playerOptions.controlBar.progressControl.keepTooltipsInside) {\\n      this.keepTooltipsInside = options.playerOptions.controlBar.progressControl.keepTooltipsInside;\\n    }\\n\\n    if (this.keepTooltipsInside) {\\n      this.tooltipProgressBar = this.addChild('TooltipProgressBar');\\n    }\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  SeekBar.prototype.createEl = function createEl() {\\n    return _Slider.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-progress-holder'\\n    }, {\\n      'aria-label': 'progress bar'\\n    });\\n  };\\n\\n  /**\\n   * Update ARIA accessibility attributes\\n   *\\n   * @method updateARIAAttributes\\n   */\\n\\n  SeekBar.prototype.updateProgress = function updateProgress() {\\n    this.updateAriaAttributes(this.el_);\\n\\n    if (this.keepTooltipsInside) {\\n      this.updateAriaAttributes(this.tooltipProgressBar.el_);\\n      this.tooltipProgressBar.el_.style.width = this.bar.el_.style.width;\\n\\n      var playerWidth = parseFloat(_globalWindow2['default'].getComputedStyle(this.player().el()).width);\\n      var tooltipWidth = parseFloat(_globalWindow2['default'].getComputedStyle(this.tooltipProgressBar.tooltip).width);\\n      var tooltipStyle = this.tooltipProgressBar.el().style;\\n      tooltipStyle.maxWidth = Math.floor(playerWidth - tooltipWidth / 2) + 'px';\\n      tooltipStyle.minWidth = Math.ceil(tooltipWidth / 2) + 'px';\\n      tooltipStyle.right = '-' + tooltipWidth / 2 + 'px';\\n    }\\n  };\\n\\n  SeekBar.prototype.updateAriaAttributes = function updateAriaAttributes(el) {\\n    // Allows for smooth scrubbing, when player can't keep up.\\n    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\\n    el.setAttribute('aria-valuenow', (this.getPercent() * 100).toFixed(2)); // machine readable value of progress bar (percentage complete)\\n    el.setAttribute('aria-valuetext', _utilsFormatTimeJs2['default'](time, this.player_.duration())); // human readable value of progress bar (time complete)\\n  };\\n\\n  /**\\n   * Get percentage of video played\\n   *\\n   * @return {Number} Percentage played\\n   * @method getPercent\\n   */\\n\\n  SeekBar.prototype.getPercent = function getPercent() {\\n    var percent = this.player_.currentTime() / this.player_.duration();\\n    return percent >= 1 ? 1 : percent;\\n  };\\n\\n  /**\\n   * Handle mouse down on seek bar\\n   *\\n   * @method handleMouseDown\\n   */\\n\\n  SeekBar.prototype.handleMouseDown = function handleMouseDown(event) {\\n    _Slider.prototype.handleMouseDown.call(this, event);\\n\\n    this.player_.scrubbing(true);\\n\\n    this.videoWasPlaying = !this.player_.paused();\\n    this.player_.pause();\\n  };\\n\\n  /**\\n   * Handle mouse move on seek bar\\n   *\\n   * @method handleMouseMove\\n   */\\n\\n  SeekBar.prototype.handleMouseMove = function handleMouseMove(event) {\\n    var newTime = this.calculateDistance(event) * this.player_.duration();\\n\\n    // Don't let video end while scrubbing.\\n    if (newTime === this.player_.duration()) {\\n      newTime = newTime - 0.1;\\n    }\\n\\n    // Set new time (tell player to seek to new time)\\n    this.player_.currentTime(newTime);\\n  };\\n\\n  /**\\n   * Handle mouse up on seek bar\\n   *\\n   * @method handleMouseUp\\n   */\\n\\n  SeekBar.prototype.handleMouseUp = function handleMouseUp(event) {\\n    _Slider.prototype.handleMouseUp.call(this, event);\\n\\n    this.player_.scrubbing(false);\\n    if (this.videoWasPlaying) {\\n      this.player_.play();\\n    }\\n  };\\n\\n  /**\\n   * Move more quickly fast forward for keyboard-only users\\n   *\\n   * @method stepForward\\n   */\\n\\n  SeekBar.prototype.stepForward = function stepForward() {\\n    this.player_.currentTime(this.player_.currentTime() + 5); // more quickly fast forward for keyboard-only users\\n  };\\n\\n  /**\\n   * Move more quickly rewind for keyboard-only users\\n   *\\n   * @method stepBack\\n   */\\n\\n  SeekBar.prototype.stepBack = function stepBack() {\\n    this.player_.currentTime(this.player_.currentTime() - 5); // more quickly rewind for keyboard-only users\\n  };\\n\\n  return SeekBar;\\n})(_sliderSliderJs2['default']);\\n\\nSeekBar.prototype.options_ = {\\n  children: ['loadProgressBar', 'mouseTimeDisplay', 'playProgressBar'],\\n  'barName': 'playProgressBar'\\n};\\n\\nSeekBar.prototype.playerEvent = 'timeupdate';\\n\\n_componentJs2['default'].registerComponent('SeekBar', SeekBar);\\nexports['default'] = SeekBar;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../slider/slider.js\\\":119,\\\"../../utils/fn.js\\\":144,\\\"../../utils/format-time.js\\\":145,\\\"./load-progress-bar.js\\\":77,\\\"./play-progress-bar.js\\\":79,\\\"./tooltip-progress-bar.js\\\":82,\\\"global/window\\\":2,\\\"object.assign\\\":45}],82:[function(_dereq_,module,exports){\\n/**\\n * @file play-progress-bar.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsDomJs = _dereq_('../../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFormatTimeJs = _dereq_('../../utils/format-time.js');\\n\\nvar _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);\\n\\n/**\\n * Shows play progress\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class PlayProgressBar\\n */\\n\\nvar TooltipProgressBar = (function (_Component) {\\n  _inherits(TooltipProgressBar, _Component);\\n\\n  function TooltipProgressBar(player, options) {\\n    _classCallCheck(this, TooltipProgressBar);\\n\\n    _Component.call(this, player, options);\\n    this.updateDataAttr();\\n    this.on(player, 'timeupdate', this.updateDataAttr);\\n    player.ready(Fn.bind(this, this.updateDataAttr));\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  TooltipProgressBar.prototype.createEl = function createEl() {\\n    var el = _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-tooltip-progress-bar vjs-slider-bar',\\n      innerHTML: '<div class=\\\"vjs-time-tooltip\\\"></div>\\\\n        <span class=\\\"vjs-control-text\\\"><span>' + this.localize('Progress') + '</span>: 0%</span>'\\n    });\\n\\n    this.tooltip = el.querySelector('.vjs-time-tooltip');\\n\\n    return el;\\n  };\\n\\n  TooltipProgressBar.prototype.updateDataAttr = function updateDataAttr() {\\n    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\\n    var formattedTime = _utilsFormatTimeJs2['default'](time, this.player_.duration());\\n    this.el_.setAttribute('data-current-time', formattedTime);\\n    this.tooltip.innerHTML = formattedTime;\\n  };\\n\\n  return TooltipProgressBar;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('TooltipProgressBar', TooltipProgressBar);\\nexports['default'] = TooltipProgressBar;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../utils/dom.js\\\":142,\\\"../../utils/fn.js\\\":144,\\\"../../utils/format-time.js\\\":145}],83:[function(_dereq_,module,exports){\\n/**\\n * @file custom-control-spacer.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _spacerJs = _dereq_('./spacer.js');\\n\\nvar _spacerJs2 = _interopRequireDefault(_spacerJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n/**\\n * Spacer specifically meant to be used as an insertion point for new plugins, etc.\\n *\\n * @extends Spacer\\n * @class CustomControlSpacer\\n */\\n\\nvar CustomControlSpacer = (function (_Spacer) {\\n  _inherits(CustomControlSpacer, _Spacer);\\n\\n  function CustomControlSpacer() {\\n    _classCallCheck(this, CustomControlSpacer);\\n\\n    _Spacer.apply(this, arguments);\\n  }\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  CustomControlSpacer.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-custom-control-spacer ' + _Spacer.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  CustomControlSpacer.prototype.createEl = function createEl() {\\n    var el = _Spacer.prototype.createEl.call(this, {\\n      className: this.buildCSSClass()\\n    });\\n\\n    // No-flex/table-cell mode requires there be some content\\n    // in the cell to fill the remaining space of the table.\\n    el.innerHTML = '&nbsp;';\\n    return el;\\n  };\\n\\n  return CustomControlSpacer;\\n})(_spacerJs2['default']);\\n\\n_componentJs2['default'].registerComponent('CustomControlSpacer', CustomControlSpacer);\\nexports['default'] = CustomControlSpacer;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"./spacer.js\\\":84}],84:[function(_dereq_,module,exports){\\n/**\\n * @file spacer.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n/**\\n * Just an empty spacer element that can be used as an append point for plugins, etc.\\n * Also can be used to create space between elements when necessary.\\n *\\n * @extends Component\\n * @class Spacer\\n */\\n\\nvar Spacer = (function (_Component) {\\n  _inherits(Spacer, _Component);\\n\\n  function Spacer() {\\n    _classCallCheck(this, Spacer);\\n\\n    _Component.apply(this, arguments);\\n  }\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  Spacer.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-spacer ' + _Component.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  Spacer.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: this.buildCSSClass()\\n    });\\n  };\\n\\n  return Spacer;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('Spacer', Spacer);\\n\\nexports['default'] = Spacer;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67}],85:[function(_dereq_,module,exports){\\n/**\\n * @file caption-settings-menu-item.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _textTrackMenuItemJs = _dereq_('./text-track-menu-item.js');\\n\\nvar _textTrackMenuItemJs2 = _interopRequireDefault(_textTrackMenuItemJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n/**\\n * The menu item for caption track settings menu\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends TextTrackMenuItem\\n * @class CaptionSettingsMenuItem\\n */\\n\\nvar CaptionSettingsMenuItem = (function (_TextTrackMenuItem) {\\n  _inherits(CaptionSettingsMenuItem, _TextTrackMenuItem);\\n\\n  function CaptionSettingsMenuItem(player, options) {\\n    _classCallCheck(this, CaptionSettingsMenuItem);\\n\\n    options['track'] = {\\n      'kind': options['kind'],\\n      'player': player,\\n      'label': options['kind'] + ' settings',\\n      'selectable': false,\\n      'default': false,\\n      mode: 'disabled'\\n    };\\n\\n    // CaptionSettingsMenuItem has no concept of 'selected'\\n    options['selectable'] = false;\\n\\n    _TextTrackMenuItem.call(this, player, options);\\n    this.addClass('vjs-texttrack-settings');\\n    this.controlText(', opens ' + options['kind'] + ' settings dialog');\\n  }\\n\\n  /**\\n   * Handle click on menu item\\n   *\\n   * @method handleClick\\n   */\\n\\n  CaptionSettingsMenuItem.prototype.handleClick = function handleClick() {\\n    this.player().getChild('textTrackSettings').show();\\n    this.player().getChild('textTrackSettings').el_.focus();\\n  };\\n\\n  return CaptionSettingsMenuItem;\\n})(_textTrackMenuItemJs2['default']);\\n\\n_componentJs2['default'].registerComponent('CaptionSettingsMenuItem', CaptionSettingsMenuItem);\\nexports['default'] = CaptionSettingsMenuItem;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"./text-track-menu-item.js\\\":93}],86:[function(_dereq_,module,exports){\\n/**\\n * @file captions-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _textTrackButtonJs = _dereq_('./text-track-button.js');\\n\\nvar _textTrackButtonJs2 = _interopRequireDefault(_textTrackButtonJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _captionSettingsMenuItemJs = _dereq_('./caption-settings-menu-item.js');\\n\\nvar _captionSettingsMenuItemJs2 = _interopRequireDefault(_captionSettingsMenuItemJs);\\n\\n/**\\n * The button component for toggling and selecting captions\\n *\\n * @param {Object} player  Player object\\n * @param {Object=} options Object of option names and values\\n * @param {Function=} ready    Ready callback function\\n * @extends TextTrackButton\\n * @class CaptionsButton\\n */\\n\\nvar CaptionsButton = (function (_TextTrackButton) {\\n  _inherits(CaptionsButton, _TextTrackButton);\\n\\n  function CaptionsButton(player, options, ready) {\\n    _classCallCheck(this, CaptionsButton);\\n\\n    _TextTrackButton.call(this, player, options, ready);\\n    this.el_.setAttribute('aria-label', 'Captions Menu');\\n  }\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  CaptionsButton.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-captions-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Update caption menu items\\n   *\\n   * @method update\\n   */\\n\\n  CaptionsButton.prototype.update = function update() {\\n    var threshold = 2;\\n    _TextTrackButton.prototype.update.call(this);\\n\\n    // if native, then threshold is 1 because no settings button\\n    if (this.player().tech_ && this.player().tech_['featuresNativeTextTracks']) {\\n      threshold = 1;\\n    }\\n\\n    if (this.items && this.items.length > threshold) {\\n      this.show();\\n    } else {\\n      this.hide();\\n    }\\n  };\\n\\n  /**\\n   * Create caption menu items\\n   *\\n   * @return {Array} Array of menu items\\n   * @method createItems\\n   */\\n\\n  CaptionsButton.prototype.createItems = function createItems() {\\n    var items = [];\\n\\n    if (!(this.player().tech_ && this.player().tech_['featuresNativeTextTracks'])) {\\n      items.push(new _captionSettingsMenuItemJs2['default'](this.player_, { 'kind': this.kind_ }));\\n    }\\n\\n    return _TextTrackButton.prototype.createItems.call(this, items);\\n  };\\n\\n  return CaptionsButton;\\n})(_textTrackButtonJs2['default']);\\n\\nCaptionsButton.prototype.kind_ = 'captions';\\nCaptionsButton.prototype.controlText_ = 'Captions';\\n\\n_componentJs2['default'].registerComponent('CaptionsButton', CaptionsButton);\\nexports['default'] = CaptionsButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"./caption-settings-menu-item.js\\\":85,\\\"./text-track-button.js\\\":92}],87:[function(_dereq_,module,exports){\\n/**\\n * @file chapters-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _textTrackButtonJs = _dereq_('./text-track-button.js');\\n\\nvar _textTrackButtonJs2 = _interopRequireDefault(_textTrackButtonJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _textTrackMenuItemJs = _dereq_('./text-track-menu-item.js');\\n\\nvar _textTrackMenuItemJs2 = _interopRequireDefault(_textTrackMenuItemJs);\\n\\nvar _chaptersTrackMenuItemJs = _dereq_('./chapters-track-menu-item.js');\\n\\nvar _chaptersTrackMenuItemJs2 = _interopRequireDefault(_chaptersTrackMenuItemJs);\\n\\nvar _menuMenuJs = _dereq_('../../menu/menu.js');\\n\\nvar _menuMenuJs2 = _interopRequireDefault(_menuMenuJs);\\n\\nvar _utilsDomJs = _dereq_('../../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsToTitleCaseJs = _dereq_('../../utils/to-title-case.js');\\n\\nvar _utilsToTitleCaseJs2 = _interopRequireDefault(_utilsToTitleCaseJs);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\n/**\\n * The button component for toggling and selecting chapters\\n * Chapters act much differently than other text tracks\\n * Cues are navigation vs. other tracks of alternative languages\\n *\\n * @param {Object} player  Player object\\n * @param {Object=} options Object of option names and values\\n * @param {Function=} ready    Ready callback function\\n * @extends TextTrackButton\\n * @class ChaptersButton\\n */\\n\\nvar ChaptersButton = (function (_TextTrackButton) {\\n  _inherits(ChaptersButton, _TextTrackButton);\\n\\n  function ChaptersButton(player, options, ready) {\\n    _classCallCheck(this, ChaptersButton);\\n\\n    _TextTrackButton.call(this, player, options, ready);\\n    this.el_.setAttribute('aria-label', 'Chapters Menu');\\n  }\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  ChaptersButton.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-chapters-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Create a menu item for each text track\\n   *\\n   * @return {Array} Array of menu items\\n   * @method createItems\\n   */\\n\\n  ChaptersButton.prototype.createItems = function createItems() {\\n    var items = [];\\n\\n    var tracks = this.player_.textTracks();\\n\\n    if (!tracks) {\\n      return items;\\n    }\\n\\n    for (var i = 0; i < tracks.length; i++) {\\n      var track = tracks[i];\\n      if (track['kind'] === this.kind_) {\\n        items.push(new _textTrackMenuItemJs2['default'](this.player_, {\\n          'track': track\\n        }));\\n      }\\n    }\\n\\n    return items;\\n  };\\n\\n  /**\\n   * Create menu from chapter buttons\\n   *\\n   * @return {Menu} Menu of chapter buttons\\n   * @method createMenu\\n   */\\n\\n  ChaptersButton.prototype.createMenu = function createMenu() {\\n    var _this = this;\\n\\n    var tracks = this.player_.textTracks() || [];\\n    var chaptersTrack = undefined;\\n    var items = this.items || [];\\n\\n    for (var i = tracks.length - 1; i >= 0; i--) {\\n\\n      // We will always choose the last track as our chaptersTrack\\n      var track = tracks[i];\\n\\n      if (track['kind'] === this.kind_) {\\n        chaptersTrack = track;\\n\\n        break;\\n      }\\n    }\\n\\n    var menu = this.menu;\\n    if (menu === undefined) {\\n      menu = new _menuMenuJs2['default'](this.player_);\\n      var title = Dom.createEl('li', {\\n        className: 'vjs-menu-title',\\n        innerHTML: _utilsToTitleCaseJs2['default'](this.kind_),\\n        tabIndex: -1\\n      });\\n      menu.children_.unshift(title);\\n      Dom.insertElFirst(title, menu.contentEl());\\n    } else {\\n      // We will empty out the menu children each time because we want a\\n      // fresh new menu child list each time\\n      items.forEach(function (item) {\\n        return menu.removeChild(item);\\n      });\\n      // Empty out the ChaptersButton menu items because we no longer need them\\n      items = [];\\n    }\\n\\n    if (chaptersTrack && chaptersTrack.cues == null) {\\n      chaptersTrack['mode'] = 'hidden';\\n\\n      var remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(chaptersTrack);\\n\\n      if (remoteTextTrackEl) {\\n        remoteTextTrackEl.addEventListener('load', function (event) {\\n          return _this.update();\\n        });\\n      }\\n    }\\n\\n    if (chaptersTrack && chaptersTrack.cues && chaptersTrack.cues.length > 0) {\\n      var cues = chaptersTrack['cues'],\\n          cue = undefined;\\n\\n      for (var i = 0, l = cues.length; i < l; i++) {\\n        cue = cues[i];\\n\\n        var mi = new _chaptersTrackMenuItemJs2['default'](this.player_, {\\n          'track': chaptersTrack,\\n          'cue': cue\\n        });\\n\\n        items.push(mi);\\n\\n        menu.addChild(mi);\\n      }\\n    }\\n\\n    if (items.length > 0) {\\n      this.show();\\n    }\\n    // Assigning the value of items back to this.items for next iteration\\n    this.items = items;\\n    return menu;\\n  };\\n\\n  return ChaptersButton;\\n})(_textTrackButtonJs2['default']);\\n\\nChaptersButton.prototype.kind_ = 'chapters';\\nChaptersButton.prototype.controlText_ = 'Chapters';\\n\\n_componentJs2['default'].registerComponent('ChaptersButton', ChaptersButton);\\nexports['default'] = ChaptersButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../menu/menu.js\\\":111,\\\"../../utils/dom.js\\\":142,\\\"../../utils/fn.js\\\":144,\\\"../../utils/to-title-case.js\\\":151,\\\"./chapters-track-menu-item.js\\\":88,\\\"./text-track-button.js\\\":92,\\\"./text-track-menu-item.js\\\":93,\\\"global/window\\\":2}],88:[function(_dereq_,module,exports){\\n/**\\n * @file chapters-track-menu-item.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _menuMenuItemJs = _dereq_('../../menu/menu-item.js');\\n\\nvar _menuMenuItemJs2 = _interopRequireDefault(_menuMenuItemJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\n/**\\n * The chapter track menu item\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends MenuItem\\n * @class ChaptersTrackMenuItem\\n */\\n\\nvar ChaptersTrackMenuItem = (function (_MenuItem) {\\n  _inherits(ChaptersTrackMenuItem, _MenuItem);\\n\\n  function ChaptersTrackMenuItem(player, options) {\\n    _classCallCheck(this, ChaptersTrackMenuItem);\\n\\n    var track = options['track'];\\n    var cue = options['cue'];\\n    var currentTime = player.currentTime();\\n\\n    // Modify options for parent MenuItem class's init.\\n    options['label'] = cue.text;\\n    options['selected'] = cue['startTime'] <= currentTime && currentTime < cue['endTime'];\\n    _MenuItem.call(this, player, options);\\n\\n    this.track = track;\\n    this.cue = cue;\\n    track.addEventListener('cuechange', Fn.bind(this, this.update));\\n  }\\n\\n  /**\\n   * Handle click on menu item\\n   *\\n   * @method handleClick\\n   */\\n\\n  ChaptersTrackMenuItem.prototype.handleClick = function handleClick() {\\n    _MenuItem.prototype.handleClick.call(this);\\n    this.player_.currentTime(this.cue.startTime);\\n    this.update(this.cue.startTime);\\n  };\\n\\n  /**\\n   * Update chapter menu item\\n   *\\n   * @method update\\n   */\\n\\n  ChaptersTrackMenuItem.prototype.update = function update() {\\n    var cue = this.cue;\\n    var currentTime = this.player_.currentTime();\\n\\n    // vjs.log(currentTime, cue.startTime);\\n    this.selected(cue['startTime'] <= currentTime && currentTime < cue['endTime']);\\n  };\\n\\n  return ChaptersTrackMenuItem;\\n})(_menuMenuItemJs2['default']);\\n\\n_componentJs2['default'].registerComponent('ChaptersTrackMenuItem', ChaptersTrackMenuItem);\\nexports['default'] = ChaptersTrackMenuItem;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../menu/menu-item.js\\\":110,\\\"../../utils/fn.js\\\":144}],89:[function(_dereq_,module,exports){\\n/**\\n * @file descriptions-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _textTrackButtonJs = _dereq_('./text-track-button.js');\\n\\nvar _textTrackButtonJs2 = _interopRequireDefault(_textTrackButtonJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\n/**\\n * The button component for toggling and selecting descriptions\\n *\\n * @param {Object} player  Player object\\n * @param {Object=} options Object of option names and values\\n * @param {Function=} ready    Ready callback function\\n * @extends TextTrackButton\\n * @class DescriptionsButton\\n */\\n\\nvar DescriptionsButton = (function (_TextTrackButton) {\\n  _inherits(DescriptionsButton, _TextTrackButton);\\n\\n  function DescriptionsButton(player, options, ready) {\\n    var _this = this;\\n\\n    _classCallCheck(this, DescriptionsButton);\\n\\n    _TextTrackButton.call(this, player, options, ready);\\n    this.el_.setAttribute('aria-label', 'Descriptions Menu');\\n\\n    var tracks = player.textTracks();\\n\\n    if (tracks) {\\n      (function () {\\n        var changeHandler = Fn.bind(_this, _this.handleTracksChange);\\n\\n        tracks.addEventListener('change', changeHandler);\\n        _this.on('dispose', function () {\\n          tracks.removeEventListener('change', changeHandler);\\n        });\\n      })();\\n    }\\n  }\\n\\n  /**\\n   * Handle text track change\\n   *\\n   * @method handleTracksChange\\n   */\\n\\n  DescriptionsButton.prototype.handleTracksChange = function handleTracksChange(event) {\\n    var tracks = this.player().textTracks();\\n    var disabled = false;\\n\\n    // Check whether a track of a different kind is showing\\n    for (var i = 0, l = tracks.length; i < l; i++) {\\n      var track = tracks[i];\\n      if (track['kind'] !== this.kind_ && track['mode'] === 'showing') {\\n        disabled = true;\\n        break;\\n      }\\n    }\\n\\n    // If another track is showing, disable this menu button\\n    if (disabled) {\\n      this.disable();\\n    } else {\\n      this.enable();\\n    }\\n  };\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  DescriptionsButton.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-descriptions-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\\n  };\\n\\n  return DescriptionsButton;\\n})(_textTrackButtonJs2['default']);\\n\\nDescriptionsButton.prototype.kind_ = 'descriptions';\\nDescriptionsButton.prototype.controlText_ = 'Descriptions';\\n\\n_componentJs2['default'].registerComponent('DescriptionsButton', DescriptionsButton);\\nexports['default'] = DescriptionsButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../utils/fn.js\\\":144,\\\"./text-track-button.js\\\":92}],90:[function(_dereq_,module,exports){\\n/**\\n * @file off-text-track-menu-item.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _textTrackMenuItemJs = _dereq_('./text-track-menu-item.js');\\n\\nvar _textTrackMenuItemJs2 = _interopRequireDefault(_textTrackMenuItemJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n/**\\n * A special menu item for turning of a specific type of text track\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends TextTrackMenuItem\\n * @class OffTextTrackMenuItem\\n */\\n\\nvar OffTextTrackMenuItem = (function (_TextTrackMenuItem) {\\n  _inherits(OffTextTrackMenuItem, _TextTrackMenuItem);\\n\\n  function OffTextTrackMenuItem(player, options) {\\n    _classCallCheck(this, OffTextTrackMenuItem);\\n\\n    // Create pseudo track info\\n    // Requires options['kind']\\n    options['track'] = {\\n      'kind': options['kind'],\\n      'player': player,\\n      'label': options['kind'] + ' off',\\n      'default': false,\\n      'mode': 'disabled'\\n    };\\n\\n    // MenuItem is selectable\\n    options['selectable'] = true;\\n\\n    _TextTrackMenuItem.call(this, player, options);\\n    this.selected(true);\\n  }\\n\\n  /**\\n   * Handle text track change\\n   *\\n   * @param {Object} event Event object\\n   * @method handleTracksChange\\n   */\\n\\n  OffTextTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {\\n    var tracks = this.player().textTracks();\\n    var selected = true;\\n\\n    for (var i = 0, l = tracks.length; i < l; i++) {\\n      var track = tracks[i];\\n      if (track['kind'] === this.track['kind'] && track['mode'] === 'showing') {\\n        selected = false;\\n        break;\\n      }\\n    }\\n\\n    this.selected(selected);\\n  };\\n\\n  return OffTextTrackMenuItem;\\n})(_textTrackMenuItemJs2['default']);\\n\\n_componentJs2['default'].registerComponent('OffTextTrackMenuItem', OffTextTrackMenuItem);\\nexports['default'] = OffTextTrackMenuItem;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"./text-track-menu-item.js\\\":93}],91:[function(_dereq_,module,exports){\\n/**\\n * @file subtitles-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _textTrackButtonJs = _dereq_('./text-track-button.js');\\n\\nvar _textTrackButtonJs2 = _interopRequireDefault(_textTrackButtonJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n/**\\n * The button component for toggling and selecting subtitles\\n *\\n * @param {Object} player  Player object\\n * @param {Object=} options Object of option names and values\\n * @param {Function=} ready    Ready callback function\\n * @extends TextTrackButton\\n * @class SubtitlesButton\\n */\\n\\nvar SubtitlesButton = (function (_TextTrackButton) {\\n  _inherits(SubtitlesButton, _TextTrackButton);\\n\\n  function SubtitlesButton(player, options, ready) {\\n    _classCallCheck(this, SubtitlesButton);\\n\\n    _TextTrackButton.call(this, player, options, ready);\\n    this.el_.setAttribute('aria-label', 'Subtitles Menu');\\n  }\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  SubtitlesButton.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-subtitles-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\\n  };\\n\\n  return SubtitlesButton;\\n})(_textTrackButtonJs2['default']);\\n\\nSubtitlesButton.prototype.kind_ = 'subtitles';\\nSubtitlesButton.prototype.controlText_ = 'Subtitles';\\n\\n_componentJs2['default'].registerComponent('SubtitlesButton', SubtitlesButton);\\nexports['default'] = SubtitlesButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"./text-track-button.js\\\":92}],92:[function(_dereq_,module,exports){\\n/**\\n * @file text-track-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _trackButtonJs = _dereq_('../track-button.js');\\n\\nvar _trackButtonJs2 = _interopRequireDefault(_trackButtonJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _textTrackMenuItemJs = _dereq_('./text-track-menu-item.js');\\n\\nvar _textTrackMenuItemJs2 = _interopRequireDefault(_textTrackMenuItemJs);\\n\\nvar _offTextTrackMenuItemJs = _dereq_('./off-text-track-menu-item.js');\\n\\nvar _offTextTrackMenuItemJs2 = _interopRequireDefault(_offTextTrackMenuItemJs);\\n\\n/**\\n * The base class for buttons that toggle specific text track types (e.g. subtitles)\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends MenuButton\\n * @class TextTrackButton\\n */\\n\\nvar TextTrackButton = (function (_TrackButton) {\\n  _inherits(TextTrackButton, _TrackButton);\\n\\n  function TextTrackButton(player) {\\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n\\n    _classCallCheck(this, TextTrackButton);\\n\\n    options.tracks = player.textTracks();\\n\\n    _TrackButton.call(this, player, options);\\n  }\\n\\n  /**\\n   * Create a menu item for each text track\\n   *\\n   * @return {Array} Array of menu items\\n   * @method createItems\\n   */\\n\\n  TextTrackButton.prototype.createItems = function createItems() {\\n    var items = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\\n\\n    // Add an OFF menu item to turn all tracks off\\n    items.push(new _offTextTrackMenuItemJs2['default'](this.player_, { 'kind': this.kind_ }));\\n\\n    var tracks = this.player_.textTracks();\\n\\n    if (!tracks) {\\n      return items;\\n    }\\n\\n    for (var i = 0; i < tracks.length; i++) {\\n      var track = tracks[i];\\n\\n      // only add tracks that are of the appropriate kind and have a label\\n      if (track['kind'] === this.kind_) {\\n        items.push(new _textTrackMenuItemJs2['default'](this.player_, {\\n          // MenuItem is selectable\\n          'selectable': true,\\n          'track': track\\n        }));\\n      }\\n    }\\n\\n    return items;\\n  };\\n\\n  return TextTrackButton;\\n})(_trackButtonJs2['default']);\\n\\n_componentJs2['default'].registerComponent('TextTrackButton', TextTrackButton);\\nexports['default'] = TextTrackButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../utils/fn.js\\\":144,\\\"../track-button.js\\\":98,\\\"./off-text-track-menu-item.js\\\":90,\\\"./text-track-menu-item.js\\\":93}],93:[function(_dereq_,module,exports){\\n/**\\n * @file text-track-menu-item.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _menuMenuItemJs = _dereq_('../../menu/menu-item.js');\\n\\nvar _menuMenuItemJs2 = _interopRequireDefault(_menuMenuItemJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\n/**\\n * The specific menu item type for selecting a language within a text track kind\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends MenuItem\\n * @class TextTrackMenuItem\\n */\\n\\nvar TextTrackMenuItem = (function (_MenuItem) {\\n  _inherits(TextTrackMenuItem, _MenuItem);\\n\\n  function TextTrackMenuItem(player, options) {\\n    var _this = this;\\n\\n    _classCallCheck(this, TextTrackMenuItem);\\n\\n    var track = options['track'];\\n    var tracks = player.textTracks();\\n\\n    // Modify options for parent MenuItem class's init.\\n    options['label'] = track['label'] || track['language'] || 'Unknown';\\n    options['selected'] = track['default'] || track['mode'] === 'showing';\\n\\n    _MenuItem.call(this, player, options);\\n\\n    this.track = track;\\n\\n    if (tracks) {\\n      (function () {\\n        var changeHandler = Fn.bind(_this, _this.handleTracksChange);\\n\\n        tracks.addEventListener('change', changeHandler);\\n        _this.on('dispose', function () {\\n          tracks.removeEventListener('change', changeHandler);\\n        });\\n      })();\\n    }\\n\\n    // iOS7 doesn't dispatch change events to TextTrackLists when an\\n    // associated track's mode changes. Without something like\\n    // Object.observe() (also not present on iOS7), it's not\\n    // possible to detect changes to the mode attribute and polyfill\\n    // the change event. As a poor substitute, we manually dispatch\\n    // change events whenever the controls modify the mode.\\n    if (tracks && tracks.onchange === undefined) {\\n      (function () {\\n        var event = undefined;\\n\\n        _this.on(['tap', 'click'], function () {\\n          if (typeof _globalWindow2['default'].Event !== 'object') {\\n            // Android 2.3 throws an Illegal Constructor error for window.Event\\n            try {\\n              event = new _globalWindow2['default'].Event('change');\\n            } catch (err) {}\\n          }\\n\\n          if (!event) {\\n            event = _globalDocument2['default'].createEvent('Event');\\n            event.initEvent('change', true, true);\\n          }\\n\\n          tracks.dispatchEvent(event);\\n        });\\n      })();\\n    }\\n  }\\n\\n  /**\\n   * Handle click on text track\\n   *\\n   * @method handleClick\\n   */\\n\\n  TextTrackMenuItem.prototype.handleClick = function handleClick(event) {\\n    var kind = this.track['kind'];\\n    var tracks = this.player_.textTracks();\\n\\n    _MenuItem.prototype.handleClick.call(this, event);\\n\\n    if (!tracks) return;\\n\\n    for (var i = 0; i < tracks.length; i++) {\\n      var track = tracks[i];\\n\\n      if (track['kind'] !== kind) {\\n        continue;\\n      }\\n\\n      if (track === this.track) {\\n        track['mode'] = 'showing';\\n      } else {\\n        track['mode'] = 'disabled';\\n      }\\n    }\\n  };\\n\\n  /**\\n   * Handle text track change\\n   *\\n   * @method handleTracksChange\\n   */\\n\\n  TextTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {\\n    this.selected(this.track['mode'] === 'showing');\\n  };\\n\\n  return TextTrackMenuItem;\\n})(_menuMenuItemJs2['default']);\\n\\n_componentJs2['default'].registerComponent('TextTrackMenuItem', TextTrackMenuItem);\\nexports['default'] = TextTrackMenuItem;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../menu/menu-item.js\\\":110,\\\"../../utils/fn.js\\\":144,\\\"global/document\\\":1,\\\"global/window\\\":2}],94:[function(_dereq_,module,exports){\\n/**\\n * @file current-time-display.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsDomJs = _dereq_('../../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFormatTimeJs = _dereq_('../../utils/format-time.js');\\n\\nvar _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);\\n\\n/**\\n * Displays the current time\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class CurrentTimeDisplay\\n */\\n\\nvar CurrentTimeDisplay = (function (_Component) {\\n  _inherits(CurrentTimeDisplay, _Component);\\n\\n  function CurrentTimeDisplay(player, options) {\\n    _classCallCheck(this, CurrentTimeDisplay);\\n\\n    _Component.call(this, player, options);\\n\\n    this.on(player, 'timeupdate', this.updateContent);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  CurrentTimeDisplay.prototype.createEl = function createEl() {\\n    var el = _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-current-time vjs-time-control vjs-control'\\n    });\\n\\n    this.contentEl_ = Dom.createEl('div', {\\n      className: 'vjs-current-time-display',\\n      // label the current time for screen reader users\\n      innerHTML: '<span class=\\\"vjs-control-text\\\">Current Time </span>' + '0:00'\\n    }, {\\n      // tell screen readers not to automatically read the time as it changes\\n      'aria-live': 'off'\\n    });\\n\\n    el.appendChild(this.contentEl_);\\n    return el;\\n  };\\n\\n  /**\\n   * Update current time display\\n   *\\n   * @method updateContent\\n   */\\n\\n  CurrentTimeDisplay.prototype.updateContent = function updateContent() {\\n    // Allows for smooth scrubbing, when player can't keep up.\\n    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\\n    var localizedText = this.localize('Current Time');\\n    var formattedTime = _utilsFormatTimeJs2['default'](time, this.player_.duration());\\n    if (formattedTime !== this.formattedTime_) {\\n      this.formattedTime_ = formattedTime;\\n      this.contentEl_.innerHTML = '<span class=\\\"vjs-control-text\\\">' + localizedText + '</span> ' + formattedTime;\\n    }\\n  };\\n\\n  return CurrentTimeDisplay;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('CurrentTimeDisplay', CurrentTimeDisplay);\\nexports['default'] = CurrentTimeDisplay;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../utils/dom.js\\\":142,\\\"../../utils/format-time.js\\\":145}],95:[function(_dereq_,module,exports){\\n/**\\n * @file duration-display.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsDomJs = _dereq_('../../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFormatTimeJs = _dereq_('../../utils/format-time.js');\\n\\nvar _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);\\n\\n/**\\n * Displays the duration\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class DurationDisplay\\n */\\n\\nvar DurationDisplay = (function (_Component) {\\n  _inherits(DurationDisplay, _Component);\\n\\n  function DurationDisplay(player, options) {\\n    _classCallCheck(this, DurationDisplay);\\n\\n    _Component.call(this, player, options);\\n\\n    this.on(player, 'durationchange', this.updateContent);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  DurationDisplay.prototype.createEl = function createEl() {\\n    var el = _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-duration vjs-time-control vjs-control'\\n    });\\n\\n    this.contentEl_ = Dom.createEl('div', {\\n      className: 'vjs-duration-display',\\n      // label the duration time for screen reader users\\n      innerHTML: '<span class=\\\"vjs-control-text\\\">' + this.localize('Duration Time') + '</span> 0:00'\\n    }, {\\n      // tell screen readers not to automatically read the time as it changes\\n      'aria-live': 'off'\\n    });\\n\\n    el.appendChild(this.contentEl_);\\n    return el;\\n  };\\n\\n  /**\\n   * Update duration time display\\n   *\\n   * @method updateContent\\n   */\\n\\n  DurationDisplay.prototype.updateContent = function updateContent() {\\n    var duration = this.player_.duration();\\n    if (duration && this.duration_ !== duration) {\\n      this.duration_ = duration;\\n      var localizedText = this.localize('Duration Time');\\n      var formattedTime = _utilsFormatTimeJs2['default'](duration);\\n      this.contentEl_.innerHTML = '<span class=\\\"vjs-control-text\\\">' + localizedText + '</span> ' + formattedTime; // label the duration time for screen reader users\\n    }\\n  };\\n\\n  return DurationDisplay;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('DurationDisplay', DurationDisplay);\\nexports['default'] = DurationDisplay;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../utils/dom.js\\\":142,\\\"../../utils/format-time.js\\\":145}],96:[function(_dereq_,module,exports){\\n/**\\n * @file remaining-time-display.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsDomJs = _dereq_('../../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFormatTimeJs = _dereq_('../../utils/format-time.js');\\n\\nvar _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);\\n\\n/**\\n * Displays the time left in the video\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class RemainingTimeDisplay\\n */\\n\\nvar RemainingTimeDisplay = (function (_Component) {\\n  _inherits(RemainingTimeDisplay, _Component);\\n\\n  function RemainingTimeDisplay(player, options) {\\n    _classCallCheck(this, RemainingTimeDisplay);\\n\\n    _Component.call(this, player, options);\\n\\n    this.on(player, 'timeupdate', this.updateContent);\\n    this.on(player, 'durationchange', this.updateContent);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  RemainingTimeDisplay.prototype.createEl = function createEl() {\\n    var el = _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-remaining-time vjs-time-control vjs-control'\\n    });\\n\\n    this.contentEl_ = Dom.createEl('div', {\\n      className: 'vjs-remaining-time-display',\\n      // label the remaining time for screen reader users\\n      innerHTML: '<span class=\\\"vjs-control-text\\\">' + this.localize('Remaining Time') + '</span> -0:00'\\n    }, {\\n      // tell screen readers not to automatically read the time as it changes\\n      'aria-live': 'off'\\n    });\\n\\n    el.appendChild(this.contentEl_);\\n    return el;\\n  };\\n\\n  /**\\n   * Update remaining time display\\n   *\\n   * @method updateContent\\n   */\\n\\n  RemainingTimeDisplay.prototype.updateContent = function updateContent() {\\n    if (this.player_.duration()) {\\n      var localizedText = this.localize('Remaining Time');\\n      var formattedTime = _utilsFormatTimeJs2['default'](this.player_.remainingTime());\\n      if (formattedTime !== this.formattedTime_) {\\n        this.formattedTime_ = formattedTime;\\n        this.contentEl_.innerHTML = '<span class=\\\"vjs-control-text\\\">' + localizedText + '</span> -' + formattedTime;\\n      }\\n    }\\n\\n    // Allows for smooth scrubbing, when player can't keep up.\\n    // var time = (this.player_.scrubbing()) ? this.player_.getCache().currentTime : this.player_.currentTime();\\n    // this.contentEl_.innerHTML = vjs.formatTime(time, this.player_.duration());\\n  };\\n\\n  return RemainingTimeDisplay;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('RemainingTimeDisplay', RemainingTimeDisplay);\\nexports['default'] = RemainingTimeDisplay;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../utils/dom.js\\\":142,\\\"../../utils/format-time.js\\\":145}],97:[function(_dereq_,module,exports){\\n/**\\n * @file time-divider.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n/**\\n * The separator between the current time and duration.\\n * Can be hidden if it's not needed in the design.\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class TimeDivider\\n */\\n\\nvar TimeDivider = (function (_Component) {\\n  _inherits(TimeDivider, _Component);\\n\\n  function TimeDivider() {\\n    _classCallCheck(this, TimeDivider);\\n\\n    _Component.apply(this, arguments);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  TimeDivider.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-time-control vjs-time-divider',\\n      innerHTML: '<div><span>/</span></div>'\\n    });\\n  };\\n\\n  return TimeDivider;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('TimeDivider', TimeDivider);\\nexports['default'] = TimeDivider;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67}],98:[function(_dereq_,module,exports){\\n/**\\n * @file track-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _menuMenuButtonJs = _dereq_('../menu/menu-button.js');\\n\\nvar _menuMenuButtonJs2 = _interopRequireDefault(_menuMenuButtonJs);\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\n/**\\n * The base class for buttons that toggle specific text track types (e.g. subtitles)\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends MenuButton\\n * @class TrackButton\\n */\\n\\nvar TrackButton = (function (_MenuButton) {\\n  _inherits(TrackButton, _MenuButton);\\n\\n  function TrackButton(player, options) {\\n    _classCallCheck(this, TrackButton);\\n\\n    var tracks = options.tracks;\\n\\n    _MenuButton.call(this, player, options);\\n\\n    if (this.items.length <= 1) {\\n      this.hide();\\n    }\\n\\n    if (!tracks) {\\n      return;\\n    }\\n\\n    var updateHandler = Fn.bind(this, this.update);\\n    tracks.addEventListener('removetrack', updateHandler);\\n    tracks.addEventListener('addtrack', updateHandler);\\n\\n    this.player_.on('dispose', function () {\\n      tracks.removeEventListener('removetrack', updateHandler);\\n      tracks.removeEventListener('addtrack', updateHandler);\\n    });\\n  }\\n\\n  return TrackButton;\\n})(_menuMenuButtonJs2['default']);\\n\\n_componentJs2['default'].registerComponent('TrackButton', TrackButton);\\nexports['default'] = TrackButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component.js\\\":67,\\\"../menu/menu-button.js\\\":109,\\\"../utils/fn.js\\\":144}],99:[function(_dereq_,module,exports){\\n/**\\n * @file volume-bar.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _sliderSliderJs = _dereq_('../../slider/slider.js');\\n\\nvar _sliderSliderJs2 = _interopRequireDefault(_sliderSliderJs);\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsFnJs = _dereq_('../../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\n// Required children\\n\\nvar _volumeLevelJs = _dereq_('./volume-level.js');\\n\\nvar _volumeLevelJs2 = _interopRequireDefault(_volumeLevelJs);\\n\\n/**\\n * The bar that contains the volume level and can be clicked on to adjust the level\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Slider\\n * @class VolumeBar\\n */\\n\\nvar VolumeBar = (function (_Slider) {\\n  _inherits(VolumeBar, _Slider);\\n\\n  function VolumeBar(player, options) {\\n    _classCallCheck(this, VolumeBar);\\n\\n    _Slider.call(this, player, options);\\n    this.on(player, 'volumechange', this.updateARIAAttributes);\\n    player.ready(Fn.bind(this, this.updateARIAAttributes));\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  VolumeBar.prototype.createEl = function createEl() {\\n    return _Slider.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-volume-bar vjs-slider-bar'\\n    }, {\\n      'aria-label': 'volume level'\\n    });\\n  };\\n\\n  /**\\n   * Handle mouse move on volume bar\\n   *\\n   * @method handleMouseMove\\n   */\\n\\n  VolumeBar.prototype.handleMouseMove = function handleMouseMove(event) {\\n    this.checkMuted();\\n    this.player_.volume(this.calculateDistance(event));\\n  };\\n\\n  VolumeBar.prototype.checkMuted = function checkMuted() {\\n    if (this.player_.muted()) {\\n      this.player_.muted(false);\\n    }\\n  };\\n\\n  /**\\n   * Get percent of volume level\\n   *\\n   * @retun {Number} Volume level percent\\n   * @method getPercent\\n   */\\n\\n  VolumeBar.prototype.getPercent = function getPercent() {\\n    if (this.player_.muted()) {\\n      return 0;\\n    } else {\\n      return this.player_.volume();\\n    }\\n  };\\n\\n  /**\\n   * Increase volume level for keyboard users\\n   *\\n   * @method stepForward\\n   */\\n\\n  VolumeBar.prototype.stepForward = function stepForward() {\\n    this.checkMuted();\\n    this.player_.volume(this.player_.volume() + 0.1);\\n  };\\n\\n  /**\\n   * Decrease volume level for keyboard users\\n   *\\n   * @method stepBack\\n   */\\n\\n  VolumeBar.prototype.stepBack = function stepBack() {\\n    this.checkMuted();\\n    this.player_.volume(this.player_.volume() - 0.1);\\n  };\\n\\n  /**\\n   * Update ARIA accessibility attributes\\n   *\\n   * @method updateARIAAttributes\\n   */\\n\\n  VolumeBar.prototype.updateARIAAttributes = function updateARIAAttributes() {\\n    // Current value of volume bar as a percentage\\n    var volume = (this.player_.volume() * 100).toFixed(2);\\n    this.el_.setAttribute('aria-valuenow', volume);\\n    this.el_.setAttribute('aria-valuetext', volume + '%');\\n  };\\n\\n  return VolumeBar;\\n})(_sliderSliderJs2['default']);\\n\\nVolumeBar.prototype.options_ = {\\n  children: ['volumeLevel'],\\n  'barName': 'volumeLevel'\\n};\\n\\nVolumeBar.prototype.playerEvent = 'volumechange';\\n\\n_componentJs2['default'].registerComponent('VolumeBar', VolumeBar);\\nexports['default'] = VolumeBar;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"../../slider/slider.js\\\":119,\\\"../../utils/fn.js\\\":144,\\\"./volume-level.js\\\":101}],100:[function(_dereq_,module,exports){\\n/**\\n * @file volume-control.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n// Required children\\n\\nvar _volumeBarJs = _dereq_('./volume-bar.js');\\n\\nvar _volumeBarJs2 = _interopRequireDefault(_volumeBarJs);\\n\\n/**\\n * The component for controlling the volume level\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class VolumeControl\\n */\\n\\nvar VolumeControl = (function (_Component) {\\n  _inherits(VolumeControl, _Component);\\n\\n  function VolumeControl(player, options) {\\n    _classCallCheck(this, VolumeControl);\\n\\n    _Component.call(this, player, options);\\n\\n    // hide volume controls when they're not supported by the current tech\\n    if (player.tech_ && player.tech_['featuresVolumeControl'] === false) {\\n      this.addClass('vjs-hidden');\\n    }\\n    this.on(player, 'loadstart', function () {\\n      if (player.tech_['featuresVolumeControl'] === false) {\\n        this.addClass('vjs-hidden');\\n      } else {\\n        this.removeClass('vjs-hidden');\\n      }\\n    });\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  VolumeControl.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-volume-control vjs-control'\\n    });\\n  };\\n\\n  return VolumeControl;\\n})(_componentJs2['default']);\\n\\nVolumeControl.prototype.options_ = {\\n  children: ['volumeBar']\\n};\\n\\n_componentJs2['default'].registerComponent('VolumeControl', VolumeControl);\\nexports['default'] = VolumeControl;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67,\\\"./volume-bar.js\\\":99}],101:[function(_dereq_,module,exports){\\n/**\\n * @file volume-level.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\n/**\\n * Shows volume level\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class VolumeLevel\\n */\\n\\nvar VolumeLevel = (function (_Component) {\\n  _inherits(VolumeLevel, _Component);\\n\\n  function VolumeLevel() {\\n    _classCallCheck(this, VolumeLevel);\\n\\n    _Component.apply(this, arguments);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  VolumeLevel.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-volume-level',\\n      innerHTML: '<span class=\\\"vjs-control-text\\\"></span>'\\n    });\\n  };\\n\\n  return VolumeLevel;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('VolumeLevel', VolumeLevel);\\nexports['default'] = VolumeLevel;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../component.js\\\":67}],102:[function(_dereq_,module,exports){\\n/**\\n * @file volume-menu-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _popupPopupJs = _dereq_('../popup/popup.js');\\n\\nvar _popupPopupJs2 = _interopRequireDefault(_popupPopupJs);\\n\\nvar _popupPopupButtonJs = _dereq_('../popup/popup-button.js');\\n\\nvar _popupPopupButtonJs2 = _interopRequireDefault(_popupPopupButtonJs);\\n\\nvar _muteToggleJs = _dereq_('./mute-toggle.js');\\n\\nvar _muteToggleJs2 = _interopRequireDefault(_muteToggleJs);\\n\\nvar _volumeControlVolumeBarJs = _dereq_('./volume-control/volume-bar.js');\\n\\nvar _volumeControlVolumeBarJs2 = _interopRequireDefault(_volumeControlVolumeBarJs);\\n\\n/**\\n * Button for volume popup\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends PopupButton\\n * @class VolumeMenuButton\\n */\\n\\nvar VolumeMenuButton = (function (_PopupButton) {\\n  _inherits(VolumeMenuButton, _PopupButton);\\n\\n  function VolumeMenuButton(player) {\\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n\\n    _classCallCheck(this, VolumeMenuButton);\\n\\n    // Default to inline\\n    if (options.inline === undefined) {\\n      options.inline = true;\\n    }\\n\\n    // If the vertical option isn't passed at all, default to true.\\n    if (options.vertical === undefined) {\\n      // If an inline volumeMenuButton is used, we should default to using\\n      // a horizontal slider for obvious reasons.\\n      if (options.inline) {\\n        options.vertical = false;\\n      } else {\\n        options.vertical = true;\\n      }\\n    }\\n\\n    // The vertical option needs to be set on the volumeBar as well,\\n    // since that will need to be passed along to the VolumeBar constructor\\n    options.volumeBar = options.volumeBar || {};\\n    options.volumeBar.vertical = !!options.vertical;\\n\\n    _PopupButton.call(this, player, options);\\n\\n    // Same listeners as MuteToggle\\n    this.on(player, 'volumechange', this.volumeUpdate);\\n    this.on(player, 'loadstart', this.volumeUpdate);\\n\\n    // hide mute toggle if the current tech doesn't support volume control\\n    function updateVisibility() {\\n      if (player.tech_ && player.tech_['featuresVolumeControl'] === false) {\\n        this.addClass('vjs-hidden');\\n      } else {\\n        this.removeClass('vjs-hidden');\\n      }\\n    }\\n\\n    updateVisibility.call(this);\\n    this.on(player, 'loadstart', updateVisibility);\\n\\n    this.on(this.volumeBar, ['slideractive', 'focus'], function () {\\n      this.addClass('vjs-slider-active');\\n    });\\n\\n    this.on(this.volumeBar, ['sliderinactive', 'blur'], function () {\\n      this.removeClass('vjs-slider-active');\\n    });\\n\\n    this.on(this.volumeBar, ['focus'], function () {\\n      this.addClass('vjs-lock-showing');\\n    });\\n\\n    this.on(this.volumeBar, ['blur'], function () {\\n      this.removeClass('vjs-lock-showing');\\n    });\\n  }\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  VolumeMenuButton.prototype.buildCSSClass = function buildCSSClass() {\\n    var orientationClass = '';\\n    if (!!this.options_.vertical) {\\n      orientationClass = 'vjs-volume-menu-button-vertical';\\n    } else {\\n      orientationClass = 'vjs-volume-menu-button-horizontal';\\n    }\\n\\n    return 'vjs-volume-menu-button ' + _PopupButton.prototype.buildCSSClass.call(this) + ' ' + orientationClass;\\n  };\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {Popup} The volume popup button\\n   * @method createPopup\\n   */\\n\\n  VolumeMenuButton.prototype.createPopup = function createPopup() {\\n    var popup = new _popupPopupJs2['default'](this.player_, {\\n      contentElType: 'div'\\n    });\\n\\n    var vb = new _volumeControlVolumeBarJs2['default'](this.player_, this.options_.volumeBar);\\n\\n    popup.addChild(vb);\\n\\n    this.menuContent = popup;\\n    this.volumeBar = vb;\\n\\n    this.attachVolumeBarEvents();\\n\\n    return popup;\\n  };\\n\\n  /**\\n   * Handle click on volume popup and calls super\\n   *\\n   * @method handleClick\\n   */\\n\\n  VolumeMenuButton.prototype.handleClick = function handleClick() {\\n    _muteToggleJs2['default'].prototype.handleClick.call(this);\\n    _PopupButton.prototype.handleClick.call(this);\\n  };\\n\\n  VolumeMenuButton.prototype.attachVolumeBarEvents = function attachVolumeBarEvents() {\\n    this.menuContent.on(['mousedown', 'touchdown'], Fn.bind(this, this.handleMouseDown));\\n  };\\n\\n  VolumeMenuButton.prototype.handleMouseDown = function handleMouseDown(event) {\\n    this.on(['mousemove', 'touchmove'], Fn.bind(this.volumeBar, this.volumeBar.handleMouseMove));\\n    this.on(this.el_.ownerDocument, ['mouseup', 'touchend'], this.handleMouseUp);\\n  };\\n\\n  VolumeMenuButton.prototype.handleMouseUp = function handleMouseUp(event) {\\n    this.off(['mousemove', 'touchmove'], Fn.bind(this.volumeBar, this.volumeBar.handleMouseMove));\\n  };\\n\\n  return VolumeMenuButton;\\n})(_popupPopupButtonJs2['default']);\\n\\nVolumeMenuButton.prototype.volumeUpdate = _muteToggleJs2['default'].prototype.update;\\nVolumeMenuButton.prototype.controlText_ = 'Mute';\\n\\n_componentJs2['default'].registerComponent('VolumeMenuButton', VolumeMenuButton);\\nexports['default'] = VolumeMenuButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component.js\\\":67,\\\"../popup/popup-button.js\\\":115,\\\"../popup/popup.js\\\":116,\\\"../utils/fn.js\\\":144,\\\"./mute-toggle.js\\\":73,\\\"./volume-control/volume-bar.js\\\":99}],103:[function(_dereq_,module,exports){\\n/**\\n * @file error-display.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _component = _dereq_('./component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _modalDialog = _dereq_('./modal-dialog');\\n\\nvar _modalDialog2 = _interopRequireDefault(_modalDialog);\\n\\nvar _utilsDom = _dereq_('./utils/dom');\\n\\nvar Dom = _interopRequireWildcard(_utilsDom);\\n\\nvar _utilsMergeOptions = _dereq_('./utils/merge-options');\\n\\nvar _utilsMergeOptions2 = _interopRequireDefault(_utilsMergeOptions);\\n\\n/**\\n * Display that an error has occurred making the video unplayable.\\n *\\n * @extends ModalDialog\\n * @class ErrorDisplay\\n */\\n\\nvar ErrorDisplay = (function (_ModalDialog) {\\n  _inherits(ErrorDisplay, _ModalDialog);\\n\\n  /**\\n   * Constructor for error display modal.\\n   *\\n   * @param  {Player} player\\n   * @param  {Object} [options]\\n   */\\n\\n  function ErrorDisplay(player, options) {\\n    _classCallCheck(this, ErrorDisplay);\\n\\n    _ModalDialog.call(this, player, options);\\n    this.on(player, 'error', this.open);\\n  }\\n\\n  /**\\n   * Include the old class for backward-compatibility.\\n   *\\n   * This can be removed in 6.0.\\n   *\\n   * @method buildCSSClass\\n   * @deprecated\\n   * @return {String}\\n   */\\n\\n  ErrorDisplay.prototype.buildCSSClass = function buildCSSClass() {\\n    return 'vjs-error-display ' + _ModalDialog.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Generates the modal content based on the player error.\\n   *\\n   * @return {String|Null}\\n   */\\n\\n  ErrorDisplay.prototype.content = function content() {\\n    var error = this.player().error();\\n    return error ? this.localize(error.message) : '';\\n  };\\n\\n  return ErrorDisplay;\\n})(_modalDialog2['default']);\\n\\nErrorDisplay.prototype.options_ = _utilsMergeOptions2['default'](_modalDialog2['default'].prototype.options_, {\\n  fillAlways: true,\\n  temporary: false,\\n  uncloseable: true\\n});\\n\\n_component2['default'].registerComponent('ErrorDisplay', ErrorDisplay);\\nexports['default'] = ErrorDisplay;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./component\\\":67,\\\"./modal-dialog\\\":112,\\\"./utils/dom\\\":142,\\\"./utils/merge-options\\\":148}],104:[function(_dereq_,module,exports){\\n/**\\n * @file event-target.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nvar _utilsEventsJs = _dereq_('./utils/events.js');\\n\\nvar Events = _interopRequireWildcard(_utilsEventsJs);\\n\\nvar EventTarget = function EventTarget() {};\\n\\nEventTarget.prototype.allowedEvents_ = {};\\n\\nEventTarget.prototype.on = function (type, fn) {\\n  // Remove the addEventListener alias before calling Events.on\\n  // so we don't get into an infinite type loop\\n  var ael = this.addEventListener;\\n  this.addEventListener = function () {};\\n  Events.on(this, type, fn);\\n  this.addEventListener = ael;\\n};\\nEventTarget.prototype.addEventListener = EventTarget.prototype.on;\\n\\nEventTarget.prototype.off = function (type, fn) {\\n  Events.off(this, type, fn);\\n};\\nEventTarget.prototype.removeEventListener = EventTarget.prototype.off;\\n\\nEventTarget.prototype.one = function (type, fn) {\\n  // Remove the addEventListener alias before calling Events.on\\n  // so we don't get into an infinite type loop\\n  var ael = this.addEventListener;\\n  this.addEventListener = function () {};\\n  Events.one(this, type, fn);\\n  this.addEventListener = ael;\\n};\\n\\nEventTarget.prototype.trigger = function (event) {\\n  var type = event.type || event;\\n\\n  if (typeof event === 'string') {\\n    event = {\\n      type: type\\n    };\\n  }\\n  event = Events.fixEvent(event);\\n\\n  if (this.allowedEvents_[type] && this['on' + type]) {\\n    this['on' + type](event);\\n  }\\n\\n  Events.trigger(this, event);\\n};\\n// The standard DOM EventTarget.dispatchEvent() is aliased to trigger()\\nEventTarget.prototype.dispatchEvent = EventTarget.prototype.trigger;\\n\\nexports['default'] = EventTarget;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./utils/events.js\\\":143}],105:[function(_dereq_,module,exports){\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _utilsLog = _dereq_('./utils/log');\\n\\nvar _utilsLog2 = _interopRequireDefault(_utilsLog);\\n\\n/*\\n * @file extend.js\\n *\\n * A combination of node inherits and babel's inherits (after transpile).\\n * Both work the same but node adds `super_` to the subClass\\n * and Bable adds the superClass as __proto__. Both seem useful.\\n */\\nvar _inherits = function _inherits(subClass, superClass) {\\n  if (typeof superClass !== 'function' && superClass !== null) {\\n    throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);\\n  }\\n\\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\\n    constructor: {\\n      value: subClass,\\n      enumerable: false,\\n      writable: true,\\n      configurable: true\\n    }\\n  });\\n\\n  if (superClass) {\\n    // node\\n    subClass.super_ = superClass;\\n  }\\n};\\n\\n/*\\n * Function for subclassing using the same inheritance that\\n * videojs uses internally\\n * ```js\\n * var Button = videojs.getComponent('Button');\\n * ```\\n * ```js\\n * var MyButton = videojs.extend(Button, {\\n *   constructor: function(player, options) {\\n *     Button.call(this, player, options);\\n *   },\\n *   onClick: function() {\\n *     // doSomething\\n *   }\\n * });\\n * ```\\n */\\nvar extendFn = function extendFn(superClass) {\\n  var subClassMethods = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n\\n  var subClass = function subClass() {\\n    superClass.apply(this, arguments);\\n  };\\n  var methods = {};\\n\\n  if (typeof subClassMethods === 'object') {\\n    if (typeof subClassMethods.init === 'function') {\\n      _utilsLog2['default'].warn('Constructor logic via init() is deprecated; please use constructor() instead.');\\n      subClassMethods.constructor = subClassMethods.init;\\n    }\\n    if (subClassMethods.constructor !== Object.prototype.constructor) {\\n      subClass = subClassMethods.constructor;\\n    }\\n    methods = subClassMethods;\\n  } else if (typeof subClassMethods === 'function') {\\n    subClass = subClassMethods;\\n  }\\n\\n  _inherits(subClass, superClass);\\n\\n  // Extend subObj's prototype with functions and other properties from props\\n  for (var name in methods) {\\n    if (methods.hasOwnProperty(name)) {\\n      subClass.prototype[name] = methods[name];\\n    }\\n  }\\n\\n  return subClass;\\n};\\n\\nexports['default'] = extendFn;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./utils/log\\\":147}],106:[function(_dereq_,module,exports){\\n/**\\n * @file fullscreen-api.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\n/*\\n * Store the browser-specific methods for the fullscreen API\\n * @type {Object|undefined}\\n * @private\\n */\\nvar FullscreenApi = {};\\n\\n// browser API methods\\n// map approach from Screenful.js - https://github.com/sindresorhus/screenfull.js\\nvar apiMap = [\\n// Spec: https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html\\n['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror'],\\n// WebKit\\n['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror'],\\n// Old WebKit (Safari 5.1)\\n['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitCurrentFullScreenElement', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitfullscreenerror'],\\n// Mozilla\\n['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror'],\\n// Microsoft\\n['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError']];\\n\\nvar specApi = apiMap[0];\\nvar browserApi = undefined;\\n\\n// determine the supported set of functions\\nfor (var i = 0; i < apiMap.length; i++) {\\n  // check for exitFullscreen function\\n  if (apiMap[i][1] in _globalDocument2['default']) {\\n    browserApi = apiMap[i];\\n    break;\\n  }\\n}\\n\\n// map the browser API names to the spec API names\\nif (browserApi) {\\n  for (var i = 0; i < browserApi.length; i++) {\\n    FullscreenApi[specApi[i]] = browserApi[i];\\n  }\\n}\\n\\nexports['default'] = FullscreenApi;\\nmodule.exports = exports['default'];\\n\\n},{\\\"global/document\\\":1}],107:[function(_dereq_,module,exports){\\n/**\\n * @file loading-spinner.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _component = _dereq_('./component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\n/* Loading Spinner\\n================================================================================ */\\n/**\\n * Loading spinner for waiting events\\n *\\n * @extends Component\\n * @class LoadingSpinner\\n */\\n\\nvar LoadingSpinner = (function (_Component) {\\n  _inherits(LoadingSpinner, _Component);\\n\\n  function LoadingSpinner() {\\n    _classCallCheck(this, LoadingSpinner);\\n\\n    _Component.apply(this, arguments);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @method createEl\\n   */\\n\\n  LoadingSpinner.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-loading-spinner',\\n      dir: 'ltr'\\n    });\\n  };\\n\\n  return LoadingSpinner;\\n})(_component2['default']);\\n\\n_component2['default'].registerComponent('LoadingSpinner', LoadingSpinner);\\nexports['default'] = LoadingSpinner;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./component\\\":67}],108:[function(_dereq_,module,exports){\\n/**\\n * @file media-error.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _objectAssign = _dereq_('object.assign');\\n\\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\\n\\n/*\\n * Custom MediaError class which mimics the standard HTML5 MediaError class.\\n *\\n * @param {Number|String|Object|MediaError} value\\n *        This can be of multiple types:\\n *        - Number: should be a standard error code\\n *        - String: an error message (the code will be 0)\\n *        - Object: arbitrary properties\\n *        - MediaError (native): used to populate a video.js MediaError object\\n *        - MediaError (video.js): will return itself if it's already a\\n *          video.js MediaError object.\\n */\\nfunction MediaError(value) {\\n\\n  // Allow redundant calls to this constructor to avoid having `instanceof`\\n  // checks peppered around the code.\\n  if (value instanceof MediaError) {\\n    return value;\\n  }\\n\\n  if (typeof value === 'number') {\\n    this.code = value;\\n  } else if (typeof value === 'string') {\\n    // default code is zero, so this is a custom error\\n    this.message = value;\\n  } else if (typeof value === 'object') {\\n\\n    // We assign the `code` property manually because native MediaError objects\\n    // do not expose it as an own/enumerable property of the object.\\n    if (typeof value.code === 'number') {\\n      this.code = value.code;\\n    }\\n\\n    _objectAssign2['default'](this, value);\\n  }\\n\\n  if (!this.message) {\\n    this.message = MediaError.defaultMessages[this.code] || '';\\n  }\\n}\\n\\n/*\\n * The error code that refers two one of the defined\\n * MediaError types\\n *\\n * @type {Number}\\n */\\nMediaError.prototype.code = 0;\\n\\n/*\\n * An optional message to be shown with the error.\\n * Message is not part of the HTML5 video spec\\n * but allows for more informative custom errors.\\n *\\n * @type {String}\\n */\\nMediaError.prototype.message = '';\\n\\n/*\\n * An optional status code that can be set by plugins\\n * to allow even more detail about the error.\\n * For example the HLS plugin might provide the specific\\n * HTTP status code that was returned when the error\\n * occurred, then allowing a custom error overlay\\n * to display more information.\\n *\\n * @type {Array}\\n */\\nMediaError.prototype.status = null;\\n\\nMediaError.errorTypes = ['MEDIA_ERR_CUSTOM', // = 0\\n'MEDIA_ERR_ABORTED', // = 1\\n'MEDIA_ERR_NETWORK', // = 2\\n'MEDIA_ERR_DECODE', // = 3\\n'MEDIA_ERR_SRC_NOT_SUPPORTED', // = 4\\n'MEDIA_ERR_ENCRYPTED' // = 5\\n];\\n\\nMediaError.defaultMessages = {\\n  1: 'You aborted the media playback',\\n  2: 'A network error caused the media download to fail part-way.',\\n  3: 'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.',\\n  4: 'The media could not be loaded, either because the server or network failed or because the format is not supported.',\\n  5: 'The media is encrypted and we do not have the keys to decrypt it.'\\n};\\n\\n// Add types as properties on MediaError\\n// e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;\\nfor (var errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {\\n  MediaError[MediaError.errorTypes[errNum]] = errNum;\\n  // values should be accessible on both the class and instance\\n  MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;\\n}\\n\\nexports['default'] = MediaError;\\nmodule.exports = exports['default'];\\n\\n},{\\\"object.assign\\\":45}],109:[function(_dereq_,module,exports){\\n/**\\n * @file menu-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _clickableComponentJs = _dereq_('../clickable-component.js');\\n\\nvar _clickableComponentJs2 = _interopRequireDefault(_clickableComponentJs);\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _menuJs = _dereq_('./menu.js');\\n\\nvar _menuJs2 = _interopRequireDefault(_menuJs);\\n\\nvar _utilsDomJs = _dereq_('../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsToTitleCaseJs = _dereq_('../utils/to-title-case.js');\\n\\nvar _utilsToTitleCaseJs2 = _interopRequireDefault(_utilsToTitleCaseJs);\\n\\n/**\\n * A button class with a popup menu\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Button\\n * @class MenuButton\\n */\\n\\nvar MenuButton = (function (_ClickableComponent) {\\n  _inherits(MenuButton, _ClickableComponent);\\n\\n  function MenuButton(player) {\\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n\\n    _classCallCheck(this, MenuButton);\\n\\n    _ClickableComponent.call(this, player, options);\\n\\n    this.update();\\n\\n    this.enabled_ = true;\\n\\n    this.el_.setAttribute('aria-haspopup', 'true');\\n    this.el_.setAttribute('role', 'menuitem');\\n    this.on('keydown', this.handleSubmenuKeyPress);\\n  }\\n\\n  /**\\n   * Update menu\\n   *\\n   * @method update\\n   */\\n\\n  MenuButton.prototype.update = function update() {\\n    var menu = this.createMenu();\\n\\n    if (this.menu) {\\n      this.removeChild(this.menu);\\n    }\\n\\n    this.menu = menu;\\n    this.addChild(menu);\\n\\n    /**\\n     * Track the state of the menu button\\n     *\\n     * @type {Boolean}\\n     * @private\\n     */\\n    this.buttonPressed_ = false;\\n    this.el_.setAttribute('aria-expanded', 'false');\\n\\n    if (this.items && this.items.length === 0) {\\n      this.hide();\\n    } else if (this.items && this.items.length > 1) {\\n      this.show();\\n    }\\n  };\\n\\n  /**\\n   * Create menu\\n   *\\n   * @return {Menu} The constructed menu\\n   * @method createMenu\\n   */\\n\\n  MenuButton.prototype.createMenu = function createMenu() {\\n    var menu = new _menuJs2['default'](this.player_);\\n\\n    // Add a title list item to the top\\n    if (this.options_.title) {\\n      var title = Dom.createEl('li', {\\n        className: 'vjs-menu-title',\\n        innerHTML: _utilsToTitleCaseJs2['default'](this.options_.title),\\n        tabIndex: -1\\n      });\\n      menu.children_.unshift(title);\\n      Dom.insertElFirst(title, menu.contentEl());\\n    }\\n\\n    this.items = this['createItems']();\\n\\n    if (this.items) {\\n      // Add menu items to the menu\\n      for (var i = 0; i < this.items.length; i++) {\\n        menu.addItem(this.items[i]);\\n      }\\n    }\\n\\n    return menu;\\n  };\\n\\n  /**\\n   * Create the list of menu items. Specific to each subclass.\\n   *\\n   * @method createItems\\n   */\\n\\n  MenuButton.prototype.createItems = function createItems() {};\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  MenuButton.prototype.createEl = function createEl() {\\n    return _ClickableComponent.prototype.createEl.call(this, 'div', {\\n      className: this.buildCSSClass()\\n    });\\n  };\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  MenuButton.prototype.buildCSSClass = function buildCSSClass() {\\n    var menuButtonClass = 'vjs-menu-button';\\n\\n    // If the inline option is passed, we want to use different styles altogether.\\n    if (this.options_.inline === true) {\\n      menuButtonClass += '-inline';\\n    } else {\\n      menuButtonClass += '-popup';\\n    }\\n\\n    return 'vjs-menu-button ' + menuButtonClass + ' ' + _ClickableComponent.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * When you click the button it adds focus, which\\n   * will show the menu indefinitely.\\n   * So we'll remove focus when the mouse leaves the button.\\n   * Focus is needed for tab navigation.\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @method handleClick\\n   */\\n\\n  MenuButton.prototype.handleClick = function handleClick() {\\n    this.one(this.menu.contentEl(), 'mouseleave', Fn.bind(this, function (e) {\\n      this.unpressButton();\\n      this.el_.blur();\\n    }));\\n    if (this.buttonPressed_) {\\n      this.unpressButton();\\n    } else {\\n      this.pressButton();\\n    }\\n  };\\n\\n  /**\\n   * Handle key press on menu\\n   *\\n   * @param {Object} event Key press event\\n   * @method handleKeyPress\\n   */\\n\\n  MenuButton.prototype.handleKeyPress = function handleKeyPress(event) {\\n\\n    // Escape (27) key or Tab (9) key unpress the 'button'\\n    if (event.which === 27 || event.which === 9) {\\n      if (this.buttonPressed_) {\\n        this.unpressButton();\\n      }\\n      // Don't preventDefault for Tab key - we still want to lose focus\\n      if (event.which !== 9) {\\n        event.preventDefault();\\n      }\\n      // Up (38) key or Down (40) key press the 'button'\\n    } else if (event.which === 38 || event.which === 40) {\\n        if (!this.buttonPressed_) {\\n          this.pressButton();\\n          event.preventDefault();\\n        }\\n      } else {\\n        _ClickableComponent.prototype.handleKeyPress.call(this, event);\\n      }\\n  };\\n\\n  /**\\n   * Handle key press on submenu\\n   *\\n   * @param {Object} event Key press event\\n   * @method handleSubmenuKeyPress\\n   */\\n\\n  MenuButton.prototype.handleSubmenuKeyPress = function handleSubmenuKeyPress(event) {\\n\\n    // Escape (27) key or Tab (9) key unpress the 'button'\\n    if (event.which === 27 || event.which === 9) {\\n      if (this.buttonPressed_) {\\n        this.unpressButton();\\n      }\\n      // Don't preventDefault for Tab key - we still want to lose focus\\n      if (event.which !== 9) {\\n        event.preventDefault();\\n      }\\n    }\\n  };\\n\\n  /**\\n   * Makes changes based on button pressed\\n   *\\n   * @method pressButton\\n   */\\n\\n  MenuButton.prototype.pressButton = function pressButton() {\\n    if (this.enabled_) {\\n      this.buttonPressed_ = true;\\n      this.menu.lockShowing();\\n      this.el_.setAttribute('aria-expanded', 'true');\\n      this.menu.focus(); // set the focus into the submenu\\n    }\\n  };\\n\\n  /**\\n   * Makes changes based on button unpressed\\n   *\\n   * @method unpressButton\\n   */\\n\\n  MenuButton.prototype.unpressButton = function unpressButton() {\\n    if (this.enabled_) {\\n      this.buttonPressed_ = false;\\n      this.menu.unlockShowing();\\n      this.el_.setAttribute('aria-expanded', 'false');\\n      this.el_.focus(); // Set focus back to this menu button\\n    }\\n  };\\n\\n  /**\\n   * Disable the menu button\\n   *\\n   * @return {Component}\\n   * @method disable\\n   */\\n\\n  MenuButton.prototype.disable = function disable() {\\n    // Unpress, but don't force focus on this button\\n    this.buttonPressed_ = false;\\n    this.menu.unlockShowing();\\n    this.el_.setAttribute('aria-expanded', 'false');\\n\\n    this.enabled_ = false;\\n\\n    return _ClickableComponent.prototype.disable.call(this);\\n  };\\n\\n  /**\\n   * Enable the menu button\\n   *\\n   * @return {Component}\\n   * @method disable\\n   */\\n\\n  MenuButton.prototype.enable = function enable() {\\n    this.enabled_ = true;\\n\\n    return _ClickableComponent.prototype.enable.call(this);\\n  };\\n\\n  return MenuButton;\\n})(_clickableComponentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('MenuButton', MenuButton);\\nexports['default'] = MenuButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../clickable-component.js\\\":65,\\\"../component.js\\\":67,\\\"../utils/dom.js\\\":142,\\\"../utils/fn.js\\\":144,\\\"../utils/to-title-case.js\\\":151,\\\"./menu.js\\\":111}],110:[function(_dereq_,module,exports){\\n/**\\n * @file menu-item.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _clickableComponentJs = _dereq_('../clickable-component.js');\\n\\nvar _clickableComponentJs2 = _interopRequireDefault(_clickableComponentJs);\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _objectAssign = _dereq_('object.assign');\\n\\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\\n\\n/**\\n * The component for a menu item. `<li>`\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Button\\n * @class MenuItem\\n */\\n\\nvar MenuItem = (function (_ClickableComponent) {\\n  _inherits(MenuItem, _ClickableComponent);\\n\\n  function MenuItem(player, options) {\\n    _classCallCheck(this, MenuItem);\\n\\n    _ClickableComponent.call(this, player, options);\\n\\n    this.selectable = options['selectable'];\\n\\n    this.selected(options['selected']);\\n\\n    if (this.selectable) {\\n      // TODO: May need to be either menuitemcheckbox or menuitemradio,\\n      //       and may need logical grouping of menu items.\\n      this.el_.setAttribute('role', 'menuitemcheckbox');\\n    } else {\\n      this.el_.setAttribute('role', 'menuitem');\\n    }\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @param {String=} type Desc\\n   * @param {Object=} props Desc\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  MenuItem.prototype.createEl = function createEl(type, props, attrs) {\\n    return _ClickableComponent.prototype.createEl.call(this, 'li', _objectAssign2['default']({\\n      className: 'vjs-menu-item',\\n      innerHTML: this.localize(this.options_['label']),\\n      tabIndex: -1\\n    }, props), attrs);\\n  };\\n\\n  /**\\n   * Handle a click on the menu item, and set it to selected\\n   *\\n   * @method handleClick\\n   */\\n\\n  MenuItem.prototype.handleClick = function handleClick() {\\n    this.selected(true);\\n  };\\n\\n  /**\\n   * Set this menu item as selected or not\\n   *\\n   * @param  {Boolean} selected\\n   * @method selected\\n   */\\n\\n  MenuItem.prototype.selected = function selected(_selected) {\\n    if (this.selectable) {\\n      if (_selected) {\\n        this.addClass('vjs-selected');\\n        this.el_.setAttribute('aria-checked', 'true');\\n        // aria-checked isn't fully supported by browsers/screen readers,\\n        // so indicate selected state to screen reader in the control text.\\n        this.controlText(', selected');\\n      } else {\\n        this.removeClass('vjs-selected');\\n        this.el_.setAttribute('aria-checked', 'false');\\n        // Indicate un-selected state to screen reader\\n        // Note that a space clears out the selected state text\\n        this.controlText(' ');\\n      }\\n    }\\n  };\\n\\n  return MenuItem;\\n})(_clickableComponentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('MenuItem', MenuItem);\\nexports['default'] = MenuItem;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../clickable-component.js\\\":65,\\\"../component.js\\\":67,\\\"object.assign\\\":45}],111:[function(_dereq_,module,exports){\\n/**\\n * @file menu.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsDomJs = _dereq_('../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsEventsJs = _dereq_('../utils/events.js');\\n\\nvar Events = _interopRequireWildcard(_utilsEventsJs);\\n\\n/**\\n * The Menu component is used to build pop up menus, including subtitle and\\n * captions selection menus.\\n *\\n * @extends Component\\n * @class Menu\\n */\\n\\nvar Menu = (function (_Component) {\\n  _inherits(Menu, _Component);\\n\\n  function Menu(player, options) {\\n    _classCallCheck(this, Menu);\\n\\n    _Component.call(this, player, options);\\n\\n    this.focusedChild_ = -1;\\n\\n    this.on('keydown', this.handleKeyPress);\\n  }\\n\\n  /**\\n   * Add a menu item to the menu\\n   *\\n   * @param {Object|String} component Component or component type to add\\n   * @method addItem\\n   */\\n\\n  Menu.prototype.addItem = function addItem(component) {\\n    this.addChild(component);\\n    component.on('click', Fn.bind(this, function () {\\n      this.unlockShowing();\\n      //TODO: Need to set keyboard focus back to the menuButton\\n    }));\\n  };\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  Menu.prototype.createEl = function createEl() {\\n    var contentElType = this.options_.contentElType || 'ul';\\n    this.contentEl_ = Dom.createEl(contentElType, {\\n      className: 'vjs-menu-content'\\n    });\\n    this.contentEl_.setAttribute('role', 'menu');\\n    var el = _Component.prototype.createEl.call(this, 'div', {\\n      append: this.contentEl_,\\n      className: 'vjs-menu'\\n    });\\n    el.setAttribute('role', 'presentation');\\n    el.appendChild(this.contentEl_);\\n\\n    // Prevent clicks from bubbling up. Needed for Menu Buttons,\\n    // where a click on the parent is significant\\n    Events.on(el, 'click', function (event) {\\n      event.preventDefault();\\n      event.stopImmediatePropagation();\\n    });\\n\\n    return el;\\n  };\\n\\n  /**\\n   * Handle key press for menu\\n   *\\n   * @param {Object} event Event object\\n   * @method handleKeyPress\\n   */\\n\\n  Menu.prototype.handleKeyPress = function handleKeyPress(event) {\\n    if (event.which === 37 || event.which === 40) {\\n      // Left and Down Arrows\\n      event.preventDefault();\\n      this.stepForward();\\n    } else if (event.which === 38 || event.which === 39) {\\n      // Up and Right Arrows\\n      event.preventDefault();\\n      this.stepBack();\\n    }\\n  };\\n\\n  /**\\n   * Move to next (lower) menu item for keyboard users\\n   *\\n   * @method stepForward\\n   */\\n\\n  Menu.prototype.stepForward = function stepForward() {\\n    var stepChild = 0;\\n\\n    if (this.focusedChild_ !== undefined) {\\n      stepChild = this.focusedChild_ + 1;\\n    }\\n    this.focus(stepChild);\\n  };\\n\\n  /**\\n   * Move to previous (higher) menu item for keyboard users\\n   *\\n   * @method stepBack\\n   */\\n\\n  Menu.prototype.stepBack = function stepBack() {\\n    var stepChild = 0;\\n\\n    if (this.focusedChild_ !== undefined) {\\n      stepChild = this.focusedChild_ - 1;\\n    }\\n    this.focus(stepChild);\\n  };\\n\\n  /**\\n   * Set focus on a menu item in the menu\\n   *\\n   * @param {Object|String} item Index of child item set focus on\\n   * @method focus\\n   */\\n\\n  Menu.prototype.focus = function focus() {\\n    var item = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\\n\\n    var children = this.children().slice();\\n    var haveTitle = children.length && children[0].className && /vjs-menu-title/.test(children[0].className);\\n\\n    if (haveTitle) {\\n      children.shift();\\n    }\\n\\n    if (children.length > 0) {\\n      if (item < 0) {\\n        item = 0;\\n      } else if (item >= children.length) {\\n        item = children.length - 1;\\n      }\\n\\n      this.focusedChild_ = item;\\n\\n      children[item].el_.focus();\\n    }\\n  };\\n\\n  return Menu;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('Menu', Menu);\\nexports['default'] = Menu;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component.js\\\":67,\\\"../utils/dom.js\\\":142,\\\"../utils/events.js\\\":143,\\\"../utils/fn.js\\\":144}],112:[function(_dereq_,module,exports){\\n/**\\n * @file modal-dialog.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _utilsDom = _dereq_('./utils/dom');\\n\\nvar Dom = _interopRequireWildcard(_utilsDom);\\n\\nvar _utilsFn = _dereq_('./utils/fn');\\n\\nvar Fn = _interopRequireWildcard(_utilsFn);\\n\\nvar _utilsLog = _dereq_('./utils/log');\\n\\nvar _utilsLog2 = _interopRequireDefault(_utilsLog);\\n\\nvar _component = _dereq_('./component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _closeButton = _dereq_('./close-button');\\n\\nvar _closeButton2 = _interopRequireDefault(_closeButton);\\n\\nvar MODAL_CLASS_NAME = 'vjs-modal-dialog';\\nvar ESC = 27;\\n\\n/**\\n * The `ModalDialog` displays over the video and its controls, which blocks\\n * interaction with the player until it is closed.\\n *\\n * Modal dialogs include a \\\"Close\\\" button and will close when that button\\n * is activated - or when ESC is pressed anywhere.\\n *\\n * @extends Component\\n * @class ModalDialog\\n */\\n\\nvar ModalDialog = (function (_Component) {\\n  _inherits(ModalDialog, _Component);\\n\\n  /**\\n   * Constructor for modals.\\n   *\\n   * @param  {Player} player\\n   * @param  {Object} [options]\\n   * @param  {Mixed} [options.content=undefined]\\n   *         Provide customized content for this modal.\\n   *\\n   * @param  {String} [options.description]\\n   *         A text description for the modal, primarily for accessibility.\\n   *\\n   * @param  {Boolean} [options.fillAlways=false]\\n   *         Normally, modals are automatically filled only the first time\\n   *         they open. This tells the modal to refresh its content\\n   *         every time it opens.\\n   *\\n   * @param  {String} [options.label]\\n   *         A text label for the modal, primarily for accessibility.\\n   *\\n   * @param  {Boolean} [options.temporary=true]\\n   *         If `true`, the modal can only be opened once; it will be\\n   *         disposed as soon as it's closed.\\n   *\\n   * @param  {Boolean} [options.uncloseable=false]\\n   *         If `true`, the user will not be able to close the modal\\n   *         through the UI in the normal ways. Programmatic closing is\\n   *         still possible.\\n   *\\n   */\\n\\n  function ModalDialog(player, options) {\\n    _classCallCheck(this, ModalDialog);\\n\\n    _Component.call(this, player, options);\\n    this.opened_ = this.hasBeenOpened_ = this.hasBeenFilled_ = false;\\n\\n    this.closeable(!this.options_.uncloseable);\\n    this.content(this.options_.content);\\n\\n    // Make sure the contentEl is defined AFTER any children are initialized\\n    // because we only want the contents of the modal in the contentEl\\n    // (not the UI elements like the close button).\\n    this.contentEl_ = Dom.createEl('div', {\\n      className: MODAL_CLASS_NAME + '-content'\\n    }, {\\n      role: 'document'\\n    });\\n\\n    this.descEl_ = Dom.createEl('p', {\\n      className: MODAL_CLASS_NAME + '-description vjs-offscreen',\\n      id: this.el().getAttribute('aria-describedby')\\n    });\\n\\n    Dom.textContent(this.descEl_, this.description());\\n    this.el_.appendChild(this.descEl_);\\n    this.el_.appendChild(this.contentEl_);\\n  }\\n\\n  /*\\n   * Modal dialog default options.\\n   *\\n   * @type {Object}\\n   * @private\\n   */\\n\\n  /**\\n   * Create the modal's DOM element\\n   *\\n   * @method createEl\\n   * @return {Element}\\n   */\\n\\n  ModalDialog.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: this.buildCSSClass(),\\n      tabIndex: -1\\n    }, {\\n      'aria-describedby': this.id() + '_description',\\n      'aria-hidden': 'true',\\n      'aria-label': this.label(),\\n      role: 'dialog'\\n    });\\n  };\\n\\n  /**\\n   * Build the modal's CSS class.\\n   *\\n   * @method buildCSSClass\\n   * @return {String}\\n   */\\n\\n  ModalDialog.prototype.buildCSSClass = function buildCSSClass() {\\n    return MODAL_CLASS_NAME + ' vjs-hidden ' + _Component.prototype.buildCSSClass.call(this);\\n  };\\n\\n  /**\\n   * Handles key presses on the document, looking for ESC, which closes\\n   * the modal.\\n   *\\n   * @method handleKeyPress\\n   * @param  {Event} e\\n   */\\n\\n  ModalDialog.prototype.handleKeyPress = function handleKeyPress(e) {\\n    if (e.which === ESC && this.closeable()) {\\n      this.close();\\n    }\\n  };\\n\\n  /**\\n   * Returns the label string for this modal. Primarily used for accessibility.\\n   *\\n   * @return {String}\\n   */\\n\\n  ModalDialog.prototype.label = function label() {\\n    return this.options_.label || this.localize('Modal Window');\\n  };\\n\\n  /**\\n   * Returns the description string for this modal. Primarily used for\\n   * accessibility.\\n   *\\n   * @return {String}\\n   */\\n\\n  ModalDialog.prototype.description = function description() {\\n    var desc = this.options_.description || this.localize('This is a modal window.');\\n\\n    // Append a universal closeability message if the modal is closeable.\\n    if (this.closeable()) {\\n      desc += ' ' + this.localize('This modal can be closed by pressing the Escape key or activating the close button.');\\n    }\\n\\n    return desc;\\n  };\\n\\n  /**\\n   * Opens the modal.\\n   *\\n   * @method open\\n   * @return {ModalDialog}\\n   */\\n\\n  ModalDialog.prototype.open = function open() {\\n    if (!this.opened_) {\\n      var player = this.player();\\n\\n      this.trigger('beforemodalopen');\\n      this.opened_ = true;\\n\\n      // Fill content if the modal has never opened before and\\n      // never been filled.\\n      if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {\\n        this.fill();\\n      }\\n\\n      // If the player was playing, pause it and take note of its previously\\n      // playing state.\\n      this.wasPlaying_ = !player.paused();\\n\\n      if (this.wasPlaying_) {\\n        player.pause();\\n      }\\n\\n      if (this.closeable()) {\\n        this.on(this.el_.ownerDocument, 'keydown', Fn.bind(this, this.handleKeyPress));\\n      }\\n\\n      player.controls(false);\\n      this.show();\\n      this.el().setAttribute('aria-hidden', 'false');\\n      this.trigger('modalopen');\\n      this.hasBeenOpened_ = true;\\n    }\\n    return this;\\n  };\\n\\n  /**\\n   * Whether or not the modal is opened currently.\\n   *\\n   * @method opened\\n   * @param  {Boolean} [value]\\n   *         If given, it will open (`true`) or close (`false`) the modal.\\n   *\\n   * @return {Boolean}\\n   */\\n\\n  ModalDialog.prototype.opened = function opened(value) {\\n    if (typeof value === 'boolean') {\\n      this[value ? 'open' : 'close']();\\n    }\\n    return this.opened_;\\n  };\\n\\n  /**\\n   * Closes the modal.\\n   *\\n   * @method close\\n   * @return {ModalDialog}\\n   */\\n\\n  ModalDialog.prototype.close = function close() {\\n    if (this.opened_) {\\n      var player = this.player();\\n\\n      this.trigger('beforemodalclose');\\n      this.opened_ = false;\\n\\n      if (this.wasPlaying_) {\\n        player.play();\\n      }\\n\\n      if (this.closeable()) {\\n        this.off(this.el_.ownerDocument, 'keydown', Fn.bind(this, this.handleKeyPress));\\n      }\\n\\n      player.controls(true);\\n      this.hide();\\n      this.el().setAttribute('aria-hidden', 'true');\\n      this.trigger('modalclose');\\n\\n      if (this.options_.temporary) {\\n        this.dispose();\\n      }\\n    }\\n    return this;\\n  };\\n\\n  /**\\n   * Whether or not the modal is closeable via the UI.\\n   *\\n   * @method closeable\\n   * @param  {Boolean} [value]\\n   *         If given as a Boolean, it will set the `closeable` option.\\n   *\\n   * @return {Boolean}\\n   */\\n\\n  ModalDialog.prototype.closeable = function closeable(value) {\\n    if (typeof value === 'boolean') {\\n      var closeable = this.closeable_ = !!value;\\n      var _close = this.getChild('closeButton');\\n\\n      // If this is being made closeable and has no close button, add one.\\n      if (closeable && !_close) {\\n\\n        // The close button should be a child of the modal - not its\\n        // content element, so temporarily change the content element.\\n        var temp = this.contentEl_;\\n        this.contentEl_ = this.el_;\\n        _close = this.addChild('closeButton', { controlText: 'Close Modal Dialog' });\\n        this.contentEl_ = temp;\\n        this.on(_close, 'close', this.close);\\n      }\\n\\n      // If this is being made uncloseable and has a close button, remove it.\\n      if (!closeable && _close) {\\n        this.off(_close, 'close', this.close);\\n        this.removeChild(_close);\\n        _close.dispose();\\n      }\\n    }\\n    return this.closeable_;\\n  };\\n\\n  /**\\n   * Fill the modal's content element with the modal's \\\"content\\\" option.\\n   *\\n   * The content element will be emptied before this change takes place.\\n   *\\n   * @method fill\\n   * @return {ModalDialog}\\n   */\\n\\n  ModalDialog.prototype.fill = function fill() {\\n    return this.fillWith(this.content());\\n  };\\n\\n  /**\\n   * Fill the modal's content element with arbitrary content.\\n   *\\n   * The content element will be emptied before this change takes place.\\n   *\\n   * @method fillWith\\n   * @param  {Mixed} [content]\\n   *         The same rules apply to this as apply to the `content` option.\\n   *\\n   * @return {ModalDialog}\\n   */\\n\\n  ModalDialog.prototype.fillWith = function fillWith(content) {\\n    var contentEl = this.contentEl();\\n    var parentEl = contentEl.parentNode;\\n    var nextSiblingEl = contentEl.nextSibling;\\n\\n    this.trigger('beforemodalfill');\\n    this.hasBeenFilled_ = true;\\n\\n    // Detach the content element from the DOM before performing\\n    // manipulation to avoid modifying the live DOM multiple times.\\n    parentEl.removeChild(contentEl);\\n    this.empty();\\n    Dom.insertContent(contentEl, content);\\n    this.trigger('modalfill');\\n\\n    // Re-inject the re-filled content element.\\n    if (nextSiblingEl) {\\n      parentEl.insertBefore(contentEl, nextSiblingEl);\\n    } else {\\n      parentEl.appendChild(contentEl);\\n    }\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Empties the content element.\\n   *\\n   * This happens automatically anytime the modal is filled.\\n   *\\n   * @method empty\\n   * @return {ModalDialog}\\n   */\\n\\n  ModalDialog.prototype.empty = function empty() {\\n    this.trigger('beforemodalempty');\\n    Dom.emptyEl(this.contentEl());\\n    this.trigger('modalempty');\\n    return this;\\n  };\\n\\n  /**\\n   * Gets or sets the modal content, which gets normalized before being\\n   * rendered into the DOM.\\n   *\\n   * This does not update the DOM or fill the modal, but it is called during\\n   * that process.\\n   *\\n   * @method content\\n   * @param  {Mixed} [value]\\n   *         If defined, sets the internal content value to be used on the\\n   *         next call(s) to `fill`. This value is normalized before being\\n   *         inserted. To \\\"clear\\\" the internal content value, pass `null`.\\n   *\\n   * @return {Mixed}\\n   */\\n\\n  ModalDialog.prototype.content = function content(value) {\\n    if (typeof value !== 'undefined') {\\n      this.content_ = value;\\n    }\\n    return this.content_;\\n  };\\n\\n  return ModalDialog;\\n})(_component2['default']);\\n\\nModalDialog.prototype.options_ = {\\n  temporary: true\\n};\\n\\n_component2['default'].registerComponent('ModalDialog', ModalDialog);\\nexports['default'] = ModalDialog;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./close-button\\\":66,\\\"./component\\\":67,\\\"./utils/dom\\\":142,\\\"./utils/fn\\\":144,\\\"./utils/log\\\":147}],113:[function(_dereq_,module,exports){\\n/**\\n * @file player.js\\n */\\n// Subclasses Component\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('./component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _utilsEventsJs = _dereq_('./utils/events.js');\\n\\nvar Events = _interopRequireWildcard(_utilsEventsJs);\\n\\nvar _utilsDomJs = _dereq_('./utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFnJs = _dereq_('./utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsGuidJs = _dereq_('./utils/guid.js');\\n\\nvar Guid = _interopRequireWildcard(_utilsGuidJs);\\n\\nvar _utilsBrowserJs = _dereq_('./utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\nvar _utilsLogJs = _dereq_('./utils/log.js');\\n\\nvar _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);\\n\\nvar _utilsToTitleCaseJs = _dereq_('./utils/to-title-case.js');\\n\\nvar _utilsToTitleCaseJs2 = _interopRequireDefault(_utilsToTitleCaseJs);\\n\\nvar _utilsTimeRangesJs = _dereq_('./utils/time-ranges.js');\\n\\nvar _utilsBufferJs = _dereq_('./utils/buffer.js');\\n\\nvar _utilsStylesheetJs = _dereq_('./utils/stylesheet.js');\\n\\nvar stylesheet = _interopRequireWildcard(_utilsStylesheetJs);\\n\\nvar _fullscreenApiJs = _dereq_('./fullscreen-api.js');\\n\\nvar _fullscreenApiJs2 = _interopRequireDefault(_fullscreenApiJs);\\n\\nvar _mediaErrorJs = _dereq_('./media-error.js');\\n\\nvar _mediaErrorJs2 = _interopRequireDefault(_mediaErrorJs);\\n\\nvar _safeJsonParseTuple = _dereq_('safe-json-parse/tuple');\\n\\nvar _safeJsonParseTuple2 = _interopRequireDefault(_safeJsonParseTuple);\\n\\nvar _objectAssign = _dereq_('object.assign');\\n\\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\\n\\nvar _utilsMergeOptionsJs = _dereq_('./utils/merge-options.js');\\n\\nvar _utilsMergeOptionsJs2 = _interopRequireDefault(_utilsMergeOptionsJs);\\n\\nvar _tracksTextTrackListConverterJs = _dereq_('./tracks/text-track-list-converter.js');\\n\\nvar _tracksTextTrackListConverterJs2 = _interopRequireDefault(_tracksTextTrackListConverterJs);\\n\\nvar _tracksAudioTrackListJs = _dereq_('./tracks/audio-track-list.js');\\n\\nvar _tracksAudioTrackListJs2 = _interopRequireDefault(_tracksAudioTrackListJs);\\n\\nvar _tracksVideoTrackListJs = _dereq_('./tracks/video-track-list.js');\\n\\nvar _tracksVideoTrackListJs2 = _interopRequireDefault(_tracksVideoTrackListJs);\\n\\n// Include required child components (importing also registers them)\\n\\nvar _techLoaderJs = _dereq_('./tech/loader.js');\\n\\nvar _techLoaderJs2 = _interopRequireDefault(_techLoaderJs);\\n\\nvar _posterImageJs = _dereq_('./poster-image.js');\\n\\nvar _posterImageJs2 = _interopRequireDefault(_posterImageJs);\\n\\nvar _tracksTextTrackDisplayJs = _dereq_('./tracks/text-track-display.js');\\n\\nvar _tracksTextTrackDisplayJs2 = _interopRequireDefault(_tracksTextTrackDisplayJs);\\n\\nvar _loadingSpinnerJs = _dereq_('./loading-spinner.js');\\n\\nvar _loadingSpinnerJs2 = _interopRequireDefault(_loadingSpinnerJs);\\n\\nvar _bigPlayButtonJs = _dereq_('./big-play-button.js');\\n\\nvar _bigPlayButtonJs2 = _interopRequireDefault(_bigPlayButtonJs);\\n\\nvar _controlBarControlBarJs = _dereq_('./control-bar/control-bar.js');\\n\\nvar _controlBarControlBarJs2 = _interopRequireDefault(_controlBarControlBarJs);\\n\\nvar _errorDisplayJs = _dereq_('./error-display.js');\\n\\nvar _errorDisplayJs2 = _interopRequireDefault(_errorDisplayJs);\\n\\nvar _tracksTextTrackSettingsJs = _dereq_('./tracks/text-track-settings.js');\\n\\nvar _tracksTextTrackSettingsJs2 = _interopRequireDefault(_tracksTextTrackSettingsJs);\\n\\nvar _modalDialog = _dereq_('./modal-dialog');\\n\\nvar _modalDialog2 = _interopRequireDefault(_modalDialog);\\n\\n// Require html5 tech, at least for disposing the original video tag\\n\\nvar _techTechJs = _dereq_('./tech/tech.js');\\n\\nvar _techTechJs2 = _interopRequireDefault(_techTechJs);\\n\\nvar _techHtml5Js = _dereq_('./tech/html5.js');\\n\\nvar _techHtml5Js2 = _interopRequireDefault(_techHtml5Js);\\n\\n/**\\n * An instance of the `Player` class is created when any of the Video.js setup methods are used to initialize a video.\\n * ```js\\n * var myPlayer = videojs('example_video_1');\\n * ```\\n * In the following example, the `data-setup` attribute tells the Video.js library to create a player instance when the library is ready.\\n * ```html\\n * <video id=\\\"example_video_1\\\" data-setup='{}' controls>\\n *   <source src=\\\"my-source.mp4\\\" type=\\\"video/mp4\\\">\\n * </video>\\n * ```\\n * After an instance has been created it can be accessed globally using `Video('example_video_1')`.\\n *\\n * @param {Element} tag        The original video tag used for configuring options\\n * @param {Object=} options    Object of option names and values\\n * @param {Function=} ready    Ready callback function\\n * @extends Component\\n * @class Player\\n */\\n\\nvar Player = (function (_Component) {\\n  _inherits(Player, _Component);\\n\\n  /**\\n   * player's constructor function\\n   *\\n   * @constructs\\n   * @method init\\n   * @param {Element} tag        The original video tag used for configuring options\\n   * @param {Object=} options    Player options\\n   * @param {Function=} ready    Ready callback function\\n   */\\n\\n  function Player(tag, options, ready) {\\n    var _this = this;\\n\\n    _classCallCheck(this, Player);\\n\\n    // Make sure tag ID exists\\n    tag.id = tag.id || 'vjs_video_' + Guid.newGUID();\\n\\n    // Set Options\\n    // The options argument overrides options set in the video tag\\n    // which overrides globally set options.\\n    // This latter part coincides with the load order\\n    // (tag must exist before Player)\\n    options = _objectAssign2['default'](Player.getTagSettings(tag), options);\\n\\n    // Delay the initialization of children because we need to set up\\n    // player properties first, and can't use `this` before `super()`\\n    options.initChildren = false;\\n\\n    // Same with creating the element\\n    options.createEl = false;\\n\\n    // we don't want the player to report touch activity on itself\\n    // see enableTouchActivity in Component\\n    options.reportTouchActivity = false;\\n\\n    // If language is not set, get the closest lang attribute\\n    if (!options.language) {\\n      if (typeof tag.closest === 'function') {\\n        var closest = tag.closest('[lang]');\\n        if (closest) {\\n          options.language = closest.getAttribute('lang');\\n        }\\n      } else {\\n        var element = tag;\\n        while (element && element.nodeType === 1) {\\n          if (Dom.getElAttributes(element).hasOwnProperty('lang')) {\\n            options.language = element.getAttribute('lang');\\n            break;\\n          }\\n          element = element.parentNode;\\n        }\\n      }\\n    }\\n\\n    // Run base component initializing with new options\\n    _Component.call(this, null, options, ready);\\n\\n    // if the global option object was accidentally blown away by\\n    // someone, bail early with an informative error\\n    if (!this.options_ || !this.options_.techOrder || !this.options_.techOrder.length) {\\n      throw new Error('No techOrder specified. Did you overwrite ' + 'videojs.options instead of just changing the ' + 'properties you want to override?');\\n    }\\n\\n    this.tag = tag; // Store the original tag used to set options\\n\\n    // Store the tag attributes used to restore html5 element\\n    this.tagAttributes = tag && Dom.getElAttributes(tag);\\n\\n    // Update current language\\n    this.language(this.options_.language);\\n\\n    // Update Supported Languages\\n    if (options.languages) {\\n      (function () {\\n        // Normalise player option languages to lowercase\\n        var languagesToLower = {};\\n\\n        Object.getOwnPropertyNames(options.languages).forEach(function (name) {\\n          languagesToLower[name.toLowerCase()] = options.languages[name];\\n        });\\n        _this.languages_ = languagesToLower;\\n      })();\\n    } else {\\n      this.languages_ = Player.prototype.options_.languages;\\n    }\\n\\n    // Cache for video property values.\\n    this.cache_ = {};\\n\\n    // Set poster\\n    this.poster_ = options.poster || '';\\n\\n    // Set controls\\n    this.controls_ = !!options.controls;\\n\\n    // Original tag settings stored in options\\n    // now remove immediately so native controls don't flash.\\n    // May be turned back on by HTML5 tech if nativeControlsForTouch is true\\n    tag.controls = false;\\n\\n    /*\\n     * Store the internal state of scrubbing\\n     *\\n     * @private\\n     * @return {Boolean} True if the user is scrubbing\\n     */\\n    this.scrubbing_ = false;\\n\\n    this.el_ = this.createEl();\\n\\n    // We also want to pass the original player options to each component and plugin\\n    // as well so they don't need to reach back into the player for options later.\\n    // We also need to do another copy of this.options_ so we don't end up with\\n    // an infinite loop.\\n    var playerOptionsCopy = _utilsMergeOptionsJs2['default'](this.options_);\\n\\n    // Load plugins\\n    if (options.plugins) {\\n      (function () {\\n        var plugins = options.plugins;\\n\\n        Object.getOwnPropertyNames(plugins).forEach(function (name) {\\n          if (typeof this[name] === 'function') {\\n            this[name](plugins[name]);\\n          } else {\\n            _utilsLogJs2['default'].error('Unable to find plugin:', name);\\n          }\\n        }, _this);\\n      })();\\n    }\\n\\n    this.options_.playerOptions = playerOptionsCopy;\\n\\n    this.initChildren();\\n\\n    // Set isAudio based on whether or not an audio tag was used\\n    this.isAudio(tag.nodeName.toLowerCase() === 'audio');\\n\\n    // Update controls className. Can't do this when the controls are initially\\n    // set because the element doesn't exist yet.\\n    if (this.controls()) {\\n      this.addClass('vjs-controls-enabled');\\n    } else {\\n      this.addClass('vjs-controls-disabled');\\n    }\\n\\n    // Set ARIA label and region role depending on player type\\n    this.el_.setAttribute('role', 'region');\\n    if (this.isAudio()) {\\n      this.el_.setAttribute('aria-label', 'audio player');\\n    } else {\\n      this.el_.setAttribute('aria-label', 'video player');\\n    }\\n\\n    if (this.isAudio()) {\\n      this.addClass('vjs-audio');\\n    }\\n\\n    if (this.flexNotSupported_()) {\\n      this.addClass('vjs-no-flex');\\n    }\\n\\n    // TODO: Make this smarter. Toggle user state between touching/mousing\\n    // using events, since devices can have both touch and mouse events.\\n    // if (browser.TOUCH_ENABLED) {\\n    //   this.addClass('vjs-touch-enabled');\\n    // }\\n\\n    // iOS Safari has broken hover handling\\n    if (!browser.IS_IOS) {\\n      this.addClass('vjs-workinghover');\\n    }\\n\\n    // Make player easily findable by ID\\n    Player.players[this.id_] = this;\\n\\n    // When the player is first initialized, trigger activity so components\\n    // like the control bar show themselves if needed\\n    this.userActive(true);\\n    this.reportUserActivity();\\n    this.listenForUserActivity_();\\n\\n    this.on('fullscreenchange', this.handleFullscreenChange_);\\n    this.on('stageclick', this.handleStageClick_);\\n  }\\n\\n  /*\\n   * Global player list\\n   *\\n   * @type {Object}\\n   */\\n\\n  /**\\n   * Destroys the video player and does any necessary cleanup\\n   * ```js\\n   *     myPlayer.dispose();\\n   * ```\\n   * This is especially helpful if you are dynamically adding and removing videos\\n   * to/from the DOM.\\n   *\\n   * @method dispose\\n   */\\n\\n  Player.prototype.dispose = function dispose() {\\n    this.trigger('dispose');\\n    // prevent dispose from being called twice\\n    this.off('dispose');\\n\\n    if (this.styleEl_ && this.styleEl_.parentNode) {\\n      this.styleEl_.parentNode.removeChild(this.styleEl_);\\n    }\\n\\n    // Kill reference to this player\\n    Player.players[this.id_] = null;\\n    if (this.tag && this.tag.player) {\\n      this.tag.player = null;\\n    }\\n    if (this.el_ && this.el_.player) {\\n      this.el_.player = null;\\n    }\\n\\n    if (this.tech_) {\\n      this.tech_.dispose();\\n    }\\n\\n    _Component.prototype.dispose.call(this);\\n  };\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  Player.prototype.createEl = function createEl() {\\n    var el = this.el_ = _Component.prototype.createEl.call(this, 'div');\\n    var tag = this.tag;\\n\\n    // Remove width/height attrs from tag so CSS can make it 100% width/height\\n    tag.removeAttribute('width');\\n    tag.removeAttribute('height');\\n\\n    // Copy over all the attributes from the tag, including ID and class\\n    // ID will now reference player box, not the video tag\\n    var attrs = Dom.getElAttributes(tag);\\n\\n    Object.getOwnPropertyNames(attrs).forEach(function (attr) {\\n      // workaround so we don't totally break IE7\\n      // http://stackoverflow.com/questions/3653444/css-styles-not-applied-on-dynamic-elements-in-internet-explorer-7\\n      if (attr === 'class') {\\n        el.className = attrs[attr];\\n      } else {\\n        el.setAttribute(attr, attrs[attr]);\\n      }\\n    });\\n\\n    // Update tag id/class for use as HTML5 playback tech\\n    // Might think we should do this after embedding in container so .vjs-tech class\\n    // doesn't flash 100% width/height, but class only applies with .video-js parent\\n    tag.playerId = tag.id;\\n    tag.id += '_html5_api';\\n    tag.className = 'vjs-tech';\\n\\n    // Make player findable on elements\\n    tag.player = el.player = this;\\n    // Default state of video is paused\\n    this.addClass('vjs-paused');\\n\\n    // Add a style element in the player that we'll use to set the width/height\\n    // of the player in a way that's still overrideable by CSS, just like the\\n    // video element\\n    if (_globalWindow2['default'].VIDEOJS_NO_DYNAMIC_STYLE !== true) {\\n      this.styleEl_ = stylesheet.createStyleElement('vjs-styles-dimensions');\\n      var defaultsStyleEl = Dom.$('.vjs-styles-defaults');\\n      var head = Dom.$('head');\\n      head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);\\n    }\\n\\n    // Pass in the width/height/aspectRatio options which will update the style el\\n    this.width(this.options_.width);\\n    this.height(this.options_.height);\\n    this.fluid(this.options_.fluid);\\n    this.aspectRatio(this.options_.aspectRatio);\\n\\n    // Hide any links within the video/audio tag, because IE doesn't hide them completely.\\n    var links = tag.getElementsByTagName('a');\\n    for (var i = 0; i < links.length; i++) {\\n      var linkEl = links.item(i);\\n      Dom.addElClass(linkEl, 'vjs-hidden');\\n      linkEl.setAttribute('hidden', 'hidden');\\n    }\\n\\n    // insertElFirst seems to cause the networkState to flicker from 3 to 2, so\\n    // keep track of the original for later so we can know if the source originally failed\\n    tag.initNetworkState_ = tag.networkState;\\n\\n    // Wrap video tag in div (el/box) container\\n    if (tag.parentNode) {\\n      tag.parentNode.insertBefore(el, tag);\\n    }\\n\\n    // insert the tag as the first child of the player element\\n    // then manually add it to the children array so that this.addChild\\n    // will work properly for other components\\n    Dom.insertElFirst(tag, el); // Breaks iPhone, fixed in HTML5 setup.\\n    this.children_.unshift(tag);\\n\\n    this.el_ = el;\\n\\n    return el;\\n  };\\n\\n  /**\\n   * Get/set player width\\n   *\\n   * @param {Number=} value Value for width\\n   * @return {Number} Width when getting\\n   * @method width\\n   */\\n\\n  Player.prototype.width = function width(value) {\\n    return this.dimension('width', value);\\n  };\\n\\n  /**\\n   * Get/set player height\\n   *\\n   * @param {Number=} value Value for height\\n   * @return {Number} Height when getting\\n   * @method height\\n   */\\n\\n  Player.prototype.height = function height(value) {\\n    return this.dimension('height', value);\\n  };\\n\\n  /**\\n   * Get/set dimension for player\\n   *\\n   * @param {String} dimension Either width or height\\n   * @param {Number=} value Value for dimension\\n   * @return {Component}\\n   * @method dimension\\n   */\\n\\n  Player.prototype.dimension = function dimension(_dimension, value) {\\n    var privDimension = _dimension + '_';\\n\\n    if (value === undefined) {\\n      return this[privDimension] || 0;\\n    }\\n\\n    if (value === '') {\\n      // If an empty string is given, reset the dimension to be automatic\\n      this[privDimension] = undefined;\\n    } else {\\n      var parsedVal = parseFloat(value);\\n\\n      if (isNaN(parsedVal)) {\\n        _utilsLogJs2['default'].error('Improper value \\\"' + value + '\\\" supplied for for ' + _dimension);\\n        return this;\\n      }\\n\\n      this[privDimension] = parsedVal;\\n    }\\n\\n    this.updateStyleEl_();\\n    return this;\\n  };\\n\\n  /**\\n   * Add/remove the vjs-fluid class\\n   *\\n   * @param {Boolean} bool Value of true adds the class, value of false removes the class\\n   * @method fluid\\n   */\\n\\n  Player.prototype.fluid = function fluid(bool) {\\n    if (bool === undefined) {\\n      return !!this.fluid_;\\n    }\\n\\n    this.fluid_ = !!bool;\\n\\n    if (bool) {\\n      this.addClass('vjs-fluid');\\n    } else {\\n      this.removeClass('vjs-fluid');\\n    }\\n  };\\n\\n  /**\\n   * Get/Set the aspect ratio\\n   *\\n   * @param {String=} ratio Aspect ratio for player\\n   * @return aspectRatio\\n   * @method aspectRatio\\n   */\\n\\n  Player.prototype.aspectRatio = function aspectRatio(ratio) {\\n    if (ratio === undefined) {\\n      return this.aspectRatio_;\\n    }\\n\\n    // Check for width:height format\\n    if (!/^\\\\d+\\\\:\\\\d+$/.test(ratio)) {\\n      throw new Error('Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.');\\n    }\\n    this.aspectRatio_ = ratio;\\n\\n    // We're assuming if you set an aspect ratio you want fluid mode,\\n    // because in fixed mode you could calculate width and height yourself.\\n    this.fluid(true);\\n\\n    this.updateStyleEl_();\\n  };\\n\\n  /**\\n   * Update styles of the player element (height, width and aspect ratio)\\n   *\\n   * @method updateStyleEl_\\n   */\\n\\n  Player.prototype.updateStyleEl_ = function updateStyleEl_() {\\n    if (_globalWindow2['default'].VIDEOJS_NO_DYNAMIC_STYLE === true) {\\n      var _width = typeof this.width_ === 'number' ? this.width_ : this.options_.width;\\n      var _height = typeof this.height_ === 'number' ? this.height_ : this.options_.height;\\n      var techEl = this.tech_ && this.tech_.el();\\n\\n      if (techEl) {\\n        if (_width >= 0) {\\n          techEl.width = _width;\\n        }\\n        if (_height >= 0) {\\n          techEl.height = _height;\\n        }\\n      }\\n\\n      return;\\n    }\\n\\n    var width = undefined;\\n    var height = undefined;\\n    var aspectRatio = undefined;\\n    var idClass = undefined;\\n\\n    // The aspect ratio is either used directly or to calculate width and height.\\n    if (this.aspectRatio_ !== undefined && this.aspectRatio_ !== 'auto') {\\n      // Use any aspectRatio that's been specifically set\\n      aspectRatio = this.aspectRatio_;\\n    } else if (this.videoWidth()) {\\n      // Otherwise try to get the aspect ratio from the video metadata\\n      aspectRatio = this.videoWidth() + ':' + this.videoHeight();\\n    } else {\\n      // Or use a default. The video element's is 2:1, but 16:9 is more common.\\n      aspectRatio = '16:9';\\n    }\\n\\n    // Get the ratio as a decimal we can use to calculate dimensions\\n    var ratioParts = aspectRatio.split(':');\\n    var ratioMultiplier = ratioParts[1] / ratioParts[0];\\n\\n    if (this.width_ !== undefined) {\\n      // Use any width that's been specifically set\\n      width = this.width_;\\n    } else if (this.height_ !== undefined) {\\n      // Or calulate the width from the aspect ratio if a height has been set\\n      width = this.height_ / ratioMultiplier;\\n    } else {\\n      // Or use the video's metadata, or use the video el's default of 300\\n      width = this.videoWidth() || 300;\\n    }\\n\\n    if (this.height_ !== undefined) {\\n      // Use any height that's been specifically set\\n      height = this.height_;\\n    } else {\\n      // Otherwise calculate the height from the ratio and the width\\n      height = width * ratioMultiplier;\\n    }\\n\\n    // Ensure the CSS class is valid by starting with an alpha character\\n    if (/^[^a-zA-Z]/.test(this.id())) {\\n      idClass = 'dimensions-' + this.id();\\n    } else {\\n      idClass = this.id() + '-dimensions';\\n    }\\n\\n    // Ensure the right class is still on the player for the style element\\n    this.addClass(idClass);\\n\\n    stylesheet.setTextContent(this.styleEl_, '\\\\n      .' + idClass + ' {\\\\n        width: ' + width + 'px;\\\\n        height: ' + height + 'px;\\\\n      }\\\\n\\\\n      .' + idClass + '.vjs-fluid {\\\\n        padding-top: ' + ratioMultiplier * 100 + '%;\\\\n      }\\\\n    ');\\n  };\\n\\n  /**\\n   * Load the Media Playback Technology (tech)\\n   * Load/Create an instance of playback technology including element and API methods\\n   * And append playback element in player div.\\n   *\\n   * @param {String} techName Name of the playback technology\\n   * @param {String} source Video source\\n   * @method loadTech_\\n   * @private\\n   */\\n\\n  Player.prototype.loadTech_ = function loadTech_(techName, source) {\\n\\n    // Pause and remove current playback technology\\n    if (this.tech_) {\\n      this.unloadTech_();\\n    }\\n\\n    // get rid of the HTML5 video tag as soon as we are using another tech\\n    if (techName !== 'Html5' && this.tag) {\\n      _techTechJs2['default'].getTech('Html5').disposeMediaElement(this.tag);\\n      this.tag.player = null;\\n      this.tag = null;\\n    }\\n\\n    this.techName_ = techName;\\n\\n    // Turn off API access because we're loading a new tech that might load asynchronously\\n    this.isReady_ = false;\\n\\n    // Grab tech-specific options from player options and add source and parent element to use.\\n    var techOptions = _objectAssign2['default']({\\n      'nativeControlsForTouch': this.options_.nativeControlsForTouch,\\n      'source': source,\\n      'playerId': this.id(),\\n      'techId': this.id() + '_' + techName + '_api',\\n      'videoTracks': this.videoTracks_,\\n      'textTracks': this.textTracks_,\\n      'audioTracks': this.audioTracks_,\\n      'autoplay': this.options_.autoplay,\\n      'preload': this.options_.preload,\\n      'loop': this.options_.loop,\\n      'muted': this.options_.muted,\\n      'poster': this.poster(),\\n      'language': this.language(),\\n      'vtt.js': this.options_['vtt.js']\\n    }, this.options_[techName.toLowerCase()]);\\n\\n    if (this.tag) {\\n      techOptions.tag = this.tag;\\n    }\\n\\n    if (source) {\\n      this.currentType_ = source.type;\\n      if (source.src === this.cache_.src && this.cache_.currentTime > 0) {\\n        techOptions.startTime = this.cache_.currentTime;\\n      }\\n\\n      this.cache_.src = source.src;\\n    }\\n\\n    // Initialize tech instance\\n    var techComponent = _techTechJs2['default'].getTech(techName);\\n    // Support old behavior of techs being registered as components.\\n    // Remove once that deprecated behavior is removed.\\n    if (!techComponent) {\\n      techComponent = _componentJs2['default'].getComponent(techName);\\n    }\\n    this.tech_ = new techComponent(techOptions);\\n\\n    // player.triggerReady is always async, so don't need this to be async\\n    this.tech_.ready(Fn.bind(this, this.handleTechReady_), true);\\n\\n    _tracksTextTrackListConverterJs2['default'].jsonToTextTracks(this.textTracksJson_ || [], this.tech_);\\n\\n    // Listen to all HTML5-defined events and trigger them on the player\\n    this.on(this.tech_, 'loadstart', this.handleTechLoadStart_);\\n    this.on(this.tech_, 'waiting', this.handleTechWaiting_);\\n    this.on(this.tech_, 'canplay', this.handleTechCanPlay_);\\n    this.on(this.tech_, 'canplaythrough', this.handleTechCanPlayThrough_);\\n    this.on(this.tech_, 'playing', this.handleTechPlaying_);\\n    this.on(this.tech_, 'ended', this.handleTechEnded_);\\n    this.on(this.tech_, 'seeking', this.handleTechSeeking_);\\n    this.on(this.tech_, 'seeked', this.handleTechSeeked_);\\n    this.on(this.tech_, 'play', this.handleTechPlay_);\\n    this.on(this.tech_, 'firstplay', this.handleTechFirstPlay_);\\n    this.on(this.tech_, 'pause', this.handleTechPause_);\\n    this.on(this.tech_, 'progress', this.handleTechProgress_);\\n    this.on(this.tech_, 'durationchange', this.handleTechDurationChange_);\\n    this.on(this.tech_, 'fullscreenchange', this.handleTechFullscreenChange_);\\n    this.on(this.tech_, 'error', this.handleTechError_);\\n    this.on(this.tech_, 'suspend', this.handleTechSuspend_);\\n    this.on(this.tech_, 'abort', this.handleTechAbort_);\\n    this.on(this.tech_, 'emptied', this.handleTechEmptied_);\\n    this.on(this.tech_, 'stalled', this.handleTechStalled_);\\n    this.on(this.tech_, 'loadedmetadata', this.handleTechLoadedMetaData_);\\n    this.on(this.tech_, 'loadeddata', this.handleTechLoadedData_);\\n    this.on(this.tech_, 'timeupdate', this.handleTechTimeUpdate_);\\n    this.on(this.tech_, 'ratechange', this.handleTechRateChange_);\\n    this.on(this.tech_, 'volumechange', this.handleTechVolumeChange_);\\n    this.on(this.tech_, 'texttrackchange', this.handleTechTextTrackChange_);\\n    this.on(this.tech_, 'loadedmetadata', this.updateStyleEl_);\\n    this.on(this.tech_, 'posterchange', this.handleTechPosterChange_);\\n    this.on(this.tech_, 'textdata', this.handleTechTextData_);\\n\\n    this.usingNativeControls(this.techGet_('controls'));\\n\\n    if (this.controls() && !this.usingNativeControls()) {\\n      this.addTechControlsListeners_();\\n    }\\n\\n    // Add the tech element in the DOM if it was not already there\\n    // Make sure to not insert the original video element if using Html5\\n    if (this.tech_.el().parentNode !== this.el() && (techName !== 'Html5' || !this.tag)) {\\n      Dom.insertElFirst(this.tech_.el(), this.el());\\n    }\\n\\n    // Get rid of the original video tag reference after the first tech is loaded\\n    if (this.tag) {\\n      this.tag.player = null;\\n      this.tag = null;\\n    }\\n  };\\n\\n  /**\\n   * Unload playback technology\\n   *\\n   * @method unloadTech_\\n   * @private\\n   */\\n\\n  Player.prototype.unloadTech_ = function unloadTech_() {\\n    // Save the current text tracks so that we can reuse the same text tracks with the next tech\\n    this.videoTracks_ = this.videoTracks();\\n    this.textTracks_ = this.textTracks();\\n    this.audioTracks_ = this.audioTracks();\\n    this.textTracksJson_ = _tracksTextTrackListConverterJs2['default'].textTracksToJson(this.tech_);\\n\\n    this.isReady_ = false;\\n\\n    this.tech_.dispose();\\n\\n    this.tech_ = false;\\n  };\\n\\n  /**\\n   * Return a reference to the current tech.\\n   * It will only return a reference to the tech if given an object with the\\n   * `IWillNotUseThisInPlugins` property on it. This is try and prevent misuse\\n   * of techs by plugins.\\n   *\\n   * @param {Object}\\n   * @return {Object} The Tech\\n   * @method tech\\n   */\\n\\n  Player.prototype.tech = function tech(safety) {\\n    if (safety && safety.IWillNotUseThisInPlugins) {\\n      return this.tech_;\\n    }\\n    var errorText = '\\\\n      Please make sure that you are not using this inside of a plugin.\\\\n      To disable this alert and error, please pass in an object with\\\\n      `IWillNotUseThisInPlugins` to the `tech` method. See\\\\n      https://github.com/videojs/video.js/issues/2617 for more info.\\\\n    ';\\n    _globalWindow2['default'].alert(errorText);\\n    throw new Error(errorText);\\n  };\\n\\n  /**\\n   * Set up click and touch listeners for the playback element\\n   *\\n   * On desktops, a click on the video itself will toggle playback,\\n   * on a mobile device a click on the video toggles controls.\\n   * (toggling controls is done by toggling the user state between active and\\n   * inactive)\\n   * A tap can signal that a user has become active, or has become inactive\\n   * e.g. a quick tap on an iPhone movie should reveal the controls. Another\\n   * quick tap should hide them again (signaling the user is in an inactive\\n   * viewing state)\\n   * In addition to this, we still want the user to be considered inactive after\\n   * a few seconds of inactivity.\\n   * Note: the only part of iOS interaction we can't mimic with this setup\\n   * is a touch and hold on the video element counting as activity in order to\\n   * keep the controls showing, but that shouldn't be an issue. A touch and hold\\n   * on any controls will still keep the user active\\n   *\\n   * @private\\n   * @method addTechControlsListeners_\\n   */\\n\\n  Player.prototype.addTechControlsListeners_ = function addTechControlsListeners_() {\\n    // Make sure to remove all the previous listeners in case we are called multiple times.\\n    this.removeTechControlsListeners_();\\n\\n    // Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do\\n    // trigger mousedown/up.\\n    // http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object\\n    // Any touch events are set to block the mousedown event from happening\\n    this.on(this.tech_, 'mousedown', this.handleTechClick_);\\n\\n    // If the controls were hidden we don't want that to change without a tap event\\n    // so we'll check if the controls were already showing before reporting user\\n    // activity\\n    this.on(this.tech_, 'touchstart', this.handleTechTouchStart_);\\n    this.on(this.tech_, 'touchmove', this.handleTechTouchMove_);\\n    this.on(this.tech_, 'touchend', this.handleTechTouchEnd_);\\n\\n    // The tap listener needs to come after the touchend listener because the tap\\n    // listener cancels out any reportedUserActivity when setting userActive(false)\\n    this.on(this.tech_, 'tap', this.handleTechTap_);\\n  };\\n\\n  /**\\n   * Remove the listeners used for click and tap controls. This is needed for\\n   * toggling to controls disabled, where a tap/touch should do nothing.\\n   *\\n   * @method removeTechControlsListeners_\\n   * @private\\n   */\\n\\n  Player.prototype.removeTechControlsListeners_ = function removeTechControlsListeners_() {\\n    // We don't want to just use `this.off()` because there might be other needed\\n    // listeners added by techs that extend this.\\n    this.off(this.tech_, 'tap', this.handleTechTap_);\\n    this.off(this.tech_, 'touchstart', this.handleTechTouchStart_);\\n    this.off(this.tech_, 'touchmove', this.handleTechTouchMove_);\\n    this.off(this.tech_, 'touchend', this.handleTechTouchEnd_);\\n    this.off(this.tech_, 'mousedown', this.handleTechClick_);\\n  };\\n\\n  /**\\n   * Player waits for the tech to be ready\\n   *\\n   * @method handleTechReady_\\n   * @private\\n   */\\n\\n  Player.prototype.handleTechReady_ = function handleTechReady_() {\\n    this.triggerReady();\\n\\n    // Keep the same volume as before\\n    if (this.cache_.volume) {\\n      this.techCall_('setVolume', this.cache_.volume);\\n    }\\n\\n    // Look if the tech found a higher resolution poster while loading\\n    this.handleTechPosterChange_();\\n\\n    // Update the duration if available\\n    this.handleTechDurationChange_();\\n\\n    // Chrome and Safari both have issues with autoplay.\\n    // In Safari (5.1.1), when we move the video element into the container div, autoplay doesn't work.\\n    // In Chrome (15), if you have autoplay + a poster + no controls, the video gets hidden (but audio plays)\\n    // This fixes both issues. Need to wait for API, so it updates displays correctly\\n    if ((this.src() || this.currentSrc()) && this.tag && this.options_.autoplay && this.paused()) {\\n      try {\\n        delete this.tag.poster; // Chrome Fix. Fixed in Chrome v16.\\n      } catch (e) {\\n        _utilsLogJs2['default']('deleting tag.poster throws in some browsers', e);\\n      }\\n      this.play();\\n    }\\n  };\\n\\n  /**\\n   * Fired when the user agent begins looking for media data\\n   *\\n   * @private\\n   * @method handleTechLoadStart_\\n   */\\n\\n  Player.prototype.handleTechLoadStart_ = function handleTechLoadStart_() {\\n    // TODO: Update to use `emptied` event instead. See #1277.\\n\\n    this.removeClass('vjs-ended');\\n\\n    // reset the error state\\n    this.error(null);\\n\\n    // If it's already playing we want to trigger a firstplay event now.\\n    // The firstplay event relies on both the play and loadstart events\\n    // which can happen in any order for a new source\\n    if (!this.paused()) {\\n      this.trigger('loadstart');\\n      this.trigger('firstplay');\\n    } else {\\n      // reset the hasStarted state\\n      this.hasStarted(false);\\n      this.trigger('loadstart');\\n    }\\n  };\\n\\n  /**\\n   * Add/remove the vjs-has-started class\\n   *\\n   * @param {Boolean} hasStarted The value of true adds the class the value of false remove the class\\n   * @return {Boolean} Boolean value if has started\\n   * @private\\n   * @method hasStarted\\n   */\\n\\n  Player.prototype.hasStarted = function hasStarted(_hasStarted) {\\n    if (_hasStarted !== undefined) {\\n      // only update if this is a new value\\n      if (this.hasStarted_ !== _hasStarted) {\\n        this.hasStarted_ = _hasStarted;\\n        if (_hasStarted) {\\n          this.addClass('vjs-has-started');\\n          // trigger the firstplay event if this newly has played\\n          this.trigger('firstplay');\\n        } else {\\n          this.removeClass('vjs-has-started');\\n        }\\n      }\\n      return this;\\n    }\\n    return !!this.hasStarted_;\\n  };\\n\\n  /**\\n   * Fired whenever the media begins or resumes playback\\n   *\\n   * @private\\n   * @method handleTechPlay_\\n   */\\n\\n  Player.prototype.handleTechPlay_ = function handleTechPlay_() {\\n    this.removeClass('vjs-ended');\\n    this.removeClass('vjs-paused');\\n    this.addClass('vjs-playing');\\n\\n    // hide the poster when the user hits play\\n    // https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play\\n    this.hasStarted(true);\\n\\n    this.trigger('play');\\n  };\\n\\n  /**\\n   * Fired whenever the media begins waiting\\n   *\\n   * @private\\n   * @method handleTechWaiting_\\n   */\\n\\n  Player.prototype.handleTechWaiting_ = function handleTechWaiting_() {\\n    var _this2 = this;\\n\\n    this.addClass('vjs-waiting');\\n    this.trigger('waiting');\\n    this.one('timeupdate', function () {\\n      return _this2.removeClass('vjs-waiting');\\n    });\\n  };\\n\\n  /**\\n   * A handler for events that signal that waiting has ended\\n   * which is not consistent between browsers. See #1351\\n   *\\n   * @private\\n   * @method handleTechCanPlay_\\n   */\\n\\n  Player.prototype.handleTechCanPlay_ = function handleTechCanPlay_() {\\n    this.removeClass('vjs-waiting');\\n    this.trigger('canplay');\\n  };\\n\\n  /**\\n   * A handler for events that signal that waiting has ended\\n   * which is not consistent between browsers. See #1351\\n   *\\n   * @private\\n   * @method handleTechCanPlayThrough_\\n   */\\n\\n  Player.prototype.handleTechCanPlayThrough_ = function handleTechCanPlayThrough_() {\\n    this.removeClass('vjs-waiting');\\n    this.trigger('canplaythrough');\\n  };\\n\\n  /**\\n   * A handler for events that signal that waiting has ended\\n   * which is not consistent between browsers. See #1351\\n   *\\n   * @private\\n   * @method handleTechPlaying_\\n   */\\n\\n  Player.prototype.handleTechPlaying_ = function handleTechPlaying_() {\\n    this.removeClass('vjs-waiting');\\n    this.trigger('playing');\\n  };\\n\\n  /**\\n   * Fired whenever the player is jumping to a new time\\n   *\\n   * @private\\n   * @method handleTechSeeking_\\n   */\\n\\n  Player.prototype.handleTechSeeking_ = function handleTechSeeking_() {\\n    this.addClass('vjs-seeking');\\n    this.trigger('seeking');\\n  };\\n\\n  /**\\n   * Fired when the player has finished jumping to a new time\\n   *\\n   * @private\\n   * @method handleTechSeeked_\\n   */\\n\\n  Player.prototype.handleTechSeeked_ = function handleTechSeeked_() {\\n    this.removeClass('vjs-seeking');\\n    this.trigger('seeked');\\n  };\\n\\n  /**\\n   * Fired the first time a video is played\\n   * Not part of the HLS spec, and we're not sure if this is the best\\n   * implementation yet, so use sparingly. If you don't have a reason to\\n   * prevent playback, use `myPlayer.one('play');` instead.\\n   *\\n   * @private\\n   * @method handleTechFirstPlay_\\n   */\\n\\n  Player.prototype.handleTechFirstPlay_ = function handleTechFirstPlay_() {\\n    //If the first starttime attribute is specified\\n    //then we will start at the given offset in seconds\\n    if (this.options_.starttime) {\\n      this.currentTime(this.options_.starttime);\\n    }\\n\\n    this.addClass('vjs-has-started');\\n    this.trigger('firstplay');\\n  };\\n\\n  /**\\n   * Fired whenever the media has been paused\\n   *\\n   * @private\\n   * @method handleTechPause_\\n   */\\n\\n  Player.prototype.handleTechPause_ = function handleTechPause_() {\\n    this.removeClass('vjs-playing');\\n    this.addClass('vjs-paused');\\n    this.trigger('pause');\\n  };\\n\\n  /**\\n   * Fired while the user agent is downloading media data\\n   *\\n   * @private\\n   * @method handleTechProgress_\\n   */\\n\\n  Player.prototype.handleTechProgress_ = function handleTechProgress_() {\\n    this.trigger('progress');\\n  };\\n\\n  /**\\n   * Fired when the end of the media resource is reached (currentTime == duration)\\n   *\\n   * @private\\n   * @method handleTechEnded_\\n   */\\n\\n  Player.prototype.handleTechEnded_ = function handleTechEnded_() {\\n    this.addClass('vjs-ended');\\n    if (this.options_.loop) {\\n      this.currentTime(0);\\n      this.play();\\n    } else if (!this.paused()) {\\n      this.pause();\\n    }\\n\\n    this.trigger('ended');\\n  };\\n\\n  /**\\n   * Fired when the duration of the media resource is first known or changed\\n   *\\n   * @private\\n   * @method handleTechDurationChange_\\n   */\\n\\n  Player.prototype.handleTechDurationChange_ = function handleTechDurationChange_() {\\n    this.duration(this.techGet_('duration'));\\n  };\\n\\n  /**\\n   * Handle a click on the media element to play/pause\\n   *\\n   * @param {Object=} event Event object\\n   * @private\\n   * @method handleTechClick_\\n   */\\n\\n  Player.prototype.handleTechClick_ = function handleTechClick_(event) {\\n    // We're using mousedown to detect clicks thanks to Flash, but mousedown\\n    // will also be triggered with right-clicks, so we need to prevent that\\n    if (event.button !== 0) return;\\n\\n    // When controls are disabled a click should not toggle playback because\\n    // the click is considered a control\\n    if (this.controls()) {\\n      if (this.paused()) {\\n        this.play();\\n      } else {\\n        this.pause();\\n      }\\n    }\\n  };\\n\\n  /**\\n   * Handle a tap on the media element. It will toggle the user\\n   * activity state, which hides and shows the controls.\\n   *\\n   * @private\\n   * @method handleTechTap_\\n   */\\n\\n  Player.prototype.handleTechTap_ = function handleTechTap_() {\\n    this.userActive(!this.userActive());\\n  };\\n\\n  /**\\n   * Handle touch to start\\n   *\\n   * @private\\n   * @method handleTechTouchStart_\\n   */\\n\\n  Player.prototype.handleTechTouchStart_ = function handleTechTouchStart_() {\\n    this.userWasActive = this.userActive();\\n  };\\n\\n  /**\\n   * Handle touch to move\\n   *\\n   * @private\\n   * @method handleTechTouchMove_\\n   */\\n\\n  Player.prototype.handleTechTouchMove_ = function handleTechTouchMove_() {\\n    if (this.userWasActive) {\\n      this.reportUserActivity();\\n    }\\n  };\\n\\n  /**\\n   * Handle touch to end\\n   *\\n   * @private\\n   * @method handleTechTouchEnd_\\n   */\\n\\n  Player.prototype.handleTechTouchEnd_ = function handleTechTouchEnd_(event) {\\n    // Stop the mouse events from also happening\\n    event.preventDefault();\\n  };\\n\\n  /**\\n   * Fired when the player switches in or out of fullscreen mode\\n   *\\n   * @private\\n   * @method handleFullscreenChange_\\n   */\\n\\n  Player.prototype.handleFullscreenChange_ = function handleFullscreenChange_() {\\n    if (this.isFullscreen()) {\\n      this.addClass('vjs-fullscreen');\\n    } else {\\n      this.removeClass('vjs-fullscreen');\\n    }\\n  };\\n\\n  /**\\n   * native click events on the SWF aren't triggered on IE11, Win8.1RT\\n   * use stageclick events triggered from inside the SWF instead\\n   *\\n   * @private\\n   * @method handleStageClick_\\n   */\\n\\n  Player.prototype.handleStageClick_ = function handleStageClick_() {\\n    this.reportUserActivity();\\n  };\\n\\n  /**\\n   * Handle Tech Fullscreen Change\\n   *\\n   * @private\\n   * @method handleTechFullscreenChange_\\n   */\\n\\n  Player.prototype.handleTechFullscreenChange_ = function handleTechFullscreenChange_(event, data) {\\n    if (data) {\\n      this.isFullscreen(data.isFullscreen);\\n    }\\n    this.trigger('fullscreenchange');\\n  };\\n\\n  /**\\n   * Fires when an error occurred during the loading of an audio/video\\n   *\\n   * @private\\n   * @method handleTechError_\\n   */\\n\\n  Player.prototype.handleTechError_ = function handleTechError_() {\\n    var error = this.tech_.error();\\n    this.error(error);\\n  };\\n\\n  /**\\n   * Fires when the browser is intentionally not getting media data\\n   *\\n   * @private\\n   * @method handleTechSuspend_\\n   */\\n\\n  Player.prototype.handleTechSuspend_ = function handleTechSuspend_() {\\n    this.trigger('suspend');\\n  };\\n\\n  /**\\n   * Fires when the loading of an audio/video is aborted\\n   *\\n   * @private\\n   * @method handleTechAbort_\\n   */\\n\\n  Player.prototype.handleTechAbort_ = function handleTechAbort_() {\\n    this.trigger('abort');\\n  };\\n\\n  /**\\n   * Fires when the current playlist is empty\\n   *\\n   * @private\\n   * @method handleTechEmptied_\\n   */\\n\\n  Player.prototype.handleTechEmptied_ = function handleTechEmptied_() {\\n    this.trigger('emptied');\\n  };\\n\\n  /**\\n   * Fires when the browser is trying to get media data, but data is not available\\n   *\\n   * @private\\n   * @method handleTechStalled_\\n   */\\n\\n  Player.prototype.handleTechStalled_ = function handleTechStalled_() {\\n    this.trigger('stalled');\\n  };\\n\\n  /**\\n   * Fires when the browser has loaded meta data for the audio/video\\n   *\\n   * @private\\n   * @method handleTechLoadedMetaData_\\n   */\\n\\n  Player.prototype.handleTechLoadedMetaData_ = function handleTechLoadedMetaData_() {\\n    this.trigger('loadedmetadata');\\n  };\\n\\n  Player.prototype.handleTechTextData_ = function handleTechTextData_() {\\n    var data = null;\\n    if (arguments.length > 1) {\\n      data = arguments[1];\\n    }\\n    this.trigger('textdata', data);\\n  };\\n\\n  /**\\n   * Fires when the browser has loaded the current frame of the audio/video\\n   *\\n   * @private\\n   * @method handleTechLoadedData_\\n   */\\n\\n  Player.prototype.handleTechLoadedData_ = function handleTechLoadedData_() {\\n    this.trigger('loadeddata');\\n  };\\n\\n  /**\\n   * Fires when the current playback position has changed\\n   *\\n   * @private\\n   * @method handleTechTimeUpdate_\\n   */\\n\\n  Player.prototype.handleTechTimeUpdate_ = function handleTechTimeUpdate_() {\\n    this.trigger('timeupdate');\\n  };\\n\\n  /**\\n   * Fires when the playing speed of the audio/video is changed\\n   *\\n   * @private\\n   * @method handleTechRateChange_\\n   */\\n\\n  Player.prototype.handleTechRateChange_ = function handleTechRateChange_() {\\n    this.trigger('ratechange');\\n  };\\n\\n  /**\\n   * Fires when the volume has been changed\\n   *\\n   * @private\\n   * @method handleTechVolumeChange_\\n   */\\n\\n  Player.prototype.handleTechVolumeChange_ = function handleTechVolumeChange_() {\\n    this.trigger('volumechange');\\n  };\\n\\n  /**\\n   * Fires when the text track has been changed\\n   *\\n   * @private\\n   * @method handleTechTextTrackChange_\\n   */\\n\\n  Player.prototype.handleTechTextTrackChange_ = function handleTechTextTrackChange_() {\\n    this.trigger('texttrackchange');\\n  };\\n\\n  /**\\n   * Get object for cached values.\\n   *\\n   * @return {Object}\\n   * @method getCache\\n   */\\n\\n  Player.prototype.getCache = function getCache() {\\n    return this.cache_;\\n  };\\n\\n  /**\\n   * Pass values to the playback tech\\n   *\\n   * @param {String=} method Method\\n   * @param {Object=} arg Argument\\n   * @private\\n   * @method techCall_\\n   */\\n\\n  Player.prototype.techCall_ = function techCall_(method, arg) {\\n    // If it's not ready yet, call method when it is\\n    if (this.tech_ && !this.tech_.isReady_) {\\n      this.tech_.ready(function () {\\n        this[method](arg);\\n      }, true);\\n\\n      // Otherwise call method now\\n    } else {\\n        try {\\n          this.tech_ && this.tech_[method](arg);\\n        } catch (e) {\\n          _utilsLogJs2['default'](e);\\n          throw e;\\n        }\\n      }\\n  };\\n\\n  /**\\n   * Get calls can't wait for the tech, and sometimes don't need to.\\n   *\\n   * @param {String} method Tech method\\n   * @return {Method}\\n   * @private\\n   * @method techGet_\\n   */\\n\\n  Player.prototype.techGet_ = function techGet_(method) {\\n    if (this.tech_ && this.tech_.isReady_) {\\n\\n      // Flash likes to die and reload when you hide or reposition it.\\n      // In these cases the object methods go away and we get errors.\\n      // When that happens we'll catch the errors and inform tech that it's not ready any more.\\n      try {\\n        return this.tech_[method]();\\n      } catch (e) {\\n        // When building additional tech libs, an expected method may not be defined yet\\n        if (this.tech_[method] === undefined) {\\n          _utilsLogJs2['default']('Video.js: ' + method + ' method not defined for ' + this.techName_ + ' playback technology.', e);\\n        } else {\\n          // When a method isn't available on the object it throws a TypeError\\n          if (e.name === 'TypeError') {\\n            _utilsLogJs2['default']('Video.js: ' + method + ' unavailable on ' + this.techName_ + ' playback technology element.', e);\\n            this.tech_.isReady_ = false;\\n          } else {\\n            _utilsLogJs2['default'](e);\\n          }\\n        }\\n        throw e;\\n      }\\n    }\\n\\n    return;\\n  };\\n\\n  /**\\n   * start media playback\\n   * ```js\\n   *     myPlayer.play();\\n   * ```\\n   *\\n   * @return {Player} self\\n   * @method play\\n   */\\n\\n  Player.prototype.play = function play() {\\n    // Only calls the tech's play if we already have a src loaded\\n    if (this.src() || this.currentSrc()) {\\n      this.techCall_('play');\\n    } else {\\n      this.tech_.one('loadstart', function () {\\n        this.play();\\n      });\\n    }\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Pause the video playback\\n   * ```js\\n   *     myPlayer.pause();\\n   * ```\\n   *\\n   * @return {Player} self\\n   * @method pause\\n   */\\n\\n  Player.prototype.pause = function pause() {\\n    this.techCall_('pause');\\n    return this;\\n  };\\n\\n  /**\\n   * Check if the player is paused\\n   * ```js\\n   *     var isPaused = myPlayer.paused();\\n   *     var isPlaying = !myPlayer.paused();\\n   * ```\\n   *\\n   * @return {Boolean} false if the media is currently playing, or true otherwise\\n   * @method paused\\n   */\\n\\n  Player.prototype.paused = function paused() {\\n    // The initial state of paused should be true (in Safari it's actually false)\\n    return this.techGet_('paused') === false ? false : true;\\n  };\\n\\n  /**\\n   * Returns whether or not the user is \\\"scrubbing\\\". Scrubbing is when the user\\n   * has clicked the progress bar handle and is dragging it along the progress bar.\\n   *\\n   * @param  {Boolean} isScrubbing   True/false the user is scrubbing\\n   * @return {Boolean}               The scrubbing status when getting\\n   * @return {Object}                The player when setting\\n   * @method scrubbing\\n   */\\n\\n  Player.prototype.scrubbing = function scrubbing(isScrubbing) {\\n    if (isScrubbing !== undefined) {\\n      this.scrubbing_ = !!isScrubbing;\\n\\n      if (isScrubbing) {\\n        this.addClass('vjs-scrubbing');\\n      } else {\\n        this.removeClass('vjs-scrubbing');\\n      }\\n\\n      return this;\\n    }\\n\\n    return this.scrubbing_;\\n  };\\n\\n  /**\\n   * Get or set the current time (in seconds)\\n   * ```js\\n   *     // get\\n   *     var whereYouAt = myPlayer.currentTime();\\n   *     // set\\n   *     myPlayer.currentTime(120); // 2 minutes into the video\\n   * ```\\n   *\\n   * @param  {Number|String=} seconds The time to seek to\\n   * @return {Number}        The time in seconds, when not setting\\n   * @return {Player}    self, when the current time is set\\n   * @method currentTime\\n   */\\n\\n  Player.prototype.currentTime = function currentTime(seconds) {\\n    if (seconds !== undefined) {\\n\\n      this.techCall_('setCurrentTime', seconds);\\n\\n      return this;\\n    }\\n\\n    // cache last currentTime and return. default to 0 seconds\\n    //\\n    // Caching the currentTime is meant to prevent a massive amount of reads on the tech's\\n    // currentTime when scrubbing, but may not provide much performance benefit afterall.\\n    // Should be tested. Also something has to read the actual current time or the cache will\\n    // never get updated.\\n    return this.cache_.currentTime = this.techGet_('currentTime') || 0;\\n  };\\n\\n  /**\\n   * Normally gets the length in time of the video in seconds;\\n   * in all but the rarest use cases an argument will NOT be passed to the method\\n   * ```js\\n   *     var lengthOfVideo = myPlayer.duration();\\n   * ```\\n   * **NOTE**: The video must have started loading before the duration can be\\n   * known, and in the case of Flash, may not be known until the video starts\\n   * playing.\\n   *\\n   * @param {Number} seconds Duration when setting\\n   * @return {Number} The duration of the video in seconds when getting\\n   * @method duration\\n   */\\n\\n  Player.prototype.duration = function duration(seconds) {\\n    if (seconds === undefined) {\\n      return this.cache_.duration || 0;\\n    }\\n\\n    seconds = parseFloat(seconds) || 0;\\n\\n    // Standardize on Inifity for signaling video is live\\n    if (seconds < 0) {\\n      seconds = Infinity;\\n    }\\n\\n    if (seconds !== this.cache_.duration) {\\n      // Cache the last set value for optimized scrubbing (esp. Flash)\\n      this.cache_.duration = seconds;\\n\\n      if (seconds === Infinity) {\\n        this.addClass('vjs-live');\\n      } else {\\n        this.removeClass('vjs-live');\\n      }\\n\\n      this.trigger('durationchange');\\n    }\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Calculates how much time is left.\\n   * ```js\\n   *     var timeLeft = myPlayer.remainingTime();\\n   * ```\\n   * Not a native video element function, but useful\\n   *\\n   * @return {Number} The time remaining in seconds\\n   * @method remainingTime\\n   */\\n\\n  Player.prototype.remainingTime = function remainingTime() {\\n    return this.duration() - this.currentTime();\\n  };\\n\\n  // http://dev.w3.org/html5/spec/video.html#dom-media-buffered\\n  // Buffered returns a timerange object.\\n  // Kind of like an array of portions of the video that have been downloaded.\\n\\n  /**\\n   * Get a TimeRange object with the times of the video that have been downloaded\\n   * If you just want the percent of the video that's been downloaded,\\n   * use bufferedPercent.\\n   * ```js\\n   *     // Number of different ranges of time have been buffered. Usually 1.\\n   *     numberOfRanges = bufferedTimeRange.length,\\n   *     // Time in seconds when the first range starts. Usually 0.\\n   *     firstRangeStart = bufferedTimeRange.start(0),\\n   *     // Time in seconds when the first range ends\\n   *     firstRangeEnd = bufferedTimeRange.end(0),\\n   *     // Length in seconds of the first time range\\n   *     firstRangeLength = firstRangeEnd - firstRangeStart;\\n   * ```\\n   *\\n   * @return {Object} A mock TimeRange object (following HTML spec)\\n   * @method buffered\\n   */\\n\\n  Player.prototype.buffered = function buffered() {\\n    var buffered = this.techGet_('buffered');\\n\\n    if (!buffered || !buffered.length) {\\n      buffered = _utilsTimeRangesJs.createTimeRange(0, 0);\\n    }\\n\\n    return buffered;\\n  };\\n\\n  /**\\n   * Get the percent (as a decimal) of the video that's been downloaded\\n   * ```js\\n   *     var howMuchIsDownloaded = myPlayer.bufferedPercent();\\n   * ```\\n   * 0 means none, 1 means all.\\n   * (This method isn't in the HTML5 spec, but it's very convenient)\\n   *\\n   * @return {Number} A decimal between 0 and 1 representing the percent\\n   * @method bufferedPercent\\n   */\\n\\n  Player.prototype.bufferedPercent = function bufferedPercent() {\\n    return _utilsBufferJs.bufferedPercent(this.buffered(), this.duration());\\n  };\\n\\n  /**\\n   * Get the ending time of the last buffered time range\\n   * This is used in the progress bar to encapsulate all time ranges.\\n   *\\n   * @return {Number} The end of the last buffered time range\\n   * @method bufferedEnd\\n   */\\n\\n  Player.prototype.bufferedEnd = function bufferedEnd() {\\n    var buffered = this.buffered(),\\n        duration = this.duration(),\\n        end = buffered.end(buffered.length - 1);\\n\\n    if (end > duration) {\\n      end = duration;\\n    }\\n\\n    return end;\\n  };\\n\\n  /**\\n   * Get or set the current volume of the media\\n   * ```js\\n   *     // get\\n   *     var howLoudIsIt = myPlayer.volume();\\n   *     // set\\n   *     myPlayer.volume(0.5); // Set volume to half\\n   * ```\\n   * 0 is off (muted), 1.0 is all the way up, 0.5 is half way.\\n   *\\n   * @param  {Number} percentAsDecimal The new volume as a decimal percent\\n   * @return {Number}              The current volume when getting\\n   * @return {Player}              self when setting\\n   * @method volume\\n   */\\n\\n  Player.prototype.volume = function volume(percentAsDecimal) {\\n    var vol = undefined;\\n\\n    if (percentAsDecimal !== undefined) {\\n      vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal))); // Force value to between 0 and 1\\n      this.cache_.volume = vol;\\n      this.techCall_('setVolume', vol);\\n\\n      return this;\\n    }\\n\\n    // Default to 1 when returning current volume.\\n    vol = parseFloat(this.techGet_('volume'));\\n    return isNaN(vol) ? 1 : vol;\\n  };\\n\\n  /**\\n   * Get the current muted state, or turn mute on or off\\n   * ```js\\n   *     // get\\n   *     var isVolumeMuted = myPlayer.muted();\\n   *     // set\\n   *     myPlayer.muted(true); // mute the volume\\n   * ```\\n   *\\n   * @param  {Boolean=} muted True to mute, false to unmute\\n   * @return {Boolean} True if mute is on, false if not when getting\\n   * @return {Player} self when setting mute\\n   * @method muted\\n   */\\n\\n  Player.prototype.muted = function muted(_muted) {\\n    if (_muted !== undefined) {\\n      this.techCall_('setMuted', _muted);\\n      return this;\\n    }\\n    return this.techGet_('muted') || false; // Default to false\\n  };\\n\\n  // Check if current tech can support native fullscreen\\n  // (e.g. with built in controls like iOS, so not our flash swf)\\n  /**\\n   * Check to see if fullscreen is supported\\n   *\\n   * @return {Boolean}\\n   * @method supportsFullScreen\\n   */\\n\\n  Player.prototype.supportsFullScreen = function supportsFullScreen() {\\n    return this.techGet_('supportsFullScreen') || false;\\n  };\\n\\n  /**\\n   * Check if the player is in fullscreen mode\\n   * ```js\\n   *     // get\\n   *     var fullscreenOrNot = myPlayer.isFullscreen();\\n   *     // set\\n   *     myPlayer.isFullscreen(true); // tell the player it's in fullscreen\\n   * ```\\n   * NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official\\n   * property and instead document.fullscreenElement is used. But isFullscreen is\\n   * still a valuable property for internal player workings.\\n   *\\n   * @param  {Boolean=} isFS Update the player's fullscreen state\\n   * @return {Boolean} true if fullscreen false if not when getting\\n   * @return {Player} self when setting\\n   * @method isFullscreen\\n   */\\n\\n  Player.prototype.isFullscreen = function isFullscreen(isFS) {\\n    if (isFS !== undefined) {\\n      this.isFullscreen_ = !!isFS;\\n      return this;\\n    }\\n    return !!this.isFullscreen_;\\n  };\\n\\n  /**\\n   * Increase the size of the video to full screen\\n   * ```js\\n   *     myPlayer.requestFullscreen();\\n   * ```\\n   * In some browsers, full screen is not supported natively, so it enters\\n   * \\\"full window mode\\\", where the video fills the browser window.\\n   * In browsers and devices that support native full screen, sometimes the\\n   * browser's default controls will be shown, and not the Video.js custom skin.\\n   * This includes most mobile devices (iOS, Android) and older versions of\\n   * Safari.\\n   *\\n   * @return {Player} self\\n   * @method requestFullscreen\\n   */\\n\\n  Player.prototype.requestFullscreen = function requestFullscreen() {\\n    var fsApi = _fullscreenApiJs2['default'];\\n\\n    this.isFullscreen(true);\\n\\n    if (fsApi.requestFullscreen) {\\n      // the browser supports going fullscreen at the element level so we can\\n      // take the controls fullscreen as well as the video\\n\\n      // Trigger fullscreenchange event after change\\n      // We have to specifically add this each time, and remove\\n      // when canceling fullscreen. Otherwise if there's multiple\\n      // players on a page, they would all be reacting to the same fullscreen\\n      // events\\n      Events.on(_globalDocument2['default'], fsApi.fullscreenchange, Fn.bind(this, function documentFullscreenChange(e) {\\n        this.isFullscreen(_globalDocument2['default'][fsApi.fullscreenElement]);\\n\\n        // If cancelling fullscreen, remove event listener.\\n        if (this.isFullscreen() === false) {\\n          Events.off(_globalDocument2['default'], fsApi.fullscreenchange, documentFullscreenChange);\\n        }\\n\\n        this.trigger('fullscreenchange');\\n      }));\\n\\n      this.el_[fsApi.requestFullscreen]();\\n    } else if (this.tech_.supportsFullScreen()) {\\n      // we can't take the video.js controls fullscreen but we can go fullscreen\\n      // with native controls\\n      this.techCall_('enterFullScreen');\\n    } else {\\n      // fullscreen isn't supported so we'll just stretch the video element to\\n      // fill the viewport\\n      this.enterFullWindow();\\n      this.trigger('fullscreenchange');\\n    }\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Return the video to its normal size after having been in full screen mode\\n   * ```js\\n   *     myPlayer.exitFullscreen();\\n   * ```\\n   *\\n   * @return {Player} self\\n   * @method exitFullscreen\\n   */\\n\\n  Player.prototype.exitFullscreen = function exitFullscreen() {\\n    var fsApi = _fullscreenApiJs2['default'];\\n    this.isFullscreen(false);\\n\\n    // Check for browser element fullscreen support\\n    if (fsApi.requestFullscreen) {\\n      _globalDocument2['default'][fsApi.exitFullscreen]();\\n    } else if (this.tech_.supportsFullScreen()) {\\n      this.techCall_('exitFullScreen');\\n    } else {\\n      this.exitFullWindow();\\n      this.trigger('fullscreenchange');\\n    }\\n\\n    return this;\\n  };\\n\\n  /**\\n   * When fullscreen isn't supported we can stretch the video container to as wide as the browser will let us.\\n   *\\n   * @method enterFullWindow\\n   */\\n\\n  Player.prototype.enterFullWindow = function enterFullWindow() {\\n    this.isFullWindow = true;\\n\\n    // Storing original doc overflow value to return to when fullscreen is off\\n    this.docOrigOverflow = _globalDocument2['default'].documentElement.style.overflow;\\n\\n    // Add listener for esc key to exit fullscreen\\n    Events.on(_globalDocument2['default'], 'keydown', Fn.bind(this, this.fullWindowOnEscKey));\\n\\n    // Hide any scroll bars\\n    _globalDocument2['default'].documentElement.style.overflow = 'hidden';\\n\\n    // Apply fullscreen styles\\n    Dom.addElClass(_globalDocument2['default'].body, 'vjs-full-window');\\n\\n    this.trigger('enterFullWindow');\\n  };\\n\\n  /**\\n   * Check for call to either exit full window or full screen on ESC key\\n   *\\n   * @param {String} event Event to check for key press\\n   * @method fullWindowOnEscKey\\n   */\\n\\n  Player.prototype.fullWindowOnEscKey = function fullWindowOnEscKey(event) {\\n    if (event.keyCode === 27) {\\n      if (this.isFullscreen() === true) {\\n        this.exitFullscreen();\\n      } else {\\n        this.exitFullWindow();\\n      }\\n    }\\n  };\\n\\n  /**\\n   * Exit full window\\n   *\\n   * @method exitFullWindow\\n   */\\n\\n  Player.prototype.exitFullWindow = function exitFullWindow() {\\n    this.isFullWindow = false;\\n    Events.off(_globalDocument2['default'], 'keydown', this.fullWindowOnEscKey);\\n\\n    // Unhide scroll bars.\\n    _globalDocument2['default'].documentElement.style.overflow = this.docOrigOverflow;\\n\\n    // Remove fullscreen styles\\n    Dom.removeElClass(_globalDocument2['default'].body, 'vjs-full-window');\\n\\n    // Resize the box, controller, and poster to original sizes\\n    // this.positionAll();\\n    this.trigger('exitFullWindow');\\n  };\\n\\n  /**\\n   * Check whether the player can play a given mimetype\\n   *\\n   * @param {String} type The mimetype to check\\n   * @return {String} 'probably', 'maybe', or '' (empty string)\\n   * @method canPlayType\\n   */\\n\\n  Player.prototype.canPlayType = function canPlayType(type) {\\n    var can = undefined;\\n\\n    // Loop through each playback technology in the options order\\n    for (var i = 0, j = this.options_.techOrder; i < j.length; i++) {\\n      var techName = _utilsToTitleCaseJs2['default'](j[i]);\\n      var tech = _techTechJs2['default'].getTech(techName);\\n\\n      // Support old behavior of techs being registered as components.\\n      // Remove once that deprecated behavior is removed.\\n      if (!tech) {\\n        tech = _componentJs2['default'].getComponent(techName);\\n      }\\n\\n      // Check if the current tech is defined before continuing\\n      if (!tech) {\\n        _utilsLogJs2['default'].error('The \\\"' + techName + '\\\" tech is undefined. Skipped browser support check for that tech.');\\n        continue;\\n      }\\n\\n      // Check if the browser supports this technology\\n      if (tech.isSupported()) {\\n        can = tech.canPlayType(type);\\n\\n        if (can) {\\n          return can;\\n        }\\n      }\\n    }\\n\\n    return '';\\n  };\\n\\n  /**\\n   * Select source based on tech-order or source-order\\n   * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,\\n   * defaults to tech-order selection\\n   *\\n   * @param {Array} sources The sources for a media asset\\n   * @return {Object|Boolean} Object of source and tech order, otherwise false\\n   * @method selectSource\\n   */\\n\\n  Player.prototype.selectSource = function selectSource(sources) {\\n    var _this3 = this;\\n\\n    // Get only the techs specified in `techOrder` that exist and are supported by the\\n    // current platform\\n    var techs = this.options_.techOrder.map(_utilsToTitleCaseJs2['default']).map(function (techName) {\\n      // `Component.getComponent(...)` is for support of old behavior of techs\\n      // being registered as components.\\n      // Remove once that deprecated behavior is removed.\\n      return [techName, _techTechJs2['default'].getTech(techName) || _componentJs2['default'].getComponent(techName)];\\n    }).filter(function (_ref) {\\n      var techName = _ref[0];\\n      var tech = _ref[1];\\n\\n      // Check if the current tech is defined before continuing\\n      if (tech) {\\n        // Check if the browser supports this technology\\n        return tech.isSupported();\\n      }\\n\\n      _utilsLogJs2['default'].error('The \\\"' + techName + '\\\" tech is undefined. Skipped browser support check for that tech.');\\n      return false;\\n    });\\n\\n    // Iterate over each `innerArray` element once per `outerArray` element and execute\\n    // `tester` with both. If `tester` returns a non-falsy value, exit early and return\\n    // that value.\\n    var findFirstPassingTechSourcePair = function findFirstPassingTechSourcePair(outerArray, innerArray, tester) {\\n      var found = undefined;\\n\\n      outerArray.some(function (outerChoice) {\\n        return innerArray.some(function (innerChoice) {\\n          found = tester(outerChoice, innerChoice);\\n\\n          if (found) {\\n            return true;\\n          }\\n        });\\n      });\\n\\n      return found;\\n    };\\n\\n    var foundSourceAndTech = undefined;\\n    var flip = function flip(fn) {\\n      return function (a, b) {\\n        return fn(b, a);\\n      };\\n    };\\n    var finder = function finder(_ref2, source) {\\n      var techName = _ref2[0];\\n      var tech = _ref2[1];\\n\\n      if (tech.canPlaySource(source, _this3.options_[techName.toLowerCase()])) {\\n        return { source: source, tech: techName };\\n      }\\n    };\\n\\n    // Depending on the truthiness of `options.sourceOrder`, we swap the order of techs and sources\\n    // to select from them based on their priority.\\n    if (this.options_.sourceOrder) {\\n      // Source-first ordering\\n      foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));\\n    } else {\\n      // Tech-first ordering\\n      foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);\\n    }\\n\\n    return foundSourceAndTech || false;\\n  };\\n\\n  /**\\n   * The source function updates the video source\\n   * There are three types of variables you can pass as the argument.\\n   * **URL String**: A URL to the the video file. Use this method if you are sure\\n   * the current playback technology (HTML5/Flash) can support the source you\\n   * provide. Currently only MP4 files can be used in both HTML5 and Flash.\\n   * ```js\\n   *     myPlayer.src(\\\"http://www.example.com/path/to/video.mp4\\\");\\n   * ```\\n   * **Source Object (or element):* * A javascript object containing information\\n   * about the source file. Use this method if you want the player to determine if\\n   * it can support the file using the type information.\\n   * ```js\\n   *     myPlayer.src({ type: \\\"video/mp4\\\", src: \\\"http://www.example.com/path/to/video.mp4\\\" });\\n   * ```\\n   * **Array of Source Objects:* * To provide multiple versions of the source so\\n   * that it can be played using HTML5 across browsers you can use an array of\\n   * source objects. Video.js will detect which version is supported and load that\\n   * file.\\n   * ```js\\n   *     myPlayer.src([\\n   *       { type: \\\"video/mp4\\\", src: \\\"http://www.example.com/path/to/video.mp4\\\" },\\n   *       { type: \\\"video/webm\\\", src: \\\"http://www.example.com/path/to/video.webm\\\" },\\n   *       { type: \\\"video/ogg\\\", src: \\\"http://www.example.com/path/to/video.ogv\\\" }\\n   *     ]);\\n   * ```\\n   *\\n   * @param  {String|Object|Array=} source The source URL, object, or array of sources\\n   * @return {String} The current video source when getting\\n   * @return {String} The player when setting\\n   * @method src\\n   */\\n\\n  Player.prototype.src = function src(source) {\\n    if (source === undefined) {\\n      return this.techGet_('src');\\n    }\\n\\n    var currentTech = _techTechJs2['default'].getTech(this.techName_);\\n    // Support old behavior of techs being registered as components.\\n    // Remove once that deprecated behavior is removed.\\n    if (!currentTech) {\\n      currentTech = _componentJs2['default'].getComponent(this.techName_);\\n    }\\n\\n    // case: Array of source objects to choose from and pick the best to play\\n    if (Array.isArray(source)) {\\n      this.sourceList_(source);\\n\\n      // case: URL String (http://myvideo...)\\n    } else if (typeof source === 'string') {\\n        // create a source object from the string\\n        this.src({ src: source });\\n\\n        // case: Source object { src: '', type: '' ... }\\n      } else if (source instanceof Object) {\\n          // check if the source has a type and the loaded tech cannot play the source\\n          // if there's no type we'll just try the current tech\\n          if (source.type && !currentTech.canPlaySource(source, this.options_[this.techName_.toLowerCase()])) {\\n            // create a source list with the current source and send through\\n            // the tech loop to check for a compatible technology\\n            this.sourceList_([source]);\\n          } else {\\n            this.cache_.src = source.src;\\n            this.currentType_ = source.type || '';\\n\\n            // wait until the tech is ready to set the source\\n            this.ready(function () {\\n\\n              // The setSource tech method was added with source handlers\\n              // so older techs won't support it\\n              // We need to check the direct prototype for the case where subclasses\\n              // of the tech do not support source handlers\\n              if (currentTech.prototype.hasOwnProperty('setSource')) {\\n                this.techCall_('setSource', source);\\n              } else {\\n                this.techCall_('src', source.src);\\n              }\\n\\n              if (this.options_.preload === 'auto') {\\n                this.load();\\n              }\\n\\n              if (this.options_.autoplay) {\\n                this.play();\\n              }\\n\\n              // Set the source synchronously if possible (#2326)\\n            }, true);\\n          }\\n        }\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Handle an array of source objects\\n   *\\n   * @param  {Array} sources Array of source objects\\n   * @private\\n   * @method sourceList_\\n   */\\n\\n  Player.prototype.sourceList_ = function sourceList_(sources) {\\n    var sourceTech = this.selectSource(sources);\\n\\n    if (sourceTech) {\\n      if (sourceTech.tech === this.techName_) {\\n        // if this technology is already loaded, set the source\\n        this.src(sourceTech.source);\\n      } else {\\n        // load this technology with the chosen source\\n        this.loadTech_(sourceTech.tech, sourceTech.source);\\n      }\\n    } else {\\n      // We need to wrap this in a timeout to give folks a chance to add error event handlers\\n      this.setTimeout(function () {\\n        this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) });\\n      }, 0);\\n\\n      // we could not find an appropriate tech, but let's still notify the delegate that this is it\\n      // this needs a better comment about why this is needed\\n      this.triggerReady();\\n    }\\n  };\\n\\n  /**\\n   * Begin loading the src data.\\n   *\\n   * @return {Player} Returns the player\\n   * @method load\\n   */\\n\\n  Player.prototype.load = function load() {\\n    this.techCall_('load');\\n    return this;\\n  };\\n\\n  /**\\n   * Reset the player. Loads the first tech in the techOrder,\\n   * and calls `reset` on the tech`.\\n   *\\n   * @return {Player} Returns the player\\n   * @method reset\\n   */\\n\\n  Player.prototype.reset = function reset() {\\n    this.loadTech_(_utilsToTitleCaseJs2['default'](this.options_.techOrder[0]), null);\\n    this.techCall_('reset');\\n    return this;\\n  };\\n\\n  /**\\n   * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4\\n   * Can be used in conjuction with `currentType` to assist in rebuilding the current source object.\\n   *\\n   * @return {String} The current source\\n   * @method currentSrc\\n   */\\n\\n  Player.prototype.currentSrc = function currentSrc() {\\n    return this.techGet_('currentSrc') || this.cache_.src || '';\\n  };\\n\\n  /**\\n   * Get the current source type e.g. video/mp4\\n   * This can allow you rebuild the current source object so that you could load the same\\n   * source and tech later\\n   *\\n   * @return {String} The source MIME type\\n   * @method currentType\\n   */\\n\\n  Player.prototype.currentType = function currentType() {\\n    return this.currentType_ || '';\\n  };\\n\\n  /**\\n   * Get or set the preload attribute\\n   *\\n   * @param {Boolean} value Boolean to determine if preload should be used\\n   * @return {String} The preload attribute value when getting\\n   * @return {Player} Returns the player when setting\\n   * @method preload\\n   */\\n\\n  Player.prototype.preload = function preload(value) {\\n    if (value !== undefined) {\\n      this.techCall_('setPreload', value);\\n      this.options_.preload = value;\\n      return this;\\n    }\\n    return this.techGet_('preload');\\n  };\\n\\n  /**\\n   * Get or set the autoplay attribute.\\n   *\\n   * @param {Boolean} value Boolean to determine if video should autoplay\\n   * @return {String} The autoplay attribute value when getting\\n   * @return {Player} Returns the player when setting\\n   * @method autoplay\\n   */\\n\\n  Player.prototype.autoplay = function autoplay(value) {\\n    if (value !== undefined) {\\n      this.techCall_('setAutoplay', value);\\n      this.options_.autoplay = value;\\n      return this;\\n    }\\n    return this.techGet_('autoplay', value);\\n  };\\n\\n  /**\\n   * Get or set the loop attribute on the video element.\\n   *\\n   * @param {Boolean} value Boolean to determine if video should loop\\n   * @return {String} The loop attribute value when getting\\n   * @return {Player} Returns the player when setting\\n   * @method loop\\n   */\\n\\n  Player.prototype.loop = function loop(value) {\\n    if (value !== undefined) {\\n      this.techCall_('setLoop', value);\\n      this.options_['loop'] = value;\\n      return this;\\n    }\\n    return this.techGet_('loop');\\n  };\\n\\n  /**\\n   * Get or set the poster image source url\\n   *\\n   * ##### EXAMPLE:\\n   * ```js\\n   *     // get\\n   *     var currentPoster = myPlayer.poster();\\n   *     // set\\n   *     myPlayer.poster('http://example.com/myImage.jpg');\\n   * ```\\n   *\\n   * @param  {String=} src Poster image source URL\\n   * @return {String} poster URL when getting\\n   * @return {Player} self when setting\\n   * @method poster\\n   */\\n\\n  Player.prototype.poster = function poster(src) {\\n    if (src === undefined) {\\n      return this.poster_;\\n    }\\n\\n    // The correct way to remove a poster is to set as an empty string\\n    // other falsey values will throw errors\\n    if (!src) {\\n      src = '';\\n    }\\n\\n    // update the internal poster variable\\n    this.poster_ = src;\\n\\n    // update the tech's poster\\n    this.techCall_('setPoster', src);\\n\\n    // alert components that the poster has been set\\n    this.trigger('posterchange');\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Some techs (e.g. YouTube) can provide a poster source in an\\n   * asynchronous way. We want the poster component to use this\\n   * poster source so that it covers up the tech's controls.\\n   * (YouTube's play button). However we only want to use this\\n   * soruce if the player user hasn't set a poster through\\n   * the normal APIs.\\n   *\\n   * @private\\n   * @method handleTechPosterChange_\\n   */\\n\\n  Player.prototype.handleTechPosterChange_ = function handleTechPosterChange_() {\\n    if (!this.poster_ && this.tech_ && this.tech_.poster) {\\n      this.poster_ = this.tech_.poster() || '';\\n\\n      // Let components know the poster has changed\\n      this.trigger('posterchange');\\n    }\\n  };\\n\\n  /**\\n   * Get or set whether or not the controls are showing.\\n   *\\n   * @param  {Boolean} bool Set controls to showing or not\\n   * @return {Boolean}    Controls are showing\\n   * @method controls\\n   */\\n\\n  Player.prototype.controls = function controls(bool) {\\n    if (bool !== undefined) {\\n      bool = !!bool; // force boolean\\n      // Don't trigger a change event unless it actually changed\\n      if (this.controls_ !== bool) {\\n        this.controls_ = bool;\\n\\n        if (this.usingNativeControls()) {\\n          this.techCall_('setControls', bool);\\n        }\\n\\n        if (bool) {\\n          this.removeClass('vjs-controls-disabled');\\n          this.addClass('vjs-controls-enabled');\\n          this.trigger('controlsenabled');\\n\\n          if (!this.usingNativeControls()) {\\n            this.addTechControlsListeners_();\\n          }\\n        } else {\\n          this.removeClass('vjs-controls-enabled');\\n          this.addClass('vjs-controls-disabled');\\n          this.trigger('controlsdisabled');\\n\\n          if (!this.usingNativeControls()) {\\n            this.removeTechControlsListeners_();\\n          }\\n        }\\n      }\\n      return this;\\n    }\\n    return !!this.controls_;\\n  };\\n\\n  /**\\n   * Toggle native controls on/off. Native controls are the controls built into\\n   * devices (e.g. default iPhone controls), Flash, or other techs\\n   * (e.g. Vimeo Controls)\\n   * **This should only be set by the current tech, because only the tech knows\\n   * if it can support native controls**\\n   *\\n   * @param  {Boolean} bool    True signals that native controls are on\\n   * @return {Player}      Returns the player\\n   * @private\\n   * @method usingNativeControls\\n   */\\n\\n  Player.prototype.usingNativeControls = function usingNativeControls(bool) {\\n    if (bool !== undefined) {\\n      bool = !!bool; // force boolean\\n      // Don't trigger a change event unless it actually changed\\n      if (this.usingNativeControls_ !== bool) {\\n        this.usingNativeControls_ = bool;\\n        if (bool) {\\n          this.addClass('vjs-using-native-controls');\\n\\n          /**\\n            * player is using the native device controls\\n           *\\n            * @event usingnativecontrols\\n            * @memberof Player\\n            * @instance\\n            * @private\\n            */\\n          this.trigger('usingnativecontrols');\\n        } else {\\n          this.removeClass('vjs-using-native-controls');\\n\\n          /**\\n            * player is using the custom HTML controls\\n           *\\n            * @event usingcustomcontrols\\n            * @memberof Player\\n            * @instance\\n            * @private\\n            */\\n          this.trigger('usingcustomcontrols');\\n        }\\n      }\\n      return this;\\n    }\\n    return !!this.usingNativeControls_;\\n  };\\n\\n  /**\\n   * Set or get the current MediaError\\n   *\\n   * @param  {*} err A MediaError or a String/Number to be turned into a MediaError\\n   * @return {MediaError|null}     when getting\\n   * @return {Player}              when setting\\n   * @method error\\n   */\\n\\n  Player.prototype.error = function error(err) {\\n    if (err === undefined) {\\n      return this.error_ || null;\\n    }\\n\\n    // restoring to default\\n    if (err === null) {\\n      this.error_ = err;\\n      this.removeClass('vjs-error');\\n      if (this.errorDisplay) {\\n        this.errorDisplay.close();\\n      }\\n      return this;\\n    }\\n\\n    this.error_ = new _mediaErrorJs2['default'](err);\\n\\n    // add the vjs-error classname to the player\\n    this.addClass('vjs-error');\\n\\n    // log the name of the error type and any message\\n    // ie8 just logs \\\"[object object]\\\" if you just log the error object\\n    _utilsLogJs2['default'].error('(CODE:' + this.error_.code + ' ' + _mediaErrorJs2['default'].errorTypes[this.error_.code] + ')', this.error_.message, this.error_);\\n\\n    // fire an error event on the player\\n    this.trigger('error');\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Returns whether or not the player is in the \\\"ended\\\" state.\\n   *\\n   * @return {Boolean} True if the player is in the ended state, false if not.\\n   * @method ended\\n   */\\n\\n  Player.prototype.ended = function ended() {\\n    return this.techGet_('ended');\\n  };\\n\\n  /**\\n   * Returns whether or not the player is in the \\\"seeking\\\" state.\\n   *\\n   * @return {Boolean} True if the player is in the seeking state, false if not.\\n   * @method seeking\\n   */\\n\\n  Player.prototype.seeking = function seeking() {\\n    return this.techGet_('seeking');\\n  };\\n\\n  /**\\n   * Returns the TimeRanges of the media that are currently available\\n   * for seeking to.\\n   *\\n   * @return {TimeRanges} the seekable intervals of the media timeline\\n   * @method seekable\\n   */\\n\\n  Player.prototype.seekable = function seekable() {\\n    return this.techGet_('seekable');\\n  };\\n\\n  /**\\n   * Report user activity\\n   *\\n   * @param {Object} event Event object\\n   * @method reportUserActivity\\n   */\\n\\n  Player.prototype.reportUserActivity = function reportUserActivity(event) {\\n    this.userActivity_ = true;\\n  };\\n\\n  /**\\n   * Get/set if user is active\\n   *\\n   * @param {Boolean} bool Value when setting\\n   * @return {Boolean} Value if user is active user when getting\\n   * @method userActive\\n   */\\n\\n  Player.prototype.userActive = function userActive(bool) {\\n    if (bool !== undefined) {\\n      bool = !!bool;\\n      if (bool !== this.userActive_) {\\n        this.userActive_ = bool;\\n        if (bool) {\\n          // If the user was inactive and is now active we want to reset the\\n          // inactivity timer\\n          this.userActivity_ = true;\\n          this.removeClass('vjs-user-inactive');\\n          this.addClass('vjs-user-active');\\n          this.trigger('useractive');\\n        } else {\\n          // We're switching the state to inactive manually, so erase any other\\n          // activity\\n          this.userActivity_ = false;\\n\\n          // Chrome/Safari/IE have bugs where when you change the cursor it can\\n          // trigger a mousemove event. This causes an issue when you're hiding\\n          // the cursor when the user is inactive, and a mousemove signals user\\n          // activity. Making it impossible to go into inactive mode. Specifically\\n          // this happens in fullscreen when we really need to hide the cursor.\\n          //\\n          // When this gets resolved in ALL browsers it can be removed\\n          // https://code.google.com/p/chromium/issues/detail?id=103041\\n          if (this.tech_) {\\n            this.tech_.one('mousemove', function (e) {\\n              e.stopPropagation();\\n              e.preventDefault();\\n            });\\n          }\\n\\n          this.removeClass('vjs-user-active');\\n          this.addClass('vjs-user-inactive');\\n          this.trigger('userinactive');\\n        }\\n      }\\n      return this;\\n    }\\n    return this.userActive_;\\n  };\\n\\n  /**\\n   * Listen for user activity based on timeout value\\n   *\\n   * @private\\n   * @method listenForUserActivity_\\n   */\\n\\n  Player.prototype.listenForUserActivity_ = function listenForUserActivity_() {\\n    var mouseInProgress = undefined,\\n        lastMoveX = undefined,\\n        lastMoveY = undefined;\\n\\n    var handleActivity = Fn.bind(this, this.reportUserActivity);\\n\\n    var handleMouseMove = function handleMouseMove(e) {\\n      // #1068 - Prevent mousemove spamming\\n      // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970\\n      if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {\\n        lastMoveX = e.screenX;\\n        lastMoveY = e.screenY;\\n        handleActivity();\\n      }\\n    };\\n\\n    var handleMouseDown = function handleMouseDown() {\\n      handleActivity();\\n      // For as long as the they are touching the device or have their mouse down,\\n      // we consider them active even if they're not moving their finger or mouse.\\n      // So we want to continue to update that they are active\\n      this.clearInterval(mouseInProgress);\\n      // Setting userActivity=true now and setting the interval to the same time\\n      // as the activityCheck interval (250) should ensure we never miss the\\n      // next activityCheck\\n      mouseInProgress = this.setInterval(handleActivity, 250);\\n    };\\n\\n    var handleMouseUp = function handleMouseUp(event) {\\n      handleActivity();\\n      // Stop the interval that maintains activity if the mouse/touch is down\\n      this.clearInterval(mouseInProgress);\\n    };\\n\\n    // Any mouse movement will be considered user activity\\n    this.on('mousedown', handleMouseDown);\\n    this.on('mousemove', handleMouseMove);\\n    this.on('mouseup', handleMouseUp);\\n\\n    // Listen for keyboard navigation\\n    // Shouldn't need to use inProgress interval because of key repeat\\n    this.on('keydown', handleActivity);\\n    this.on('keyup', handleActivity);\\n\\n    // Run an interval every 250 milliseconds instead of stuffing everything into\\n    // the mousemove/touchmove function itself, to prevent performance degradation.\\n    // `this.reportUserActivity` simply sets this.userActivity_ to true, which\\n    // then gets picked up by this loop\\n    // http://ejohn.org/blog/learning-from-twitter/\\n    var inactivityTimeout = undefined;\\n    var activityCheck = this.setInterval(function () {\\n      // Check to see if mouse/touch activity has happened\\n      if (this.userActivity_) {\\n        // Reset the activity tracker\\n        this.userActivity_ = false;\\n\\n        // If the user state was inactive, set the state to active\\n        this.userActive(true);\\n\\n        // Clear any existing inactivity timeout to start the timer over\\n        this.clearTimeout(inactivityTimeout);\\n\\n        var timeout = this.options_['inactivityTimeout'];\\n        if (timeout > 0) {\\n          // In <timeout> milliseconds, if no more activity has occurred the\\n          // user will be considered inactive\\n          inactivityTimeout = this.setTimeout(function () {\\n            // Protect against the case where the inactivityTimeout can trigger just\\n            // before the next user activity is picked up by the activityCheck loop\\n            // causing a flicker\\n            if (!this.userActivity_) {\\n              this.userActive(false);\\n            }\\n          }, timeout);\\n        }\\n      }\\n    }, 250);\\n  };\\n\\n  /**\\n   * Gets or sets the current playback rate.  A playback rate of\\n   * 1.0 represents normal speed and 0.5 would indicate half-speed\\n   * playback, for instance.\\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate\\n   *\\n   * @param  {Number} rate    New playback rate to set.\\n   * @return {Number}         Returns the new playback rate when setting\\n   * @return {Number}         Returns the current playback rate when getting\\n   * @method playbackRate\\n   */\\n\\n  Player.prototype.playbackRate = function playbackRate(rate) {\\n    if (rate !== undefined) {\\n      this.techCall_('setPlaybackRate', rate);\\n      return this;\\n    }\\n\\n    if (this.tech_ && this.tech_['featuresPlaybackRate']) {\\n      return this.techGet_('playbackRate');\\n    } else {\\n      return 1.0;\\n    }\\n  };\\n\\n  /**\\n   * Gets or sets the audio flag\\n   *\\n   * @param  {Boolean} bool    True signals that this is an audio player.\\n   * @return {Boolean}         Returns true if player is audio, false if not when getting\\n   * @return {Player}      Returns the player if setting\\n   * @private\\n   * @method isAudio\\n   */\\n\\n  Player.prototype.isAudio = function isAudio(bool) {\\n    if (bool !== undefined) {\\n      this.isAudio_ = !!bool;\\n      return this;\\n    }\\n\\n    return !!this.isAudio_;\\n  };\\n\\n  /**\\n   * Returns the current state of network activity for the element, from\\n   * the codes in the list below.\\n   * - NETWORK_EMPTY (numeric value 0)\\n   *   The element has not yet been initialised. All attributes are in\\n   *   their initial states.\\n   * - NETWORK_IDLE (numeric value 1)\\n   *   The element's resource selection algorithm is active and has\\n   *   selected a resource, but it is not actually using the network at\\n   *   this time.\\n   * - NETWORK_LOADING (numeric value 2)\\n   *   The user agent is actively trying to download data.\\n   * - NETWORK_NO_SOURCE (numeric value 3)\\n   *   The element's resource selection algorithm is active, but it has\\n   *   not yet found a resource to use.\\n   *\\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states\\n   * @return {Number} the current network activity state\\n   * @method networkState\\n   */\\n\\n  Player.prototype.networkState = function networkState() {\\n    return this.techGet_('networkState');\\n  };\\n\\n  /**\\n   * Returns a value that expresses the current state of the element\\n   * with respect to rendering the current playback position, from the\\n   * codes in the list below.\\n   * - HAVE_NOTHING (numeric value 0)\\n   *   No information regarding the media resource is available.\\n   * - HAVE_METADATA (numeric value 1)\\n   *   Enough of the resource has been obtained that the duration of the\\n   *   resource is available.\\n   * - HAVE_CURRENT_DATA (numeric value 2)\\n   *   Data for the immediate current playback position is available.\\n   * - HAVE_FUTURE_DATA (numeric value 3)\\n   *   Data for the immediate current playback position is available, as\\n   *   well as enough data for the user agent to advance the current\\n   *   playback position in the direction of playback.\\n   * - HAVE_ENOUGH_DATA (numeric value 4)\\n   *   The user agent estimates that enough data is available for\\n   *   playback to proceed uninterrupted.\\n   *\\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate\\n   * @return {Number} the current playback rendering state\\n   * @method readyState\\n   */\\n\\n  Player.prototype.readyState = function readyState() {\\n    return this.techGet_('readyState');\\n  };\\n\\n  /**\\n   * Get a video track list\\n   * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist\\n   *\\n   * @return {VideoTrackList} thes current video track list\\n   * @method videoTracks\\n   */\\n\\n  Player.prototype.videoTracks = function videoTracks() {\\n    // if we have not yet loadTech_, we create videoTracks_\\n    // these will be passed to the tech during loading\\n    if (!this.tech_) {\\n      this.videoTracks_ = this.videoTracks_ || new _tracksVideoTrackListJs2['default']();\\n      return this.videoTracks_;\\n    }\\n\\n    return this.tech_.videoTracks();\\n  };\\n\\n  /**\\n   * Get an audio track list\\n   * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist\\n   *\\n   * @return {AudioTrackList} thes current audio track list\\n   * @method audioTracks\\n   */\\n\\n  Player.prototype.audioTracks = function audioTracks() {\\n    // if we have not yet loadTech_, we create videoTracks_\\n    // these will be passed to the tech during loading\\n    if (!this.tech_) {\\n      this.audioTracks_ = this.audioTracks_ || new _tracksAudioTrackListJs2['default']();\\n      return this.audioTracks_;\\n    }\\n\\n    return this.tech_.audioTracks();\\n  };\\n\\n  /*\\n    * Text tracks are tracks of timed text events.\\n    * Captions - text displayed over the video for the hearing impaired\\n    * Subtitles - text displayed over the video for those who don't understand language in the video\\n    * Chapters - text displayed in a menu allowing the user to jump to particular points (chapters) in the video\\n    * Descriptions (not supported yet) - audio descriptions that are read back to the user by a screen reading device\\n    */\\n\\n  /**\\n   * Get an array of associated text tracks. captions, subtitles, chapters, descriptions\\n   * http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks\\n   *\\n   * @return {Array}           Array of track objects\\n   * @method textTracks\\n   */\\n\\n  Player.prototype.textTracks = function textTracks() {\\n    // cannot use techGet_ directly because it checks to see whether the tech is ready.\\n    // Flash is unlikely to be ready in time but textTracks should still work.\\n    return this.tech_ && this.tech_['textTracks']();\\n  };\\n\\n  /**\\n   * Get an array of remote text tracks\\n   *\\n   * @return {Array}\\n   * @method remoteTextTracks\\n   */\\n\\n  Player.prototype.remoteTextTracks = function remoteTextTracks() {\\n    return this.tech_ && this.tech_['remoteTextTracks']();\\n  };\\n\\n  /**\\n   * Get an array of remote html track elements\\n   *\\n   * @return {HTMLTrackElement[]}\\n   * @method remoteTextTrackEls\\n   */\\n\\n  Player.prototype.remoteTextTrackEls = function remoteTextTrackEls() {\\n    return this.tech_ && this.tech_['remoteTextTrackEls']();\\n  };\\n\\n  /**\\n   * Add a text track\\n   * In addition to the W3C settings we allow adding additional info through options.\\n   * http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack\\n   *\\n   * @param {String}  kind        Captions, subtitles, chapters, descriptions, or metadata\\n   * @param {String=} label       Optional label\\n   * @param {String=} language    Optional language\\n   * @method addTextTrack\\n   */\\n\\n  Player.prototype.addTextTrack = function addTextTrack(kind, label, language) {\\n    return this.tech_ && this.tech_['addTextTrack'](kind, label, language);\\n  };\\n\\n  /**\\n   * Add a remote text track\\n   *\\n   * @param {Object} options    Options for remote text track\\n   * @method addRemoteTextTrack\\n   */\\n\\n  Player.prototype.addRemoteTextTrack = function addRemoteTextTrack(options) {\\n    return this.tech_ && this.tech_['addRemoteTextTrack'](options);\\n  };\\n\\n  /**\\n   * Remove a remote text track\\n   *\\n   * @param {Object} track    Remote text track to remove\\n   * @method removeRemoteTextTrack\\n   */\\n  // destructure the input into an object with a track argument, defaulting to arguments[0]\\n  // default the whole argument to an empty object if nothing was passed in\\n\\n  Player.prototype.removeRemoteTextTrack = function removeRemoteTextTrack() {\\n    var _ref3 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\\n\\n    var _ref3$track = _ref3.track;\\n    var track = _ref3$track === undefined ? arguments[0] : _ref3$track;\\n    // jshint ignore:line\\n    this.tech_ && this.tech_['removeRemoteTextTrack'](track);\\n  };\\n\\n  /**\\n   * Get video width\\n   *\\n   * @return {Number} Video width\\n   * @method videoWidth\\n   */\\n\\n  Player.prototype.videoWidth = function videoWidth() {\\n    return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;\\n  };\\n\\n  /**\\n   * Get video height\\n   *\\n   * @return {Number} Video height\\n   * @method videoHeight\\n   */\\n\\n  Player.prototype.videoHeight = function videoHeight() {\\n    return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;\\n  };\\n\\n  // Methods to add support for\\n  // initialTime: function(){ return this.techCall_('initialTime'); },\\n  // startOffsetTime: function(){ return this.techCall_('startOffsetTime'); },\\n  // played: function(){ return this.techCall_('played'); },\\n  // defaultPlaybackRate: function(){ return this.techCall_('defaultPlaybackRate'); },\\n  // defaultMuted: function(){ return this.techCall_('defaultMuted'); }\\n\\n  /**\\n   * The player's language code\\n   * NOTE: The language should be set in the player options if you want the\\n   * the controls to be built with a specific language. Changing the lanugage\\n   * later will not update controls text.\\n   *\\n   * @param {String} code  The locale string\\n   * @return {String}      The locale string when getting\\n   * @return {Player}      self when setting\\n   * @method language\\n   */\\n\\n  Player.prototype.language = function language(code) {\\n    if (code === undefined) {\\n      return this.language_;\\n    }\\n\\n    this.language_ = ('' + code).toLowerCase();\\n    return this;\\n  };\\n\\n  /**\\n   * Get the player's language dictionary\\n   * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time\\n   * Languages specified directly in the player options have precedence\\n   *\\n   * @return {Array} Array of languages\\n   * @method languages\\n   */\\n\\n  Player.prototype.languages = function languages() {\\n    return _utilsMergeOptionsJs2['default'](Player.prototype.options_.languages, this.languages_);\\n  };\\n\\n  /**\\n   * Converts track info to JSON\\n   *\\n   * @return {Object} JSON object of options\\n   * @method toJSON\\n   */\\n\\n  Player.prototype.toJSON = function toJSON() {\\n    var options = _utilsMergeOptionsJs2['default'](this.options_);\\n    var tracks = options.tracks;\\n\\n    options.tracks = [];\\n\\n    for (var i = 0; i < tracks.length; i++) {\\n      var track = tracks[i];\\n\\n      // deep merge tracks and null out player so no circular references\\n      track = _utilsMergeOptionsJs2['default'](track);\\n      track.player = undefined;\\n      options.tracks[i] = track;\\n    }\\n\\n    return options;\\n  };\\n\\n  /**\\n   * Creates a simple modal dialog (an instance of the `ModalDialog`\\n   * component) that immediately overlays the player with arbitrary\\n   * content and removes itself when closed.\\n   *\\n   * @param {String|Function|Element|Array|Null} content\\n   *        Same as `ModalDialog#content`'s param of the same name.\\n   *\\n   *        The most straight-forward usage is to provide a string or DOM\\n   *        element.\\n   *\\n   * @param {Object} [options]\\n   *        Extra options which will be passed on to the `ModalDialog`.\\n   *\\n   * @return {ModalDialog}\\n   */\\n\\n  Player.prototype.createModal = function createModal(content, options) {\\n    var player = this;\\n\\n    options = options || {};\\n    options.content = content || '';\\n\\n    var modal = new _modalDialog2['default'](player, options);\\n\\n    player.addChild(modal);\\n    modal.on('dispose', function () {\\n      player.removeChild(modal);\\n    });\\n\\n    return modal.open();\\n  };\\n\\n  /**\\n   * Gets tag settings\\n   *\\n   * @param {Element} tag The player tag\\n   * @return {Array} An array of sources and track objects\\n   * @static\\n   * @method getTagSettings\\n   */\\n\\n  Player.getTagSettings = function getTagSettings(tag) {\\n    var baseOptions = {\\n      'sources': [],\\n      'tracks': []\\n    };\\n\\n    var tagOptions = Dom.getElAttributes(tag);\\n    var dataSetup = tagOptions['data-setup'];\\n\\n    // Check if data-setup attr exists.\\n    if (dataSetup !== null) {\\n      // Parse options JSON\\n\\n      var _safeParseTuple = _safeJsonParseTuple2['default'](dataSetup || '{}');\\n\\n      var err = _safeParseTuple[0];\\n      var data = _safeParseTuple[1];\\n\\n      if (err) {\\n        _utilsLogJs2['default'].error(err);\\n      }\\n      _objectAssign2['default'](tagOptions, data);\\n    }\\n\\n    _objectAssign2['default'](baseOptions, tagOptions);\\n\\n    // Get tag children settings\\n    if (tag.hasChildNodes()) {\\n      var children = tag.childNodes;\\n\\n      for (var i = 0, j = children.length; i < j; i++) {\\n        var child = children[i];\\n        // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/\\n        var childName = child.nodeName.toLowerCase();\\n        if (childName === 'source') {\\n          baseOptions.sources.push(Dom.getElAttributes(child));\\n        } else if (childName === 'track') {\\n          baseOptions.tracks.push(Dom.getElAttributes(child));\\n        }\\n      }\\n    }\\n\\n    return baseOptions;\\n  };\\n\\n  return Player;\\n})(_componentJs2['default']);\\n\\nPlayer.players = {};\\n\\nvar navigator = _globalWindow2['default'].navigator;\\n/*\\n * Player instance options, surfaced using options\\n * options = Player.prototype.options_\\n * Make changes in options, not here.\\n *\\n * @type {Object}\\n * @private\\n */\\nPlayer.prototype.options_ = {\\n  // Default order of fallback technology\\n  techOrder: ['html5', 'flash'],\\n  // techOrder: ['flash','html5'],\\n\\n  html5: {},\\n  flash: {},\\n\\n  // defaultVolume: 0.85,\\n  defaultVolume: 0.00, // The freakin seaguls are driving me crazy!\\n\\n  // default inactivity timeout\\n  inactivityTimeout: 2000,\\n\\n  // default playback rates\\n  playbackRates: [],\\n  // Add playback rate selection by adding rates\\n  // 'playbackRates': [0.5, 1, 1.5, 2],\\n\\n  // Included control sets\\n  children: ['mediaLoader', 'posterImage', 'textTrackDisplay', 'loadingSpinner', 'bigPlayButton', 'controlBar', 'errorDisplay', 'textTrackSettings'],\\n\\n  language: navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language || 'en',\\n\\n  // locales and their language translations\\n  languages: {},\\n\\n  // Default message to show when a video cannot be played.\\n  notSupportedMessage: 'No compatible source was found for this media.'\\n};\\n\\n/**\\n * Fired when the user agent begins looking for media data\\n *\\n * @event loadstart\\n */\\nPlayer.prototype.handleTechLoadStart_;\\n\\n/**\\n * Fired when the player has initial duration and dimension information\\n *\\n * @event loadedmetadata\\n */\\nPlayer.prototype.handleLoadedMetaData_;\\n\\n/**\\n * Fired when the player receives text data\\n *\\n * @event textdata\\n */\\nPlayer.prototype.handleTextData_;\\n\\n/**\\n * Fired when the player has downloaded data at the current playback position\\n *\\n * @event loadeddata\\n */\\nPlayer.prototype.handleLoadedData_;\\n\\n/**\\n * Fired when the user is active, e.g. moves the mouse over the player\\n *\\n * @event useractive\\n */\\nPlayer.prototype.handleUserActive_;\\n\\n/**\\n * Fired when the user is inactive, e.g. a short delay after the last mouse move or control interaction\\n *\\n * @event userinactive\\n */\\nPlayer.prototype.handleUserInactive_;\\n\\n/**\\n * Fired when the current playback position has changed *\\n * During playback this is fired every 15-250 milliseconds, depending on the\\n * playback technology in use.\\n *\\n * @event timeupdate\\n */\\nPlayer.prototype.handleTimeUpdate_;\\n\\n/**\\n * Fired when video playback ends\\n *\\n * @event ended\\n */\\nPlayer.prototype.handleTechEnded_;\\n\\n/**\\n * Fired when the volume changes\\n *\\n * @event volumechange\\n */\\nPlayer.prototype.handleVolumeChange_;\\n\\n/**\\n * Fired when an error occurs\\n *\\n * @event error\\n */\\nPlayer.prototype.handleError_;\\n\\nPlayer.prototype.flexNotSupported_ = function () {\\n  var elem = _globalDocument2['default'].createElement('i');\\n\\n  // Note: We don't actually use flexBasis (or flexOrder), but it's one of the more\\n  // common flex features that we can rely on when checking for flex support.\\n  return !('flexBasis' in elem.style || 'webkitFlexBasis' in elem.style || 'mozFlexBasis' in elem.style || 'msFlexBasis' in elem.style || 'msFlexOrder' in elem.style) /* IE10-specific (2012 flex spec)  */;\\n};\\n\\n_componentJs2['default'].registerComponent('Player', Player);\\nexports['default'] = Player;\\nmodule.exports = exports['default'];\\n// If empty string, make it a parsable json object.\\n\\n},{\\\"./big-play-button.js\\\":63,\\\"./component.js\\\":67,\\\"./control-bar/control-bar.js\\\":70,\\\"./error-display.js\\\":103,\\\"./fullscreen-api.js\\\":106,\\\"./loading-spinner.js\\\":107,\\\"./media-error.js\\\":108,\\\"./modal-dialog\\\":112,\\\"./poster-image.js\\\":117,\\\"./tech/html5.js\\\":122,\\\"./tech/loader.js\\\":123,\\\"./tech/tech.js\\\":124,\\\"./tracks/audio-track-list.js\\\":125,\\\"./tracks/text-track-display.js\\\":130,\\\"./tracks/text-track-list-converter.js\\\":131,\\\"./tracks/text-track-settings.js\\\":133,\\\"./tracks/video-track-list.js\\\":138,\\\"./utils/browser.js\\\":140,\\\"./utils/buffer.js\\\":141,\\\"./utils/dom.js\\\":142,\\\"./utils/events.js\\\":143,\\\"./utils/fn.js\\\":144,\\\"./utils/guid.js\\\":146,\\\"./utils/log.js\\\":147,\\\"./utils/merge-options.js\\\":148,\\\"./utils/stylesheet.js\\\":149,\\\"./utils/time-ranges.js\\\":150,\\\"./utils/to-title-case.js\\\":151,\\\"global/document\\\":1,\\\"global/window\\\":2,\\\"object.assign\\\":45,\\\"safe-json-parse/tuple\\\":54}],114:[function(_dereq_,module,exports){\\n/**\\n * @file plugins.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _playerJs = _dereq_('./player.js');\\n\\nvar _playerJs2 = _interopRequireDefault(_playerJs);\\n\\n/**\\n * The method for registering a video.js plugin\\n *\\n * @param  {String} name The name of the plugin\\n * @param  {Function} init The function that is run when the player inits\\n * @method plugin\\n */\\nvar plugin = function plugin(name, init) {\\n  _playerJs2['default'].prototype[name] = init;\\n};\\n\\nexports['default'] = plugin;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./player.js\\\":113}],115:[function(_dereq_,module,exports){\\n/**\\n * @file popup-button.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _clickableComponentJs = _dereq_('../clickable-component.js');\\n\\nvar _clickableComponentJs2 = _interopRequireDefault(_clickableComponentJs);\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _popupJs = _dereq_('./popup.js');\\n\\nvar _popupJs2 = _interopRequireDefault(_popupJs);\\n\\nvar _utilsDomJs = _dereq_('../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsToTitleCaseJs = _dereq_('../utils/to-title-case.js');\\n\\nvar _utilsToTitleCaseJs2 = _interopRequireDefault(_utilsToTitleCaseJs);\\n\\n/**\\n * A button class with a popup control\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends ClickableComponent\\n * @class PopupButton\\n */\\n\\nvar PopupButton = (function (_ClickableComponent) {\\n  _inherits(PopupButton, _ClickableComponent);\\n\\n  function PopupButton(player) {\\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n\\n    _classCallCheck(this, PopupButton);\\n\\n    _ClickableComponent.call(this, player, options);\\n\\n    this.update();\\n  }\\n\\n  /**\\n   * Update popup\\n   *\\n   * @method update\\n   */\\n\\n  PopupButton.prototype.update = function update() {\\n    var popup = this.createPopup();\\n\\n    if (this.popup) {\\n      this.removeChild(this.popup);\\n    }\\n\\n    this.popup = popup;\\n    this.addChild(popup);\\n\\n    if (this.items && this.items.length === 0) {\\n      this.hide();\\n    } else if (this.items && this.items.length > 1) {\\n      this.show();\\n    }\\n  };\\n\\n  /**\\n   * Create popup - Override with specific functionality for component\\n   *\\n   * @return {Popup} The constructed popup\\n   * @method createPopup\\n   */\\n\\n  PopupButton.prototype.createPopup = function createPopup() {};\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  PopupButton.prototype.createEl = function createEl() {\\n    return _ClickableComponent.prototype.createEl.call(this, 'div', {\\n      className: this.buildCSSClass()\\n    });\\n  };\\n\\n  /**\\n   * Allow sub components to stack CSS class names\\n   *\\n   * @return {String} The constructed class name\\n   * @method buildCSSClass\\n   */\\n\\n  PopupButton.prototype.buildCSSClass = function buildCSSClass() {\\n    var menuButtonClass = 'vjs-menu-button';\\n\\n    // If the inline option is passed, we want to use different styles altogether.\\n    if (this.options_.inline === true) {\\n      menuButtonClass += '-inline';\\n    } else {\\n      menuButtonClass += '-popup';\\n    }\\n\\n    return 'vjs-menu-button ' + menuButtonClass + ' ' + _ClickableComponent.prototype.buildCSSClass.call(this);\\n  };\\n\\n  return PopupButton;\\n})(_clickableComponentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('PopupButton', PopupButton);\\nexports['default'] = PopupButton;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../clickable-component.js\\\":65,\\\"../component.js\\\":67,\\\"../utils/dom.js\\\":142,\\\"../utils/fn.js\\\":144,\\\"../utils/to-title-case.js\\\":151,\\\"./popup.js\\\":116}],116:[function(_dereq_,module,exports){\\n/**\\n * @file popup.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsDomJs = _dereq_('../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsEventsJs = _dereq_('../utils/events.js');\\n\\nvar Events = _interopRequireWildcard(_utilsEventsJs);\\n\\n/**\\n * The Popup component is used to build pop up controls.\\n *\\n * @extends Component\\n * @class Popup\\n */\\n\\nvar Popup = (function (_Component) {\\n  _inherits(Popup, _Component);\\n\\n  function Popup() {\\n    _classCallCheck(this, Popup);\\n\\n    _Component.apply(this, arguments);\\n  }\\n\\n  /**\\n   * Add a popup item to the popup\\n   *\\n   * @param {Object|String} component Component or component type to add\\n   * @method addItem\\n   */\\n\\n  Popup.prototype.addItem = function addItem(component) {\\n    this.addChild(component);\\n    component.on('click', Fn.bind(this, function () {\\n      this.unlockShowing();\\n    }));\\n  };\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  Popup.prototype.createEl = function createEl() {\\n    var contentElType = this.options_.contentElType || 'ul';\\n    this.contentEl_ = Dom.createEl(contentElType, {\\n      className: 'vjs-menu-content'\\n    });\\n    var el = _Component.prototype.createEl.call(this, 'div', {\\n      append: this.contentEl_,\\n      className: 'vjs-menu'\\n    });\\n    el.appendChild(this.contentEl_);\\n\\n    // Prevent clicks from bubbling up. Needed for Popup Buttons,\\n    // where a click on the parent is significant\\n    Events.on(el, 'click', function (event) {\\n      event.preventDefault();\\n      event.stopImmediatePropagation();\\n    });\\n\\n    return el;\\n  };\\n\\n  return Popup;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('Popup', Popup);\\nexports['default'] = Popup;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component.js\\\":67,\\\"../utils/dom.js\\\":142,\\\"../utils/events.js\\\":143,\\\"../utils/fn.js\\\":144}],117:[function(_dereq_,module,exports){\\n/**\\n * @file poster-image.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _clickableComponentJs = _dereq_('./clickable-component.js');\\n\\nvar _clickableComponentJs2 = _interopRequireDefault(_clickableComponentJs);\\n\\nvar _componentJs = _dereq_('./component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsFnJs = _dereq_('./utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsDomJs = _dereq_('./utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsBrowserJs = _dereq_('./utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\n/**\\n * The component that handles showing the poster image.\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Button\\n * @class PosterImage\\n */\\n\\nvar PosterImage = (function (_ClickableComponent) {\\n  _inherits(PosterImage, _ClickableComponent);\\n\\n  function PosterImage(player, options) {\\n    _classCallCheck(this, PosterImage);\\n\\n    _ClickableComponent.call(this, player, options);\\n\\n    this.update();\\n    player.on('posterchange', Fn.bind(this, this.update));\\n  }\\n\\n  /**\\n   * Clean up the poster image\\n   *\\n   * @method dispose\\n   */\\n\\n  PosterImage.prototype.dispose = function dispose() {\\n    this.player().off('posterchange', this.update);\\n    _ClickableComponent.prototype.dispose.call(this);\\n  };\\n\\n  /**\\n   * Create the poster's image element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  PosterImage.prototype.createEl = function createEl() {\\n    var el = Dom.createEl('div', {\\n      className: 'vjs-poster',\\n\\n      // Don't want poster to be tabbable.\\n      tabIndex: -1\\n    });\\n\\n    // To ensure the poster image resizes while maintaining its original aspect\\n    // ratio, use a div with `background-size` when available. For browsers that\\n    // do not support `background-size` (e.g. IE8), fall back on using a regular\\n    // img element.\\n    if (!browser.BACKGROUND_SIZE_SUPPORTED) {\\n      this.fallbackImg_ = Dom.createEl('img');\\n      el.appendChild(this.fallbackImg_);\\n    }\\n\\n    return el;\\n  };\\n\\n  /**\\n   * Event handler for updates to the player's poster source\\n   *\\n   * @method update\\n   */\\n\\n  PosterImage.prototype.update = function update() {\\n    var url = this.player().poster();\\n\\n    this.setSrc(url);\\n\\n    // If there's no poster source we should display:none on this component\\n    // so it's not still clickable or right-clickable\\n    if (url) {\\n      this.show();\\n    } else {\\n      this.hide();\\n    }\\n  };\\n\\n  /**\\n   * Set the poster source depending on the display method\\n   *\\n   * @param {String} url The URL to the poster source\\n   * @method setSrc\\n   */\\n\\n  PosterImage.prototype.setSrc = function setSrc(url) {\\n    if (this.fallbackImg_) {\\n      this.fallbackImg_.src = url;\\n    } else {\\n      var backgroundImage = '';\\n      // Any falsey values should stay as an empty string, otherwise\\n      // this will throw an extra error\\n      if (url) {\\n        backgroundImage = 'url(\\\"' + url + '\\\")';\\n      }\\n\\n      this.el_.style.backgroundImage = backgroundImage;\\n    }\\n  };\\n\\n  /**\\n   * Event handler for clicks on the poster image\\n   *\\n   * @method handleClick\\n   */\\n\\n  PosterImage.prototype.handleClick = function handleClick() {\\n    // We don't want a click to trigger playback when controls are disabled\\n    // but CSS should be hiding the poster to prevent that from happening\\n    if (this.player_.paused()) {\\n      this.player_.play();\\n    } else {\\n      this.player_.pause();\\n    }\\n  };\\n\\n  return PosterImage;\\n})(_clickableComponentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('PosterImage', PosterImage);\\nexports['default'] = PosterImage;\\nmodule.exports = exports['default'];\\n\\n},{\\\"./clickable-component.js\\\":65,\\\"./component.js\\\":67,\\\"./utils/browser.js\\\":140,\\\"./utils/dom.js\\\":142,\\\"./utils/fn.js\\\":144}],118:[function(_dereq_,module,exports){\\n/**\\n * @file setup.js\\n *\\n * Functions for automatically setting up a player\\n * based on the data-setup attribute of the video tag\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nvar _utilsEventsJs = _dereq_('./utils/events.js');\\n\\nvar Events = _interopRequireWildcard(_utilsEventsJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _windowLoaded = false;\\nvar videojs = undefined;\\n\\n// Automatically set up any tags that have a data-setup attribute\\nvar autoSetup = function autoSetup() {\\n  // One day, when we stop supporting IE8, go back to this, but in the meantime...*hack hack hack*\\n  // var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));\\n  // var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));\\n  // var mediaEls = vids.concat(audios);\\n\\n  // Because IE8 doesn't support calling slice on a node list, we need to loop through each list of elements\\n  // to build up a new, combined list of elements.\\n  var vids = _globalDocument2['default'].getElementsByTagName('video');\\n  var audios = _globalDocument2['default'].getElementsByTagName('audio');\\n  var mediaEls = [];\\n  if (vids && vids.length > 0) {\\n    for (var i = 0, e = vids.length; i < e; i++) {\\n      mediaEls.push(vids[i]);\\n    }\\n  }\\n  if (audios && audios.length > 0) {\\n    for (var i = 0, e = audios.length; i < e; i++) {\\n      mediaEls.push(audios[i]);\\n    }\\n  }\\n\\n  // Check if any media elements exist\\n  if (mediaEls && mediaEls.length > 0) {\\n\\n    for (var i = 0, e = mediaEls.length; i < e; i++) {\\n      var mediaEl = mediaEls[i];\\n\\n      // Check if element exists, has getAttribute func.\\n      // IE seems to consider typeof el.getAttribute == 'object' instead of 'function' like expected, at least when loading the player immediately.\\n      if (mediaEl && mediaEl.getAttribute) {\\n\\n        // Make sure this player hasn't already been set up.\\n        if (mediaEl['player'] === undefined) {\\n          var options = mediaEl.getAttribute('data-setup');\\n\\n          // Check if data-setup attr exists.\\n          // We only auto-setup if they've added the data-setup attr.\\n          if (options !== null) {\\n            // Create new video.js instance.\\n            var player = videojs(mediaEl);\\n          }\\n        }\\n\\n        // If getAttribute isn't defined, we need to wait for the DOM.\\n      } else {\\n          autoSetupTimeout(1);\\n          break;\\n        }\\n    }\\n\\n    // No videos were found, so keep looping unless page is finished loading.\\n  } else if (!_windowLoaded) {\\n      autoSetupTimeout(1);\\n    }\\n};\\n\\n// Pause to let the DOM keep processing\\nvar autoSetupTimeout = function autoSetupTimeout(wait, vjs) {\\n  if (vjs) {\\n    videojs = vjs;\\n  }\\n\\n  setTimeout(autoSetup, wait);\\n};\\n\\nif (_globalDocument2['default'].readyState === 'complete') {\\n  _windowLoaded = true;\\n} else {\\n  Events.one(_globalWindow2['default'], 'load', function () {\\n    _windowLoaded = true;\\n  });\\n}\\n\\nvar hasLoaded = function hasLoaded() {\\n  return _windowLoaded;\\n};\\n\\nexports.autoSetup = autoSetup;\\nexports.autoSetupTimeout = autoSetupTimeout;\\nexports.hasLoaded = hasLoaded;\\n\\n},{\\\"./utils/events.js\\\":143,\\\"global/document\\\":1,\\\"global/window\\\":2}],119:[function(_dereq_,module,exports){\\n/**\\n * @file slider.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _utilsDomJs = _dereq_('../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _objectAssign = _dereq_('object.assign');\\n\\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\\n\\n/**\\n * The base functionality for sliders like the volume bar and seek bar\\n *\\n * @param {Player|Object} player\\n * @param {Object=} options\\n * @extends Component\\n * @class Slider\\n */\\n\\nvar Slider = (function (_Component) {\\n  _inherits(Slider, _Component);\\n\\n  function Slider(player, options) {\\n    _classCallCheck(this, Slider);\\n\\n    _Component.call(this, player, options);\\n\\n    // Set property names to bar to match with the child Slider class is looking for\\n    this.bar = this.getChild(this.options_.barName);\\n\\n    // Set a horizontal or vertical class on the slider depending on the slider type\\n    this.vertical(!!this.options_.vertical);\\n\\n    this.on('mousedown', this.handleMouseDown);\\n    this.on('touchstart', this.handleMouseDown);\\n    this.on('focus', this.handleFocus);\\n    this.on('blur', this.handleBlur);\\n    this.on('click', this.handleClick);\\n\\n    this.on(player, 'controlsvisible', this.update);\\n    this.on(player, this.playerEvent, this.update);\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @param {String} type Type of element to create\\n   * @param {Object=} props List of properties in Object form\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  Slider.prototype.createEl = function createEl(type) {\\n    var props = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n    var attributes = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\\n\\n    // Add the slider element class to all sub classes\\n    props.className = props.className + ' vjs-slider';\\n    props = _objectAssign2['default']({\\n      tabIndex: 0\\n    }, props);\\n\\n    attributes = _objectAssign2['default']({\\n      'role': 'slider',\\n      'aria-valuenow': 0,\\n      'aria-valuemin': 0,\\n      'aria-valuemax': 100,\\n      tabIndex: 0\\n    }, attributes);\\n\\n    return _Component.prototype.createEl.call(this, type, props, attributes);\\n  };\\n\\n  /**\\n   * Handle mouse down on slider\\n   *\\n   * @param {Object} event Mouse down event object\\n   * @method handleMouseDown\\n   */\\n\\n  Slider.prototype.handleMouseDown = function handleMouseDown(event) {\\n    var doc = this.bar.el_.ownerDocument;\\n\\n    event.preventDefault();\\n    Dom.blockTextSelection();\\n\\n    this.addClass('vjs-sliding');\\n    this.trigger('slideractive');\\n\\n    this.on(doc, 'mousemove', this.handleMouseMove);\\n    this.on(doc, 'mouseup', this.handleMouseUp);\\n    this.on(doc, 'touchmove', this.handleMouseMove);\\n    this.on(doc, 'touchend', this.handleMouseUp);\\n\\n    this.handleMouseMove(event);\\n  };\\n\\n  /**\\n   * To be overridden by a subclass\\n   *\\n   * @method handleMouseMove\\n   */\\n\\n  Slider.prototype.handleMouseMove = function handleMouseMove() {};\\n\\n  /**\\n   * Handle mouse up on Slider\\n   *\\n   * @method handleMouseUp\\n   */\\n\\n  Slider.prototype.handleMouseUp = function handleMouseUp() {\\n    var doc = this.bar.el_.ownerDocument;\\n\\n    Dom.unblockTextSelection();\\n\\n    this.removeClass('vjs-sliding');\\n    this.trigger('sliderinactive');\\n\\n    this.off(doc, 'mousemove', this.handleMouseMove);\\n    this.off(doc, 'mouseup', this.handleMouseUp);\\n    this.off(doc, 'touchmove', this.handleMouseMove);\\n    this.off(doc, 'touchend', this.handleMouseUp);\\n\\n    this.update();\\n  };\\n\\n  /**\\n   * Update slider\\n   *\\n   * @method update\\n   */\\n\\n  Slider.prototype.update = function update() {\\n    // In VolumeBar init we have a setTimeout for update that pops and update to the end of the\\n    // execution stack. The player is destroyed before then update will cause an error\\n    if (!this.el_) return;\\n\\n    // If scrubbing, we could use a cached value to make the handle keep up with the user's mouse.\\n    // On HTML5 browsers scrubbing is really smooth, but some flash players are slow, so we might want to utilize this later.\\n    // var progress =  (this.player_.scrubbing()) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();\\n    var progress = this.getPercent();\\n    var bar = this.bar;\\n\\n    // If there's no bar...\\n    if (!bar) return;\\n\\n    // Protect against no duration and other division issues\\n    if (typeof progress !== 'number' || progress !== progress || progress < 0 || progress === Infinity) {\\n      progress = 0;\\n    }\\n\\n    // Convert to a percentage for setting\\n    var percentage = (progress * 100).toFixed(2) + '%';\\n\\n    // Set the new bar width or height\\n    if (this.vertical()) {\\n      bar.el().style.height = percentage;\\n    } else {\\n      bar.el().style.width = percentage;\\n    }\\n  };\\n\\n  /**\\n   * Calculate distance for slider\\n   *\\n   * @param {Object} event Event object\\n   * @method calculateDistance\\n   */\\n\\n  Slider.prototype.calculateDistance = function calculateDistance(event) {\\n    var position = Dom.getPointerPosition(this.el_, event);\\n    if (this.vertical()) {\\n      return position.y;\\n    }\\n    return position.x;\\n  };\\n\\n  /**\\n   * Handle on focus for slider\\n   *\\n   * @method handleFocus\\n   */\\n\\n  Slider.prototype.handleFocus = function handleFocus() {\\n    this.on(this.bar.el_.ownerDocument, 'keydown', this.handleKeyPress);\\n  };\\n\\n  /**\\n   * Handle key press for slider\\n   *\\n   * @param {Object} event Event object\\n   * @method handleKeyPress\\n   */\\n\\n  Slider.prototype.handleKeyPress = function handleKeyPress(event) {\\n    if (event.which === 37 || event.which === 40) {\\n      // Left and Down Arrows\\n      event.preventDefault();\\n      this.stepBack();\\n    } else if (event.which === 38 || event.which === 39) {\\n      // Up and Right Arrows\\n      event.preventDefault();\\n      this.stepForward();\\n    }\\n  };\\n\\n  /**\\n   * Handle on blur for slider\\n   *\\n   * @method handleBlur\\n   */\\n\\n  Slider.prototype.handleBlur = function handleBlur() {\\n    this.off(this.bar.el_.ownerDocument, 'keydown', this.handleKeyPress);\\n  };\\n\\n  /**\\n   * Listener for click events on slider, used to prevent clicks\\n   *   from bubbling up to parent elements like button menus.\\n   *\\n   * @param {Object} event Event object\\n   * @method handleClick\\n   */\\n\\n  Slider.prototype.handleClick = function handleClick(event) {\\n    event.stopImmediatePropagation();\\n    event.preventDefault();\\n  };\\n\\n  /**\\n   * Get/set if slider is horizontal for vertical\\n   *\\n   * @param {Boolean} bool True if slider is vertical, false is horizontal\\n   * @return {Boolean} True if slider is vertical, false is horizontal\\n   * @method vertical\\n   */\\n\\n  Slider.prototype.vertical = function vertical(bool) {\\n    if (bool === undefined) {\\n      return this.vertical_ || false;\\n    }\\n\\n    this.vertical_ = !!bool;\\n\\n    if (this.vertical_) {\\n      this.addClass('vjs-slider-vertical');\\n    } else {\\n      this.addClass('vjs-slider-horizontal');\\n    }\\n\\n    return this;\\n  };\\n\\n  return Slider;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('Slider', Slider);\\nexports['default'] = Slider;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component.js\\\":67,\\\"../utils/dom.js\\\":142,\\\"object.assign\\\":45}],120:[function(_dereq_,module,exports){\\n/**\\n * @file flash-rtmp.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\nfunction FlashRtmpDecorator(Flash) {\\n  Flash.streamingFormats = {\\n    'rtmp/mp4': 'MP4',\\n    'rtmp/flv': 'FLV'\\n  };\\n\\n  Flash.streamFromParts = function (connection, stream) {\\n    return connection + '&' + stream;\\n  };\\n\\n  Flash.streamToParts = function (src) {\\n    var parts = {\\n      connection: '',\\n      stream: ''\\n    };\\n\\n    if (!src) return parts;\\n\\n    // Look for the normal URL separator we expect, '&'.\\n    // If found, we split the URL into two pieces around the\\n    // first '&'.\\n    var connEnd = src.search(/&(?!\\\\w+=)/);\\n    var streamBegin = undefined;\\n    if (connEnd !== -1) {\\n      streamBegin = connEnd + 1;\\n    } else {\\n      // If there's not a '&', we use the last '/' as the delimiter.\\n      connEnd = streamBegin = src.lastIndexOf('/') + 1;\\n      if (connEnd === 0) {\\n        // really, there's not a '/'?\\n        connEnd = streamBegin = src.length;\\n      }\\n    }\\n    parts.connection = src.substring(0, connEnd);\\n    parts.stream = src.substring(streamBegin, src.length);\\n\\n    return parts;\\n  };\\n\\n  Flash.isStreamingType = function (srcType) {\\n    return srcType in Flash.streamingFormats;\\n  };\\n\\n  // RTMP has four variations, any string starting\\n  // with one of these protocols should be valid\\n  Flash.RTMP_RE = /^rtmp[set]?:\\\\/\\\\//i;\\n\\n  Flash.isStreamingSrc = function (src) {\\n    return Flash.RTMP_RE.test(src);\\n  };\\n\\n  /**\\n   * A source handler for RTMP urls\\n   * @type {Object}\\n   */\\n  Flash.rtmpSourceHandler = {};\\n\\n  /**\\n   * Check if Flash can play the given videotype\\n   * @param  {String} type    The mimetype to check\\n   * @return {String}         'probably', 'maybe', or '' (empty string)\\n   */\\n  Flash.rtmpSourceHandler.canPlayType = function (type) {\\n    if (Flash.isStreamingType(type)) {\\n      return 'maybe';\\n    }\\n\\n    return '';\\n  };\\n\\n  /**\\n   * Check if Flash can handle the source natively\\n   * @param  {Object} source  The source object\\n   * @param  {Object} options The options passed to the tech\\n   * @return {String}         'probably', 'maybe', or '' (empty string)\\n   */\\n  Flash.rtmpSourceHandler.canHandleSource = function (source, options) {\\n    var can = Flash.rtmpSourceHandler.canPlayType(source.type);\\n\\n    if (can) {\\n      return can;\\n    }\\n\\n    if (Flash.isStreamingSrc(source.src)) {\\n      return 'maybe';\\n    }\\n\\n    return '';\\n  };\\n\\n  /**\\n   * Pass the source to the flash object\\n   * Adaptive source handlers will have more complicated workflows before passing\\n   * video data to the video element\\n   * @param  {Object} source   The source object\\n   * @param  {Flash}  tech     The instance of the Flash tech\\n   * @param  {Object} options  The options to pass to the source\\n   */\\n  Flash.rtmpSourceHandler.handleSource = function (source, tech, options) {\\n    var srcParts = Flash.streamToParts(source.src);\\n\\n    tech['setRtmpConnection'](srcParts.connection);\\n    tech['setRtmpStream'](srcParts.stream);\\n  };\\n\\n  // Register the native source handler\\n  Flash.registerSourceHandler(Flash.rtmpSourceHandler);\\n\\n  return Flash;\\n}\\n\\nexports['default'] = FlashRtmpDecorator;\\nmodule.exports = exports['default'];\\n\\n},{}],121:[function(_dereq_,module,exports){\\n/**\\n * @file flash.js\\n * VideoJS-SWF - Custom Flash Player with HTML5-ish API\\n * https://github.com/zencoder/video-js-swf\\n * Not using setupTriggers. Using global onEvent func to distribute events\\n */\\n\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _tech = _dereq_('./tech');\\n\\nvar _tech2 = _interopRequireDefault(_tech);\\n\\nvar _utilsDomJs = _dereq_('../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsUrlJs = _dereq_('../utils/url.js');\\n\\nvar Url = _interopRequireWildcard(_utilsUrlJs);\\n\\nvar _utilsTimeRangesJs = _dereq_('../utils/time-ranges.js');\\n\\nvar _flashRtmp = _dereq_('./flash-rtmp');\\n\\nvar _flashRtmp2 = _interopRequireDefault(_flashRtmp);\\n\\nvar _component = _dereq_('../component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _objectAssign = _dereq_('object.assign');\\n\\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\\n\\nvar navigator = _globalWindow2['default'].navigator;\\n/**\\n * Flash Media Controller - Wrapper for fallback SWF API\\n *\\n * @param {Object=} options Object of option names and values\\n * @param {Function=} ready Ready callback function\\n * @extends Tech\\n * @class Flash\\n */\\n\\nvar Flash = (function (_Tech) {\\n  _inherits(Flash, _Tech);\\n\\n  function Flash(options, ready) {\\n    _classCallCheck(this, Flash);\\n\\n    _Tech.call(this, options, ready);\\n\\n    // Set the source when ready\\n    if (options.source) {\\n      this.ready(function () {\\n        this.setSource(options.source);\\n      }, true);\\n    }\\n\\n    // Having issues with Flash reloading on certain page actions (hide/resize/fullscreen) in certain browsers\\n    // This allows resetting the playhead when we catch the reload\\n    if (options.startTime) {\\n      this.ready(function () {\\n        this.load();\\n        this.play();\\n        this.currentTime(options.startTime);\\n      }, true);\\n    }\\n\\n    // Add global window functions that the swf expects\\n    // A 4.x workflow we weren't able to solve for in 5.0\\n    // because of the need to hard code these functions\\n    // into the swf for security reasons\\n    _globalWindow2['default'].videojs = _globalWindow2['default'].videojs || {};\\n    _globalWindow2['default'].videojs.Flash = _globalWindow2['default'].videojs.Flash || {};\\n    _globalWindow2['default'].videojs.Flash.onReady = Flash.onReady;\\n    _globalWindow2['default'].videojs.Flash.onEvent = Flash.onEvent;\\n    _globalWindow2['default'].videojs.Flash.onError = Flash.onError;\\n\\n    this.on('seeked', function () {\\n      this.lastSeekTarget_ = undefined;\\n    });\\n  }\\n\\n  // Create setters and getters for attributes\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  Flash.prototype.createEl = function createEl() {\\n    var options = this.options_;\\n\\n    // If video.js is hosted locally you should also set the location\\n    // for the hosted swf, which should be relative to the page (not video.js)\\n    // Otherwise this adds a CDN url.\\n    // The CDN also auto-adds a swf URL for that specific version.\\n    if (!options.swf) {\\n      options.swf = '//vjs.zencdn.net/swf/5.1.0/video-js.swf';\\n    }\\n\\n    // Generate ID for swf object\\n    var objId = options.techId;\\n\\n    // Merge default flashvars with ones passed in to init\\n    var flashVars = _objectAssign2['default']({\\n\\n      // SWF Callback Functions\\n      'readyFunction': 'videojs.Flash.onReady',\\n      'eventProxyFunction': 'videojs.Flash.onEvent',\\n      'errorEventProxyFunction': 'videojs.Flash.onError',\\n\\n      // Player Settings\\n      'autoplay': options.autoplay,\\n      'preload': options.preload,\\n      'loop': options.loop,\\n      'muted': options.muted\\n\\n    }, options.flashVars);\\n\\n    // Merge default parames with ones passed in\\n    var params = _objectAssign2['default']({\\n      'wmode': 'opaque', // Opaque is needed to overlay controls, but can affect playback performance\\n      'bgcolor': '#000000' // Using bgcolor prevents a white flash when the object is loading\\n    }, options.params);\\n\\n    // Merge default attributes with ones passed in\\n    var attributes = _objectAssign2['default']({\\n      'id': objId,\\n      'name': objId, // Both ID and Name needed or swf to identify itself\\n      'class': 'vjs-tech'\\n    }, options.attributes);\\n\\n    this.el_ = Flash.embed(options.swf, flashVars, params, attributes);\\n    this.el_.tech = this;\\n\\n    return this.el_;\\n  };\\n\\n  /**\\n   * Play for flash tech\\n   *\\n   * @method play\\n   */\\n\\n  Flash.prototype.play = function play() {\\n    if (this.ended()) {\\n      this.setCurrentTime(0);\\n    }\\n    this.el_.vjs_play();\\n  };\\n\\n  /**\\n   * Pause for flash tech\\n   *\\n   * @method pause\\n   */\\n\\n  Flash.prototype.pause = function pause() {\\n    this.el_.vjs_pause();\\n  };\\n\\n  /**\\n   * Get/set video\\n   *\\n   * @param {Object=} src Source object\\n   * @return {Object}\\n   * @method src\\n   */\\n\\n  Flash.prototype.src = function src(_src) {\\n    if (_src === undefined) {\\n      return this.currentSrc();\\n    }\\n\\n    // Setting src through `src` not `setSrc` will be deprecated\\n    return this.setSrc(_src);\\n  };\\n\\n  /**\\n   * Set video\\n   *\\n   * @param {Object=} src Source object\\n   * @deprecated\\n   * @method setSrc\\n   */\\n\\n  Flash.prototype.setSrc = function setSrc(src) {\\n    // Make sure source URL is absolute.\\n    src = Url.getAbsoluteURL(src);\\n    this.el_.vjs_src(src);\\n\\n    // Currently the SWF doesn't autoplay if you load a source later.\\n    // e.g. Load player w/ no source, wait 2s, set src.\\n    if (this.autoplay()) {\\n      var tech = this;\\n      this.setTimeout(function () {\\n        tech.play();\\n      }, 0);\\n    }\\n  };\\n\\n  /**\\n   * Returns true if the tech is currently seeking.\\n   * @return {boolean} true if seeking\\n   */\\n\\n  Flash.prototype.seeking = function seeking() {\\n    return this.lastSeekTarget_ !== undefined;\\n  };\\n\\n  /**\\n   * Set current time\\n   *\\n   * @param {Number} time Current time of video\\n   * @method setCurrentTime\\n   */\\n\\n  Flash.prototype.setCurrentTime = function setCurrentTime(time) {\\n    var seekable = this.seekable();\\n    if (seekable.length) {\\n      // clamp to the current seekable range\\n      time = time > seekable.start(0) ? time : seekable.start(0);\\n      time = time < seekable.end(seekable.length - 1) ? time : seekable.end(seekable.length - 1);\\n\\n      this.lastSeekTarget_ = time;\\n      this.trigger('seeking');\\n      this.el_.vjs_setProperty('currentTime', time);\\n      _Tech.prototype.setCurrentTime.call(this);\\n    }\\n  };\\n\\n  /**\\n   * Get current time\\n   *\\n   * @param {Number=} time Current time of video\\n   * @return {Number} Current time\\n   * @method currentTime\\n   */\\n\\n  Flash.prototype.currentTime = function currentTime(time) {\\n    // when seeking make the reported time keep up with the requested time\\n    // by reading the time we're seeking to\\n    if (this.seeking()) {\\n      return this.lastSeekTarget_ || 0;\\n    }\\n    return this.el_.vjs_getProperty('currentTime');\\n  };\\n\\n  /**\\n   * Get current source\\n   *\\n   * @method currentSrc\\n   */\\n\\n  Flash.prototype.currentSrc = function currentSrc() {\\n    if (this.currentSource_) {\\n      return this.currentSource_.src;\\n    } else {\\n      return this.el_.vjs_getProperty('currentSrc');\\n    }\\n  };\\n\\n  /**\\n   * Get media duration\\n   *\\n   * @returns {Number} Media duration\\n   */\\n\\n  Flash.prototype.duration = function duration() {\\n    if (this.readyState() === 0) {\\n      return NaN;\\n    } else {\\n      var duration = this.el_.vjs_getProperty('duration');\\n      return duration >= 0 ? duration : Infinity;\\n    }\\n  };\\n\\n  /**\\n   * Load media into player\\n   *\\n   * @method load\\n   */\\n\\n  Flash.prototype.load = function load() {\\n    this.el_.vjs_load();\\n  };\\n\\n  /**\\n   * Get poster\\n   *\\n   * @method poster\\n   */\\n\\n  Flash.prototype.poster = function poster() {\\n    this.el_.vjs_getProperty('poster');\\n  };\\n\\n  /**\\n   * Poster images are not handled by the Flash tech so make this a no-op\\n   *\\n   * @method setPoster\\n   */\\n\\n  Flash.prototype.setPoster = function setPoster() {};\\n\\n  /**\\n   * Determine if can seek in media\\n   *\\n   * @return {TimeRangeObject}\\n   * @method seekable\\n   */\\n\\n  Flash.prototype.seekable = function seekable() {\\n    var duration = this.duration();\\n    if (duration === 0) {\\n      return _utilsTimeRangesJs.createTimeRange();\\n    }\\n    return _utilsTimeRangesJs.createTimeRange(0, duration);\\n  };\\n\\n  /**\\n   * Get buffered time range\\n   *\\n   * @return {TimeRangeObject}\\n   * @method buffered\\n   */\\n\\n  Flash.prototype.buffered = function buffered() {\\n    var ranges = this.el_.vjs_getProperty('buffered');\\n    if (ranges.length === 0) {\\n      return _utilsTimeRangesJs.createTimeRange();\\n    }\\n    return _utilsTimeRangesJs.createTimeRange(ranges[0][0], ranges[0][1]);\\n  };\\n\\n  /**\\n   * Get fullscreen support -\\n   * Flash does not allow fullscreen through javascript\\n   * so always returns false\\n   *\\n   * @return {Boolean} false\\n   * @method supportsFullScreen\\n   */\\n\\n  Flash.prototype.supportsFullScreen = function supportsFullScreen() {\\n    return false; // Flash does not allow fullscreen through javascript\\n  };\\n\\n  /**\\n   * Request to enter fullscreen\\n   * Flash does not allow fullscreen through javascript\\n   * so always returns false\\n   *\\n   * @return {Boolean} false\\n   * @method enterFullScreen\\n   */\\n\\n  Flash.prototype.enterFullScreen = function enterFullScreen() {\\n    return false;\\n  };\\n\\n  return Flash;\\n})(_tech2['default']);\\n\\nvar _api = Flash.prototype;\\nvar _readWrite = 'rtmpConnection,rtmpStream,preload,defaultPlaybackRate,playbackRate,autoplay,loop,mediaGroup,controller,controls,volume,muted,defaultMuted'.split(',');\\nvar _readOnly = 'networkState,readyState,initialTime,startOffsetTime,paused,ended,videoWidth,videoHeight'.split(',');\\n\\nfunction _createSetter(attr) {\\n  var attrUpper = attr.charAt(0).toUpperCase() + attr.slice(1);\\n  _api['set' + attrUpper] = function (val) {\\n    return this.el_.vjs_setProperty(attr, val);\\n  };\\n}\\nfunction _createGetter(attr) {\\n  _api[attr] = function () {\\n    return this.el_.vjs_getProperty(attr);\\n  };\\n}\\n\\n// Create getter and setters for all read/write attributes\\nfor (var i = 0; i < _readWrite.length; i++) {\\n  _createGetter(_readWrite[i]);\\n  _createSetter(_readWrite[i]);\\n}\\n\\n// Create getters for read-only attributes\\nfor (var i = 0; i < _readOnly.length; i++) {\\n  _createGetter(_readOnly[i]);\\n}\\n\\n/* Flash Support Testing -------------------------------------------------------- */\\n\\nFlash.isSupported = function () {\\n  return Flash.version()[0] >= 10;\\n  // return swfobject.hasFlashPlayerVersion('10');\\n};\\n\\n// Add Source Handler pattern functions to this tech\\n_tech2['default'].withSourceHandlers(Flash);\\n\\n/*\\n * The default native source handler.\\n * This simply passes the source to the video element. Nothing fancy.\\n *\\n * @param  {Object} source   The source object\\n * @param  {Flash} tech  The instance of the Flash tech\\n */\\nFlash.nativeSourceHandler = {};\\n\\n/**\\n * Check if Flash can play the given videotype\\n * @param  {String} type    The mimetype to check\\n * @return {String}         'probably', 'maybe', or '' (empty string)\\n */\\nFlash.nativeSourceHandler.canPlayType = function (type) {\\n  if (type in Flash.formats) {\\n    return 'maybe';\\n  }\\n\\n  return '';\\n};\\n\\n/*\\n * Check Flash can handle the source natively\\n *\\n * @param  {Object} source  The source object\\n * @param  {Object} options The options passed to the tech\\n * @return {String}         'probably', 'maybe', or '' (empty string)\\n */\\nFlash.nativeSourceHandler.canHandleSource = function (source, options) {\\n  var type;\\n\\n  function guessMimeType(src) {\\n    var ext = Url.getFileExtension(src);\\n    if (ext) {\\n      return 'video/' + ext;\\n    }\\n    return '';\\n  }\\n\\n  if (!source.type) {\\n    type = guessMimeType(source.src);\\n  } else {\\n    // Strip code information from the type because we don't get that specific\\n    type = source.type.replace(/;.*/, '').toLowerCase();\\n  }\\n\\n  return Flash.nativeSourceHandler.canPlayType(type);\\n};\\n\\n/*\\n * Pass the source to the flash object\\n * Adaptive source handlers will have more complicated workflows before passing\\n * video data to the video element\\n *\\n * @param  {Object} source   The source object\\n * @param  {Flash}  tech     The instance of the Flash tech\\n * @param  {Object} options  The options to pass to the source\\n */\\nFlash.nativeSourceHandler.handleSource = function (source, tech, options) {\\n  tech.setSrc(source.src);\\n};\\n\\n/*\\n * Clean up the source handler when disposing the player or switching sources..\\n * (no cleanup is needed when supporting the format natively)\\n */\\nFlash.nativeSourceHandler.dispose = function () {};\\n\\n// Register the native source handler\\nFlash.registerSourceHandler(Flash.nativeSourceHandler);\\n\\nFlash.formats = {\\n  'video/flv': 'FLV',\\n  'video/x-flv': 'FLV',\\n  'video/mp4': 'MP4',\\n  'video/m4v': 'MP4'\\n};\\n\\nFlash.onReady = function (currSwf) {\\n  var el = Dom.getEl(currSwf);\\n  var tech = el && el.tech;\\n\\n  // if there is no el then the tech has been disposed\\n  // and the tech element was removed from the player div\\n  if (tech && tech.el()) {\\n    // check that the flash object is really ready\\n    Flash.checkReady(tech);\\n  }\\n};\\n\\n// The SWF isn't always ready when it says it is. Sometimes the API functions still need to be added to the object.\\n// If it's not ready, we set a timeout to check again shortly.\\nFlash.checkReady = function (tech) {\\n  // stop worrying if the tech has been disposed\\n  if (!tech.el()) {\\n    return;\\n  }\\n\\n  // check if API property exists\\n  if (tech.el().vjs_getProperty) {\\n    // tell tech it's ready\\n    tech.triggerReady();\\n  } else {\\n    // wait longer\\n    this.setTimeout(function () {\\n      Flash['checkReady'](tech);\\n    }, 50);\\n  }\\n};\\n\\n// Trigger events from the swf on the player\\nFlash.onEvent = function (swfID, eventName) {\\n  var tech = Dom.getEl(swfID).tech;\\n  tech.trigger(eventName, Array.prototype.slice.call(arguments, 2));\\n};\\n\\n// Log errors from the swf\\nFlash.onError = function (swfID, err) {\\n  var tech = Dom.getEl(swfID).tech;\\n\\n  // trigger MEDIA_ERR_SRC_NOT_SUPPORTED\\n  if (err === 'srcnotfound') {\\n    return tech.error(4);\\n  }\\n\\n  // trigger a custom error\\n  tech.error('FLASH: ' + err);\\n};\\n\\n// Flash Version Check\\nFlash.version = function () {\\n  var version = '0,0,0';\\n\\n  // IE\\n  try {\\n    version = new _globalWindow2['default'].ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\\\\D+/g, ',').match(/^,?(.+),?$/)[1];\\n\\n    // other browsers\\n  } catch (e) {\\n    try {\\n      if (navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin) {\\n        version = (navigator.plugins['Shockwave Flash 2.0'] || navigator.plugins['Shockwave Flash']).description.replace(/\\\\D+/g, ',').match(/^,?(.+),?$/)[1];\\n      }\\n    } catch (err) {}\\n  }\\n  return version.split(',');\\n};\\n\\n// Flash embedding method. Only used in non-iframe mode\\nFlash.embed = function (swf, flashVars, params, attributes) {\\n  var code = Flash.getEmbedCode(swf, flashVars, params, attributes);\\n\\n  // Get element by embedding code and retrieving created element\\n  var obj = Dom.createEl('div', { innerHTML: code }).childNodes[0];\\n\\n  return obj;\\n};\\n\\nFlash.getEmbedCode = function (swf, flashVars, params, attributes) {\\n  var objTag = '<object type=\\\"application/x-shockwave-flash\\\" ';\\n  var flashVarsString = '';\\n  var paramsString = '';\\n  var attrsString = '';\\n\\n  // Convert flash vars to string\\n  if (flashVars) {\\n    Object.getOwnPropertyNames(flashVars).forEach(function (key) {\\n      flashVarsString += key + '=' + flashVars[key] + '&amp;';\\n    });\\n  }\\n\\n  // Add swf, flashVars, and other default params\\n  params = _objectAssign2['default']({\\n    'movie': swf,\\n    'flashvars': flashVarsString,\\n    'allowScriptAccess': 'always', // Required to talk to swf\\n    'allowNetworking': 'all' // All should be default, but having security issues.\\n  }, params);\\n\\n  // Create param tags string\\n  Object.getOwnPropertyNames(params).forEach(function (key) {\\n    paramsString += '<param name=\\\"' + key + '\\\" value=\\\"' + params[key] + '\\\" />';\\n  });\\n\\n  attributes = _objectAssign2['default']({\\n    // Add swf to attributes (need both for IE and Others to work)\\n    'data': swf,\\n\\n    // Default to 100% width/height\\n    'width': '100%',\\n    'height': '100%'\\n\\n  }, attributes);\\n\\n  // Create Attributes string\\n  Object.getOwnPropertyNames(attributes).forEach(function (key) {\\n    attrsString += key + '=\\\"' + attributes[key] + '\\\" ';\\n  });\\n\\n  return '' + objTag + attrsString + '>' + paramsString + '</object>';\\n};\\n\\n// Run Flash through the RTMP decorator\\n_flashRtmp2['default'](Flash);\\n\\n_component2['default'].registerComponent('Flash', Flash);\\n_tech2['default'].registerTech('Flash', Flash);\\nexports['default'] = Flash;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component\\\":67,\\\"../utils/dom.js\\\":142,\\\"../utils/time-ranges.js\\\":150,\\\"../utils/url.js\\\":152,\\\"./flash-rtmp\\\":120,\\\"./tech\\\":124,\\\"global/window\\\":2,\\\"object.assign\\\":45}],122:[function(_dereq_,module,exports){\\n/**\\n * @file html5.js\\n * HTML5 Media Controller - Wrapper for HTML5 Media API\\n */\\n\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nvar _templateObject = _taggedTemplateLiteralLoose(['Text Tracks are being loaded from another origin but the crossorigin attribute isn\\\\'t used. \\\\n            This may prevent text tracks from loading.'], ['Text Tracks are being loaded from another origin but the crossorigin attribute isn\\\\'t used. \\\\n            This may prevent text tracks from loading.']);\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nfunction _taggedTemplateLiteralLoose(strings, raw) { strings.raw = raw; return strings; }\\n\\nvar _techJs = _dereq_('./tech.js');\\n\\nvar _techJs2 = _interopRequireDefault(_techJs);\\n\\nvar _component = _dereq_('../component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _utilsDomJs = _dereq_('../utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsUrlJs = _dereq_('../utils/url.js');\\n\\nvar Url = _interopRequireWildcard(_utilsUrlJs);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsLogJs = _dereq_('../utils/log.js');\\n\\nvar _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);\\n\\nvar _tsml = _dereq_('tsml');\\n\\nvar _tsml2 = _interopRequireDefault(_tsml);\\n\\nvar _srcJsTracksTextTrackJs = _dereq_('../../../src/js/tracks/text-track.js');\\n\\nvar _srcJsTracksTextTrackJs2 = _interopRequireDefault(_srcJsTracksTextTrackJs);\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _objectAssign = _dereq_('object.assign');\\n\\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\\n\\nvar _utilsMergeOptionsJs = _dereq_('../utils/merge-options.js');\\n\\nvar _utilsMergeOptionsJs2 = _interopRequireDefault(_utilsMergeOptionsJs);\\n\\nvar _utilsToTitleCaseJs = _dereq_('../utils/to-title-case.js');\\n\\nvar _utilsToTitleCaseJs2 = _interopRequireDefault(_utilsToTitleCaseJs);\\n\\n/**\\n * HTML5 Media Controller - Wrapper for HTML5 Media API\\n *\\n * @param {Object=} options Object of option names and values\\n * @param {Function=} ready Ready callback function\\n * @extends Tech\\n * @class Html5\\n */\\n\\nvar Html5 = (function (_Tech) {\\n  _inherits(Html5, _Tech);\\n\\n  function Html5(options, ready) {\\n    var _this = this;\\n\\n    _classCallCheck(this, Html5);\\n\\n    _Tech.call(this, options, ready);\\n\\n    var source = options.source;\\n    var crossoriginTracks = false;\\n\\n    // Set the source if one is provided\\n    // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)\\n    // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source\\n    // anyway so the error gets fired.\\n    if (source && (this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {\\n      this.setSource(source);\\n    } else {\\n      this.handleLateInit_(this.el_);\\n    }\\n\\n    if (this.el_.hasChildNodes()) {\\n\\n      var nodes = this.el_.childNodes;\\n      var nodesLength = nodes.length;\\n      var removeNodes = [];\\n\\n      while (nodesLength--) {\\n        var node = nodes[nodesLength];\\n        var nodeName = node.nodeName.toLowerCase();\\n\\n        if (nodeName === 'track') {\\n          if (!this.featuresNativeTextTracks) {\\n            // Empty video tag tracks so the built-in player doesn't use them also.\\n            // This may not be fast enough to stop HTML5 browsers from reading the tags\\n            // so we'll need to turn off any default tracks if we're manually doing\\n            // captions and subtitles. videoElement.textTracks\\n            removeNodes.push(node);\\n          } else {\\n            // store HTMLTrackElement and TextTrack to remote list\\n            this.remoteTextTrackEls().addTrackElement_(node);\\n            this.remoteTextTracks().addTrack_(node.track);\\n            if (!crossoriginTracks && !this.el_.hasAttribute('crossorigin') && Url.isCrossOrigin(node.src)) {\\n              crossoriginTracks = true;\\n            }\\n          }\\n        }\\n      }\\n\\n      for (var i = 0; i < removeNodes.length; i++) {\\n        this.el_.removeChild(removeNodes[i]);\\n      }\\n    }\\n\\n    var trackTypes = ['audio', 'video'];\\n\\n    // ProxyNativeTextTracks\\n    trackTypes.forEach(function (type) {\\n      var capitalType = _utilsToTitleCaseJs2['default'](type);\\n\\n      if (!_this['featuresNative' + capitalType + 'Tracks']) {\\n        return;\\n      }\\n      var tl = _this.el()[type + 'Tracks'];\\n\\n      if (tl && tl.addEventListener) {\\n        tl.addEventListener('change', Fn.bind(_this, _this['handle' + capitalType + 'TrackChange_']));\\n        tl.addEventListener('addtrack', Fn.bind(_this, _this['handle' + capitalType + 'TrackAdd_']));\\n        tl.addEventListener('removetrack', Fn.bind(_this, _this['handle' + capitalType + 'TrackRemove_']));\\n\\n        // Remove (native) trackts that are not used anymore\\n        _this.on('loadstart', _this['removeOld' + capitalType + 'Tracks_']);\\n      }\\n    });\\n\\n    if (this.featuresNativeTextTracks) {\\n      if (crossoriginTracks) {\\n        _utilsLogJs2['default'].warn(_tsml2['default'](_templateObject));\\n      }\\n\\n      this.handleTextTrackChange_ = Fn.bind(this, this.handleTextTrackChange);\\n      this.handleTextTrackAdd_ = Fn.bind(this, this.handleTextTrackAdd);\\n      this.handleTextTrackRemove_ = Fn.bind(this, this.handleTextTrackRemove);\\n      this.proxyNativeTextTracks_();\\n    }\\n\\n    // Determine if native controls should be used\\n    // Our goal should be to get the custom controls on mobile solid everywhere\\n    // so we can remove this all together. Right now this will block custom\\n    // controls on touch enabled laptops like the Chrome Pixel\\n    if ((browser.TOUCH_ENABLED || browser.IS_IPHONE || browser.IS_NATIVE_ANDROID) && options.nativeControlsForTouch === true) {\\n      this.setControls(true);\\n    }\\n\\n    this.triggerReady();\\n  }\\n\\n  /* HTML5 Support Testing ---------------------------------------------------- */\\n\\n  /*\\n  * Element for testing browser HTML5 video capabilities\\n  *\\n  * @type {Element}\\n  * @constant\\n  * @private\\n  */\\n\\n  /**\\n   * Dispose of html5 media element\\n   *\\n   * @method dispose\\n   */\\n\\n  Html5.prototype.dispose = function dispose() {\\n    var _this2 = this;\\n\\n    // Un-ProxyNativeTracks\\n    ['audio', 'video', 'text'].forEach(function (type) {\\n      var capitalType = _utilsToTitleCaseJs2['default'](type);\\n      var tl = _this2.el_[type + 'Tracks'];\\n\\n      if (tl && tl.removeEventListener) {\\n        tl.removeEventListener('change', _this2['handle' + capitalType + 'TrackChange_']);\\n        tl.removeEventListener('addtrack', _this2['handle' + capitalType + 'TrackAdd_']);\\n        tl.removeEventListener('removetrack', _this2['handle' + capitalType + 'TrackRemove_']);\\n      }\\n\\n      // Stop removing old text tracks\\n      if (tl) {\\n        _this2.off('loadstart', _this2['removeOld' + capitalType + 'Tracks_']);\\n      }\\n    });\\n\\n    Html5.disposeMediaElement(this.el_);\\n    // tech will handle clearing of the emulated track list\\n    _Tech.prototype.dispose.call(this);\\n  };\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  Html5.prototype.createEl = function createEl() {\\n    var el = this.options_.tag;\\n\\n    // Check if this browser supports moving the element into the box.\\n    // On the iPhone video will break if you move the element,\\n    // So we have to create a brand new element.\\n    if (!el || this['movingMediaElementInDOM'] === false) {\\n\\n      // If the original tag is still there, clone and remove it.\\n      if (el) {\\n        var clone = el.cloneNode(true);\\n        el.parentNode.insertBefore(clone, el);\\n        Html5.disposeMediaElement(el);\\n        el = clone;\\n      } else {\\n        el = _globalDocument2['default'].createElement('video');\\n\\n        // determine if native controls should be used\\n        var tagAttributes = this.options_.tag && Dom.getElAttributes(this.options_.tag);\\n        var attributes = _utilsMergeOptionsJs2['default']({}, tagAttributes);\\n        if (!browser.TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {\\n          delete attributes.controls;\\n        }\\n\\n        Dom.setElAttributes(el, _objectAssign2['default'](attributes, {\\n          id: this.options_.techId,\\n          'class': 'vjs-tech'\\n        }));\\n      }\\n    }\\n\\n    // Update specific tag settings, in case they were overridden\\n    var settingsAttrs = ['autoplay', 'preload', 'loop', 'muted'];\\n    for (var i = settingsAttrs.length - 1; i >= 0; i--) {\\n      var attr = settingsAttrs[i];\\n      var overwriteAttrs = {};\\n      if (typeof this.options_[attr] !== 'undefined') {\\n        overwriteAttrs[attr] = this.options_[attr];\\n      }\\n      Dom.setElAttributes(el, overwriteAttrs);\\n    }\\n\\n    return el;\\n    // jenniisawesome = true;\\n  };\\n\\n  // If we're loading the playback object after it has started loading\\n  // or playing the video (often with autoplay on) then the loadstart event\\n  // has already fired and we need to fire it manually because many things\\n  // rely on it.\\n\\n  Html5.prototype.handleLateInit_ = function handleLateInit_(el) {\\n    var _this3 = this;\\n\\n    if (el.networkState === 0 || el.networkState === 3) {\\n      // The video element hasn't started loading the source yet\\n      // or didn't find a source\\n      return;\\n    }\\n\\n    if (el.readyState === 0) {\\n      var _ret = (function () {\\n        // NetworkState is set synchronously BUT loadstart is fired at the\\n        // end of the current stack, usually before setInterval(fn, 0).\\n        // So at this point we know loadstart may have already fired or is\\n        // about to fire, and either way the player hasn't seen it yet.\\n        // We don't want to fire loadstart prematurely here and cause a\\n        // double loadstart so we'll wait and see if it happens between now\\n        // and the next loop, and fire it if not.\\n        // HOWEVER, we also want to make sure it fires before loadedmetadata\\n        // which could also happen between now and the next loop, so we'll\\n        // watch for that also.\\n        var loadstartFired = false;\\n        var setLoadstartFired = function setLoadstartFired() {\\n          loadstartFired = true;\\n        };\\n        _this3.on('loadstart', setLoadstartFired);\\n\\n        var triggerLoadstart = function triggerLoadstart() {\\n          // We did miss the original loadstart. Make sure the player\\n          // sees loadstart before loadedmetadata\\n          if (!loadstartFired) {\\n            this.trigger('loadstart');\\n          }\\n        };\\n        _this3.on('loadedmetadata', triggerLoadstart);\\n\\n        _this3.ready(function () {\\n          this.off('loadstart', setLoadstartFired);\\n          this.off('loadedmetadata', triggerLoadstart);\\n\\n          if (!loadstartFired) {\\n            // We did miss the original native loadstart. Fire it now.\\n            this.trigger('loadstart');\\n          }\\n        });\\n\\n        return {\\n          v: undefined\\n        };\\n      })();\\n\\n      if (typeof _ret === 'object') return _ret.v;\\n    }\\n\\n    // From here on we know that loadstart already fired and we missed it.\\n    // The other readyState events aren't as much of a problem if we double\\n    // them, so not going to go to as much trouble as loadstart to prevent\\n    // that unless we find reason to.\\n    var eventsToTrigger = ['loadstart'];\\n\\n    // loadedmetadata: newly equal to HAVE_METADATA (1) or greater\\n    eventsToTrigger.push('loadedmetadata');\\n\\n    // loadeddata: newly increased to HAVE_CURRENT_DATA (2) or greater\\n    if (el.readyState >= 2) {\\n      eventsToTrigger.push('loadeddata');\\n    }\\n\\n    // canplay: newly increased to HAVE_FUTURE_DATA (3) or greater\\n    if (el.readyState >= 3) {\\n      eventsToTrigger.push('canplay');\\n    }\\n\\n    // canplaythrough: newly equal to HAVE_ENOUGH_DATA (4)\\n    if (el.readyState >= 4) {\\n      eventsToTrigger.push('canplaythrough');\\n    }\\n\\n    // We still need to give the player time to add event listeners\\n    this.ready(function () {\\n      eventsToTrigger.forEach(function (type) {\\n        this.trigger(type);\\n      }, this);\\n    });\\n  };\\n\\n  Html5.prototype.proxyNativeTextTracks_ = function proxyNativeTextTracks_() {\\n    var tt = this.el().textTracks;\\n\\n    if (tt) {\\n      // Add tracks - if player is initialised after DOM loaded, textTracks\\n      // will not trigger addtrack\\n      for (var i = 0; i < tt.length; i++) {\\n        this.textTracks().addTrack_(tt[i]);\\n      }\\n\\n      if (tt.addEventListener) {\\n        tt.addEventListener('change', this.handleTextTrackChange_);\\n        tt.addEventListener('addtrack', this.handleTextTrackAdd_);\\n        tt.addEventListener('removetrack', this.handleTextTrackRemove_);\\n      }\\n\\n      // Remove (native) texttracks that are not used anymore\\n      this.on('loadstart', this.removeOldTextTracks_);\\n    }\\n  };\\n\\n  Html5.prototype.handleTextTrackChange = function handleTextTrackChange(e) {\\n    var tt = this.textTracks();\\n    this.textTracks().trigger({\\n      type: 'change',\\n      target: tt,\\n      currentTarget: tt,\\n      srcElement: tt\\n    });\\n  };\\n\\n  Html5.prototype.handleTextTrackAdd = function handleTextTrackAdd(e) {\\n    this.textTracks().addTrack_(e.track);\\n  };\\n\\n  Html5.prototype.handleTextTrackRemove = function handleTextTrackRemove(e) {\\n    this.textTracks().removeTrack_(e.track);\\n  };\\n\\n  Html5.prototype.handleVideoTrackChange_ = function handleVideoTrackChange_(e) {\\n    var vt = this.videoTracks();\\n    this.videoTracks().trigger({\\n      type: 'change',\\n      target: vt,\\n      currentTarget: vt,\\n      srcElement: vt\\n    });\\n  };\\n\\n  Html5.prototype.handleVideoTrackAdd_ = function handleVideoTrackAdd_(e) {\\n    this.videoTracks().addTrack_(e.track);\\n  };\\n\\n  Html5.prototype.handleVideoTrackRemove_ = function handleVideoTrackRemove_(e) {\\n    this.videoTracks().removeTrack_(e.track);\\n  };\\n\\n  Html5.prototype.handleAudioTrackChange_ = function handleAudioTrackChange_(e) {\\n    var audioTrackList = this.audioTracks();\\n    this.audioTracks().trigger({\\n      type: 'change',\\n      target: audioTrackList,\\n      currentTarget: audioTrackList,\\n      srcElement: audioTrackList\\n    });\\n  };\\n\\n  Html5.prototype.handleAudioTrackAdd_ = function handleAudioTrackAdd_(e) {\\n    this.audioTracks().addTrack_(e.track);\\n  };\\n\\n  Html5.prototype.handleAudioTrackRemove_ = function handleAudioTrackRemove_(e) {\\n    this.audioTracks().removeTrack_(e.track);\\n  };\\n\\n  /**\\n   * This is a helper function that is used in removeOldTextTracks_, removeOldAudioTracks_ and\\n   * removeOldVideoTracks_\\n   * @param {Track[]} techTracks Tracks for this tech\\n   * @param {Track[]} elTracks Tracks for the HTML5 video element\\n   * @private\\n   */\\n\\n  Html5.prototype.removeOldTracks_ = function removeOldTracks_(techTracks, elTracks) {\\n    // This will loop over the techTracks and check if they are still used by the HTML5 video element\\n    // If not, they will be removed from the emulated list\\n    var removeTracks = [];\\n    if (!elTracks) {\\n      return;\\n    }\\n\\n    for (var i = 0; i < techTracks.length; i++) {\\n      var techTrack = techTracks[i];\\n\\n      var found = false;\\n      for (var j = 0; j < elTracks.length; j++) {\\n        if (elTracks[j] === techTrack) {\\n          found = true;\\n          break;\\n        }\\n      }\\n\\n      if (!found) {\\n        removeTracks.push(techTrack);\\n      }\\n    }\\n\\n    for (var i = 0; i < removeTracks.length; i++) {\\n      var _track = removeTracks[i];\\n      techTracks.removeTrack_(_track);\\n    }\\n  };\\n\\n  Html5.prototype.removeOldTextTracks_ = function removeOldTextTracks_() {\\n    var techTracks = this.textTracks();\\n    var elTracks = this.el().textTracks;\\n    this.removeOldTracks_(techTracks, elTracks);\\n  };\\n\\n  Html5.prototype.removeOldAudioTracks_ = function removeOldAudioTracks_() {\\n    var techTracks = this.audioTracks();\\n    var elTracks = this.el().audioTracks;\\n    this.removeOldTracks_(techTracks, elTracks);\\n  };\\n\\n  Html5.prototype.removeOldVideoTracks_ = function removeOldVideoTracks_() {\\n    var techTracks = this.videoTracks();\\n    var elTracks = this.el().videoTracks;\\n    this.removeOldTracks_(techTracks, elTracks);\\n  };\\n\\n  /**\\n   * Play for html5 tech\\n   *\\n   * @method play\\n   */\\n\\n  Html5.prototype.play = function play() {\\n    var playPromise = this.el_.play();\\n\\n    // Catch/silence error when a pause interrupts a play request\\n    // on browsers which return a promise\\n    if (playPromise !== undefined && typeof playPromise.then === 'function') {\\n      playPromise.then(null, function (e) {});\\n    }\\n  };\\n\\n  /**\\n   * Pause for html5 tech\\n   *\\n   * @method pause\\n   */\\n\\n  Html5.prototype.pause = function pause() {\\n    this.el_.pause();\\n  };\\n\\n  /**\\n   * Paused for html5 tech\\n   *\\n   * @return {Boolean}\\n   * @method paused\\n   */\\n\\n  Html5.prototype.paused = function paused() {\\n    return this.el_.paused;\\n  };\\n\\n  /**\\n   * Get current time\\n   *\\n   * @return {Number}\\n   * @method currentTime\\n   */\\n\\n  Html5.prototype.currentTime = function currentTime() {\\n    return this.el_.currentTime;\\n  };\\n\\n  /**\\n   * Set current time\\n   *\\n   * @param {Number} seconds Current time of video\\n   * @method setCurrentTime\\n   */\\n\\n  Html5.prototype.setCurrentTime = function setCurrentTime(seconds) {\\n    try {\\n      this.el_.currentTime = seconds;\\n    } catch (e) {\\n      _utilsLogJs2['default'](e, 'Video is not ready. (Video.js)');\\n      // this.warning(VideoJS.warnings.videoNotReady);\\n    }\\n  };\\n\\n  /**\\n   * Get duration\\n   *\\n   * @return {Number}\\n   * @method duration\\n   */\\n\\n  Html5.prototype.duration = function duration() {\\n    return this.el_.duration || 0;\\n  };\\n\\n  /**\\n   * Get a TimeRange object that represents the intersection\\n   * of the time ranges for which the user agent has all\\n   * relevant media\\n   *\\n   * @return {TimeRangeObject}\\n   * @method buffered\\n   */\\n\\n  Html5.prototype.buffered = function buffered() {\\n    return this.el_.buffered;\\n  };\\n\\n  /**\\n   * Get volume level\\n   *\\n   * @return {Number}\\n   * @method volume\\n   */\\n\\n  Html5.prototype.volume = function volume() {\\n    return this.el_.volume;\\n  };\\n\\n  /**\\n   * Set volume level\\n   *\\n   * @param {Number} percentAsDecimal Volume percent as a decimal\\n   * @method setVolume\\n   */\\n\\n  Html5.prototype.setVolume = function setVolume(percentAsDecimal) {\\n    this.el_.volume = percentAsDecimal;\\n  };\\n\\n  /**\\n   * Get if muted\\n   *\\n   * @return {Boolean}\\n   * @method muted\\n   */\\n\\n  Html5.prototype.muted = function muted() {\\n    return this.el_.muted;\\n  };\\n\\n  /**\\n   * Set muted\\n   *\\n   * @param {Boolean} If player is to be muted or note\\n   * @method setMuted\\n   */\\n\\n  Html5.prototype.setMuted = function setMuted(muted) {\\n    this.el_.muted = muted;\\n  };\\n\\n  /**\\n   * Get player width\\n   *\\n   * @return {Number}\\n   * @method width\\n   */\\n\\n  Html5.prototype.width = function width() {\\n    return this.el_.offsetWidth;\\n  };\\n\\n  /**\\n   * Get player height\\n   *\\n   * @return {Number}\\n   * @method height\\n   */\\n\\n  Html5.prototype.height = function height() {\\n    return this.el_.offsetHeight;\\n  };\\n\\n  /**\\n   * Get if there is fullscreen support\\n   *\\n   * @return {Boolean}\\n   * @method supportsFullScreen\\n   */\\n\\n  Html5.prototype.supportsFullScreen = function supportsFullScreen() {\\n    if (typeof this.el_.webkitEnterFullScreen === 'function') {\\n      var userAgent = _globalWindow2['default'].navigator.userAgent;\\n      // Seems to be broken in Chromium/Chrome && Safari in Leopard\\n      if (/Android/.test(userAgent) || !/Chrome|Mac OS X 10.5/.test(userAgent)) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  };\\n\\n  /**\\n   * Request to enter fullscreen\\n   *\\n   * @method enterFullScreen\\n   */\\n\\n  Html5.prototype.enterFullScreen = function enterFullScreen() {\\n    var video = this.el_;\\n\\n    if ('webkitDisplayingFullscreen' in video) {\\n      this.one('webkitbeginfullscreen', function () {\\n        this.one('webkitendfullscreen', function () {\\n          this.trigger('fullscreenchange', { isFullscreen: false });\\n        });\\n\\n        this.trigger('fullscreenchange', { isFullscreen: true });\\n      });\\n    }\\n\\n    if (video.paused && video.networkState <= video.HAVE_METADATA) {\\n      // attempt to prime the video element for programmatic access\\n      // this isn't necessary on the desktop but shouldn't hurt\\n      this.el_.play();\\n\\n      // playing and pausing synchronously during the transition to fullscreen\\n      // can get iOS ~6.1 devices into a play/pause loop\\n      this.setTimeout(function () {\\n        video.pause();\\n        video.webkitEnterFullScreen();\\n      }, 0);\\n    } else {\\n      video.webkitEnterFullScreen();\\n    }\\n  };\\n\\n  /**\\n   * Request to exit fullscreen\\n   *\\n   * @method exitFullScreen\\n   */\\n\\n  Html5.prototype.exitFullScreen = function exitFullScreen() {\\n    this.el_.webkitExitFullScreen();\\n  };\\n\\n  /**\\n   * Get/set video\\n   *\\n   * @param {Object=} src Source object\\n   * @return {Object}\\n   * @method src\\n   */\\n\\n  Html5.prototype.src = function src(_src) {\\n    if (_src === undefined) {\\n      return this.el_.src;\\n    } else {\\n      // Setting src through `src` instead of `setSrc` will be deprecated\\n      this.setSrc(_src);\\n    }\\n  };\\n\\n  /**\\n   * Set video\\n   *\\n   * @param {Object} src Source object\\n   * @deprecated\\n   * @method setSrc\\n   */\\n\\n  Html5.prototype.setSrc = function setSrc(src) {\\n    this.el_.src = src;\\n  };\\n\\n  /**\\n   * Load media into player\\n   *\\n   * @method load\\n   */\\n\\n  Html5.prototype.load = function load() {\\n    this.el_.load();\\n  };\\n\\n  /**\\n   * Reset the tech. Removes all sources and calls `load`.\\n   *\\n   * @method reset\\n   */\\n\\n  Html5.prototype.reset = function reset() {\\n    Html5.resetMediaElement(this.el_);\\n  };\\n\\n  /**\\n   * Get current source\\n   *\\n   * @return {Object}\\n   * @method currentSrc\\n   */\\n\\n  Html5.prototype.currentSrc = function currentSrc() {\\n    if (this.currentSource_) {\\n      return this.currentSource_.src;\\n    } else {\\n      return this.el_.currentSrc;\\n    }\\n  };\\n\\n  /**\\n   * Get poster\\n   *\\n   * @return {String}\\n   * @method poster\\n   */\\n\\n  Html5.prototype.poster = function poster() {\\n    return this.el_.poster;\\n  };\\n\\n  /**\\n   * Set poster\\n   *\\n   * @param {String} val URL to poster image\\n   * @method\\n   */\\n\\n  Html5.prototype.setPoster = function setPoster(val) {\\n    this.el_.poster = val;\\n  };\\n\\n  /**\\n   * Get preload attribute\\n   *\\n   * @return {String}\\n   * @method preload\\n   */\\n\\n  Html5.prototype.preload = function preload() {\\n    return this.el_.preload;\\n  };\\n\\n  /**\\n   * Set preload attribute\\n   *\\n   * @param {String} val Value for preload attribute\\n   * @method setPreload\\n   */\\n\\n  Html5.prototype.setPreload = function setPreload(val) {\\n    this.el_.preload = val;\\n  };\\n\\n  /**\\n   * Get autoplay attribute\\n   *\\n   * @return {String}\\n   * @method autoplay\\n   */\\n\\n  Html5.prototype.autoplay = function autoplay() {\\n    return this.el_.autoplay;\\n  };\\n\\n  /**\\n   * Set autoplay attribute\\n   *\\n   * @param {String} val Value for preload attribute\\n   * @method setAutoplay\\n   */\\n\\n  Html5.prototype.setAutoplay = function setAutoplay(val) {\\n    this.el_.autoplay = val;\\n  };\\n\\n  /**\\n   * Get controls attribute\\n   *\\n   * @return {String}\\n   * @method controls\\n   */\\n\\n  Html5.prototype.controls = function controls() {\\n    return this.el_.controls;\\n  };\\n\\n  /**\\n   * Set controls attribute\\n   *\\n   * @param {String} val Value for controls attribute\\n   * @method setControls\\n   */\\n\\n  Html5.prototype.setControls = function setControls(val) {\\n    this.el_.controls = !!val;\\n  };\\n\\n  /**\\n   * Get loop attribute\\n   *\\n   * @return {String}\\n   * @method loop\\n   */\\n\\n  Html5.prototype.loop = function loop() {\\n    return this.el_.loop;\\n  };\\n\\n  /**\\n   * Set loop attribute\\n   *\\n   * @param {String} val Value for loop attribute\\n   * @method setLoop\\n   */\\n\\n  Html5.prototype.setLoop = function setLoop(val) {\\n    this.el_.loop = val;\\n  };\\n\\n  /**\\n   * Get error value\\n   *\\n   * @return {String}\\n   * @method error\\n   */\\n\\n  Html5.prototype.error = function error() {\\n    return this.el_.error;\\n  };\\n\\n  /**\\n   * Get whether or not the player is in the \\\"seeking\\\" state\\n   *\\n   * @return {Boolean}\\n   * @method seeking\\n   */\\n\\n  Html5.prototype.seeking = function seeking() {\\n    return this.el_.seeking;\\n  };\\n\\n  /**\\n   * Get a TimeRanges object that represents the\\n   * ranges of the media resource to which it is possible\\n   * for the user agent to seek.\\n   *\\n   * @return {TimeRangeObject}\\n   * @method seekable\\n   */\\n\\n  Html5.prototype.seekable = function seekable() {\\n    return this.el_.seekable;\\n  };\\n\\n  /**\\n   * Get if video ended\\n   *\\n   * @return {Boolean}\\n   * @method ended\\n   */\\n\\n  Html5.prototype.ended = function ended() {\\n    return this.el_.ended;\\n  };\\n\\n  /**\\n   * Get the value of the muted content attribute\\n   * This attribute has no dynamic effect, it only\\n   * controls the default state of the element\\n   *\\n   * @return {Boolean}\\n   * @method defaultMuted\\n   */\\n\\n  Html5.prototype.defaultMuted = function defaultMuted() {\\n    return this.el_.defaultMuted;\\n  };\\n\\n  /**\\n   * Get desired speed at which the media resource is to play\\n   *\\n   * @return {Number}\\n   * @method playbackRate\\n   */\\n\\n  Html5.prototype.playbackRate = function playbackRate() {\\n    return this.el_.playbackRate;\\n  };\\n\\n  /**\\n   * Returns a TimeRanges object that represents the ranges of the\\n   * media resource that the user agent has played.\\n   * @return {TimeRangeObject} the range of points on the media\\n   * timeline that has been reached through normal playback\\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-played\\n   */\\n\\n  Html5.prototype.played = function played() {\\n    return this.el_.played;\\n  };\\n\\n  /**\\n   * Set desired speed at which the media resource is to play\\n   *\\n   * @param {Number} val Speed at which the media resource is to play\\n   * @method setPlaybackRate\\n   */\\n\\n  Html5.prototype.setPlaybackRate = function setPlaybackRate(val) {\\n    this.el_.playbackRate = val;\\n  };\\n\\n  /**\\n   * Get the current state of network activity for the element, from\\n   * the list below\\n   * NETWORK_EMPTY (numeric value 0)\\n   * NETWORK_IDLE (numeric value 1)\\n   * NETWORK_LOADING (numeric value 2)\\n   * NETWORK_NO_SOURCE (numeric value 3)\\n   *\\n   * @return {Number}\\n   * @method networkState\\n   */\\n\\n  Html5.prototype.networkState = function networkState() {\\n    return this.el_.networkState;\\n  };\\n\\n  /**\\n   * Get a value that expresses the current state of the element\\n   * with respect to rendering the current playback position, from\\n   * the codes in the list below\\n   * HAVE_NOTHING (numeric value 0)\\n   * HAVE_METADATA (numeric value 1)\\n   * HAVE_CURRENT_DATA (numeric value 2)\\n   * HAVE_FUTURE_DATA (numeric value 3)\\n   * HAVE_ENOUGH_DATA (numeric value 4)\\n   *\\n   * @return {Number}\\n   * @method readyState\\n   */\\n\\n  Html5.prototype.readyState = function readyState() {\\n    return this.el_.readyState;\\n  };\\n\\n  /**\\n   * Get width of video\\n   *\\n   * @return {Number}\\n   * @method videoWidth\\n   */\\n\\n  Html5.prototype.videoWidth = function videoWidth() {\\n    return this.el_.videoWidth;\\n  };\\n\\n  /**\\n   * Get height of video\\n   *\\n   * @return {Number}\\n   * @method videoHeight\\n   */\\n\\n  Html5.prototype.videoHeight = function videoHeight() {\\n    return this.el_.videoHeight;\\n  };\\n\\n  /**\\n   * Get text tracks\\n   *\\n   * @return {TextTrackList}\\n   * @method textTracks\\n   */\\n\\n  Html5.prototype.textTracks = function textTracks() {\\n    return _Tech.prototype.textTracks.call(this);\\n  };\\n\\n  /**\\n   * Creates and returns a text track object\\n   *\\n   * @param {String} kind Text track kind (subtitles, captions, descriptions\\n   *                                       chapters and metadata)\\n   * @param {String=} label Label to identify the text track\\n   * @param {String=} language Two letter language abbreviation\\n   * @return {TextTrackObject}\\n   * @method addTextTrack\\n   */\\n\\n  Html5.prototype.addTextTrack = function addTextTrack(kind, label, language) {\\n    if (!this['featuresNativeTextTracks']) {\\n      return _Tech.prototype.addTextTrack.call(this, kind, label, language);\\n    }\\n\\n    return this.el_.addTextTrack(kind, label, language);\\n  };\\n\\n  /**\\n   * Creates a remote text track object and returns a html track element\\n   *\\n   * @param {Object} options The object should contain values for\\n   * kind, language, label and src (location of the WebVTT file)\\n   * @return {HTMLTrackElement}\\n   * @method addRemoteTextTrack\\n   */\\n\\n  Html5.prototype.addRemoteTextTrack = function addRemoteTextTrack() {\\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\\n\\n    if (!this['featuresNativeTextTracks']) {\\n      return _Tech.prototype.addRemoteTextTrack.call(this, options);\\n    }\\n\\n    var htmlTrackElement = _globalDocument2['default'].createElement('track');\\n\\n    if (options.kind) {\\n      htmlTrackElement.kind = options.kind;\\n    }\\n    if (options.label) {\\n      htmlTrackElement.label = options.label;\\n    }\\n    if (options.language || options.srclang) {\\n      htmlTrackElement.srclang = options.language || options.srclang;\\n    }\\n    if (options['default']) {\\n      htmlTrackElement['default'] = options['default'];\\n    }\\n    if (options.id) {\\n      htmlTrackElement.id = options.id;\\n    }\\n    if (options.src) {\\n      htmlTrackElement.src = options.src;\\n    }\\n\\n    this.el().appendChild(htmlTrackElement);\\n\\n    // store HTMLTrackElement and TextTrack to remote list\\n    this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);\\n    this.remoteTextTracks().addTrack_(htmlTrackElement.track);\\n\\n    return htmlTrackElement;\\n  };\\n\\n  /**\\n   * Remove remote text track from TextTrackList object\\n   *\\n   * @param {TextTrackObject} track Texttrack object to remove\\n   * @method removeRemoteTextTrack\\n   */\\n\\n  Html5.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track) {\\n    if (!this['featuresNativeTextTracks']) {\\n      return _Tech.prototype.removeRemoteTextTrack.call(this, track);\\n    }\\n\\n    var tracks = undefined,\\n        i = undefined;\\n\\n    var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);\\n\\n    // remove HTMLTrackElement and TextTrack from remote list\\n    this.remoteTextTrackEls().removeTrackElement_(trackElement);\\n    this.remoteTextTracks().removeTrack_(track);\\n\\n    tracks = this.$$('track');\\n\\n    i = tracks.length;\\n    while (i--) {\\n      if (track === tracks[i] || track === tracks[i].track) {\\n        this.el().removeChild(tracks[i]);\\n      }\\n    }\\n  };\\n\\n  return Html5;\\n})(_techJs2['default']);\\n\\nHtml5.TEST_VID = _globalDocument2['default'].createElement('video');\\nvar track = _globalDocument2['default'].createElement('track');\\ntrack.kind = 'captions';\\ntrack.srclang = 'en';\\ntrack.label = 'English';\\nHtml5.TEST_VID.appendChild(track);\\n\\n/*\\n * Check if HTML5 video is supported by this browser/device\\n *\\n * @return {Boolean}\\n */\\nHtml5.isSupported = function () {\\n  // IE9 with no Media Player is a LIAR! (#984)\\n  try {\\n    Html5.TEST_VID['volume'] = 0.5;\\n  } catch (e) {\\n    return false;\\n  }\\n\\n  return !!Html5.TEST_VID.canPlayType;\\n};\\n\\n// Add Source Handler pattern functions to this tech\\n_techJs2['default'].withSourceHandlers(Html5);\\n\\n/*\\n * The default native source handler.\\n * This simply passes the source to the video element. Nothing fancy.\\n *\\n * @param  {Object} source   The source object\\n * @param  {Html5} tech  The instance of the HTML5 tech\\n */\\nHtml5.nativeSourceHandler = {};\\n\\n/*\\n * Check if the video element can play the given videotype\\n *\\n * @param  {String} type    The mimetype to check\\n * @return {String}         'probably', 'maybe', or '' (empty string)\\n */\\nHtml5.nativeSourceHandler.canPlayType = function (type) {\\n  // IE9 on Windows 7 without MediaPlayer throws an error here\\n  // https://github.com/videojs/video.js/issues/519\\n  try {\\n    return Html5.TEST_VID.canPlayType(type);\\n  } catch (e) {\\n    return '';\\n  }\\n};\\n\\n/*\\n * Check if the video element can handle the source natively\\n *\\n * @param  {Object} source  The source object\\n * @param  {Object} options The options passed to the tech\\n * @return {String}         'probably', 'maybe', or '' (empty string)\\n */\\nHtml5.nativeSourceHandler.canHandleSource = function (source, options) {\\n  var match, ext;\\n\\n  // If a type was provided we should rely on that\\n  if (source.type) {\\n    return Html5.nativeSourceHandler.canPlayType(source.type);\\n  } else if (source.src) {\\n    // If no type, fall back to checking 'video/[EXTENSION]'\\n    ext = Url.getFileExtension(source.src);\\n\\n    return Html5.nativeSourceHandler.canPlayType('video/' + ext);\\n  }\\n\\n  return '';\\n};\\n\\n/*\\n * Pass the source to the video element\\n * Adaptive source handlers will have more complicated workflows before passing\\n * video data to the video element\\n *\\n * @param  {Object} source   The source object\\n * @param  {Html5}  tech     The instance of the Html5 tech\\n * @param  {Object} options  The options to pass to the source\\n */\\nHtml5.nativeSourceHandler.handleSource = function (source, tech, options) {\\n  tech.setSrc(source.src);\\n};\\n\\n/*\\n* Clean up the source handler when disposing the player or switching sources..\\n* (no cleanup is needed when supporting the format natively)\\n*/\\nHtml5.nativeSourceHandler.dispose = function () {};\\n\\n// Register the native source handler\\nHtml5.registerSourceHandler(Html5.nativeSourceHandler);\\n\\n/*\\n * Check if the volume can be changed in this browser/device.\\n * Volume cannot be changed in a lot of mobile devices.\\n * Specifically, it can't be changed from 1 on iOS.\\n *\\n * @return {Boolean}\\n */\\nHtml5.canControlVolume = function () {\\n  // IE will error if Windows Media Player not installed #3315\\n  try {\\n    var volume = Html5.TEST_VID.volume;\\n    Html5.TEST_VID.volume = volume / 2 + 0.1;\\n    return volume !== Html5.TEST_VID.volume;\\n  } catch (e) {\\n    return false;\\n  }\\n};\\n\\n/*\\n * Check if playbackRate is supported in this browser/device.\\n *\\n * @return {Boolean}\\n */\\nHtml5.canControlPlaybackRate = function () {\\n  // Playback rate API is implemented in Android Chrome, but doesn't do anything\\n  // https://github.com/videojs/video.js/issues/3180\\n  if (browser.IS_ANDROID && browser.IS_CHROME) {\\n    return false;\\n  }\\n  // IE will error if Windows Media Player not installed #3315\\n  try {\\n    var playbackRate = Html5.TEST_VID.playbackRate;\\n    Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;\\n    return playbackRate !== Html5.TEST_VID.playbackRate;\\n  } catch (e) {\\n    return false;\\n  }\\n};\\n\\n/*\\n * Check to see if native text tracks are supported by this browser/device\\n *\\n * @return {Boolean}\\n */\\nHtml5.supportsNativeTextTracks = function () {\\n  var supportsTextTracks;\\n\\n  // Figure out native text track support\\n  // If mode is a number, we cannot change it because it'll disappear from view.\\n  // Browsers with numeric modes include IE10 and older (<=2013) samsung android models.\\n  // Firefox isn't playing nice either with modifying the mode\\n  // TODO: Investigate firefox: https://github.com/videojs/video.js/issues/1862\\n  supportsTextTracks = !!Html5.TEST_VID.textTracks;\\n  if (supportsTextTracks && Html5.TEST_VID.textTracks.length > 0) {\\n    supportsTextTracks = typeof Html5.TEST_VID.textTracks[0]['mode'] !== 'number';\\n  }\\n  if (supportsTextTracks && browser.IS_FIREFOX) {\\n    supportsTextTracks = false;\\n  }\\n  if (supportsTextTracks && !('onremovetrack' in Html5.TEST_VID.textTracks)) {\\n    supportsTextTracks = false;\\n  }\\n\\n  return supportsTextTracks;\\n};\\n\\n/*\\n * Check to see if native video tracks are supported by this browser/device\\n *\\n * @return {Boolean}\\n */\\nHtml5.supportsNativeVideoTracks = function () {\\n  var supportsVideoTracks = !!Html5.TEST_VID.videoTracks;\\n  return supportsVideoTracks;\\n};\\n\\n/*\\n * Check to see if native audio tracks are supported by this browser/device\\n *\\n * @return {Boolean}\\n */\\nHtml5.supportsNativeAudioTracks = function () {\\n  var supportsAudioTracks = !!Html5.TEST_VID.audioTracks;\\n  return supportsAudioTracks;\\n};\\n\\n/**\\n * An array of events available on the Html5 tech.\\n *\\n * @private\\n * @type {Array}\\n */\\nHtml5.Events = ['loadstart', 'suspend', 'abort', 'error', 'emptied', 'stalled', 'loadedmetadata', 'loadeddata', 'canplay', 'canplaythrough', 'playing', 'waiting', 'seeking', 'seeked', 'ended', 'durationchange', 'timeupdate', 'progress', 'play', 'pause', 'ratechange', 'volumechange'];\\n\\n/*\\n * Set the tech's volume control support status\\n *\\n * @type {Boolean}\\n */\\nHtml5.prototype['featuresVolumeControl'] = Html5.canControlVolume();\\n\\n/*\\n * Set the tech's playbackRate support status\\n *\\n * @type {Boolean}\\n */\\nHtml5.prototype['featuresPlaybackRate'] = Html5.canControlPlaybackRate();\\n\\n/*\\n * Set the tech's status on moving the video element.\\n * In iOS, if you move a video element in the DOM, it breaks video playback.\\n *\\n * @type {Boolean}\\n */\\nHtml5.prototype['movingMediaElementInDOM'] = !browser.IS_IOS;\\n\\n/*\\n * Set the the tech's fullscreen resize support status.\\n * HTML video is able to automatically resize when going to fullscreen.\\n * (No longer appears to be used. Can probably be removed.)\\n */\\nHtml5.prototype['featuresFullscreenResize'] = true;\\n\\n/*\\n * Set the tech's progress event support status\\n * (this disables the manual progress events of the Tech)\\n */\\nHtml5.prototype['featuresProgressEvents'] = true;\\n\\n/*\\n * Sets the tech's status on native text track support\\n *\\n * @type {Boolean}\\n */\\nHtml5.prototype['featuresNativeTextTracks'] = Html5.supportsNativeTextTracks();\\n\\n/**\\n * Sets the tech's status on native text track support\\n *\\n * @type {Boolean}\\n */\\nHtml5.prototype['featuresNativeVideoTracks'] = Html5.supportsNativeVideoTracks();\\n\\n/**\\n * Sets the tech's status on native audio track support\\n *\\n * @type {Boolean}\\n */\\nHtml5.prototype['featuresNativeAudioTracks'] = Html5.supportsNativeAudioTracks();\\n\\n// HTML5 Feature detection and Device Fixes --------------------------------- //\\nvar canPlayType = undefined;\\nvar mpegurlRE = /^application\\\\/(?:x-|vnd\\\\.apple\\\\.)mpegurl/i;\\nvar mp4RE = /^video\\\\/mp4/i;\\n\\nHtml5.patchCanPlayType = function () {\\n  // Android 4.0 and above can play HLS to some extent but it reports being unable to do so\\n  if (browser.ANDROID_VERSION >= 4.0) {\\n    if (!canPlayType) {\\n      canPlayType = Html5.TEST_VID.constructor.prototype.canPlayType;\\n    }\\n\\n    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {\\n      if (type && mpegurlRE.test(type)) {\\n        return 'maybe';\\n      }\\n      return canPlayType.call(this, type);\\n    };\\n  }\\n\\n  // Override Android 2.2 and less canPlayType method which is broken\\n  if (browser.IS_OLD_ANDROID) {\\n    if (!canPlayType) {\\n      canPlayType = Html5.TEST_VID.constructor.prototype.canPlayType;\\n    }\\n\\n    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {\\n      if (type && mp4RE.test(type)) {\\n        return 'maybe';\\n      }\\n      return canPlayType.call(this, type);\\n    };\\n  }\\n};\\n\\nHtml5.unpatchCanPlayType = function () {\\n  var r = Html5.TEST_VID.constructor.prototype.canPlayType;\\n  Html5.TEST_VID.constructor.prototype.canPlayType = canPlayType;\\n  canPlayType = null;\\n  return r;\\n};\\n\\n// by default, patch the video element\\nHtml5.patchCanPlayType();\\n\\nHtml5.disposeMediaElement = function (el) {\\n  if (!el) {\\n    return;\\n  }\\n\\n  if (el.parentNode) {\\n    el.parentNode.removeChild(el);\\n  }\\n\\n  // remove any child track or source nodes to prevent their loading\\n  while (el.hasChildNodes()) {\\n    el.removeChild(el.firstChild);\\n  }\\n\\n  // remove any src reference. not setting `src=''` because that causes a warning\\n  // in firefox\\n  el.removeAttribute('src');\\n\\n  // force the media element to update its loading state by calling load()\\n  // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)\\n  if (typeof el.load === 'function') {\\n    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\\n    (function () {\\n      try {\\n        el.load();\\n      } catch (e) {\\n        // not supported\\n      }\\n    })();\\n  }\\n};\\n\\nHtml5.resetMediaElement = function (el) {\\n  if (!el) {\\n    return;\\n  }\\n\\n  var sources = el.querySelectorAll('source');\\n  var i = sources.length;\\n  while (i--) {\\n    el.removeChild(sources[i]);\\n  }\\n\\n  // remove any src reference.\\n  // not setting `src=''` because that throws an error\\n  el.removeAttribute('src');\\n\\n  if (typeof el.load === 'function') {\\n    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\\n    (function () {\\n      try {\\n        el.load();\\n      } catch (e) {}\\n    })();\\n  }\\n};\\n\\n_component2['default'].registerComponent('Html5', Html5);\\n_techJs2['default'].registerTech('Html5', Html5);\\nexports['default'] = Html5;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../../src/js/tracks/text-track.js\\\":134,\\\"../component\\\":67,\\\"../utils/browser.js\\\":140,\\\"../utils/dom.js\\\":142,\\\"../utils/fn.js\\\":144,\\\"../utils/log.js\\\":147,\\\"../utils/merge-options.js\\\":148,\\\"../utils/to-title-case.js\\\":151,\\\"../utils/url.js\\\":152,\\\"./tech.js\\\":124,\\\"global/document\\\":1,\\\"global/window\\\":2,\\\"object.assign\\\":45,\\\"tsml\\\":55}],123:[function(_dereq_,module,exports){\\n/**\\n * @file loader.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _componentJs = _dereq_('../component.js');\\n\\nvar _componentJs2 = _interopRequireDefault(_componentJs);\\n\\nvar _techJs = _dereq_('./tech.js');\\n\\nvar _techJs2 = _interopRequireDefault(_techJs);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _utilsToTitleCaseJs = _dereq_('../utils/to-title-case.js');\\n\\nvar _utilsToTitleCaseJs2 = _interopRequireDefault(_utilsToTitleCaseJs);\\n\\n/**\\n * The Media Loader is the component that decides which playback technology to load\\n * when the player is initialized.\\n *\\n * @param {Object} player  Main Player\\n * @param {Object=} options Object of option names and values\\n * @param {Function=} ready    Ready callback function\\n * @extends Component\\n * @class MediaLoader\\n */\\n\\nvar MediaLoader = (function (_Component) {\\n  _inherits(MediaLoader, _Component);\\n\\n  function MediaLoader(player, options, ready) {\\n    _classCallCheck(this, MediaLoader);\\n\\n    _Component.call(this, player, options, ready);\\n\\n    // If there are no sources when the player is initialized,\\n    // load the first supported playback technology.\\n\\n    if (!options.playerOptions['sources'] || options.playerOptions['sources'].length === 0) {\\n      for (var i = 0, j = options.playerOptions['techOrder']; i < j.length; i++) {\\n        var techName = _utilsToTitleCaseJs2['default'](j[i]);\\n        var tech = _techJs2['default'].getTech(techName);\\n        // Support old behavior of techs being registered as components.\\n        // Remove once that deprecated behavior is removed.\\n        if (!techName) {\\n          tech = _componentJs2['default'].getComponent(techName);\\n        }\\n\\n        // Check if the browser supports this technology\\n        if (tech && tech.isSupported()) {\\n          player.loadTech_(techName);\\n          break;\\n        }\\n      }\\n    } else {\\n      // // Loop through playback technologies (HTML5, Flash) and check for support.\\n      // // Then load the best source.\\n      // // A few assumptions here:\\n      // //   All playback technologies respect preload false.\\n      player.src(options.playerOptions['sources']);\\n    }\\n  }\\n\\n  return MediaLoader;\\n})(_componentJs2['default']);\\n\\n_componentJs2['default'].registerComponent('MediaLoader', MediaLoader);\\nexports['default'] = MediaLoader;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component.js\\\":67,\\\"../utils/to-title-case.js\\\":151,\\\"./tech.js\\\":124,\\\"global/window\\\":2}],124:[function(_dereq_,module,exports){\\n/**\\n * @file tech.js\\n * Media Technology Controller - Base class for media playback\\n * technology controllers like Flash and HTML5\\n */\\n\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _component = _dereq_('../component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _tracksHtmlTrackElement = _dereq_('../tracks/html-track-element');\\n\\nvar _tracksHtmlTrackElement2 = _interopRequireDefault(_tracksHtmlTrackElement);\\n\\nvar _tracksHtmlTrackElementList = _dereq_('../tracks/html-track-element-list');\\n\\nvar _tracksHtmlTrackElementList2 = _interopRequireDefault(_tracksHtmlTrackElementList);\\n\\nvar _utilsMergeOptionsJs = _dereq_('../utils/merge-options.js');\\n\\nvar _utilsMergeOptionsJs2 = _interopRequireDefault(_utilsMergeOptionsJs);\\n\\nvar _tracksTextTrack = _dereq_('../tracks/text-track');\\n\\nvar _tracksTextTrack2 = _interopRequireDefault(_tracksTextTrack);\\n\\nvar _tracksTextTrackList = _dereq_('../tracks/text-track-list');\\n\\nvar _tracksTextTrackList2 = _interopRequireDefault(_tracksTextTrackList);\\n\\nvar _tracksVideoTrack = _dereq_('../tracks/video-track');\\n\\nvar _tracksVideoTrack2 = _interopRequireDefault(_tracksVideoTrack);\\n\\nvar _tracksVideoTrackList = _dereq_('../tracks/video-track-list');\\n\\nvar _tracksVideoTrackList2 = _interopRequireDefault(_tracksVideoTrackList);\\n\\nvar _tracksAudioTrackList = _dereq_('../tracks/audio-track-list');\\n\\nvar _tracksAudioTrackList2 = _interopRequireDefault(_tracksAudioTrackList);\\n\\nvar _tracksAudioTrack = _dereq_('../tracks/audio-track');\\n\\nvar _tracksAudioTrack2 = _interopRequireDefault(_tracksAudioTrack);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsLogJs = _dereq_('../utils/log.js');\\n\\nvar _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);\\n\\nvar _utilsTimeRangesJs = _dereq_('../utils/time-ranges.js');\\n\\nvar _utilsBufferJs = _dereq_('../utils/buffer.js');\\n\\nvar _mediaErrorJs = _dereq_('../media-error.js');\\n\\nvar _mediaErrorJs2 = _interopRequireDefault(_mediaErrorJs);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\n/**\\n * Base class for media (HTML5 Video, Flash) controllers\\n *\\n * @param {Object=} options Options object\\n * @param {Function=} ready Ready callback function\\n * @extends Component\\n * @class Tech\\n */\\n\\nvar Tech = (function (_Component) {\\n  _inherits(Tech, _Component);\\n\\n  function Tech() {\\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\\n    var ready = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];\\n\\n    _classCallCheck(this, Tech);\\n\\n    // we don't want the tech to report user activity automatically.\\n    // This is done manually in addControlsListeners\\n    options.reportTouchActivity = false;\\n    _Component.call(this, null, options, ready);\\n\\n    // keep track of whether the current source has played at all to\\n    // implement a very limited played()\\n    this.hasStarted_ = false;\\n    this.on('playing', function () {\\n      this.hasStarted_ = true;\\n    });\\n    this.on('loadstart', function () {\\n      this.hasStarted_ = false;\\n    });\\n\\n    this.textTracks_ = options.textTracks;\\n    this.videoTracks_ = options.videoTracks;\\n    this.audioTracks_ = options.audioTracks;\\n\\n    // Manually track progress in cases where the browser/flash player doesn't report it.\\n    if (!this.featuresProgressEvents) {\\n      this.manualProgressOn();\\n    }\\n\\n    // Manually track timeupdates in cases where the browser/flash player doesn't report it.\\n    if (!this.featuresTimeupdateEvents) {\\n      this.manualTimeUpdatesOn();\\n    }\\n\\n    if (options.nativeCaptions === false || options.nativeTextTracks === false) {\\n      this.featuresNativeTextTracks = false;\\n    }\\n\\n    if (!this.featuresNativeTextTracks) {\\n      this.on('ready', this.emulateTextTracks);\\n    }\\n\\n    this.initTextTrackListeners();\\n    this.initTrackListeners();\\n\\n    // Turn on component tap events\\n    this.emitTapEvents();\\n  }\\n\\n  /**\\n   * List of associated text tracks\\n   *\\n   * @type {TextTrackList}\\n   * @private\\n   */\\n\\n  /* Fallbacks for unsupported event types\\n  ================================================================================ */\\n  // Manually trigger progress events based on changes to the buffered amount\\n  // Many flash players and older HTML5 browsers don't send progress or progress-like events\\n  /**\\n   * Turn on progress events\\n   *\\n   * @method manualProgressOn\\n   */\\n\\n  Tech.prototype.manualProgressOn = function manualProgressOn() {\\n    this.on('durationchange', this.onDurationChange);\\n\\n    this.manualProgress = true;\\n\\n    // Trigger progress watching when a source begins loading\\n    this.one('ready', this.trackProgress);\\n  };\\n\\n  /**\\n   * Turn off progress events\\n   *\\n   * @method manualProgressOff\\n   */\\n\\n  Tech.prototype.manualProgressOff = function manualProgressOff() {\\n    this.manualProgress = false;\\n    this.stopTrackingProgress();\\n\\n    this.off('durationchange', this.onDurationChange);\\n  };\\n\\n  /**\\n   * Track progress\\n   *\\n   * @method trackProgress\\n   */\\n\\n  Tech.prototype.trackProgress = function trackProgress() {\\n    this.stopTrackingProgress();\\n    this.progressInterval = this.setInterval(Fn.bind(this, function () {\\n      // Don't trigger unless buffered amount is greater than last time\\n\\n      var numBufferedPercent = this.bufferedPercent();\\n\\n      if (this.bufferedPercent_ !== numBufferedPercent) {\\n        this.trigger('progress');\\n      }\\n\\n      this.bufferedPercent_ = numBufferedPercent;\\n\\n      if (numBufferedPercent === 1) {\\n        this.stopTrackingProgress();\\n      }\\n    }), 500);\\n  };\\n\\n  /**\\n   * Update duration\\n   *\\n   * @method onDurationChange\\n   */\\n\\n  Tech.prototype.onDurationChange = function onDurationChange() {\\n    this.duration_ = this.duration();\\n  };\\n\\n  /**\\n   * Create and get TimeRange object for buffering\\n   *\\n   * @return {TimeRangeObject}\\n   * @method buffered\\n   */\\n\\n  Tech.prototype.buffered = function buffered() {\\n    return _utilsTimeRangesJs.createTimeRange(0, 0);\\n  };\\n\\n  /**\\n   * Get buffered percent\\n   *\\n   * @return {Number}\\n   * @method bufferedPercent\\n   */\\n\\n  Tech.prototype.bufferedPercent = function bufferedPercent() {\\n    return _utilsBufferJs.bufferedPercent(this.buffered(), this.duration_);\\n  };\\n\\n  /**\\n   * Stops tracking progress by clearing progress interval\\n   *\\n   * @method stopTrackingProgress\\n   */\\n\\n  Tech.prototype.stopTrackingProgress = function stopTrackingProgress() {\\n    this.clearInterval(this.progressInterval);\\n  };\\n\\n  /*! Time Tracking -------------------------------------------------------------- */\\n  /**\\n   * Set event listeners for on play and pause and tracking current time\\n   *\\n   * @method manualTimeUpdatesOn\\n   */\\n\\n  Tech.prototype.manualTimeUpdatesOn = function manualTimeUpdatesOn() {\\n    this.manualTimeUpdates = true;\\n\\n    this.on('play', this.trackCurrentTime);\\n    this.on('pause', this.stopTrackingCurrentTime);\\n  };\\n\\n  /**\\n   * Remove event listeners for on play and pause and tracking current time\\n   *\\n   * @method manualTimeUpdatesOff\\n   */\\n\\n  Tech.prototype.manualTimeUpdatesOff = function manualTimeUpdatesOff() {\\n    this.manualTimeUpdates = false;\\n    this.stopTrackingCurrentTime();\\n    this.off('play', this.trackCurrentTime);\\n    this.off('pause', this.stopTrackingCurrentTime);\\n  };\\n\\n  /**\\n   * Tracks current time\\n   *\\n   * @method trackCurrentTime\\n   */\\n\\n  Tech.prototype.trackCurrentTime = function trackCurrentTime() {\\n    if (this.currentTimeInterval) {\\n      this.stopTrackingCurrentTime();\\n    }\\n    this.currentTimeInterval = this.setInterval(function () {\\n      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });\\n    }, 250); // 42 = 24 fps // 250 is what Webkit uses // FF uses 15\\n  };\\n\\n  /**\\n   * Turn off play progress tracking (when paused or dragging)\\n   *\\n   * @method stopTrackingCurrentTime\\n   */\\n\\n  Tech.prototype.stopTrackingCurrentTime = function stopTrackingCurrentTime() {\\n    this.clearInterval(this.currentTimeInterval);\\n\\n    // #1002 - if the video ends right before the next timeupdate would happen,\\n    // the progress bar won't make it all the way to the end\\n    this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });\\n  };\\n\\n  /**\\n   * Turn off any manual progress or timeupdate tracking\\n   *\\n   * @method dispose\\n   */\\n\\n  Tech.prototype.dispose = function dispose() {\\n\\n    // clear out all tracks because we can't reuse them between techs\\n    this.clearTracks(['audio', 'video', 'text']);\\n\\n    // Turn off any manual progress or timeupdate tracking\\n    if (this.manualProgress) {\\n      this.manualProgressOff();\\n    }\\n\\n    if (this.manualTimeUpdates) {\\n      this.manualTimeUpdatesOff();\\n    }\\n\\n    _Component.prototype.dispose.call(this);\\n  };\\n\\n  /**\\n   * clear out a track list, or multiple track lists\\n   *\\n   * Note: Techs without source handlers should call this between\\n   * sources for video & audio tracks, as usually you don't want\\n   * to use them between tracks and we have no automatic way to do\\n   * it for you\\n   *\\n   * @method clearTracks\\n   * @param {Array|String} types type(s) of track lists to empty\\n   */\\n\\n  Tech.prototype.clearTracks = function clearTracks(types) {\\n    var _this = this;\\n\\n    types = [].concat(types);\\n    // clear out all tracks because we can't reuse them between techs\\n    types.forEach(function (type) {\\n      var list = _this[type + 'Tracks']() || [];\\n      var i = list.length;\\n      while (i--) {\\n        var track = list[i];\\n        if (type === 'text') {\\n          _this.removeRemoteTextTrack(track);\\n        }\\n        list.removeTrack_(track);\\n      }\\n    });\\n  };\\n\\n  /**\\n   * Reset the tech. Removes all sources and resets readyState.\\n   *\\n   * @method reset\\n   */\\n\\n  Tech.prototype.reset = function reset() {};\\n\\n  /**\\n   * When invoked without an argument, returns a MediaError object\\n   * representing the current error state of the player or null if\\n   * there is no error. When invoked with an argument, set the current\\n   * error state of the player.\\n   * @param {MediaError=} err    Optional an error object\\n   * @return {MediaError}        the current error object or null\\n   * @method error\\n   */\\n\\n  Tech.prototype.error = function error(err) {\\n    if (err !== undefined) {\\n      this.error_ = new _mediaErrorJs2['default'](err);\\n      this.trigger('error');\\n    }\\n    return this.error_;\\n  };\\n\\n  /**\\n   * Return the time ranges that have been played through for the\\n   * current source. This implementation is incomplete. It does not\\n   * track the played time ranges, only whether the source has played\\n   * at all or not.\\n   * @return {TimeRangeObject} a single time range if this video has\\n   * played or an empty set of ranges if not.\\n   * @method played\\n   */\\n\\n  Tech.prototype.played = function played() {\\n    if (this.hasStarted_) {\\n      return _utilsTimeRangesJs.createTimeRange(0, 0);\\n    }\\n    return _utilsTimeRangesJs.createTimeRange();\\n  };\\n\\n  /**\\n   * Set current time\\n   *\\n   * @method setCurrentTime\\n   */\\n\\n  Tech.prototype.setCurrentTime = function setCurrentTime() {\\n    // improve the accuracy of manual timeupdates\\n    if (this.manualTimeUpdates) {\\n      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });\\n    }\\n  };\\n\\n  /**\\n   * Initialize texttrack listeners\\n   *\\n   * @method initTextTrackListeners\\n   */\\n\\n  Tech.prototype.initTextTrackListeners = function initTextTrackListeners() {\\n    var textTrackListChanges = Fn.bind(this, function () {\\n      this.trigger('texttrackchange');\\n    });\\n\\n    var tracks = this.textTracks();\\n\\n    if (!tracks) return;\\n\\n    tracks.addEventListener('removetrack', textTrackListChanges);\\n    tracks.addEventListener('addtrack', textTrackListChanges);\\n\\n    this.on('dispose', Fn.bind(this, function () {\\n      tracks.removeEventListener('removetrack', textTrackListChanges);\\n      tracks.removeEventListener('addtrack', textTrackListChanges);\\n    }));\\n  };\\n\\n  /**\\n   * Initialize audio and video track listeners\\n   *\\n   * @method initTrackListeners\\n   */\\n\\n  Tech.prototype.initTrackListeners = function initTrackListeners() {\\n    var _this2 = this;\\n\\n    var trackTypes = ['video', 'audio'];\\n\\n    trackTypes.forEach(function (type) {\\n      var trackListChanges = function trackListChanges() {\\n        _this2.trigger(type + 'trackchange');\\n      };\\n\\n      var tracks = _this2[type + 'Tracks']();\\n\\n      tracks.addEventListener('removetrack', trackListChanges);\\n      tracks.addEventListener('addtrack', trackListChanges);\\n\\n      _this2.on('dispose', function () {\\n        tracks.removeEventListener('removetrack', trackListChanges);\\n        tracks.removeEventListener('addtrack', trackListChanges);\\n      });\\n    });\\n  };\\n\\n  /**\\n   * Emulate texttracks\\n   *\\n   * @method emulateTextTracks\\n   */\\n\\n  Tech.prototype.emulateTextTracks = function emulateTextTracks() {\\n    var _this3 = this;\\n\\n    var tracks = this.textTracks();\\n    if (!tracks) {\\n      return;\\n    }\\n\\n    if (!_globalWindow2['default']['WebVTT'] && this.el().parentNode != null) {\\n      (function () {\\n        var script = _globalDocument2['default'].createElement('script');\\n        script.src = _this3.options_['vtt.js'] || 'https://cdn.rawgit.com/gkatsev/vtt.js/vjs-v0.12.1/dist/vtt.min.js';\\n        script.onload = function () {\\n          _this3.trigger('vttjsloaded');\\n        };\\n        script.onerror = function () {\\n          _this3.trigger('vttjserror');\\n        };\\n        _this3.on('dispose', function () {\\n          script.onload = null;\\n          script.onerror = null;\\n        });\\n        // but have not loaded yet and we set it to true before the inject so that\\n        // we don't overwrite the injected window.WebVTT if it loads right away\\n        _globalWindow2['default']['WebVTT'] = true;\\n        _this3.el().parentNode.appendChild(script);\\n      })();\\n    }\\n\\n    var updateDisplay = function updateDisplay() {\\n      return _this3.trigger('texttrackchange');\\n    };\\n    var textTracksChanges = function textTracksChanges() {\\n      updateDisplay();\\n\\n      for (var i = 0; i < tracks.length; i++) {\\n        var track = tracks[i];\\n        track.removeEventListener('cuechange', updateDisplay);\\n        if (track.mode === 'showing') {\\n          track.addEventListener('cuechange', updateDisplay);\\n        }\\n      }\\n    };\\n\\n    textTracksChanges();\\n    tracks.addEventListener('change', textTracksChanges);\\n\\n    this.on('dispose', function () {\\n      tracks.removeEventListener('change', textTracksChanges);\\n    });\\n  };\\n\\n  /**\\n   * Get videotracks\\n   *\\n   * @returns {VideoTrackList}\\n   * @method videoTracks\\n   */\\n\\n  Tech.prototype.videoTracks = function videoTracks() {\\n    this.videoTracks_ = this.videoTracks_ || new _tracksVideoTrackList2['default']();\\n    return this.videoTracks_;\\n  };\\n\\n  /**\\n   * Get audiotracklist\\n   *\\n   * @returns {AudioTrackList}\\n   * @method audioTracks\\n   */\\n\\n  Tech.prototype.audioTracks = function audioTracks() {\\n    this.audioTracks_ = this.audioTracks_ || new _tracksAudioTrackList2['default']();\\n    return this.audioTracks_;\\n  };\\n\\n  /*\\n   * Provide default methods for text tracks.\\n   *\\n   * Html5 tech overrides these.\\n   */\\n\\n  /**\\n   * Get texttracks\\n   *\\n   * @returns {TextTrackList}\\n   * @method textTracks\\n   */\\n\\n  Tech.prototype.textTracks = function textTracks() {\\n    this.textTracks_ = this.textTracks_ || new _tracksTextTrackList2['default']();\\n    return this.textTracks_;\\n  };\\n\\n  /**\\n   * Get remote texttracks\\n   *\\n   * @returns {TextTrackList}\\n   * @method remoteTextTracks\\n   */\\n\\n  Tech.prototype.remoteTextTracks = function remoteTextTracks() {\\n    this.remoteTextTracks_ = this.remoteTextTracks_ || new _tracksTextTrackList2['default']();\\n    return this.remoteTextTracks_;\\n  };\\n\\n  /**\\n   * Get remote htmltrackelements\\n   *\\n   * @returns {HTMLTrackElementList}\\n   * @method remoteTextTrackEls\\n   */\\n\\n  Tech.prototype.remoteTextTrackEls = function remoteTextTrackEls() {\\n    this.remoteTextTrackEls_ = this.remoteTextTrackEls_ || new _tracksHtmlTrackElementList2['default']();\\n    return this.remoteTextTrackEls_;\\n  };\\n\\n  /**\\n   * Creates and returns a remote text track object\\n   *\\n   * @param {String} kind Text track kind (subtitles, captions, descriptions\\n   *                                       chapters and metadata)\\n   * @param {String=} label Label to identify the text track\\n   * @param {String=} language Two letter language abbreviation\\n   * @return {TextTrackObject}\\n   * @method addTextTrack\\n   */\\n\\n  Tech.prototype.addTextTrack = function addTextTrack(kind, label, language) {\\n    if (!kind) {\\n      throw new Error('TextTrack kind is required but was not provided');\\n    }\\n\\n    return createTrackHelper(this, kind, label, language);\\n  };\\n\\n  /**\\n   * Creates a remote text track object and returns a emulated html track element\\n   *\\n   * @param {Object} options The object should contain values for\\n   * kind, language, label and src (location of the WebVTT file)\\n   * @return {HTMLTrackElement}\\n   * @method addRemoteTextTrack\\n   */\\n\\n  Tech.prototype.addRemoteTextTrack = function addRemoteTextTrack(options) {\\n    var track = _utilsMergeOptionsJs2['default'](options, {\\n      tech: this\\n    });\\n\\n    var htmlTrackElement = new _tracksHtmlTrackElement2['default'](track);\\n\\n    // store HTMLTrackElement and TextTrack to remote list\\n    this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);\\n    this.remoteTextTracks().addTrack_(htmlTrackElement.track);\\n\\n    // must come after remoteTextTracks()\\n    this.textTracks().addTrack_(htmlTrackElement.track);\\n\\n    return htmlTrackElement;\\n  };\\n\\n  /**\\n   * Remove remote texttrack\\n   *\\n   * @param {TextTrackObject} track Texttrack to remove\\n   * @method removeRemoteTextTrack\\n   */\\n\\n  Tech.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track) {\\n    this.textTracks().removeTrack_(track);\\n\\n    var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);\\n\\n    // remove HTMLTrackElement and TextTrack from remote list\\n    this.remoteTextTrackEls().removeTrackElement_(trackElement);\\n    this.remoteTextTracks().removeTrack_(track);\\n  };\\n\\n  /**\\n   * Provide a default setPoster method for techs\\n   * Poster support for techs should be optional, so we don't want techs to\\n   * break if they don't have a way to set a poster.\\n   *\\n   * @method setPoster\\n   */\\n\\n  Tech.prototype.setPoster = function setPoster() {};\\n\\n  /*\\n   * Check if the tech can support the given type\\n   *\\n   * The base tech does not support any type, but source handlers might\\n   * overwrite this.\\n   *\\n   * @param  {String} type    The mimetype to check\\n   * @return {String}         'probably', 'maybe', or '' (empty string)\\n   */\\n\\n  Tech.prototype.canPlayType = function canPlayType() {\\n    return '';\\n  };\\n\\n  /*\\n   * Return whether the argument is a Tech or not.\\n   * Can be passed either a Class like `Html5` or a instance like `player.tech_`\\n   *\\n   * @param {Object} component An item to check\\n   * @return {Boolean}         Whether it is a tech or not\\n   */\\n\\n  Tech.isTech = function isTech(component) {\\n    return component.prototype instanceof Tech || component instanceof Tech || component === Tech;\\n  };\\n\\n  /**\\n   * Registers a Tech\\n   *\\n   * @param {String} name Name of the Tech to register\\n   * @param {Object} tech The tech to register\\n   * @static\\n   * @method registerComponent\\n   */\\n\\n  Tech.registerTech = function registerTech(name, tech) {\\n    if (!Tech.techs_) {\\n      Tech.techs_ = {};\\n    }\\n\\n    if (!Tech.isTech(tech)) {\\n      throw new Error('Tech ' + name + ' must be a Tech');\\n    }\\n\\n    Tech.techs_[name] = tech;\\n    return tech;\\n  };\\n\\n  /**\\n   * Gets a component by name\\n   *\\n   * @param {String} name Name of the component to get\\n   * @return {Component}\\n   * @static\\n   * @method getComponent\\n   */\\n\\n  Tech.getTech = function getTech(name) {\\n    if (Tech.techs_ && Tech.techs_[name]) {\\n      return Tech.techs_[name];\\n    }\\n\\n    if (_globalWindow2['default'] && _globalWindow2['default'].videojs && _globalWindow2['default'].videojs[name]) {\\n      _utilsLogJs2['default'].warn('The ' + name + ' tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)');\\n      return _globalWindow2['default'].videojs[name];\\n    }\\n  };\\n\\n  return Tech;\\n})(_component2['default']);\\n\\nTech.prototype.textTracks_;\\n\\n/**\\n * List of associated audio tracks\\n *\\n * @type {AudioTrackList}\\n * @private\\n */\\nTech.prototype.audioTracks_;\\n\\n/**\\n * List of associated video tracks\\n *\\n * @type {VideoTrackList}\\n * @private\\n */\\nTech.prototype.videoTracks_;\\n\\nvar createTrackHelper = function createTrackHelper(self, kind, label, language) {\\n  var options = arguments.length <= 4 || arguments[4] === undefined ? {} : arguments[4];\\n\\n  var tracks = self.textTracks();\\n\\n  options.kind = kind;\\n\\n  if (label) {\\n    options.label = label;\\n  }\\n  if (language) {\\n    options.language = language;\\n  }\\n  options.tech = self;\\n\\n  var track = new _tracksTextTrack2['default'](options);\\n  tracks.addTrack_(track);\\n\\n  return track;\\n};\\n\\nTech.prototype.featuresVolumeControl = true;\\n\\n// Resizing plugins using request fullscreen reloads the plugin\\nTech.prototype.featuresFullscreenResize = false;\\nTech.prototype.featuresPlaybackRate = false;\\n\\n// Optional events that we can manually mimic with timers\\n// currently not triggered by video-js-swf\\nTech.prototype.featuresProgressEvents = false;\\nTech.prototype.featuresTimeupdateEvents = false;\\n\\nTech.prototype.featuresNativeTextTracks = false;\\n\\n/*\\n * A functional mixin for techs that want to use the Source Handler pattern.\\n *\\n * ##### EXAMPLE:\\n *\\n *   Tech.withSourceHandlers.call(MyTech);\\n *\\n */\\nTech.withSourceHandlers = function (_Tech) {\\n  /*\\n   * Register a source handler\\n   * Source handlers are scripts for handling specific formats.\\n   * The source handler pattern is used for adaptive formats (HLS, DASH) that\\n   * manually load video data and feed it into a Source Buffer (Media Source Extensions)\\n   * @param  {Function} handler  The source handler\\n   * @param  {Boolean}  first    Register it before any existing handlers\\n   */\\n  _Tech.registerSourceHandler = function (handler, index) {\\n    var handlers = _Tech.sourceHandlers;\\n\\n    if (!handlers) {\\n      handlers = _Tech.sourceHandlers = [];\\n    }\\n\\n    if (index === undefined) {\\n      // add to the end of the list\\n      index = handlers.length;\\n    }\\n\\n    handlers.splice(index, 0, handler);\\n  };\\n\\n  /*\\n   * Check if the tech can support the given type\\n   * @param  {String} type    The mimetype to check\\n   * @return {String}         'probably', 'maybe', or '' (empty string)\\n   */\\n  _Tech.canPlayType = function (type) {\\n    var handlers = _Tech.sourceHandlers || [];\\n    var can = undefined;\\n\\n    for (var i = 0; i < handlers.length; i++) {\\n      can = handlers[i].canPlayType(type);\\n\\n      if (can) {\\n        return can;\\n      }\\n    }\\n\\n    return '';\\n  };\\n\\n  /*\\n   * Return the first source handler that supports the source\\n   * TODO: Answer question: should 'probably' be prioritized over 'maybe'\\n   * @param  {Object} source  The source object\\n   * @param  {Object} options The options passed to the tech\\n   * @returns {Object}       The first source handler that supports the source\\n   * @returns {null}         Null if no source handler is found\\n   */\\n  _Tech.selectSourceHandler = function (source, options) {\\n    var handlers = _Tech.sourceHandlers || [];\\n    var can = undefined;\\n\\n    for (var i = 0; i < handlers.length; i++) {\\n      can = handlers[i].canHandleSource(source, options);\\n\\n      if (can) {\\n        return handlers[i];\\n      }\\n    }\\n\\n    return null;\\n  };\\n\\n  /*\\n   * Check if the tech can support the given source\\n   * @param  {Object} srcObj  The source object\\n   * @param  {Object} options The options passed to the tech\\n   * @return {String}         'probably', 'maybe', or '' (empty string)\\n   */\\n  _Tech.canPlaySource = function (srcObj, options) {\\n    var sh = _Tech.selectSourceHandler(srcObj, options);\\n\\n    if (sh) {\\n      return sh.canHandleSource(srcObj, options);\\n    }\\n\\n    return '';\\n  };\\n\\n  /*\\n   * When using a source handler, prefer its implementation of\\n   * any function normally provided by the tech.\\n   */\\n  var deferrable = ['seekable', 'duration'];\\n\\n  deferrable.forEach(function (fnName) {\\n    var originalFn = this[fnName];\\n\\n    if (typeof originalFn !== 'function') {\\n      return;\\n    }\\n\\n    this[fnName] = function () {\\n      if (this.sourceHandler_ && this.sourceHandler_[fnName]) {\\n        return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);\\n      }\\n      return originalFn.apply(this, arguments);\\n    };\\n  }, _Tech.prototype);\\n\\n  /*\\n   * Create a function for setting the source using a source object\\n   * and source handlers.\\n   * Should never be called unless a source handler was found.\\n   * @param {Object} source  A source object with src and type keys\\n   * @return {Tech} self\\n   */\\n  _Tech.prototype.setSource = function (source) {\\n    var sh = _Tech.selectSourceHandler(source, this.options_);\\n\\n    if (!sh) {\\n      // Fall back to a native source hander when unsupported sources are\\n      // deliberately set\\n      if (_Tech.nativeSourceHandler) {\\n        sh = _Tech.nativeSourceHandler;\\n      } else {\\n        _utilsLogJs2['default'].error('No source hander found for the current source.');\\n      }\\n    }\\n\\n    // Dispose any existing source handler\\n    this.disposeSourceHandler();\\n    this.off('dispose', this.disposeSourceHandler);\\n\\n    // if we have a source and get another one\\n    // then we are loading something new\\n    // than clear all of our current tracks\\n    if (this.currentSource_) {\\n      this.clearTracks(['audio', 'video']);\\n\\n      this.currentSource_ = null;\\n    }\\n\\n    if (sh !== _Tech.nativeSourceHandler) {\\n\\n      this.currentSource_ = source;\\n\\n      // Catch if someone replaced the src without calling setSource.\\n      // If they do, set currentSource_ to null and dispose our source handler.\\n      this.off(this.el_, 'loadstart', _Tech.prototype.firstLoadStartListener_);\\n      this.off(this.el_, 'loadstart', _Tech.prototype.successiveLoadStartListener_);\\n      this.one(this.el_, 'loadstart', _Tech.prototype.firstLoadStartListener_);\\n    }\\n\\n    this.sourceHandler_ = sh.handleSource(source, this, this.options_);\\n    this.on('dispose', this.disposeSourceHandler);\\n\\n    return this;\\n  };\\n\\n  // On the first loadstart after setSource\\n  _Tech.prototype.firstLoadStartListener_ = function () {\\n    this.one(this.el_, 'loadstart', _Tech.prototype.successiveLoadStartListener_);\\n  };\\n\\n  // On successive loadstarts when setSource has not been called again\\n  _Tech.prototype.successiveLoadStartListener_ = function () {\\n    this.currentSource_ = null;\\n    this.disposeSourceHandler();\\n    this.one(this.el_, 'loadstart', _Tech.prototype.successiveLoadStartListener_);\\n  };\\n\\n  /*\\n   * Clean up any existing source handler\\n   */\\n  _Tech.prototype.disposeSourceHandler = function () {\\n    if (this.sourceHandler_ && this.sourceHandler_.dispose) {\\n      this.off(this.el_, 'loadstart', _Tech.prototype.firstLoadStartListener_);\\n      this.off(this.el_, 'loadstart', _Tech.prototype.successiveLoadStartListener_);\\n      this.sourceHandler_.dispose();\\n      this.sourceHandler_ = null;\\n    }\\n  };\\n};\\n\\n_component2['default'].registerComponent('Tech', Tech);\\n// Old name for Tech\\n_component2['default'].registerComponent('MediaTechController', Tech);\\nTech.registerTech('Tech', Tech);\\nexports['default'] = Tech;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component\\\":67,\\\"../media-error.js\\\":108,\\\"../tracks/audio-track\\\":126,\\\"../tracks/audio-track-list\\\":125,\\\"../tracks/html-track-element\\\":128,\\\"../tracks/html-track-element-list\\\":127,\\\"../tracks/text-track\\\":134,\\\"../tracks/text-track-list\\\":132,\\\"../tracks/video-track\\\":139,\\\"../tracks/video-track-list\\\":138,\\\"../utils/buffer.js\\\":141,\\\"../utils/fn.js\\\":144,\\\"../utils/log.js\\\":147,\\\"../utils/merge-options.js\\\":148,\\\"../utils/time-ranges.js\\\":150,\\\"global/document\\\":1,\\\"global/window\\\":2}],125:[function(_dereq_,module,exports){\\n/**\\n * @file audio-track-list.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _trackList = _dereq_('./track-list');\\n\\nvar _trackList2 = _interopRequireDefault(_trackList);\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\n/**\\n * anywhere we call this function we diverge from the spec\\n * as we only support one enabled audiotrack at a time\\n *\\n * @param {Array|AudioTrackList} list list to work on\\n * @param {AudioTrack} track the track to skip\\n */\\nvar disableOthers = function disableOthers(list, track) {\\n  for (var i = 0; i < list.length; i++) {\\n    if (track.id === list[i].id) {\\n      continue;\\n    }\\n    // another audio track is enabled, disable it\\n    list[i].enabled = false;\\n  }\\n};\\n/**\\n * A list of possible audio tracks. All functionality is in the\\n * base class Tracklist and the spec for AudioTrackList is located at:\\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist\\n *\\n * interface AudioTrackList : EventTarget {\\n *   readonly attribute unsigned long length;\\n *   getter AudioTrack (unsigned long index);\\n *   AudioTrack? getTrackById(DOMString id);\\n *\\n *   attribute EventHandler onchange;\\n *   attribute EventHandler onaddtrack;\\n *   attribute EventHandler onremovetrack;\\n * };\\n *\\n * @param {AudioTrack[]} tracks a list of audio tracks to instantiate the list with\\n * @extends TrackList\\n * @class AudioTrackList\\n */\\n\\nvar AudioTrackList = (function (_TrackList) {\\n  _inherits(AudioTrackList, _TrackList);\\n\\n  function AudioTrackList() {\\n    var tracks = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\\n\\n    _classCallCheck(this, AudioTrackList);\\n\\n    var list = undefined;\\n\\n    // make sure only 1 track is enabled\\n    // sorted from last index to first index\\n    for (var i = tracks.length - 1; i >= 0; i--) {\\n      if (tracks[i].enabled) {\\n        disableOthers(tracks, tracks[i]);\\n        break;\\n      }\\n    }\\n\\n    // IE8 forces us to implement inheritance ourselves\\n    // as it does not support Object.defineProperty properly\\n    if (browser.IS_IE8) {\\n      list = _globalDocument2['default'].createElement('custom');\\n      for (var prop in _trackList2['default'].prototype) {\\n        if (prop !== 'constructor') {\\n          list[prop] = _trackList2['default'].prototype[prop];\\n        }\\n      }\\n      for (var prop in AudioTrackList.prototype) {\\n        if (prop !== 'constructor') {\\n          list[prop] = AudioTrackList.prototype[prop];\\n        }\\n      }\\n    }\\n\\n    list = _TrackList.call(this, tracks, list);\\n    list.changing_ = false;\\n\\n    return list;\\n  }\\n\\n  AudioTrackList.prototype.addTrack_ = function addTrack_(track) {\\n    var _this = this;\\n\\n    if (track.enabled) {\\n      disableOthers(this, track);\\n    }\\n\\n    _TrackList.prototype.addTrack_.call(this, track);\\n    // native tracks don't have this\\n    if (!track.addEventListener) {\\n      return;\\n    }\\n\\n    track.addEventListener('enabledchange', function () {\\n      // when we are disabling other tracks (since we don't support\\n      // more than one track at a time) we will set changing_\\n      // to true so that we don't trigger additional change events\\n      if (_this.changing_) {\\n        return;\\n      }\\n      _this.changing_ = true;\\n      disableOthers(_this, track);\\n      _this.changing_ = false;\\n      _this.trigger('change');\\n    });\\n  };\\n\\n  AudioTrackList.prototype.addTrack = function addTrack(track) {\\n    this.addTrack_(track);\\n  };\\n\\n  AudioTrackList.prototype.removeTrack = function removeTrack(track) {\\n    _TrackList.prototype.removeTrack_.call(this, track);\\n  };\\n\\n  return AudioTrackList;\\n})(_trackList2['default']);\\n\\nexports['default'] = AudioTrackList;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../utils/browser.js\\\":140,\\\"./track-list\\\":136,\\\"global/document\\\":1}],126:[function(_dereq_,module,exports){\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _trackEnums = _dereq_('./track-enums');\\n\\nvar _track = _dereq_('./track');\\n\\nvar _track2 = _interopRequireDefault(_track);\\n\\nvar _utilsMergeOptions = _dereq_('../utils/merge-options');\\n\\nvar _utilsMergeOptions2 = _interopRequireDefault(_utilsMergeOptions);\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\n/**\\n * A single audio text track as defined in:\\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotrack\\n *\\n * interface AudioTrack {\\n *   readonly attribute DOMString id;\\n *   readonly attribute DOMString kind;\\n *   readonly attribute DOMString label;\\n *   readonly attribute DOMString language;\\n *   attribute boolean enabled;\\n * };\\n *\\n * @param {Object=} options Object of option names and values\\n * @class AudioTrack\\n */\\n\\nvar AudioTrack = (function (_Track) {\\n  _inherits(AudioTrack, _Track);\\n\\n  function AudioTrack() {\\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\\n\\n    _classCallCheck(this, AudioTrack);\\n\\n    var settings = _utilsMergeOptions2['default'](options, {\\n      kind: _trackEnums.AudioTrackKind[options.kind] || ''\\n    });\\n    // on IE8 this will be a document element\\n    // for every other browser this will be a normal object\\n    var track = _Track.call(this, settings);\\n    var enabled = false;\\n\\n    if (browser.IS_IE8) {\\n      for (var prop in AudioTrack.prototype) {\\n        if (prop !== 'constructor') {\\n          track[prop] = AudioTrack.prototype[prop];\\n        }\\n      }\\n    }\\n\\n    Object.defineProperty(track, 'enabled', {\\n      get: function get() {\\n        return enabled;\\n      },\\n      set: function set(newEnabled) {\\n        // an invalid or unchanged value\\n        if (typeof newEnabled !== 'boolean' || newEnabled === enabled) {\\n          return;\\n        }\\n        enabled = newEnabled;\\n        this.trigger('enabledchange');\\n      }\\n    });\\n\\n    // if the user sets this track to selected then\\n    // set selected to that true value otherwise\\n    // we keep it false\\n    if (settings.enabled) {\\n      track.enabled = settings.enabled;\\n    }\\n    track.loaded_ = true;\\n\\n    return track;\\n  }\\n\\n  return AudioTrack;\\n})(_track2['default']);\\n\\nexports['default'] = AudioTrack;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../utils/browser.js\\\":140,\\\"../utils/merge-options\\\":148,\\\"./track\\\":137,\\\"./track-enums\\\":135}],127:[function(_dereq_,module,exports){\\n/**\\n * @file html-track-element-list.js\\n */\\n\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar HtmlTrackElementList = (function () {\\n  function HtmlTrackElementList() {\\n    var trackElements = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\\n\\n    _classCallCheck(this, HtmlTrackElementList);\\n\\n    var list = this;\\n\\n    if (browser.IS_IE8) {\\n      list = _globalDocument2['default'].createElement('custom');\\n\\n      for (var prop in HtmlTrackElementList.prototype) {\\n        if (prop !== 'constructor') {\\n          list[prop] = HtmlTrackElementList.prototype[prop];\\n        }\\n      }\\n    }\\n\\n    list.trackElements_ = [];\\n\\n    Object.defineProperty(list, 'length', {\\n      get: function get() {\\n        return this.trackElements_.length;\\n      }\\n    });\\n\\n    for (var i = 0, _length = trackElements.length; i < _length; i++) {\\n      list.addTrackElement_(trackElements[i]);\\n    }\\n\\n    if (browser.IS_IE8) {\\n      return list;\\n    }\\n  }\\n\\n  HtmlTrackElementList.prototype.addTrackElement_ = function addTrackElement_(trackElement) {\\n    this.trackElements_.push(trackElement);\\n  };\\n\\n  HtmlTrackElementList.prototype.getTrackElementByTrack_ = function getTrackElementByTrack_(track) {\\n    var trackElement_ = undefined;\\n\\n    for (var i = 0, _length2 = this.trackElements_.length; i < _length2; i++) {\\n      if (track === this.trackElements_[i].track) {\\n        trackElement_ = this.trackElements_[i];\\n\\n        break;\\n      }\\n    }\\n\\n    return trackElement_;\\n  };\\n\\n  HtmlTrackElementList.prototype.removeTrackElement_ = function removeTrackElement_(trackElement) {\\n    for (var i = 0, _length3 = this.trackElements_.length; i < _length3; i++) {\\n      if (trackElement === this.trackElements_[i]) {\\n        this.trackElements_.splice(i, 1);\\n\\n        break;\\n      }\\n    }\\n  };\\n\\n  return HtmlTrackElementList;\\n})();\\n\\nexports['default'] = HtmlTrackElementList;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../utils/browser.js\\\":140,\\\"global/document\\\":1}],128:[function(_dereq_,module,exports){\\n/**\\n * @file html-track-element.js\\n */\\n\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _eventTarget = _dereq_('../event-target');\\n\\nvar _eventTarget2 = _interopRequireDefault(_eventTarget);\\n\\nvar _tracksTextTrack = _dereq_('../tracks/text-track');\\n\\nvar _tracksTextTrack2 = _interopRequireDefault(_tracksTextTrack);\\n\\nvar NONE = 0;\\nvar LOADING = 1;\\nvar LOADED = 2;\\nvar ERROR = 3;\\n\\n/**\\n * https://html.spec.whatwg.org/multipage/embedded-content.html#htmltrackelement\\n *\\n * interface HTMLTrackElement : HTMLElement {\\n *   attribute DOMString kind;\\n *   attribute DOMString src;\\n *   attribute DOMString srclang;\\n *   attribute DOMString label;\\n *   attribute boolean default;\\n *\\n *   const unsigned short NONE = 0;\\n *   const unsigned short LOADING = 1;\\n *   const unsigned short LOADED = 2;\\n *   const unsigned short ERROR = 3;\\n *   readonly attribute unsigned short readyState;\\n *\\n *   readonly attribute TextTrack track;\\n * };\\n *\\n * @param {Object} options TextTrack configuration\\n * @class HTMLTrackElement\\n */\\n\\nvar HTMLTrackElement = (function (_EventTarget) {\\n  _inherits(HTMLTrackElement, _EventTarget);\\n\\n  function HTMLTrackElement() {\\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\\n\\n    _classCallCheck(this, HTMLTrackElement);\\n\\n    _EventTarget.call(this);\\n\\n    var readyState = undefined,\\n        trackElement = this;\\n\\n    if (browser.IS_IE8) {\\n      trackElement = _globalDocument2['default'].createElement('custom');\\n\\n      for (var prop in HTMLTrackElement.prototype) {\\n        if (prop !== 'constructor') {\\n          trackElement[prop] = HTMLTrackElement.prototype[prop];\\n        }\\n      }\\n    }\\n\\n    var track = new _tracksTextTrack2['default'](options);\\n\\n    trackElement.kind = track.kind;\\n    trackElement.src = track.src;\\n    trackElement.srclang = track.language;\\n    trackElement.label = track.label;\\n    trackElement['default'] = track['default'];\\n\\n    Object.defineProperty(trackElement, 'readyState', {\\n      get: function get() {\\n        return readyState;\\n      }\\n    });\\n\\n    Object.defineProperty(trackElement, 'track', {\\n      get: function get() {\\n        return track;\\n      }\\n    });\\n\\n    readyState = NONE;\\n\\n    track.addEventListener('loadeddata', function () {\\n      readyState = LOADED;\\n\\n      trackElement.trigger({\\n        type: 'load',\\n        target: trackElement\\n      });\\n    });\\n\\n    if (browser.IS_IE8) {\\n      return trackElement;\\n    }\\n  }\\n\\n  return HTMLTrackElement;\\n})(_eventTarget2['default']);\\n\\nHTMLTrackElement.prototype.allowedEvents_ = {\\n  load: 'load'\\n};\\n\\nHTMLTrackElement.NONE = NONE;\\nHTMLTrackElement.LOADING = LOADING;\\nHTMLTrackElement.LOADED = LOADED;\\nHTMLTrackElement.ERROR = ERROR;\\n\\nexports['default'] = HTMLTrackElement;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../event-target\\\":104,\\\"../tracks/text-track\\\":134,\\\"../utils/browser.js\\\":140,\\\"global/document\\\":1}],129:[function(_dereq_,module,exports){\\n/**\\n * @file text-track-cue-list.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\n/**\\n * A List of text track cues as defined in:\\n * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist\\n *\\n * interface TextTrackCueList {\\n *   readonly attribute unsigned long length;\\n *   getter TextTrackCue (unsigned long index);\\n *   TextTrackCue? getCueById(DOMString id);\\n * };\\n *\\n * @param {Array} cues A list of cues to be initialized with\\n * @class TextTrackCueList\\n */\\n\\nvar TextTrackCueList = (function () {\\n  function TextTrackCueList(cues) {\\n    _classCallCheck(this, TextTrackCueList);\\n\\n    var list = this;\\n\\n    if (browser.IS_IE8) {\\n      list = _globalDocument2['default'].createElement('custom');\\n\\n      for (var prop in TextTrackCueList.prototype) {\\n        if (prop !== 'constructor') {\\n          list[prop] = TextTrackCueList.prototype[prop];\\n        }\\n      }\\n    }\\n\\n    TextTrackCueList.prototype.setCues_.call(list, cues);\\n\\n    Object.defineProperty(list, 'length', {\\n      get: function get() {\\n        return this.length_;\\n      }\\n    });\\n\\n    if (browser.IS_IE8) {\\n      return list;\\n    }\\n  }\\n\\n  /**\\n   * A setter for cues in this list\\n   *\\n   * @param {Array} cues an array of cues\\n   * @method setCues_\\n   * @private\\n   */\\n\\n  TextTrackCueList.prototype.setCues_ = function setCues_(cues) {\\n    var oldLength = this.length || 0;\\n    var i = 0;\\n    var l = cues.length;\\n\\n    this.cues_ = cues;\\n    this.length_ = cues.length;\\n\\n    var defineProp = function defineProp(index) {\\n      if (!('' + index in this)) {\\n        Object.defineProperty(this, '' + index, {\\n          get: function get() {\\n            return this.cues_[index];\\n          }\\n        });\\n      }\\n    };\\n\\n    if (oldLength < l) {\\n      i = oldLength;\\n\\n      for (; i < l; i++) {\\n        defineProp.call(this, i);\\n      }\\n    }\\n  };\\n\\n  /**\\n   * Get a cue that is currently in the Cue list by id\\n   *\\n   * @param {String} id\\n   * @method getCueById\\n   * @return {Object} a single cue\\n   */\\n\\n  TextTrackCueList.prototype.getCueById = function getCueById(id) {\\n    var result = null;\\n\\n    for (var i = 0, l = this.length; i < l; i++) {\\n      var cue = this[i];\\n\\n      if (cue.id === id) {\\n        result = cue;\\n        break;\\n      }\\n    }\\n\\n    return result;\\n  };\\n\\n  return TextTrackCueList;\\n})();\\n\\nexports['default'] = TextTrackCueList;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../utils/browser.js\\\":140,\\\"global/document\\\":1}],130:[function(_dereq_,module,exports){\\n/**\\n * @file text-track-display.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _component = _dereq_('../component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _menuMenuJs = _dereq_('../menu/menu.js');\\n\\nvar _menuMenuJs2 = _interopRequireDefault(_menuMenuJs);\\n\\nvar _menuMenuItemJs = _dereq_('../menu/menu-item.js');\\n\\nvar _menuMenuItemJs2 = _interopRequireDefault(_menuMenuItemJs);\\n\\nvar _menuMenuButtonJs = _dereq_('../menu/menu-button.js');\\n\\nvar _menuMenuButtonJs2 = _interopRequireDefault(_menuMenuButtonJs);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar darkGray = '#222';\\nvar lightGray = '#ccc';\\nvar fontMap = {\\n  monospace: 'monospace',\\n  sansSerif: 'sans-serif',\\n  serif: 'serif',\\n  monospaceSansSerif: '\\\"Andale Mono\\\", \\\"Lucida Console\\\", monospace',\\n  monospaceSerif: '\\\"Courier New\\\", monospace',\\n  proportionalSansSerif: 'sans-serif',\\n  proportionalSerif: 'serif',\\n  casual: '\\\"Comic Sans MS\\\", Impact, fantasy',\\n  script: '\\\"Monotype Corsiva\\\", cursive',\\n  smallcaps: '\\\"Andale Mono\\\", \\\"Lucida Console\\\", monospace, sans-serif'\\n};\\n\\n/**\\n * The component for displaying text track cues\\n *\\n * @param {Object} player  Main Player\\n * @param {Object=} options Object of option names and values\\n * @param {Function=} ready    Ready callback function\\n * @extends Component\\n * @class TextTrackDisplay\\n */\\n\\nvar TextTrackDisplay = (function (_Component) {\\n  _inherits(TextTrackDisplay, _Component);\\n\\n  function TextTrackDisplay(player, options, ready) {\\n    _classCallCheck(this, TextTrackDisplay);\\n\\n    _Component.call(this, player, options, ready);\\n\\n    player.on('loadstart', Fn.bind(this, this.toggleDisplay));\\n    player.on('texttrackchange', Fn.bind(this, this.updateDisplay));\\n\\n    // This used to be called during player init, but was causing an error\\n    // if a track should show by default and the display hadn't loaded yet.\\n    // Should probably be moved to an external track loader when we support\\n    // tracks that don't need a display.\\n    player.ready(Fn.bind(this, function () {\\n      if (player.tech_ && player.tech_['featuresNativeTextTracks']) {\\n        this.hide();\\n        return;\\n      }\\n\\n      player.on('fullscreenchange', Fn.bind(this, this.updateDisplay));\\n\\n      var tracks = this.options_.playerOptions['tracks'] || [];\\n      for (var i = 0; i < tracks.length; i++) {\\n        var track = tracks[i];\\n        this.player_.addRemoteTextTrack(track);\\n      }\\n\\n      var modes = { 'captions': 1, 'subtitles': 1 };\\n      var trackList = this.player_.textTracks();\\n      var firstDesc = undefined;\\n      var firstCaptions = undefined;\\n\\n      if (trackList) {\\n        for (var i = 0; i < trackList.length; i++) {\\n          var track = trackList[i];\\n          if (track['default']) {\\n            if (track.kind === 'descriptions' && !firstDesc) {\\n              firstDesc = track;\\n            } else if (track.kind in modes && !firstCaptions) {\\n              firstCaptions = track;\\n            }\\n          }\\n        }\\n\\n        // We want to show the first default track but captions and subtitles\\n        // take precedence over descriptions.\\n        // So, display the first default captions or subtitles track\\n        // and otherwise the first default descriptions track.\\n        if (firstCaptions) {\\n          firstCaptions.mode = 'showing';\\n        } else if (firstDesc) {\\n          firstDesc.mode = 'showing';\\n        }\\n      }\\n    }));\\n  }\\n\\n  /**\\n  * Add cue HTML to display\\n  *\\n  * @param {Number} color Hex number for color, like #f0e\\n  * @param {Number} opacity Value for opacity,0.0 - 1.0\\n  * @return {RGBAColor} In the form 'rgba(255, 0, 0, 0.3)'\\n  * @method constructColor\\n  */\\n\\n  /**\\n   * Toggle display texttracks\\n   *\\n   * @method toggleDisplay\\n   */\\n\\n  TextTrackDisplay.prototype.toggleDisplay = function toggleDisplay() {\\n    if (this.player_.tech_ && this.player_.tech_['featuresNativeTextTracks']) {\\n      this.hide();\\n    } else {\\n      this.show();\\n    }\\n  };\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  TextTrackDisplay.prototype.createEl = function createEl() {\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-text-track-display'\\n    }, {\\n      'aria-live': 'assertive',\\n      'aria-atomic': 'true'\\n    });\\n  };\\n\\n  /**\\n   * Clear display texttracks\\n   *\\n   * @method clearDisplay\\n   */\\n\\n  TextTrackDisplay.prototype.clearDisplay = function clearDisplay() {\\n    if (typeof _globalWindow2['default']['WebVTT'] === 'function') {\\n      _globalWindow2['default']['WebVTT']['processCues'](_globalWindow2['default'], [], this.el_);\\n    }\\n  };\\n\\n  /**\\n   * Update display texttracks\\n   *\\n   * @method updateDisplay\\n   */\\n\\n  TextTrackDisplay.prototype.updateDisplay = function updateDisplay() {\\n    var tracks = this.player_.textTracks();\\n\\n    this.clearDisplay();\\n\\n    if (!tracks) {\\n      return;\\n    }\\n\\n    // Track display prioritization model: if multiple tracks are 'showing',\\n    //  display the first 'subtitles' or 'captions' track which is 'showing',\\n    //  otherwise display the first 'descriptions' track which is 'showing'\\n\\n    var descriptionsTrack = null;\\n    var captionsSubtitlesTrack = null;\\n\\n    var i = tracks.length;\\n    while (i--) {\\n      var track = tracks[i];\\n      if (track['mode'] === 'showing') {\\n        if (track['kind'] === 'descriptions') {\\n          descriptionsTrack = track;\\n        } else {\\n          captionsSubtitlesTrack = track;\\n        }\\n      }\\n    }\\n\\n    if (captionsSubtitlesTrack) {\\n      this.updateForTrack(captionsSubtitlesTrack);\\n    } else if (descriptionsTrack) {\\n      this.updateForTrack(descriptionsTrack);\\n    }\\n  };\\n\\n  /**\\n   * Add texttrack to texttrack list\\n   *\\n   * @param {TextTrackObject} track Texttrack object to be added to list\\n   * @method updateForTrack\\n   */\\n\\n  TextTrackDisplay.prototype.updateForTrack = function updateForTrack(track) {\\n    if (typeof _globalWindow2['default']['WebVTT'] !== 'function' || !track['activeCues']) {\\n      return;\\n    }\\n\\n    var overrides = this.player_['textTrackSettings'].getValues();\\n\\n    var cues = [];\\n    for (var _i = 0; _i < track['activeCues'].length; _i++) {\\n      cues.push(track['activeCues'][_i]);\\n    }\\n\\n    _globalWindow2['default']['WebVTT']['processCues'](_globalWindow2['default'], cues, this.el_);\\n\\n    var i = cues.length;\\n    while (i--) {\\n      var cue = cues[i];\\n      if (!cue) {\\n        continue;\\n      }\\n\\n      var cueDiv = cue.displayState;\\n      if (overrides.color) {\\n        cueDiv.firstChild.style.color = overrides.color;\\n      }\\n      if (overrides.textOpacity) {\\n        tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));\\n      }\\n      if (overrides.backgroundColor) {\\n        cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;\\n      }\\n      if (overrides.backgroundOpacity) {\\n        tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));\\n      }\\n      if (overrides.windowColor) {\\n        if (overrides.windowOpacity) {\\n          tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));\\n        } else {\\n          cueDiv.style.backgroundColor = overrides.windowColor;\\n        }\\n      }\\n      if (overrides.edgeStyle) {\\n        if (overrides.edgeStyle === 'dropshadow') {\\n          cueDiv.firstChild.style.textShadow = '2px 2px 3px ' + darkGray + ', 2px 2px 4px ' + darkGray + ', 2px 2px 5px ' + darkGray;\\n        } else if (overrides.edgeStyle === 'raised') {\\n          cueDiv.firstChild.style.textShadow = '1px 1px ' + darkGray + ', 2px 2px ' + darkGray + ', 3px 3px ' + darkGray;\\n        } else if (overrides.edgeStyle === 'depressed') {\\n          cueDiv.firstChild.style.textShadow = '1px 1px ' + lightGray + ', 0 1px ' + lightGray + ', -1px -1px ' + darkGray + ', 0 -1px ' + darkGray;\\n        } else if (overrides.edgeStyle === 'uniform') {\\n          cueDiv.firstChild.style.textShadow = '0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray;\\n        }\\n      }\\n      if (overrides.fontPercent && overrides.fontPercent !== 1) {\\n        var fontSize = _globalWindow2['default'].parseFloat(cueDiv.style.fontSize);\\n        cueDiv.style.fontSize = fontSize * overrides.fontPercent + 'px';\\n        cueDiv.style.height = 'auto';\\n        cueDiv.style.top = 'auto';\\n        cueDiv.style.bottom = '2px';\\n      }\\n      if (overrides.fontFamily && overrides.fontFamily !== 'default') {\\n        if (overrides.fontFamily === 'small-caps') {\\n          cueDiv.firstChild.style.fontVariant = 'small-caps';\\n        } else {\\n          cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];\\n        }\\n      }\\n    }\\n  };\\n\\n  return TextTrackDisplay;\\n})(_component2['default']);\\n\\nfunction constructColor(color, opacity) {\\n  return 'rgba(' +\\n  // color looks like \\\"#f0e\\\"\\n  parseInt(color[1] + color[1], 16) + ',' + parseInt(color[2] + color[2], 16) + ',' + parseInt(color[3] + color[3], 16) + ',' + opacity + ')';\\n}\\n\\n/**\\n * Try to update style\\n * Some style changes will throw an error, particularly in IE8. Those should be noops.\\n *\\n * @param {Element} el The element to be styles\\n * @param {CSSProperty} style The CSS property to be styled\\n * @param {CSSStyle} rule The actual style to be applied to the property\\n * @method tryUpdateStyle\\n */\\nfunction tryUpdateStyle(el, style, rule) {\\n  //\\n  try {\\n    el.style[style] = rule;\\n  } catch (e) {}\\n}\\n\\n_component2['default'].registerComponent('TextTrackDisplay', TextTrackDisplay);\\nexports['default'] = TextTrackDisplay;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component\\\":67,\\\"../menu/menu-button.js\\\":109,\\\"../menu/menu-item.js\\\":110,\\\"../menu/menu.js\\\":111,\\\"../utils/fn.js\\\":144,\\\"global/document\\\":1,\\\"global/window\\\":2}],131:[function(_dereq_,module,exports){\\n/**\\n * Utilities for capturing text track state and re-creating tracks\\n * based on a capture.\\n *\\n * @file text-track-list-converter.js\\n */\\n\\n/**\\n * Examine a single text track and return a JSON-compatible javascript\\n * object that represents the text track's state.\\n * @param track {TextTrackObject} the text track to query\\n * @return {Object} a serializable javascript representation of the\\n * @private\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\nvar trackToJson_ = function trackToJson_(track) {\\n  var ret = ['kind', 'label', 'language', 'id', 'inBandMetadataTrackDispatchType', 'mode', 'src'].reduce(function (acc, prop, i) {\\n    if (track[prop]) {\\n      acc[prop] = track[prop];\\n    }\\n\\n    return acc;\\n  }, {\\n    cues: track.cues && Array.prototype.map.call(track.cues, function (cue) {\\n      return {\\n        startTime: cue.startTime,\\n        endTime: cue.endTime,\\n        text: cue.text,\\n        id: cue.id\\n      };\\n    })\\n  });\\n\\n  return ret;\\n};\\n\\n/**\\n * Examine a tech and return a JSON-compatible javascript array that\\n * represents the state of all text tracks currently configured. The\\n * return array is compatible with `jsonToTextTracks`.\\n * @param tech {tech} the tech object to query\\n * @return {Array} a serializable javascript representation of the\\n * @function textTracksToJson\\n */\\nvar textTracksToJson = function textTracksToJson(tech) {\\n\\n  var trackEls = tech.$$('track');\\n\\n  var trackObjs = Array.prototype.map.call(trackEls, function (t) {\\n    return t.track;\\n  });\\n  var tracks = Array.prototype.map.call(trackEls, function (trackEl) {\\n    var json = trackToJson_(trackEl.track);\\n    if (trackEl.src) {\\n      json.src = trackEl.src;\\n    }\\n    return json;\\n  });\\n\\n  return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function (track) {\\n    return trackObjs.indexOf(track) === -1;\\n  }).map(trackToJson_));\\n};\\n\\n/**\\n * Creates a set of remote text tracks on a tech based on an array of\\n * javascript text track representations.\\n * @param json {Array} an array of text track representation objects,\\n * like those that would be produced by `textTracksToJson`\\n * @param tech {tech} the tech to create text tracks on\\n * @function jsonToTextTracks\\n */\\nvar jsonToTextTracks = function jsonToTextTracks(json, tech) {\\n  json.forEach(function (track) {\\n    var addedTrack = tech.addRemoteTextTrack(track).track;\\n    if (!track.src && track.cues) {\\n      track.cues.forEach(function (cue) {\\n        return addedTrack.addCue(cue);\\n      });\\n    }\\n  });\\n\\n  return tech.textTracks();\\n};\\n\\nexports['default'] = { textTracksToJson: textTracksToJson, jsonToTextTracks: jsonToTextTracks, trackToJson_: trackToJson_ };\\nmodule.exports = exports['default'];\\n\\n},{}],132:[function(_dereq_,module,exports){\\n/**\\n * @file text-track-list.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _trackList = _dereq_('./track-list');\\n\\nvar _trackList2 = _interopRequireDefault(_trackList);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\n/**\\n * A list of possible text tracks. All functionality is in the\\n * base class TrackList. The spec for TextTrackList is located at:\\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist\\n *\\n * interface TextTrackList : EventTarget {\\n *   readonly attribute unsigned long length;\\n *   getter TextTrack (unsigned long index);\\n *   TextTrack? getTrackById(DOMString id);\\n *\\n *   attribute EventHandler onchange;\\n *   attribute EventHandler onaddtrack;\\n *   attribute EventHandler onremovetrack;\\n * };\\n *\\n * @param {TextTrack[]} tracks A list of tracks to initialize the list with\\n * @extends TrackList\\n * @class TextTrackList\\n */\\n\\nvar TextTrackList = (function (_TrackList) {\\n  _inherits(TextTrackList, _TrackList);\\n\\n  function TextTrackList() {\\n    var tracks = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\\n\\n    _classCallCheck(this, TextTrackList);\\n\\n    var list = undefined;\\n\\n    // IE8 forces us to implement inheritance ourselves\\n    // as it does not support Object.defineProperty properly\\n    if (browser.IS_IE8) {\\n      list = _globalDocument2['default'].createElement('custom');\\n      for (var prop in _trackList2['default'].prototype) {\\n        if (prop !== 'constructor') {\\n          list[prop] = _trackList2['default'].prototype[prop];\\n        }\\n      }\\n      for (var prop in TextTrackList.prototype) {\\n        if (prop !== 'constructor') {\\n          list[prop] = TextTrackList.prototype[prop];\\n        }\\n      }\\n    }\\n\\n    list = _TrackList.call(this, tracks, list);\\n    return list;\\n  }\\n\\n  TextTrackList.prototype.addTrack_ = function addTrack_(track) {\\n    _TrackList.prototype.addTrack_.call(this, track);\\n    track.addEventListener('modechange', Fn.bind(this, function () {\\n      this.trigger('change');\\n    }));\\n  };\\n\\n  /**\\n   * Remove TextTrack from TextTrackList\\n   * NOTE: Be mindful of what is passed in as it may be a HTMLTrackElement\\n   *\\n   * @param {TextTrack} rtrack\\n   * @method removeTrack_\\n   * @private\\n   */\\n\\n  TextTrackList.prototype.removeTrack_ = function removeTrack_(rtrack) {\\n    var track = undefined;\\n\\n    for (var i = 0, l = this.length; i < l; i++) {\\n      if (this[i] === rtrack) {\\n        track = this[i];\\n        if (track.off) {\\n          track.off();\\n        }\\n\\n        this.tracks_.splice(i, 1);\\n\\n        break;\\n      }\\n    }\\n\\n    if (!track) {\\n      return;\\n    }\\n\\n    this.trigger({\\n      track: track,\\n      type: 'removetrack'\\n    });\\n  };\\n\\n  /**\\n   * Get a TextTrack from TextTrackList by a tracks id\\n   *\\n   * @param {String} id - the id of the track to get\\n   * @method getTrackById\\n   * @return {TextTrack}\\n   * @private\\n   */\\n\\n  TextTrackList.prototype.getTrackById = function getTrackById(id) {\\n    var result = null;\\n\\n    for (var i = 0, l = this.length; i < l; i++) {\\n      var track = this[i];\\n\\n      if (track.id === id) {\\n        result = track;\\n        break;\\n      }\\n    }\\n\\n    return result;\\n  };\\n\\n  return TextTrackList;\\n})(_trackList2['default']);\\n\\nexports['default'] = TextTrackList;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../utils/browser.js\\\":140,\\\"../utils/fn.js\\\":144,\\\"./track-list\\\":136,\\\"global/document\\\":1}],133:[function(_dereq_,module,exports){\\n/**\\n * @file text-track-settings.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _component = _dereq_('../component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _utilsEventsJs = _dereq_('../utils/events.js');\\n\\nvar Events = _interopRequireWildcard(_utilsEventsJs);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsLogJs = _dereq_('../utils/log.js');\\n\\nvar _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);\\n\\nvar _safeJsonParseTuple = _dereq_('safe-json-parse/tuple');\\n\\nvar _safeJsonParseTuple2 = _interopRequireDefault(_safeJsonParseTuple);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\n/**\\n * Manipulate settings of texttracks\\n *\\n * @param {Object} player  Main Player\\n * @param {Object=} options Object of option names and values\\n * @extends Component\\n * @class TextTrackSettings\\n */\\n\\nvar TextTrackSettings = (function (_Component) {\\n  _inherits(TextTrackSettings, _Component);\\n\\n  function TextTrackSettings(player, options) {\\n    _classCallCheck(this, TextTrackSettings);\\n\\n    _Component.call(this, player, options);\\n    this.hide();\\n\\n    // Grab `persistTextTrackSettings` from the player options if not passed in child options\\n    if (options.persistTextTrackSettings === undefined) {\\n      this.options_.persistTextTrackSettings = this.options_.playerOptions.persistTextTrackSettings;\\n    }\\n\\n    Events.on(this.$('.vjs-done-button'), 'click', Fn.bind(this, function () {\\n      this.saveSettings();\\n      this.hide();\\n    }));\\n\\n    Events.on(this.$('.vjs-default-button'), 'click', Fn.bind(this, function () {\\n      this.$('.vjs-fg-color > select').selectedIndex = 0;\\n      this.$('.vjs-bg-color > select').selectedIndex = 0;\\n      this.$('.window-color > select').selectedIndex = 0;\\n      this.$('.vjs-text-opacity > select').selectedIndex = 0;\\n      this.$('.vjs-bg-opacity > select').selectedIndex = 0;\\n      this.$('.vjs-window-opacity > select').selectedIndex = 0;\\n      this.$('.vjs-edge-style select').selectedIndex = 0;\\n      this.$('.vjs-font-family select').selectedIndex = 0;\\n      this.$('.vjs-font-percent select').selectedIndex = 2;\\n      this.updateDisplay();\\n    }));\\n\\n    Events.on(this.$('.vjs-fg-color > select'), 'change', Fn.bind(this, this.updateDisplay));\\n    Events.on(this.$('.vjs-bg-color > select'), 'change', Fn.bind(this, this.updateDisplay));\\n    Events.on(this.$('.window-color > select'), 'change', Fn.bind(this, this.updateDisplay));\\n    Events.on(this.$('.vjs-text-opacity > select'), 'change', Fn.bind(this, this.updateDisplay));\\n    Events.on(this.$('.vjs-bg-opacity > select'), 'change', Fn.bind(this, this.updateDisplay));\\n    Events.on(this.$('.vjs-window-opacity > select'), 'change', Fn.bind(this, this.updateDisplay));\\n    Events.on(this.$('.vjs-font-percent select'), 'change', Fn.bind(this, this.updateDisplay));\\n    Events.on(this.$('.vjs-edge-style select'), 'change', Fn.bind(this, this.updateDisplay));\\n    Events.on(this.$('.vjs-font-family select'), 'change', Fn.bind(this, this.updateDisplay));\\n\\n    if (this.options_.persistTextTrackSettings) {\\n      this.restoreSettings();\\n    }\\n  }\\n\\n  /**\\n   * Create the component's DOM element\\n   *\\n   * @return {Element}\\n   * @method createEl\\n   */\\n\\n  TextTrackSettings.prototype.createEl = function createEl() {\\n    var uniqueId = this.id_;\\n    var dialogLabelId = 'TTsettingsDialogLabel-' + uniqueId;\\n    var dialogDescriptionId = 'TTsettingsDialogDescription-' + uniqueId;\\n\\n    return _Component.prototype.createEl.call(this, 'div', {\\n      className: 'vjs-caption-settings vjs-modal-overlay',\\n      innerHTML: captionOptionsMenuTemplate(uniqueId, dialogLabelId, dialogDescriptionId),\\n      tabIndex: -1\\n    }, {\\n      role: 'dialog',\\n      'aria-labelledby': dialogLabelId,\\n      'aria-describedby': dialogDescriptionId\\n    });\\n  };\\n\\n  /**\\n   * Get texttrack settings\\n   * Settings are\\n   * .vjs-edge-style\\n   * .vjs-font-family\\n   * .vjs-fg-color\\n   * .vjs-text-opacity\\n   * .vjs-bg-color\\n   * .vjs-bg-opacity\\n   * .window-color\\n   * .vjs-window-opacity\\n   *\\n   * @return {Object}\\n   * @method getValues\\n   */\\n\\n  TextTrackSettings.prototype.getValues = function getValues() {\\n    var textEdge = getSelectedOptionValue(this.$('.vjs-edge-style select'));\\n    var fontFamily = getSelectedOptionValue(this.$('.vjs-font-family select'));\\n    var fgColor = getSelectedOptionValue(this.$('.vjs-fg-color > select'));\\n    var textOpacity = getSelectedOptionValue(this.$('.vjs-text-opacity > select'));\\n    var bgColor = getSelectedOptionValue(this.$('.vjs-bg-color > select'));\\n    var bgOpacity = getSelectedOptionValue(this.$('.vjs-bg-opacity > select'));\\n    var windowColor = getSelectedOptionValue(this.$('.window-color > select'));\\n    var windowOpacity = getSelectedOptionValue(this.$('.vjs-window-opacity > select'));\\n    var fontPercent = _globalWindow2['default']['parseFloat'](getSelectedOptionValue(this.$('.vjs-font-percent > select')));\\n\\n    var result = {\\n      'backgroundOpacity': bgOpacity,\\n      'textOpacity': textOpacity,\\n      'windowOpacity': windowOpacity,\\n      'edgeStyle': textEdge,\\n      'fontFamily': fontFamily,\\n      'color': fgColor,\\n      'backgroundColor': bgColor,\\n      'windowColor': windowColor,\\n      'fontPercent': fontPercent\\n    };\\n    for (var _name in result) {\\n      if (result[_name] === '' || result[_name] === 'none' || _name === 'fontPercent' && result[_name] === 1.00) {\\n        delete result[_name];\\n      }\\n    }\\n    return result;\\n  };\\n\\n  /**\\n   * Set texttrack settings\\n   * Settings are\\n   * .vjs-edge-style\\n   * .vjs-font-family\\n   * .vjs-fg-color\\n   * .vjs-text-opacity\\n   * .vjs-bg-color\\n   * .vjs-bg-opacity\\n   * .window-color\\n   * .vjs-window-opacity\\n   *\\n   * @param {Object} values Object with texttrack setting values\\n   * @method setValues\\n   */\\n\\n  TextTrackSettings.prototype.setValues = function setValues(values) {\\n    setSelectedOption(this.$('.vjs-edge-style select'), values.edgeStyle);\\n    setSelectedOption(this.$('.vjs-font-family select'), values.fontFamily);\\n    setSelectedOption(this.$('.vjs-fg-color > select'), values.color);\\n    setSelectedOption(this.$('.vjs-text-opacity > select'), values.textOpacity);\\n    setSelectedOption(this.$('.vjs-bg-color > select'), values.backgroundColor);\\n    setSelectedOption(this.$('.vjs-bg-opacity > select'), values.backgroundOpacity);\\n    setSelectedOption(this.$('.window-color > select'), values.windowColor);\\n    setSelectedOption(this.$('.vjs-window-opacity > select'), values.windowOpacity);\\n\\n    var fontPercent = values.fontPercent;\\n\\n    if (fontPercent) {\\n      fontPercent = fontPercent.toFixed(2);\\n    }\\n\\n    setSelectedOption(this.$('.vjs-font-percent > select'), fontPercent);\\n  };\\n\\n  /**\\n   * Restore texttrack settings\\n   *\\n   * @method restoreSettings\\n   */\\n\\n  TextTrackSettings.prototype.restoreSettings = function restoreSettings() {\\n    var err = undefined,\\n        values = undefined;\\n\\n    try {\\n      var _safeParseTuple = _safeJsonParseTuple2['default'](_globalWindow2['default'].localStorage.getItem('vjs-text-track-settings'));\\n\\n      err = _safeParseTuple[0];\\n      values = _safeParseTuple[1];\\n\\n      if (err) {\\n        _utilsLogJs2['default'].error(err);\\n      }\\n    } catch (e) {\\n      _utilsLogJs2['default'].warn(e);\\n    }\\n\\n    if (values) {\\n      this.setValues(values);\\n    }\\n  };\\n\\n  /**\\n   * Save texttrack settings to local storage\\n   *\\n   * @method saveSettings\\n   */\\n\\n  TextTrackSettings.prototype.saveSettings = function saveSettings() {\\n    if (!this.options_.persistTextTrackSettings) {\\n      return;\\n    }\\n\\n    var values = this.getValues();\\n    try {\\n      if (Object.getOwnPropertyNames(values).length > 0) {\\n        _globalWindow2['default'].localStorage.setItem('vjs-text-track-settings', JSON.stringify(values));\\n      } else {\\n        _globalWindow2['default'].localStorage.removeItem('vjs-text-track-settings');\\n      }\\n    } catch (e) {\\n      _utilsLogJs2['default'].warn(e);\\n    }\\n  };\\n\\n  /**\\n   * Update display of texttrack settings\\n   *\\n   * @method updateDisplay\\n   */\\n\\n  TextTrackSettings.prototype.updateDisplay = function updateDisplay() {\\n    var ttDisplay = this.player_.getChild('textTrackDisplay');\\n    if (ttDisplay) {\\n      ttDisplay.updateDisplay();\\n    }\\n  };\\n\\n  return TextTrackSettings;\\n})(_component2['default']);\\n\\n_component2['default'].registerComponent('TextTrackSettings', TextTrackSettings);\\n\\nfunction getSelectedOptionValue(target) {\\n  var selectedOption = undefined;\\n  // not all browsers support selectedOptions, so, fallback to options\\n  if (target.selectedOptions) {\\n    selectedOption = target.selectedOptions[0];\\n  } else if (target.options) {\\n    selectedOption = target.options[target.options.selectedIndex];\\n  }\\n\\n  return selectedOption.value;\\n}\\n\\nfunction setSelectedOption(target, value) {\\n  if (!value) {\\n    return;\\n  }\\n\\n  var i = undefined;\\n  for (i = 0; i < target.options.length; i++) {\\n    var option = target.options[i];\\n    if (option.value === value) {\\n      break;\\n    }\\n  }\\n\\n  target.selectedIndex = i;\\n}\\n\\nfunction captionOptionsMenuTemplate(uniqueId, dialogLabelId, dialogDescriptionId) {\\n\\n  var template = '\\\\n    <div role=\\\"document\\\">\\\\n      <div role=\\\"heading\\\" aria-level=\\\"1\\\" id=\\\"' + dialogLabelId + '\\\" class=\\\"vjs-control-text\\\">Captions Settings Dialog</div>\\\\n      <div id=\\\"' + dialogDescriptionId + '\\\" class=\\\"vjs-control-text\\\">Beginning of dialog window. Escape will cancel and close the window.</div>\\\\n      <div class=\\\"vjs-tracksettings\\\">\\\\n        <div class=\\\"vjs-tracksettings-colors\\\">\\\\n          <fieldset class=\\\"vjs-fg-color vjs-tracksetting\\\">\\\\n            <legend>Text</legend>\\\\n            <label class=\\\"vjs-label\\\" for=\\\"captions-foreground-color-' + uniqueId + '\\\">Color</label>\\\\n            <select id=\\\"captions-foreground-color-' + uniqueId + '\\\">\\\\n              <option value=\\\"#FFF\\\" selected>White</option>\\\\n              <option value=\\\"#000\\\">Black</option>\\\\n              <option value=\\\"#F00\\\">Red</option>\\\\n              <option value=\\\"#0F0\\\">Green</option>\\\\n              <option value=\\\"#00F\\\">Blue</option>\\\\n              <option value=\\\"#FF0\\\">Yellow</option>\\\\n              <option value=\\\"#F0F\\\">Magenta</option>\\\\n              <option value=\\\"#0FF\\\">Cyan</option>\\\\n            </select>\\\\n            <span class=\\\"vjs-text-opacity vjs-opacity\\\">\\\\n              <label class=\\\"vjs-label\\\" for=\\\"captions-foreground-opacity-' + uniqueId + '\\\">Transparency</label>\\\\n              <select id=\\\"captions-foreground-opacity-' + uniqueId + '\\\">\\\\n                <option value=\\\"1\\\" selected>Opaque</option>\\\\n                <option value=\\\"0.5\\\">Semi-Opaque</option>\\\\n              </select>\\\\n            </span>\\\\n          </fieldset>\\\\n          <fieldset class=\\\"vjs-bg-color vjs-tracksetting\\\">\\\\n            <legend>Background</legend>\\\\n            <label class=\\\"vjs-label\\\" for=\\\"captions-background-color-' + uniqueId + '\\\">Color</label>\\\\n            <select id=\\\"captions-background-color-' + uniqueId + '\\\">\\\\n              <option value=\\\"#000\\\" selected>Black</option>\\\\n              <option value=\\\"#FFF\\\">White</option>\\\\n              <option value=\\\"#F00\\\">Red</option>\\\\n              <option value=\\\"#0F0\\\">Green</option>\\\\n              <option value=\\\"#00F\\\">Blue</option>\\\\n              <option value=\\\"#FF0\\\">Yellow</option>\\\\n              <option value=\\\"#F0F\\\">Magenta</option>\\\\n              <option value=\\\"#0FF\\\">Cyan</option>\\\\n            </select>\\\\n            <span class=\\\"vjs-bg-opacity vjs-opacity\\\">\\\\n              <label class=\\\"vjs-label\\\" for=\\\"captions-background-opacity-' + uniqueId + '\\\">Transparency</label>\\\\n              <select id=\\\"captions-background-opacity-' + uniqueId + '\\\">\\\\n                <option value=\\\"1\\\" selected>Opaque</option>\\\\n                <option value=\\\"0.5\\\">Semi-Transparent</option>\\\\n                <option value=\\\"0\\\">Transparent</option>\\\\n              </select>\\\\n            </span>\\\\n          </fieldset>\\\\n          <fieldset class=\\\"window-color vjs-tracksetting\\\">\\\\n            <legend>Window</legend>\\\\n            <label class=\\\"vjs-label\\\" for=\\\"captions-window-color-' + uniqueId + '\\\">Color</label>\\\\n            <select id=\\\"captions-window-color-' + uniqueId + '\\\">\\\\n              <option value=\\\"#000\\\" selected>Black</option>\\\\n              <option value=\\\"#FFF\\\">White</option>\\\\n              <option value=\\\"#F00\\\">Red</option>\\\\n              <option value=\\\"#0F0\\\">Green</option>\\\\n              <option value=\\\"#00F\\\">Blue</option>\\\\n              <option value=\\\"#FF0\\\">Yellow</option>\\\\n              <option value=\\\"#F0F\\\">Magenta</option>\\\\n              <option value=\\\"#0FF\\\">Cyan</option>\\\\n            </select>\\\\n            <span class=\\\"vjs-window-opacity vjs-opacity\\\">\\\\n              <label class=\\\"vjs-label\\\" for=\\\"captions-window-opacity-' + uniqueId + '\\\">Transparency</label>\\\\n              <select id=\\\"captions-window-opacity-' + uniqueId + '\\\">\\\\n                <option value=\\\"0\\\" selected>Transparent</option>\\\\n                <option value=\\\"0.5\\\">Semi-Transparent</option>\\\\n                <option value=\\\"1\\\">Opaque</option>\\\\n              </select>\\\\n            </span>\\\\n          </fieldset>\\\\n        </div> <!-- vjs-tracksettings-colors -->\\\\n        <div class=\\\"vjs-tracksettings-font\\\">\\\\n          <div class=\\\"vjs-font-percent vjs-tracksetting\\\">\\\\n            <label class=\\\"vjs-label\\\" for=\\\"captions-font-size-' + uniqueId + '\\\">Font Size</label>\\\\n            <select id=\\\"captions-font-size-' + uniqueId + '\\\">\\\\n              <option value=\\\"0.50\\\">50%</option>\\\\n              <option value=\\\"0.75\\\">75%</option>\\\\n              <option value=\\\"1.00\\\" selected>100%</option>\\\\n              <option value=\\\"1.25\\\">125%</option>\\\\n              <option value=\\\"1.50\\\">150%</option>\\\\n              <option value=\\\"1.75\\\">175%</option>\\\\n              <option value=\\\"2.00\\\">200%</option>\\\\n              <option value=\\\"3.00\\\">300%</option>\\\\n              <option value=\\\"4.00\\\">400%</option>\\\\n            </select>\\\\n          </div>\\\\n          <div class=\\\"vjs-edge-style vjs-tracksetting\\\">\\\\n            <label class=\\\"vjs-label\\\" for=\\\"captions-edge-style-' + uniqueId + '\\\">Text Edge Style</label>\\\\n            <select id=\\\"captions-edge-style-' + uniqueId + '\\\">\\\\n              <option value=\\\"none\\\" selected>None</option>\\\\n              <option value=\\\"raised\\\">Raised</option>\\\\n              <option value=\\\"depressed\\\">Depressed</option>\\\\n              <option value=\\\"uniform\\\">Uniform</option>\\\\n              <option value=\\\"dropshadow\\\">Dropshadow</option>\\\\n            </select>\\\\n          </div>\\\\n          <div class=\\\"vjs-font-family vjs-tracksetting\\\">\\\\n            <label class=\\\"vjs-label\\\" for=\\\"captions-font-family-' + uniqueId + '\\\">Font Family</label>\\\\n            <select id=\\\"captions-font-family-' + uniqueId + '\\\">\\\\n              <option value=\\\"proportionalSansSerif\\\" selected>Proportional Sans-Serif</option>\\\\n              <option value=\\\"monospaceSansSerif\\\">Monospace Sans-Serif</option>\\\\n              <option value=\\\"proportionalSerif\\\">Proportional Serif</option>\\\\n              <option value=\\\"monospaceSerif\\\">Monospace Serif</option>\\\\n              <option value=\\\"casual\\\">Casual</option>\\\\n              <option value=\\\"script\\\">Script</option>\\\\n              <option value=\\\"small-caps\\\">Small Caps</option>\\\\n            </select>\\\\n          </div>\\\\n        </div> <!-- vjs-tracksettings-font -->\\\\n        <div class=\\\"vjs-tracksettings-controls\\\">\\\\n          <button class=\\\"vjs-default-button\\\">Defaults</button>\\\\n          <button class=\\\"vjs-done-button\\\">Done</button>\\\\n        </div>\\\\n      </div> <!-- vjs-tracksettings -->\\\\n    </div> <!--  role=\\\"document\\\" -->';\\n\\n  return template;\\n}\\n\\nexports['default'] = TextTrackSettings;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../component\\\":67,\\\"../utils/events.js\\\":143,\\\"../utils/fn.js\\\":144,\\\"../utils/log.js\\\":147,\\\"global/window\\\":2,\\\"safe-json-parse/tuple\\\":54}],134:[function(_dereq_,module,exports){\\n/**\\n * @file text-track.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _textTrackCueList = _dereq_('./text-track-cue-list');\\n\\nvar _textTrackCueList2 = _interopRequireDefault(_textTrackCueList);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _trackEnums = _dereq_('./track-enums');\\n\\nvar _utilsLogJs = _dereq_('../utils/log.js');\\n\\nvar _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _trackJs = _dereq_('./track.js');\\n\\nvar _trackJs2 = _interopRequireDefault(_trackJs);\\n\\nvar _utilsUrlJs = _dereq_('../utils/url.js');\\n\\nvar _xhr = _dereq_('xhr');\\n\\nvar _xhr2 = _interopRequireDefault(_xhr);\\n\\nvar _utilsMergeOptions = _dereq_('../utils/merge-options');\\n\\nvar _utilsMergeOptions2 = _interopRequireDefault(_utilsMergeOptions);\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\n/**\\n * takes a webvtt file contents and parses it into cues\\n *\\n * @param {String} srcContent webVTT file contents\\n * @param {Track} track track to addcues to\\n */\\nvar parseCues = function parseCues(srcContent, track) {\\n  var parser = new _globalWindow2['default'].WebVTT.Parser(_globalWindow2['default'], _globalWindow2['default'].vttjs, _globalWindow2['default'].WebVTT.StringDecoder());\\n  var errors = [];\\n\\n  parser.oncue = function (cue) {\\n    track.addCue(cue);\\n  };\\n\\n  parser.onparsingerror = function (error) {\\n    errors.push(error);\\n  };\\n\\n  parser.onflush = function () {\\n    track.trigger({\\n      type: 'loadeddata',\\n      target: track\\n    });\\n  };\\n\\n  parser.parse(srcContent);\\n  if (errors.length > 0) {\\n    if (console.groupCollapsed) {\\n      console.groupCollapsed('Text Track parsing errors for ' + track.src);\\n    }\\n    errors.forEach(function (error) {\\n      return _utilsLogJs2['default'].error(error);\\n    });\\n    if (console.groupEnd) {\\n      console.groupEnd();\\n    }\\n  }\\n\\n  parser.flush();\\n};\\n\\n/**\\n * load a track from a  specifed url\\n *\\n * @param {String} src url to load track from\\n * @param {Track} track track to addcues to\\n */\\nvar loadTrack = function loadTrack(src, track) {\\n  var opts = {\\n    uri: src\\n  };\\n  var crossOrigin = _utilsUrlJs.isCrossOrigin(src);\\n\\n  if (crossOrigin) {\\n    opts.cors = crossOrigin;\\n  }\\n\\n  _xhr2['default'](opts, Fn.bind(this, function (err, response, responseBody) {\\n    if (err) {\\n      return _utilsLogJs2['default'].error(err, response);\\n    }\\n\\n    track.loaded_ = true;\\n\\n    // Make sure that vttjs has loaded, otherwise, wait till it finished loading\\n    // NOTE: this is only used for the alt/video.novtt.js build\\n    if (typeof _globalWindow2['default'].WebVTT !== 'function') {\\n      if (track.tech_) {\\n        (function () {\\n          var loadHandler = function loadHandler() {\\n            return parseCues(responseBody, track);\\n          };\\n          track.tech_.on('vttjsloaded', loadHandler);\\n          track.tech_.on('vttjserror', function () {\\n            _utilsLogJs2['default'].error('vttjs failed to load, stopping trying to process ' + track.src);\\n            track.tech_.off('vttjsloaded', loadHandler);\\n          });\\n        })();\\n      }\\n    } else {\\n      parseCues(responseBody, track);\\n    }\\n  }));\\n};\\n\\n/**\\n * A single text track as defined in:\\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack\\n *\\n * interface TextTrack : EventTarget {\\n *   readonly attribute TextTrackKind kind;\\n *   readonly attribute DOMString label;\\n *   readonly attribute DOMString language;\\n *\\n *   readonly attribute DOMString id;\\n *   readonly attribute DOMString inBandMetadataTrackDispatchType;\\n *\\n *   attribute TextTrackMode mode;\\n *\\n *   readonly attribute TextTrackCueList? cues;\\n *   readonly attribute TextTrackCueList? activeCues;\\n *\\n *   void addCue(TextTrackCue cue);\\n *   void removeCue(TextTrackCue cue);\\n *\\n *   attribute EventHandler oncuechange;\\n * };\\n *\\n * @param {Object=} options Object of option names and values\\n * @extends Track\\n * @class TextTrack\\n */\\n\\nvar TextTrack = (function (_Track) {\\n  _inherits(TextTrack, _Track);\\n\\n  function TextTrack() {\\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\\n\\n    _classCallCheck(this, TextTrack);\\n\\n    if (!options.tech) {\\n      throw new Error('A tech was not provided.');\\n    }\\n\\n    var settings = _utilsMergeOptions2['default'](options, {\\n      kind: _trackEnums.TextTrackKind[options.kind] || 'subtitles',\\n      language: options.language || options.srclang || ''\\n    });\\n    var mode = _trackEnums.TextTrackMode[settings.mode] || 'disabled';\\n    var default_ = settings['default'];\\n\\n    if (settings.kind === 'metadata' || settings.kind === 'chapters') {\\n      mode = 'hidden';\\n    }\\n    // on IE8 this will be a document element\\n    // for every other browser this will be a normal object\\n    var tt = _Track.call(this, settings);\\n    tt.tech_ = settings.tech;\\n\\n    if (browser.IS_IE8) {\\n      for (var prop in TextTrack.prototype) {\\n        if (prop !== 'constructor') {\\n          tt[prop] = TextTrack.prototype[prop];\\n        }\\n      }\\n    }\\n\\n    tt.cues_ = [];\\n    tt.activeCues_ = [];\\n\\n    var cues = new _textTrackCueList2['default'](tt.cues_);\\n    var activeCues = new _textTrackCueList2['default'](tt.activeCues_);\\n    var changed = false;\\n    var timeupdateHandler = Fn.bind(tt, function () {\\n      this.activeCues;\\n      if (changed) {\\n        this.trigger('cuechange');\\n        changed = false;\\n      }\\n    });\\n\\n    if (mode !== 'disabled') {\\n      tt.tech_.on('timeupdate', timeupdateHandler);\\n    }\\n\\n    Object.defineProperty(tt, 'default', {\\n      get: function get() {\\n        return default_;\\n      },\\n      set: function set() {}\\n    });\\n\\n    Object.defineProperty(tt, 'mode', {\\n      get: function get() {\\n        return mode;\\n      },\\n      set: function set(newMode) {\\n        if (!_trackEnums.TextTrackMode[newMode]) {\\n          return;\\n        }\\n        mode = newMode;\\n        if (mode === 'showing') {\\n          this.tech_.on('timeupdate', timeupdateHandler);\\n        }\\n        this.trigger('modechange');\\n      }\\n    });\\n\\n    Object.defineProperty(tt, 'cues', {\\n      get: function get() {\\n        if (!this.loaded_) {\\n          return null;\\n        }\\n\\n        return cues;\\n      },\\n      set: function set() {}\\n    });\\n\\n    Object.defineProperty(tt, 'activeCues', {\\n      get: function get() {\\n        if (!this.loaded_) {\\n          return null;\\n        }\\n\\n        // nothing to do\\n        if (this.cues.length === 0) {\\n          return activeCues;\\n        }\\n\\n        var ct = this.tech_.currentTime();\\n        var active = [];\\n\\n        for (var i = 0, l = this.cues.length; i < l; i++) {\\n          var cue = this.cues[i];\\n\\n          if (cue.startTime <= ct && cue.endTime >= ct) {\\n            active.push(cue);\\n          } else if (cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct) {\\n            active.push(cue);\\n          }\\n        }\\n\\n        changed = false;\\n\\n        if (active.length !== this.activeCues_.length) {\\n          changed = true;\\n        } else {\\n          for (var i = 0; i < active.length; i++) {\\n            if (this.activeCues_.indexOf(active[i]) === -1) {\\n              changed = true;\\n            }\\n          }\\n        }\\n\\n        this.activeCues_ = active;\\n        activeCues.setCues_(this.activeCues_);\\n\\n        return activeCues;\\n      },\\n      set: function set() {}\\n    });\\n\\n    if (settings.src) {\\n      tt.src = settings.src;\\n      loadTrack(settings.src, tt);\\n    } else {\\n      tt.loaded_ = true;\\n    }\\n\\n    return tt;\\n  }\\n\\n  /**\\n   * cuechange - One or more cues in the track have become active or stopped being active.\\n   */\\n\\n  /**\\n   * add a cue to the internal list of cues\\n   *\\n   * @param {Object} cue the cue to add to our internal list\\n   * @method addCue\\n   */\\n\\n  TextTrack.prototype.addCue = function addCue(cue) {\\n    var tracks = this.tech_.textTracks();\\n\\n    if (tracks) {\\n      for (var i = 0; i < tracks.length; i++) {\\n        if (tracks[i] !== this) {\\n          tracks[i].removeCue(cue);\\n        }\\n      }\\n    }\\n\\n    this.cues_.push(cue);\\n    this.cues.setCues_(this.cues_);\\n  };\\n\\n  /**\\n   * remvoe a cue from our internal list\\n   *\\n   * @param {Object} removeCue the cue to remove from our internal list\\n   * @method removeCue\\n   */\\n\\n  TextTrack.prototype.removeCue = function removeCue(_removeCue) {\\n    var removed = false;\\n\\n    for (var i = 0, l = this.cues_.length; i < l; i++) {\\n      var cue = this.cues_[i];\\n\\n      if (cue === _removeCue) {\\n        this.cues_.splice(i, 1);\\n        removed = true;\\n      }\\n    }\\n\\n    if (removed) {\\n      this.cues.setCues_(this.cues_);\\n    }\\n  };\\n\\n  return TextTrack;\\n})(_trackJs2['default']);\\n\\nTextTrack.prototype.allowedEvents_ = {\\n  cuechange: 'cuechange'\\n};\\n\\nexports['default'] = TextTrack;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../utils/browser.js\\\":140,\\\"../utils/fn.js\\\":144,\\\"../utils/log.js\\\":147,\\\"../utils/merge-options\\\":148,\\\"../utils/url.js\\\":152,\\\"./text-track-cue-list\\\":129,\\\"./track-enums\\\":135,\\\"./track.js\\\":137,\\\"global/document\\\":1,\\\"global/window\\\":2,\\\"xhr\\\":56}],135:[function(_dereq_,module,exports){\\n/**\\n * @file track-kinds.js\\n */\\n\\n/**\\n * https://html.spec.whatwg.org/multipage/embedded-content.html#dom-videotrack-kind\\n *\\n * enum VideoTrackKind {\\n *   \\\"alternative\\\",\\n *   \\\"captions\\\",\\n *   \\\"main\\\",\\n *   \\\"sign\\\",\\n *   \\\"subtitles\\\",\\n *   \\\"commentary\\\",\\n *   \\\"\\\",\\n * };\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\nvar VideoTrackKind = {\\n  alternative: 'alternative',\\n  captions: 'captions',\\n  main: 'main',\\n  sign: 'sign',\\n  subtitles: 'subtitles',\\n  commentary: 'commentary'\\n};\\n\\n/**\\n * https://html.spec.whatwg.org/multipage/embedded-content.html#dom-audiotrack-kind\\n *\\n * enum AudioTrackKind {\\n *   \\\"alternative\\\",\\n *   \\\"descriptions\\\",\\n *   \\\"main\\\",\\n *   \\\"main-desc\\\",\\n *   \\\"translation\\\",\\n *   \\\"commentary\\\",\\n *   \\\"\\\",\\n * };\\n */\\nvar AudioTrackKind = {\\n  alternative: 'alternative',\\n  descriptions: 'descriptions',\\n  main: 'main',\\n  'main-desc': 'main-desc',\\n  translation: 'translation',\\n  commentary: 'commentary'\\n};\\n\\n/**\\n * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackkind\\n *\\n * enum TextTrackKind {\\n *   \\\"subtitles\\\",\\n *   \\\"captions\\\",\\n *   \\\"descriptions\\\",\\n *   \\\"chapters\\\",\\n *   \\\"metadata\\\"\\n * };\\n */\\nvar TextTrackKind = {\\n  subtitles: 'subtitles',\\n  captions: 'captions',\\n  descriptions: 'descriptions',\\n  chapters: 'chapters',\\n  metadata: 'metadata'\\n};\\n\\n/**\\n * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode\\n *\\n * enum TextTrackMode { \\\"disabled\\\",  \\\"hidden\\\",  \\\"showing\\\" };\\n */\\nvar TextTrackMode = {\\n  disabled: 'disabled',\\n  hidden: 'hidden',\\n  showing: 'showing'\\n};\\n\\n/* jshint ignore:start */\\n// we ignore jshint here because it does not see\\n// AudioTrackKind as defined here\\nexports['default'] = { VideoTrackKind: VideoTrackKind, AudioTrackKind: AudioTrackKind, TextTrackKind: TextTrackKind, TextTrackMode: TextTrackMode };\\n\\n/* jshint ignore:end */\\nmodule.exports = exports['default'];\\n\\n},{}],136:[function(_dereq_,module,exports){\\n/**\\n * @file track-list.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _eventTarget = _dereq_('../event-target');\\n\\nvar _eventTarget2 = _interopRequireDefault(_eventTarget);\\n\\nvar _utilsFnJs = _dereq_('../utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\n/**\\n * Common functionaliy between Text, Audio, and Video TrackLists\\n * Interfaces defined in the following spec:\\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html\\n *\\n * @param {Track[]} tracks A list of tracks to initialize the list with\\n * @param {Object} list the child object with inheritance done manually for ie8\\n * @extends EventTarget\\n * @class TrackList\\n */\\n\\nvar TrackList = (function (_EventTarget) {\\n  _inherits(TrackList, _EventTarget);\\n\\n  function TrackList() {\\n    var tracks = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\\n    var list = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\\n\\n    _classCallCheck(this, TrackList);\\n\\n    _EventTarget.call(this);\\n    if (!list) {\\n      list = this;\\n      if (browser.IS_IE8) {\\n        list = _globalDocument2['default'].createElement('custom');\\n        for (var prop in TrackList.prototype) {\\n          if (prop !== 'constructor') {\\n            list[prop] = TrackList.prototype[prop];\\n          }\\n        }\\n      }\\n    }\\n\\n    list.tracks_ = [];\\n    Object.defineProperty(list, 'length', {\\n      get: function get() {\\n        return this.tracks_.length;\\n      }\\n    });\\n\\n    for (var i = 0; i < tracks.length; i++) {\\n      list.addTrack_(tracks[i]);\\n    }\\n\\n    return list;\\n  }\\n\\n  /**\\n   * change - One or more tracks in the track list have been enabled or disabled.\\n   * addtrack - A track has been added to the track list.\\n   * removetrack - A track has been removed from the track list.\\n   */\\n\\n  /**\\n   * Add a Track from TrackList\\n   *\\n   * @param {Mixed} track\\n   * @method addTrack_\\n   * @private\\n   */\\n\\n  TrackList.prototype.addTrack_ = function addTrack_(track) {\\n    var index = this.tracks_.length;\\n\\n    if (!('' + index in this)) {\\n      Object.defineProperty(this, index, {\\n        get: function get() {\\n          return this.tracks_[index];\\n        }\\n      });\\n    }\\n\\n    // Do not add duplicate tracks\\n    if (this.tracks_.indexOf(track) === -1) {\\n      this.tracks_.push(track);\\n      this.trigger({\\n        track: track,\\n        type: 'addtrack'\\n      });\\n    }\\n  };\\n\\n  /**\\n   * Remove a Track from TrackList\\n   *\\n   * @param {Track} rtrack track to be removed\\n   * @method removeTrack_\\n   * @private\\n   */\\n\\n  TrackList.prototype.removeTrack_ = function removeTrack_(rtrack) {\\n    var track = undefined;\\n\\n    for (var i = 0, l = this.length; i < l; i++) {\\n      if (this[i] === rtrack) {\\n        track = this[i];\\n        if (track.off) {\\n          track.off();\\n        }\\n\\n        this.tracks_.splice(i, 1);\\n\\n        break;\\n      }\\n    }\\n\\n    if (!track) {\\n      return;\\n    }\\n\\n    this.trigger({\\n      track: track,\\n      type: 'removetrack'\\n    });\\n  };\\n\\n  /**\\n   * Get a Track from the TrackList by a tracks id\\n   *\\n   * @param {String} id - the id of the track to get\\n   * @method getTrackById\\n   * @return {Track}\\n   * @private\\n   */\\n\\n  TrackList.prototype.getTrackById = function getTrackById(id) {\\n    var result = null;\\n\\n    for (var i = 0, l = this.length; i < l; i++) {\\n      var track = this[i];\\n      if (track.id === id) {\\n        result = track;\\n        break;\\n      }\\n    }\\n\\n    return result;\\n  };\\n\\n  return TrackList;\\n})(_eventTarget2['default']);\\n\\nTrackList.prototype.allowedEvents_ = {\\n  change: 'change',\\n  addtrack: 'addtrack',\\n  removetrack: 'removetrack'\\n};\\n\\n// emulate attribute EventHandler support to allow for feature detection\\nfor (var _event in TrackList.prototype.allowedEvents_) {\\n  TrackList.prototype['on' + _event] = null;\\n}\\n\\nexports['default'] = TrackList;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../event-target\\\":104,\\\"../utils/browser.js\\\":140,\\\"../utils/fn.js\\\":144,\\\"global/document\\\":1}],137:[function(_dereq_,module,exports){\\n/**\\n * @file track.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _utilsGuidJs = _dereq_('../utils/guid.js');\\n\\nvar Guid = _interopRequireWildcard(_utilsGuidJs);\\n\\nvar _eventTarget = _dereq_('../event-target');\\n\\nvar _eventTarget2 = _interopRequireDefault(_eventTarget);\\n\\n/**\\n * setup the common parts of an audio, video, or text track\\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html\\n *\\n * @param {String} type The type of track we are dealing with audio|video|text\\n * @param {Object=} options Object of option names and values\\n * @extends EventTarget\\n * @class Track\\n */\\n\\nvar Track = (function (_EventTarget) {\\n  _inherits(Track, _EventTarget);\\n\\n  function Track() {\\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\\n\\n    _classCallCheck(this, Track);\\n\\n    _EventTarget.call(this);\\n\\n    var track = this;\\n    if (browser.IS_IE8) {\\n      track = _globalDocument2['default'].createElement('custom');\\n      for (var prop in Track.prototype) {\\n        if (prop !== 'constructor') {\\n          track[prop] = Track.prototype[prop];\\n        }\\n      }\\n    }\\n\\n    var trackProps = {\\n      id: options.id || 'vjs_track_' + Guid.newGUID(),\\n      kind: options.kind || '',\\n      label: options.label || '',\\n      language: options.language || ''\\n    };\\n\\n    var _loop = function (key) {\\n      Object.defineProperty(track, key, {\\n        get: function get() {\\n          return trackProps[key];\\n        },\\n        set: function set() {}\\n      });\\n    };\\n\\n    for (var key in trackProps) {\\n      _loop(key);\\n    }\\n\\n    return track;\\n  }\\n\\n  return Track;\\n})(_eventTarget2['default']);\\n\\nexports['default'] = Track;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../event-target\\\":104,\\\"../utils/browser.js\\\":140,\\\"../utils/guid.js\\\":146,\\\"global/document\\\":1}],138:[function(_dereq_,module,exports){\\n/**\\n * @file video-track-list.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _trackList = _dereq_('./track-list');\\n\\nvar _trackList2 = _interopRequireDefault(_trackList);\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\n/**\\n * disable other video tracks before selecting the new one\\n *\\n * @param {Array|VideoTrackList} list list to work on\\n * @param {VideoTrack} track the track to skip\\n */\\nvar disableOthers = function disableOthers(list, track) {\\n  for (var i = 0; i < list.length; i++) {\\n    if (track.id === list[i].id) {\\n      continue;\\n    }\\n    // another audio track is enabled, disable it\\n    list[i].selected = false;\\n  }\\n};\\n\\n/**\\n* A list of possiblee video tracks. Most functionality is in the\\n * base class Tracklist and the spec for VideoTrackList is located at:\\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist\\n *\\n * interface VideoTrackList : EventTarget {\\n *   readonly attribute unsigned long length;\\n *   getter VideoTrack (unsigned long index);\\n *   VideoTrack? getTrackById(DOMString id);\\n *   readonly attribute long selectedIndex;\\n *\\n *   attribute EventHandler onchange;\\n *   attribute EventHandler onaddtrack;\\n *   attribute EventHandler onremovetrack;\\n * };\\n *\\n * @param {VideoTrack[]} tracks a list of video tracks to instantiate the list with\\n # @extends TrackList\\n * @class VideoTrackList\\n */\\n\\nvar VideoTrackList = (function (_TrackList) {\\n  _inherits(VideoTrackList, _TrackList);\\n\\n  function VideoTrackList() {\\n    var tracks = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\\n\\n    _classCallCheck(this, VideoTrackList);\\n\\n    var list = undefined;\\n\\n    // make sure only 1 track is enabled\\n    // sorted from last index to first index\\n    for (var i = tracks.length - 1; i >= 0; i--) {\\n      if (tracks[i].selected) {\\n        disableOthers(tracks, tracks[i]);\\n        break;\\n      }\\n    }\\n\\n    // IE8 forces us to implement inheritance ourselves\\n    // as it does not support Object.defineProperty properly\\n    if (browser.IS_IE8) {\\n      list = _globalDocument2['default'].createElement('custom');\\n      for (var prop in _trackList2['default'].prototype) {\\n        if (prop !== 'constructor') {\\n          list[prop] = _trackList2['default'].prototype[prop];\\n        }\\n      }\\n      for (var prop in VideoTrackList.prototype) {\\n        if (prop !== 'constructor') {\\n          list[prop] = VideoTrackList.prototype[prop];\\n        }\\n      }\\n    }\\n\\n    list = _TrackList.call(this, tracks, list);\\n    list.changing_ = false;\\n\\n    Object.defineProperty(list, 'selectedIndex', {\\n      get: function get() {\\n        for (var i = 0; i < this.length; i++) {\\n          if (this[i].selected) {\\n            return i;\\n          }\\n        }\\n        return -1;\\n      },\\n      set: function set() {}\\n    });\\n\\n    return list;\\n  }\\n\\n  VideoTrackList.prototype.addTrack_ = function addTrack_(track) {\\n    var _this = this;\\n\\n    if (track.selected) {\\n      disableOthers(this, track);\\n    }\\n\\n    _TrackList.prototype.addTrack_.call(this, track);\\n    // native tracks don't have this\\n    if (!track.addEventListener) {\\n      return;\\n    }\\n    track.addEventListener('selectedchange', function () {\\n      if (_this.changing_) {\\n        return;\\n      }\\n      _this.changing_ = true;\\n      disableOthers(_this, track);\\n      _this.changing_ = false;\\n      _this.trigger('change');\\n    });\\n  };\\n\\n  VideoTrackList.prototype.addTrack = function addTrack(track) {\\n    this.addTrack_(track);\\n  };\\n\\n  VideoTrackList.prototype.removeTrack = function removeTrack(track) {\\n    _TrackList.prototype.removeTrack_.call(this, track);\\n  };\\n\\n  return VideoTrackList;\\n})(_trackList2['default']);\\n\\nexports['default'] = VideoTrackList;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../utils/browser.js\\\":140,\\\"./track-list\\\":136,\\\"global/document\\\":1}],139:[function(_dereq_,module,exports){\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _trackEnums = _dereq_('./track-enums');\\n\\nvar _track = _dereq_('./track');\\n\\nvar _track2 = _interopRequireDefault(_track);\\n\\nvar _utilsMergeOptions = _dereq_('../utils/merge-options');\\n\\nvar _utilsMergeOptions2 = _interopRequireDefault(_utilsMergeOptions);\\n\\nvar _utilsBrowserJs = _dereq_('../utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\n/**\\n * A single video text track as defined in:\\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotrack\\n *\\n * interface VideoTrack {\\n *   readonly attribute DOMString id;\\n *   readonly attribute DOMString kind;\\n *   readonly attribute DOMString label;\\n *   readonly attribute DOMString language;\\n *   attribute boolean selected;\\n * };\\n *\\n * @param {Object=} options Object of option names and values\\n * @class VideoTrack\\n */\\n\\nvar VideoTrack = (function (_Track) {\\n  _inherits(VideoTrack, _Track);\\n\\n  function VideoTrack() {\\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\\n\\n    _classCallCheck(this, VideoTrack);\\n\\n    var settings = _utilsMergeOptions2['default'](options, {\\n      kind: _trackEnums.VideoTrackKind[options.kind] || ''\\n    });\\n\\n    // on IE8 this will be a document element\\n    // for every other browser this will be a normal object\\n    var track = _Track.call(this, settings);\\n    var selected = false;\\n\\n    if (browser.IS_IE8) {\\n      for (var prop in VideoTrack.prototype) {\\n        if (prop !== 'constructor') {\\n          track[prop] = VideoTrack.prototype[prop];\\n        }\\n      }\\n    }\\n\\n    Object.defineProperty(track, 'selected', {\\n      get: function get() {\\n        return selected;\\n      },\\n      set: function set(newSelected) {\\n        // an invalid or unchanged value\\n        if (typeof newSelected !== 'boolean' || newSelected === selected) {\\n          return;\\n        }\\n        selected = newSelected;\\n        this.trigger('selectedchange');\\n      }\\n    });\\n\\n    // if the user sets this track to selected then\\n    // set selected to that true value otherwise\\n    // we keep it false\\n    if (settings.selected) {\\n      track.selected = settings.selected;\\n    }\\n\\n    return track;\\n  }\\n\\n  return VideoTrack;\\n})(_track2['default']);\\n\\nexports['default'] = VideoTrack;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../utils/browser.js\\\":140,\\\"../utils/merge-options\\\":148,\\\"./track\\\":137,\\\"./track-enums\\\":135}],140:[function(_dereq_,module,exports){\\n/**\\n * @file browser.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar USER_AGENT = _globalWindow2['default'].navigator.userAgent;\\nvar webkitVersionMap = /AppleWebKit\\\\/([\\\\d.]+)/i.exec(USER_AGENT);\\nvar appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null;\\n\\n/*\\n * Device is an iPhone\\n *\\n * @type {Boolean}\\n * @constant\\n * @private\\n */\\nvar IS_IPAD = /iPad/i.test(USER_AGENT);\\n\\nexports.IS_IPAD = IS_IPAD;\\n// The Facebook app's UIWebView identifies as both an iPhone and iPad, so\\n// to identify iPhones, we need to exclude iPads.\\n// http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/\\nvar IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;\\nexports.IS_IPHONE = IS_IPHONE;\\nvar IS_IPOD = /iPod/i.test(USER_AGENT);\\nexports.IS_IPOD = IS_IPOD;\\nvar IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;\\n\\nexports.IS_IOS = IS_IOS;\\nvar IOS_VERSION = (function () {\\n  var match = USER_AGENT.match(/OS (\\\\d+)_/i);\\n  if (match && match[1]) {\\n    return match[1];\\n  }\\n})();\\n\\nexports.IOS_VERSION = IOS_VERSION;\\nvar IS_ANDROID = /Android/i.test(USER_AGENT);\\nexports.IS_ANDROID = IS_ANDROID;\\nvar ANDROID_VERSION = (function () {\\n  // This matches Android Major.Minor.Patch versions\\n  // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned\\n  var match = USER_AGENT.match(/Android (\\\\d+)(?:\\\\.(\\\\d+))?(?:\\\\.(\\\\d+))*/i),\\n      major,\\n      minor;\\n\\n  if (!match) {\\n    return null;\\n  }\\n\\n  major = match[1] && parseFloat(match[1]);\\n  minor = match[2] && parseFloat(match[2]);\\n\\n  if (major && minor) {\\n    return parseFloat(match[1] + '.' + match[2]);\\n  } else if (major) {\\n    return major;\\n  } else {\\n    return null;\\n  }\\n})();\\nexports.ANDROID_VERSION = ANDROID_VERSION;\\n// Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser\\nvar IS_OLD_ANDROID = IS_ANDROID && /webkit/i.test(USER_AGENT) && ANDROID_VERSION < 2.3;\\nexports.IS_OLD_ANDROID = IS_OLD_ANDROID;\\nvar IS_NATIVE_ANDROID = IS_ANDROID && ANDROID_VERSION < 5 && appleWebkitVersion < 537;\\n\\nexports.IS_NATIVE_ANDROID = IS_NATIVE_ANDROID;\\nvar IS_FIREFOX = /Firefox/i.test(USER_AGENT);\\nexports.IS_FIREFOX = IS_FIREFOX;\\nvar IS_EDGE = /Edge/i.test(USER_AGENT);\\nexports.IS_EDGE = IS_EDGE;\\nvar IS_CHROME = !IS_EDGE && /Chrome/i.test(USER_AGENT);\\nexports.IS_CHROME = IS_CHROME;\\nvar IS_IE8 = /MSIE\\\\s8\\\\.0/.test(USER_AGENT);\\nexports.IS_IE8 = IS_IE8;\\nvar IE_VERSION = (function (result) {\\n  return result && parseFloat(result[1]);\\n})(/MSIE\\\\s(\\\\d+)\\\\.\\\\d/.exec(USER_AGENT));\\n\\nexports.IE_VERSION = IE_VERSION;\\nvar TOUCH_ENABLED = !!('ontouchstart' in _globalWindow2['default'] || _globalWindow2['default'].DocumentTouch && _globalDocument2['default'] instanceof _globalWindow2['default'].DocumentTouch);\\nexports.TOUCH_ENABLED = TOUCH_ENABLED;\\nvar BACKGROUND_SIZE_SUPPORTED = ('backgroundSize' in _globalDocument2['default'].createElement('video').style);\\nexports.BACKGROUND_SIZE_SUPPORTED = BACKGROUND_SIZE_SUPPORTED;\\n\\n},{\\\"global/document\\\":1,\\\"global/window\\\":2}],141:[function(_dereq_,module,exports){\\n/**\\n * @file buffer.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\nexports.bufferedPercent = bufferedPercent;\\n\\nvar _timeRangesJs = _dereq_('./time-ranges.js');\\n\\n/**\\n * Compute how much your video has been buffered\\n *\\n * @param  {Object} Buffered object\\n * @param  {Number} Total duration\\n * @return {Number} Percent buffered of the total duration\\n * @private\\n * @function bufferedPercent\\n */\\n\\nfunction bufferedPercent(buffered, duration) {\\n  var bufferedDuration = 0,\\n      start,\\n      end;\\n\\n  if (!duration) {\\n    return 0;\\n  }\\n\\n  if (!buffered || !buffered.length) {\\n    buffered = _timeRangesJs.createTimeRange(0, 0);\\n  }\\n\\n  for (var i = 0; i < buffered.length; i++) {\\n    start = buffered.start(i);\\n    end = buffered.end(i);\\n\\n    // buffered end can be bigger than duration by a very small fraction\\n    if (end > duration) {\\n      end = duration;\\n    }\\n\\n    bufferedDuration += end - start;\\n  }\\n\\n  return bufferedDuration / duration;\\n}\\n\\n},{\\\"./time-ranges.js\\\":150}],142:[function(_dereq_,module,exports){\\n/**\\n * @file dom.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\nexports.getEl = getEl;\\nexports.createEl = createEl;\\nexports.textContent = textContent;\\nexports.insertElFirst = insertElFirst;\\nexports.getElData = getElData;\\nexports.hasElData = hasElData;\\nexports.removeElData = removeElData;\\nexports.hasElClass = hasElClass;\\nexports.addElClass = addElClass;\\nexports.removeElClass = removeElClass;\\nexports.toggleElClass = toggleElClass;\\nexports.setElAttributes = setElAttributes;\\nexports.getElAttributes = getElAttributes;\\nexports.blockTextSelection = blockTextSelection;\\nexports.unblockTextSelection = unblockTextSelection;\\nexports.findElPosition = findElPosition;\\nexports.getPointerPosition = getPointerPosition;\\nexports.isEl = isEl;\\nexports.isTextNode = isTextNode;\\nexports.emptyEl = emptyEl;\\nexports.normalizeContent = normalizeContent;\\nexports.appendContent = appendContent;\\nexports.insertContent = insertContent;\\n\\nvar _templateObject = _taggedTemplateLiteralLoose(['Setting attributes in the second argument of createEl()\\\\n                has been deprecated. Use the third argument instead.\\\\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.'], ['Setting attributes in the second argument of createEl()\\\\n                has been deprecated. Use the third argument instead.\\\\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.']);\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _taggedTemplateLiteralLoose(strings, raw) { strings.raw = raw; return strings; }\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _guidJs = _dereq_('./guid.js');\\n\\nvar Guid = _interopRequireWildcard(_guidJs);\\n\\nvar _logJs = _dereq_('./log.js');\\n\\nvar _logJs2 = _interopRequireDefault(_logJs);\\n\\nvar _tsml = _dereq_('tsml');\\n\\nvar _tsml2 = _interopRequireDefault(_tsml);\\n\\n/**\\n * Detect if a value is a string with any non-whitespace characters.\\n *\\n * @param  {String} str\\n * @return {Boolean}\\n */\\nfunction isNonBlankString(str) {\\n  return typeof str === 'string' && /\\\\S/.test(str);\\n}\\n\\n/**\\n * Throws an error if the passed string has whitespace. This is used by\\n * class methods to be relatively consistent with the classList API.\\n *\\n * @param  {String} str\\n * @return {Boolean}\\n */\\nfunction throwIfWhitespace(str) {\\n  if (/\\\\s/.test(str)) {\\n    throw new Error('class has illegal whitespace characters');\\n  }\\n}\\n\\n/**\\n * Produce a regular expression for matching a class name.\\n *\\n * @param  {String} className\\n * @return {RegExp}\\n */\\nfunction classRegExp(className) {\\n  return new RegExp('(^|\\\\\\\\s)' + className + '($|\\\\\\\\s)');\\n}\\n\\n/**\\n * Creates functions to query the DOM using a given method.\\n *\\n * @function createQuerier\\n * @private\\n * @param  {String} method\\n * @return {Function}\\n */\\nfunction createQuerier(method) {\\n  return function (selector, context) {\\n    if (!isNonBlankString(selector)) {\\n      return _globalDocument2['default'][method](null);\\n    }\\n    if (isNonBlankString(context)) {\\n      context = _globalDocument2['default'].querySelector(context);\\n    }\\n    return (isEl(context) ? context : _globalDocument2['default'])[method](selector);\\n  };\\n}\\n\\n/**\\n * Shorthand for document.getElementById()\\n * Also allows for CSS (jQuery) ID syntax. But nothing other than IDs.\\n *\\n * @param  {String} id  Element ID\\n * @return {Element}    Element with supplied ID\\n * @function getEl\\n */\\n\\nfunction getEl(id) {\\n  if (id.indexOf('#') === 0) {\\n    id = id.slice(1);\\n  }\\n\\n  return _globalDocument2['default'].getElementById(id);\\n}\\n\\n/**\\n * Creates an element and applies properties.\\n *\\n * @param  {String} [tagName='div'] Name of tag to be created.\\n * @param  {Object} [properties={}] Element properties to be applied.\\n * @param  {Object} [attributes={}] Element attributes to be applied.\\n * @return {Element}\\n * @function createEl\\n */\\n\\nfunction createEl() {\\n  var tagName = arguments.length <= 0 || arguments[0] === undefined ? 'div' : arguments[0];\\n  var properties = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n  var attributes = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\\n\\n  var el = _globalDocument2['default'].createElement(tagName);\\n\\n  Object.getOwnPropertyNames(properties).forEach(function (propName) {\\n    var val = properties[propName];\\n\\n    // See #2176\\n    // We originally were accepting both properties and attributes in the\\n    // same object, but that doesn't work so well.\\n    if (propName.indexOf('aria-') !== -1 || propName === 'role' || propName === 'type') {\\n      _logJs2['default'].warn(_tsml2['default'](_templateObject, propName, val));\\n      el.setAttribute(propName, val);\\n    } else {\\n      el[propName] = val;\\n    }\\n  });\\n\\n  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\\n    var val = attributes[attrName];\\n    el.setAttribute(attrName, attributes[attrName]);\\n  });\\n\\n  return el;\\n}\\n\\n/**\\n * Injects text into an element, replacing any existing contents entirely.\\n *\\n * @param  {Element} el\\n * @param  {String} text\\n * @return {Element}\\n * @function textContent\\n */\\n\\nfunction textContent(el, text) {\\n  if (typeof el.textContent === 'undefined') {\\n    el.innerText = text;\\n  } else {\\n    el.textContent = text;\\n  }\\n}\\n\\n/**\\n * Insert an element as the first child node of another\\n *\\n * @param  {Element} child   Element to insert\\n * @param  {Element} parent Element to insert child into\\n * @private\\n * @function insertElFirst\\n */\\n\\nfunction insertElFirst(child, parent) {\\n  if (parent.firstChild) {\\n    parent.insertBefore(child, parent.firstChild);\\n  } else {\\n    parent.appendChild(child);\\n  }\\n}\\n\\n/**\\n * Element Data Store. Allows for binding data to an element without putting it directly on the element.\\n * Ex. Event listeners are stored here.\\n * (also from jsninja.com, slightly modified and updated for closure compiler)\\n *\\n * @type {Object}\\n * @private\\n */\\nvar elData = {};\\n\\n/*\\n * Unique attribute name to store an element's guid in\\n *\\n * @type {String}\\n * @constant\\n * @private\\n */\\nvar elIdAttr = 'vdata' + new Date().getTime();\\n\\n/**\\n * Returns the cache object where data for an element is stored\\n *\\n * @param  {Element} el Element to store data for.\\n * @return {Object}\\n * @function getElData\\n */\\n\\nfunction getElData(el) {\\n  var id = el[elIdAttr];\\n\\n  if (!id) {\\n    id = el[elIdAttr] = Guid.newGUID();\\n  }\\n\\n  if (!elData[id]) {\\n    elData[id] = {};\\n  }\\n\\n  return elData[id];\\n}\\n\\n/**\\n * Returns whether or not an element has cached data\\n *\\n * @param  {Element} el A dom element\\n * @return {Boolean}\\n * @private\\n * @function hasElData\\n */\\n\\nfunction hasElData(el) {\\n  var id = el[elIdAttr];\\n\\n  if (!id) {\\n    return false;\\n  }\\n\\n  return !!Object.getOwnPropertyNames(elData[id]).length;\\n}\\n\\n/**\\n * Delete data for the element from the cache and the guid attr from getElementById\\n *\\n * @param  {Element} el Remove data for an element\\n * @private\\n * @function removeElData\\n */\\n\\nfunction removeElData(el) {\\n  var id = el[elIdAttr];\\n\\n  if (!id) {\\n    return;\\n  }\\n\\n  // Remove all stored data\\n  delete elData[id];\\n\\n  // Remove the elIdAttr property from the DOM node\\n  try {\\n    delete el[elIdAttr];\\n  } catch (e) {\\n    if (el.removeAttribute) {\\n      el.removeAttribute(elIdAttr);\\n    } else {\\n      // IE doesn't appear to support removeAttribute on the document element\\n      el[elIdAttr] = null;\\n    }\\n  }\\n}\\n\\n/**\\n * Check if an element has a CSS class\\n *\\n * @function hasElClass\\n * @param {Element} element Element to check\\n * @param {String} classToCheck Classname to check\\n */\\n\\nfunction hasElClass(element, classToCheck) {\\n  if (element.classList) {\\n    return element.classList.contains(classToCheck);\\n  } else {\\n    throwIfWhitespace(classToCheck);\\n    return classRegExp(classToCheck).test(element.className);\\n  }\\n}\\n\\n/**\\n * Add a CSS class name to an element\\n *\\n * @function addElClass\\n * @param {Element} element    Element to add class name to\\n * @param {String} classToAdd Classname to add\\n */\\n\\nfunction addElClass(element, classToAdd) {\\n  if (element.classList) {\\n    element.classList.add(classToAdd);\\n\\n    // Don't need to `throwIfWhitespace` here because `hasElClass` will do it\\n    // in the case of classList not being supported.\\n  } else if (!hasElClass(element, classToAdd)) {\\n      element.className = (element.className + ' ' + classToAdd).trim();\\n    }\\n\\n  return element;\\n}\\n\\n/**\\n * Remove a CSS class name from an element\\n *\\n * @function removeElClass\\n * @param {Element} element    Element to remove from class name\\n * @param {String} classToRemove Classname to remove\\n */\\n\\nfunction removeElClass(element, classToRemove) {\\n  if (element.classList) {\\n    element.classList.remove(classToRemove);\\n  } else {\\n    throwIfWhitespace(classToRemove);\\n    element.className = element.className.split(/\\\\s+/).filter(function (c) {\\n      return c !== classToRemove;\\n    }).join(' ');\\n  }\\n\\n  return element;\\n}\\n\\n/**\\n * Adds or removes a CSS class name on an element depending on an optional\\n * condition or the presence/absence of the class name.\\n *\\n * @function toggleElClass\\n * @param    {Element} element\\n * @param    {String} classToToggle\\n * @param    {Boolean|Function} [predicate]\\n *           Can be a function that returns a Boolean. If `true`, the class\\n *           will be added; if `false`, the class will be removed. If not\\n *           given, the class will be added if not present and vice versa.\\n */\\n\\nfunction toggleElClass(element, classToToggle, predicate) {\\n\\n  // This CANNOT use `classList` internally because IE does not support the\\n  // second parameter to the `classList.toggle()` method! Which is fine because\\n  // `classList` will be used by the add/remove functions.\\n  var has = hasElClass(element, classToToggle);\\n\\n  if (typeof predicate === 'function') {\\n    predicate = predicate(element, classToToggle);\\n  }\\n\\n  if (typeof predicate !== 'boolean') {\\n    predicate = !has;\\n  }\\n\\n  // If the necessary class operation matches the current state of the\\n  // element, no action is required.\\n  if (predicate === has) {\\n    return;\\n  }\\n\\n  if (predicate) {\\n    addElClass(element, classToToggle);\\n  } else {\\n    removeElClass(element, classToToggle);\\n  }\\n\\n  return element;\\n}\\n\\n/**\\n * Apply attributes to an HTML element.\\n *\\n * @param  {Element} el         Target element.\\n * @param  {Object=} attributes Element attributes to be applied.\\n * @private\\n * @function setElAttributes\\n */\\n\\nfunction setElAttributes(el, attributes) {\\n  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\\n    var attrValue = attributes[attrName];\\n\\n    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {\\n      el.removeAttribute(attrName);\\n    } else {\\n      el.setAttribute(attrName, attrValue === true ? '' : attrValue);\\n    }\\n  });\\n}\\n\\n/**\\n * Get an element's attribute values, as defined on the HTML tag\\n * Attributes are not the same as properties. They're defined on the tag\\n * or with setAttribute (which shouldn't be used with HTML)\\n * This will return true or false for boolean attributes.\\n *\\n * @param  {Element} tag Element from which to get tag attributes\\n * @return {Object}\\n * @private\\n * @function getElAttributes\\n */\\n\\nfunction getElAttributes(tag) {\\n  var obj, knownBooleans, attrs, attrName, attrVal;\\n\\n  obj = {};\\n\\n  // known boolean attributes\\n  // we can check for matching boolean properties, but older browsers\\n  // won't know about HTML5 boolean attributes that we still read from\\n  knownBooleans = ',' + 'autoplay,controls,loop,muted,default' + ',';\\n\\n  if (tag && tag.attributes && tag.attributes.length > 0) {\\n    attrs = tag.attributes;\\n\\n    for (var i = attrs.length - 1; i >= 0; i--) {\\n      attrName = attrs[i].name;\\n      attrVal = attrs[i].value;\\n\\n      // check for known booleans\\n      // the matching element property will return a value for typeof\\n      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {\\n        // the value of an included boolean attribute is typically an empty\\n        // string ('') which would equal false if we just check for a false value.\\n        // we also don't want support bad code like autoplay='false'\\n        attrVal = attrVal !== null ? true : false;\\n      }\\n\\n      obj[attrName] = attrVal;\\n    }\\n  }\\n\\n  return obj;\\n}\\n\\n/**\\n * Attempt to block the ability to select text while dragging controls\\n *\\n * @return {Boolean}\\n * @function blockTextSelection\\n */\\n\\nfunction blockTextSelection() {\\n  _globalDocument2['default'].body.focus();\\n  _globalDocument2['default'].onselectstart = function () {\\n    return false;\\n  };\\n}\\n\\n/**\\n * Turn off text selection blocking\\n *\\n * @return {Boolean}\\n * @function unblockTextSelection\\n */\\n\\nfunction unblockTextSelection() {\\n  _globalDocument2['default'].onselectstart = function () {\\n    return true;\\n  };\\n}\\n\\n/**\\n * Offset Left\\n * getBoundingClientRect technique from\\n * John Resig http://ejohn.org/blog/getboundingclientrect-is-awesome/\\n *\\n * @function findElPosition\\n * @param {Element} el Element from which to get offset\\n * @return {Object}\\n */\\n\\nfunction findElPosition(el) {\\n  var box = undefined;\\n\\n  if (el.getBoundingClientRect && el.parentNode) {\\n    box = el.getBoundingClientRect();\\n  }\\n\\n  if (!box) {\\n    return {\\n      left: 0,\\n      top: 0\\n    };\\n  }\\n\\n  var docEl = _globalDocument2['default'].documentElement;\\n  var body = _globalDocument2['default'].body;\\n\\n  var clientLeft = docEl.clientLeft || body.clientLeft || 0;\\n  var scrollLeft = _globalWindow2['default'].pageXOffset || body.scrollLeft;\\n  var left = box.left + scrollLeft - clientLeft;\\n\\n  var clientTop = docEl.clientTop || body.clientTop || 0;\\n  var scrollTop = _globalWindow2['default'].pageYOffset || body.scrollTop;\\n  var top = box.top + scrollTop - clientTop;\\n\\n  // Android sometimes returns slightly off decimal values, so need to round\\n  return {\\n    left: Math.round(left),\\n    top: Math.round(top)\\n  };\\n}\\n\\n/**\\n * Get pointer position in element\\n * Returns an object with x and y coordinates.\\n * The base on the coordinates are the bottom left of the element.\\n *\\n * @function getPointerPosition\\n * @param {Element} el Element on which to get the pointer position on\\n * @param {Event} event Event object\\n * @return {Object} This object will have x and y coordinates corresponding to the mouse position\\n */\\n\\nfunction getPointerPosition(el, event) {\\n  var position = {};\\n  var box = findElPosition(el);\\n  var boxW = el.offsetWidth;\\n  var boxH = el.offsetHeight;\\n\\n  var boxY = box.top;\\n  var boxX = box.left;\\n  var pageY = event.pageY;\\n  var pageX = event.pageX;\\n\\n  if (event.changedTouches) {\\n    pageX = event.changedTouches[0].pageX;\\n    pageY = event.changedTouches[0].pageY;\\n  }\\n\\n  position.y = Math.max(0, Math.min(1, (boxY - pageY + boxH) / boxH));\\n  position.x = Math.max(0, Math.min(1, (pageX - boxX) / boxW));\\n\\n  return position;\\n}\\n\\n/**\\n * Determines, via duck typing, whether or not a value is a DOM element.\\n *\\n * @function isEl\\n * @param    {Mixed} value\\n * @return   {Boolean}\\n */\\n\\nfunction isEl(value) {\\n  return !!value && typeof value === 'object' && value.nodeType === 1;\\n}\\n\\n/**\\n * Determines, via duck typing, whether or not a value is a text node.\\n *\\n * @param  {Mixed} value\\n * @return {Boolean}\\n */\\n\\nfunction isTextNode(value) {\\n  return !!value && typeof value === 'object' && value.nodeType === 3;\\n}\\n\\n/**\\n * Empties the contents of an element.\\n *\\n * @function emptyEl\\n * @param    {Element} el\\n * @return   {Element}\\n */\\n\\nfunction emptyEl(el) {\\n  while (el.firstChild) {\\n    el.removeChild(el.firstChild);\\n  }\\n  return el;\\n}\\n\\n/**\\n * Normalizes content for eventual insertion into the DOM.\\n *\\n * This allows a wide range of content definition methods, but protects\\n * from falling into the trap of simply writing to `innerHTML`, which is\\n * an XSS concern.\\n *\\n * The content for an element can be passed in multiple types and\\n * combinations, whose behavior is as follows:\\n *\\n * - String\\n *   Normalized into a text node.\\n *\\n * - Element, TextNode\\n *   Passed through.\\n *\\n * - Array\\n *   A one-dimensional array of strings, elements, nodes, or functions (which\\n *   return single strings, elements, or nodes).\\n *\\n * - Function\\n *   If the sole argument, is expected to produce a string, element,\\n *   node, or array.\\n *\\n * @function normalizeContent\\n * @param    {String|Element|TextNode|Array|Function} content\\n * @return   {Array}\\n */\\n\\nfunction normalizeContent(content) {\\n\\n  // First, invoke content if it is a function. If it produces an array,\\n  // that needs to happen before normalization.\\n  if (typeof content === 'function') {\\n    content = content();\\n  }\\n\\n  // Next up, normalize to an array, so one or many items can be normalized,\\n  // filtered, and returned.\\n  return (Array.isArray(content) ? content : [content]).map(function (value) {\\n\\n    // First, invoke value if it is a function to produce a new value,\\n    // which will be subsequently normalized to a Node of some kind.\\n    if (typeof value === 'function') {\\n      value = value();\\n    }\\n\\n    if (isEl(value) || isTextNode(value)) {\\n      return value;\\n    }\\n\\n    if (typeof value === 'string' && /\\\\S/.test(value)) {\\n      return _globalDocument2['default'].createTextNode(value);\\n    }\\n  }).filter(function (value) {\\n    return value;\\n  });\\n}\\n\\n/**\\n * Normalizes and appends content to an element.\\n *\\n * @function appendContent\\n * @param    {Element} el\\n * @param    {String|Element|TextNode|Array|Function} content\\n *           See: `normalizeContent`\\n * @return   {Element}\\n */\\n\\nfunction appendContent(el, content) {\\n  normalizeContent(content).forEach(function (node) {\\n    return el.appendChild(node);\\n  });\\n  return el;\\n}\\n\\n/**\\n * Normalizes and inserts content into an element; this is identical to\\n * `appendContent()`, except it empties the element first.\\n *\\n * @function insertContent\\n * @param    {Element} el\\n * @param    {String|Element|TextNode|Array|Function} content\\n *           See: `normalizeContent`\\n * @return   {Element}\\n */\\n\\nfunction insertContent(el, content) {\\n  return appendContent(emptyEl(el), content);\\n}\\n\\n/**\\n * Finds a single DOM element matching `selector` within the optional\\n * `context` of another DOM element (defaulting to `document`).\\n *\\n * @function $\\n * @param    {String} selector\\n *           A valid CSS selector, which will be passed to `querySelector`.\\n *\\n * @param    {Element|String} [context=document]\\n *           A DOM element within which to query. Can also be a selector\\n *           string in which case the first matching element will be used\\n *           as context. If missing (or no element matches selector), falls\\n *           back to `document`.\\n *\\n * @return   {Element|null}\\n */\\nvar $ = createQuerier('querySelector');\\n\\nexports.$ = $;\\n/**\\n * Finds a all DOM elements matching `selector` within the optional\\n * `context` of another DOM element (defaulting to `document`).\\n *\\n * @function $$\\n * @param    {String} selector\\n *           A valid CSS selector, which will be passed to `querySelectorAll`.\\n *\\n * @param    {Element|String} [context=document]\\n *           A DOM element within which to query. Can also be a selector\\n *           string in which case the first matching element will be used\\n *           as context. If missing (or no element matches selector), falls\\n *           back to `document`.\\n *\\n * @return   {NodeList}\\n */\\nvar $$ = createQuerier('querySelectorAll');\\nexports.$$ = $$;\\n\\n},{\\\"./guid.js\\\":146,\\\"./log.js\\\":147,\\\"global/document\\\":1,\\\"global/window\\\":2,\\\"tsml\\\":55}],143:[function(_dereq_,module,exports){\\n/**\\n * @file events.js\\n *\\n * Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)\\n * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)\\n * This should work very similarly to jQuery's events, however it's based off the book version which isn't as\\n * robust as jquery's, so there's probably some differences.\\n */\\n\\n'use strict';\\n\\nexports.__esModule = true;\\nexports.on = on;\\nexports.off = off;\\nexports.trigger = trigger;\\nexports.one = one;\\nexports.fixEvent = fixEvent;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nvar _domJs = _dereq_('./dom.js');\\n\\nvar Dom = _interopRequireWildcard(_domJs);\\n\\nvar _guidJs = _dereq_('./guid.js');\\n\\nvar Guid = _interopRequireWildcard(_guidJs);\\n\\nvar _logJs = _dereq_('./log.js');\\n\\nvar _logJs2 = _interopRequireDefault(_logJs);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\n/**\\n * Add an event listener to element\\n * It stores the handler function in a separate cache object\\n * and adds a generic handler to the element's event,\\n * along with a unique id (guid) to the element.\\n *\\n * @param  {Element|Object}   elem Element or object to bind listeners to\\n * @param  {String|Array}   type Type of event to bind to.\\n * @param  {Function} fn   Event listener.\\n * @method on\\n */\\n\\nfunction on(elem, type, fn) {\\n  if (Array.isArray(type)) {\\n    return _handleMultipleEvents(on, elem, type, fn);\\n  }\\n\\n  var data = Dom.getElData(elem);\\n\\n  // We need a place to store all our handler data\\n  if (!data.handlers) data.handlers = {};\\n\\n  if (!data.handlers[type]) data.handlers[type] = [];\\n\\n  if (!fn.guid) fn.guid = Guid.newGUID();\\n\\n  data.handlers[type].push(fn);\\n\\n  if (!data.dispatcher) {\\n    data.disabled = false;\\n\\n    data.dispatcher = function (event, hash) {\\n\\n      if (data.disabled) return;\\n      event = fixEvent(event);\\n\\n      var handlers = data.handlers[event.type];\\n\\n      if (handlers) {\\n        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.\\n        var handlersCopy = handlers.slice(0);\\n\\n        for (var m = 0, n = handlersCopy.length; m < n; m++) {\\n          if (event.isImmediatePropagationStopped()) {\\n            break;\\n          } else {\\n            try {\\n              handlersCopy[m].call(elem, event, hash);\\n            } catch (e) {\\n              _logJs2['default'].error(e);\\n            }\\n          }\\n        }\\n      }\\n    };\\n  }\\n\\n  if (data.handlers[type].length === 1) {\\n    if (elem.addEventListener) {\\n      elem.addEventListener(type, data.dispatcher, false);\\n    } else if (elem.attachEvent) {\\n      elem.attachEvent('on' + type, data.dispatcher);\\n    }\\n  }\\n}\\n\\n/**\\n * Removes event listeners from an element\\n *\\n * @param  {Element|Object}   elem Object to remove listeners from\\n * @param  {String|Array=}   type Type of listener to remove. Don't include to remove all events from element.\\n * @param  {Function} fn   Specific listener to remove. Don't include to remove listeners for an event type.\\n * @method off\\n */\\n\\nfunction off(elem, type, fn) {\\n  // Don't want to add a cache object through getElData if not needed\\n  if (!Dom.hasElData(elem)) return;\\n\\n  var data = Dom.getElData(elem);\\n\\n  // If no events exist, nothing to unbind\\n  if (!data.handlers) {\\n    return;\\n  }\\n\\n  if (Array.isArray(type)) {\\n    return _handleMultipleEvents(off, elem, type, fn);\\n  }\\n\\n  // Utility function\\n  var removeType = function removeType(t) {\\n    data.handlers[t] = [];\\n    _cleanUpEvents(elem, t);\\n  };\\n\\n  // Are we removing all bound events?\\n  if (!type) {\\n    for (var t in data.handlers) {\\n      removeType(t);\\n    }return;\\n  }\\n\\n  var handlers = data.handlers[type];\\n\\n  // If no handlers exist, nothing to unbind\\n  if (!handlers) return;\\n\\n  // If no listener was provided, remove all listeners for type\\n  if (!fn) {\\n    removeType(type);\\n    return;\\n  }\\n\\n  // We're only removing a single handler\\n  if (fn.guid) {\\n    for (var n = 0; n < handlers.length; n++) {\\n      if (handlers[n].guid === fn.guid) {\\n        handlers.splice(n--, 1);\\n      }\\n    }\\n  }\\n\\n  _cleanUpEvents(elem, type);\\n}\\n\\n/**\\n * Trigger an event for an element\\n *\\n * @param  {Element|Object}      elem  Element to trigger an event on\\n * @param  {Event|Object|String} event A string (the type) or an event object with a type attribute\\n * @param  {Object} [hash] data hash to pass along with the event\\n * @return {Boolean=} Returned only if default was prevented\\n * @method trigger\\n */\\n\\nfunction trigger(elem, event, hash) {\\n  // Fetches element data and a reference to the parent (for bubbling).\\n  // Don't want to add a data object to cache for every parent,\\n  // so checking hasElData first.\\n  var elemData = Dom.hasElData(elem) ? Dom.getElData(elem) : {};\\n  var parent = elem.parentNode || elem.ownerDocument;\\n  // type = event.type || event,\\n  // handler;\\n\\n  // If an event name was passed as a string, creates an event out of it\\n  if (typeof event === 'string') {\\n    event = { type: event, target: elem };\\n  }\\n  // Normalizes the event properties.\\n  event = fixEvent(event);\\n\\n  // If the passed element has a dispatcher, executes the established handlers.\\n  if (elemData.dispatcher) {\\n    elemData.dispatcher.call(elem, event, hash);\\n  }\\n\\n  // Unless explicitly stopped or the event does not bubble (e.g. media events)\\n  // recursively calls this function to bubble the event up the DOM.\\n  if (parent && !event.isPropagationStopped() && event.bubbles === true) {\\n    trigger.call(null, parent, event, hash);\\n\\n    // If at the top of the DOM, triggers the default action unless disabled.\\n  } else if (!parent && !event.defaultPrevented) {\\n      var targetData = Dom.getElData(event.target);\\n\\n      // Checks if the target has a default action for this event.\\n      if (event.target[event.type]) {\\n        // Temporarily disables event dispatching on the target as we have already executed the handler.\\n        targetData.disabled = true;\\n        // Executes the default action.\\n        if (typeof event.target[event.type] === 'function') {\\n          event.target[event.type]();\\n        }\\n        // Re-enables event dispatching.\\n        targetData.disabled = false;\\n      }\\n    }\\n\\n  // Inform the triggerer if the default was prevented by returning false\\n  return !event.defaultPrevented;\\n}\\n\\n/**\\n * Trigger a listener only once for an event\\n *\\n * @param  {Element|Object}   elem Element or object to\\n * @param  {String|Array}   type Name/type of event\\n * @param  {Function} fn Event handler function\\n * @method one\\n */\\n\\nfunction one(elem, type, fn) {\\n  if (Array.isArray(type)) {\\n    return _handleMultipleEvents(one, elem, type, fn);\\n  }\\n  var func = function func() {\\n    off(elem, type, func);\\n    fn.apply(this, arguments);\\n  };\\n  // copy the guid to the new function so it can removed using the original function's ID\\n  func.guid = fn.guid = fn.guid || Guid.newGUID();\\n  on(elem, type, func);\\n}\\n\\n/**\\n * Fix a native event to have standard property values\\n *\\n * @param  {Object} event Event object to fix\\n * @return {Object}\\n * @private\\n * @method fixEvent\\n */\\n\\nfunction fixEvent(event) {\\n\\n  function returnTrue() {\\n    return true;\\n  }\\n  function returnFalse() {\\n    return false;\\n  }\\n\\n  // Test if fixing up is needed\\n  // Used to check if !event.stopPropagation instead of isPropagationStopped\\n  // But native events return true for stopPropagation, but don't have\\n  // other expected methods like isPropagationStopped. Seems to be a problem\\n  // with the Javascript Ninja code. So we're just overriding all events now.\\n  if (!event || !event.isPropagationStopped) {\\n    var old = event || _globalWindow2['default'].event;\\n\\n    event = {};\\n    // Clone the old object so that we can modify the values event = {};\\n    // IE8 Doesn't like when you mess with native event properties\\n    // Firefox returns false for event.hasOwnProperty('type') and other props\\n    //  which makes copying more difficult.\\n    // TODO: Probably best to create a whitelist of event props\\n    for (var key in old) {\\n      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y\\n      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation\\n      // and webkitMovementX/Y\\n      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation' && key !== 'webkitMovementX' && key !== 'webkitMovementY') {\\n        // Chrome 32+ warns if you try to copy deprecated returnValue, but\\n        // we still want to if preventDefault isn't supported (IE8).\\n        if (!(key === 'returnValue' && old.preventDefault)) {\\n          event[key] = old[key];\\n        }\\n      }\\n    }\\n\\n    // The event occurred on this element\\n    if (!event.target) {\\n      event.target = event.srcElement || _globalDocument2['default'];\\n    }\\n\\n    // Handle which other element the event is related to\\n    if (!event.relatedTarget) {\\n      event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;\\n    }\\n\\n    // Stop the default browser action\\n    event.preventDefault = function () {\\n      if (old.preventDefault) {\\n        old.preventDefault();\\n      }\\n      event.returnValue = false;\\n      old.returnValue = false;\\n      event.defaultPrevented = true;\\n    };\\n\\n    event.defaultPrevented = false;\\n\\n    // Stop the event from bubbling\\n    event.stopPropagation = function () {\\n      if (old.stopPropagation) {\\n        old.stopPropagation();\\n      }\\n      event.cancelBubble = true;\\n      old.cancelBubble = true;\\n      event.isPropagationStopped = returnTrue;\\n    };\\n\\n    event.isPropagationStopped = returnFalse;\\n\\n    // Stop the event from bubbling and executing other handlers\\n    event.stopImmediatePropagation = function () {\\n      if (old.stopImmediatePropagation) {\\n        old.stopImmediatePropagation();\\n      }\\n      event.isImmediatePropagationStopped = returnTrue;\\n      event.stopPropagation();\\n    };\\n\\n    event.isImmediatePropagationStopped = returnFalse;\\n\\n    // Handle mouse position\\n    if (event.clientX != null) {\\n      var doc = _globalDocument2['default'].documentElement,\\n          body = _globalDocument2['default'].body;\\n\\n      event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\\n      event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\\n    }\\n\\n    // Handle key presses\\n    event.which = event.charCode || event.keyCode;\\n\\n    // Fix button for mouse clicks:\\n    // 0 == left; 1 == middle; 2 == right\\n    if (event.button != null) {\\n      event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;\\n    }\\n  }\\n\\n  // Returns fixed-up instance\\n  return event;\\n}\\n\\n/**\\n * Clean up the listener cache and dispatchers\\n*\\n * @param  {Element|Object} elem Element to clean up\\n * @param  {String} type Type of event to clean up\\n * @private\\n * @method _cleanUpEvents\\n */\\nfunction _cleanUpEvents(elem, type) {\\n  var data = Dom.getElData(elem);\\n\\n  // Remove the events of a particular type if there are none left\\n  if (data.handlers[type].length === 0) {\\n    delete data.handlers[type];\\n    // data.handlers[type] = null;\\n    // Setting to null was causing an error with data.handlers\\n\\n    // Remove the meta-handler from the element\\n    if (elem.removeEventListener) {\\n      elem.removeEventListener(type, data.dispatcher, false);\\n    } else if (elem.detachEvent) {\\n      elem.detachEvent('on' + type, data.dispatcher);\\n    }\\n  }\\n\\n  // Remove the events object if there are no types left\\n  if (Object.getOwnPropertyNames(data.handlers).length <= 0) {\\n    delete data.handlers;\\n    delete data.dispatcher;\\n    delete data.disabled;\\n  }\\n\\n  // Finally remove the element data if there is no data left\\n  if (Object.getOwnPropertyNames(data).length === 0) {\\n    Dom.removeElData(elem);\\n  }\\n}\\n\\n/**\\n * Loops through an array of event types and calls the requested method for each type.\\n *\\n * @param  {Function} fn   The event method we want to use.\\n * @param  {Element|Object} elem Element or object to bind listeners to\\n * @param  {String}   type Type of event to bind to.\\n * @param  {Function} callback   Event listener.\\n * @private\\n * @function _handleMultipleEvents\\n */\\nfunction _handleMultipleEvents(fn, elem, types, callback) {\\n  types.forEach(function (type) {\\n    //Call the event method for each one of the types\\n    fn(elem, type, callback);\\n  });\\n}\\n\\n},{\\\"./dom.js\\\":142,\\\"./guid.js\\\":146,\\\"./log.js\\\":147,\\\"global/document\\\":1,\\\"global/window\\\":2}],144:[function(_dereq_,module,exports){\\n/**\\n * @file fn.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nvar _guidJs = _dereq_('./guid.js');\\n\\n/**\\n * Bind (a.k.a proxy or Context). A simple method for changing the context of a function\\n * It also stores a unique id on the function so it can be easily removed from events\\n *\\n * @param  {*}   context The object to bind as scope\\n * @param  {Function} fn      The function to be bound to a scope\\n * @param  {Number=}   uid     An optional unique ID for the function to be set\\n * @return {Function}\\n * @private\\n * @method bind\\n */\\nvar bind = function bind(context, fn, uid) {\\n  // Make sure the function has a unique ID\\n  if (!fn.guid) {\\n    fn.guid = _guidJs.newGUID();\\n  }\\n\\n  // Create the new function that changes the context\\n  var ret = function ret() {\\n    return fn.apply(context, arguments);\\n  };\\n\\n  // Allow for the ability to individualize this function\\n  // Needed in the case where multiple objects might share the same prototype\\n  // IF both items add an event listener with the same function, then you try to remove just one\\n  // it will remove both because they both have the same guid.\\n  // when using this, you need to use the bind method when you remove the listener as well.\\n  // currently used in text tracks\\n  ret.guid = uid ? uid + '_' + fn.guid : fn.guid;\\n\\n  return ret;\\n};\\nexports.bind = bind;\\n\\n},{\\\"./guid.js\\\":146}],145:[function(_dereq_,module,exports){\\n/**\\n * @file format-time.js\\n *\\n * Format seconds as a time string, H:MM:SS or M:SS\\n * Supplying a guide (in seconds) will force a number of leading zeros\\n * to cover the length of the guide\\n *\\n * @param  {Number} seconds Number of seconds to be turned into a string\\n * @param  {Number} guide   Number (in seconds) to model the string after\\n * @return {String}         Time formatted as H:MM:SS or M:SS\\n * @private\\n * @function formatTime\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\nfunction formatTime(seconds) {\\n  var guide = arguments.length <= 1 || arguments[1] === undefined ? seconds : arguments[1];\\n  return (function () {\\n    seconds = seconds < 0 ? 0 : seconds;\\n    var s = Math.floor(seconds % 60);\\n    var m = Math.floor(seconds / 60 % 60);\\n    var h = Math.floor(seconds / 3600);\\n    var gm = Math.floor(guide / 60 % 60);\\n    var gh = Math.floor(guide / 3600);\\n\\n    // handle invalid times\\n    if (isNaN(seconds) || seconds === Infinity) {\\n      // '-' is false for all relational operators (e.g. <, >=) so this setting\\n      // will add the minimum number of fields specified by the guide\\n      h = m = s = '-';\\n    }\\n\\n    // Check if we need to show hours\\n    h = h > 0 || gh > 0 ? h + ':' : '';\\n\\n    // If hours are showing, we may need to add a leading zero.\\n    // Always show at least one digit of minutes.\\n    m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':';\\n\\n    // Check if leading zero is need for seconds\\n    s = s < 10 ? '0' + s : s;\\n\\n    return h + m + s;\\n  })();\\n}\\n\\nexports['default'] = formatTime;\\nmodule.exports = exports['default'];\\n\\n},{}],146:[function(_dereq_,module,exports){\\n/**\\n * @file guid.js\\n *\\n * Unique ID for an element or function\\n * @type {Number}\\n * @private\\n */\\n\\\"use strict\\\";\\n\\nexports.__esModule = true;\\nexports.newGUID = newGUID;\\nvar _guid = 1;\\n\\n/**\\n * Get the next unique ID\\n *\\n * @return {String} \\n * @function newGUID\\n */\\n\\nfunction newGUID() {\\n  return _guid++;\\n}\\n\\n},{}],147:[function(_dereq_,module,exports){\\n/**\\n * @file log.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _browser = _dereq_('./browser');\\n\\n/**\\n * Log messages to the console and history based on the type of message\\n *\\n * @param  {String} type\\n *         The name of the console method to use.\\n * @param  {Array} args\\n *         The arguments to be passed to the matching console method.\\n * @param  {Boolean} [stringify]\\n *         By default, only old IEs should get console argument stringification,\\n *         but this is exposed as a parameter to facilitate testing.\\n */\\nvar logByType = function logByType(type, args) {\\n  var stringify = arguments.length <= 2 || arguments[2] === undefined ? !!_browser.IE_VERSION && _browser.IE_VERSION < 11 : arguments[2];\\n\\n  var console = _globalWindow2['default'].console;\\n\\n  // If there's no console then don't try to output messages, but they will\\n  // still be stored in `log.history`.\\n  //\\n  // Was setting these once outside of this function, but containing them\\n  // in the function makes it easier to test cases where console doesn't exist\\n  // when the module is executed.\\n  var fn = console && console[type] || function () {};\\n\\n  if (type !== 'log') {\\n\\n    // add the type to the front of the message when it's not \\\"log\\\"\\n    args.unshift(type.toUpperCase() + ':');\\n  }\\n\\n  // add to history\\n  log.history.push(args);\\n\\n  // add console prefix after adding to history\\n  args.unshift('VIDEOJS:');\\n\\n  // IEs previous to 11 log objects uselessly as \\\"[object Object]\\\"; so, JSONify\\n  // objects and arrays for those less-capable browsers.\\n  if (stringify) {\\n    args = args.map(function (a) {\\n      if (a && typeof a === 'object' || Array.isArray(a)) {\\n        try {\\n          return JSON.stringify(a);\\n        } catch (x) {}\\n      }\\n\\n      // Cast to string before joining, so we get null and undefined explicitly\\n      // included in output (as we would in a modern console).\\n      return String(a);\\n    }).join(' ');\\n  }\\n\\n  // Old IE versions do not allow .apply() for console methods (they are\\n  // reported as objects rather than functions).\\n  if (!fn.apply) {\\n    fn(args);\\n  } else {\\n    fn[Array.isArray(args) ? 'apply' : 'call'](console, args);\\n  }\\n};\\n\\nexports.logByType = logByType;\\n/**\\n * Log plain debug messages\\n *\\n * @function log\\n */\\nfunction log() {\\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\\n    args[_key] = arguments[_key];\\n  }\\n\\n  logByType('log', args);\\n}\\n\\n/**\\n * Keep a history of log messages\\n *\\n * @type {Array}\\n */\\nlog.history = [];\\n\\n/**\\n * Log error messages\\n *\\n * @method error\\n */\\nlog.error = function () {\\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\\n    args[_key2] = arguments[_key2];\\n  }\\n\\n  return logByType('error', args);\\n};\\n\\n/**\\n * Log warning messages\\n *\\n * @method warn\\n */\\nlog.warn = function () {\\n  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\\n    args[_key3] = arguments[_key3];\\n  }\\n\\n  return logByType('warn', args);\\n};\\n\\nexports['default'] = log;\\n\\n},{\\\"./browser\\\":140,\\\"global/window\\\":2}],148:[function(_dereq_,module,exports){\\n/**\\n * @file merge-options.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\nexports['default'] = mergeOptions;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _lodashCompatObjectMerge = _dereq_('lodash-compat/object/merge');\\n\\nvar _lodashCompatObjectMerge2 = _interopRequireDefault(_lodashCompatObjectMerge);\\n\\nfunction isPlain(obj) {\\n  return !!obj && typeof obj === 'object' && obj.toString() === '[object Object]' && obj.constructor === Object;\\n}\\n\\n/**\\n * Merge customizer. video.js simply overwrites non-simple objects\\n * (like arrays) instead of attempting to overlay them.\\n * @see https://lodash.com/docs#merge\\n */\\nvar customizer = function customizer(destination, source) {\\n  // If we're not working with a plain object, copy the value as is\\n  // If source is an array, for instance, it will replace destination\\n  if (!isPlain(source)) {\\n    return source;\\n  }\\n\\n  // If the new value is a plain object but the first object value is not\\n  // we need to create a new object for the first object to merge with.\\n  // This makes it consistent with how merge() works by default\\n  // and also protects from later changes the to first object affecting\\n  // the second object's values.\\n  if (!isPlain(destination)) {\\n    return mergeOptions(source);\\n  }\\n};\\n\\n/**\\n * Merge one or more options objects, recursively merging **only**\\n * plain object properties.  Previously `deepMerge`.\\n *\\n * @param  {...Object} source One or more objects to merge\\n * @returns {Object}          a new object that is the union of all\\n * provided objects\\n * @function mergeOptions\\n */\\n\\nfunction mergeOptions() {\\n  // contruct the call dynamically to handle the variable number of\\n  // objects to merge\\n  var args = Array.prototype.slice.call(arguments);\\n\\n  // unshift an empty object into the front of the call as the target\\n  // of the merge\\n  args.unshift({});\\n\\n  // customize conflict resolution to match our historical merge behavior\\n  args.push(customizer);\\n\\n  _lodashCompatObjectMerge2['default'].apply(null, args);\\n\\n  // return the mutated result object\\n  return args[0];\\n}\\n\\nmodule.exports = exports['default'];\\n\\n},{\\\"lodash-compat/object/merge\\\":40}],149:[function(_dereq_,module,exports){\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar createStyleElement = function createStyleElement(className) {\\n  var style = _globalDocument2['default'].createElement('style');\\n  style.className = className;\\n\\n  return style;\\n};\\n\\nexports.createStyleElement = createStyleElement;\\nvar setTextContent = function setTextContent(el, content) {\\n  if (el.styleSheet) {\\n    el.styleSheet.cssText = content;\\n  } else {\\n    el.textContent = content;\\n  }\\n};\\nexports.setTextContent = setTextContent;\\n\\n},{\\\"global/document\\\":1}],150:[function(_dereq_,module,exports){\\n'use strict';\\n\\nexports.__esModule = true;\\nexports.createTimeRanges = createTimeRanges;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _logJs = _dereq_('./log.js');\\n\\nvar _logJs2 = _interopRequireDefault(_logJs);\\n\\n/**\\n * @file time-ranges.js\\n *\\n * Should create a fake TimeRange object\\n * Mimics an HTML5 time range instance, which has functions that\\n * return the start and end times for a range\\n * TimeRanges are returned by the buffered() method\\n *\\n * @param  {(Number|Array)} Start of a single range or an array of ranges\\n * @param  {Number} End of a single range\\n * @private\\n * @method createTimeRanges\\n */\\n\\nfunction createTimeRanges(start, end) {\\n  if (Array.isArray(start)) {\\n    return createTimeRangesObj(start);\\n  } else if (start === undefined || end === undefined) {\\n    return createTimeRangesObj();\\n  }\\n  return createTimeRangesObj([[start, end]]);\\n}\\n\\nexports.createTimeRange = createTimeRanges;\\n\\nfunction createTimeRangesObj(ranges) {\\n  if (ranges === undefined || ranges.length === 0) {\\n    return {\\n      length: 0,\\n      start: function start() {\\n        throw new Error('This TimeRanges object is empty');\\n      },\\n      end: function end() {\\n        throw new Error('This TimeRanges object is empty');\\n      }\\n    };\\n  }\\n  return {\\n    length: ranges.length,\\n    start: getRange.bind(null, 'start', 0, ranges),\\n    end: getRange.bind(null, 'end', 1, ranges)\\n  };\\n}\\n\\nfunction getRange(fnName, valueIndex, ranges, rangeIndex) {\\n  if (rangeIndex === undefined) {\\n    _logJs2['default'].warn('DEPRECATED: Function \\\\'' + fnName + '\\\\' on \\\\'TimeRanges\\\\' called without an index argument.');\\n    rangeIndex = 0;\\n  }\\n  rangeCheck(fnName, rangeIndex, ranges.length - 1);\\n  return ranges[rangeIndex][valueIndex];\\n}\\n\\nfunction rangeCheck(fnName, index, maxIndex) {\\n  if (index < 0 || index > maxIndex) {\\n    throw new Error('Failed to execute \\\\'' + fnName + '\\\\' on \\\\'TimeRanges\\\\': The index provided (' + index + ') is greater than or equal to the maximum bound (' + maxIndex + ').');\\n  }\\n}\\n\\n},{\\\"./log.js\\\":147}],151:[function(_dereq_,module,exports){\\n/**\\n * @file to-title-case.js\\n *\\n * Uppercase the first letter of a string\\n *\\n * @param  {String} string String to be uppercased\\n * @return {String}\\n * @private\\n * @method toTitleCase\\n */\\n\\\"use strict\\\";\\n\\nexports.__esModule = true;\\nfunction toTitleCase(string) {\\n  return string.charAt(0).toUpperCase() + string.slice(1);\\n}\\n\\nexports[\\\"default\\\"] = toTitleCase;\\nmodule.exports = exports[\\\"default\\\"];\\n\\n},{}],152:[function(_dereq_,module,exports){\\n/**\\n * @file url.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\n/**\\n * Resolve and parse the elements of a URL\\n *\\n * @param  {String} url The url to parse\\n * @return {Object}     An object of url details\\n * @method parseUrl\\n */\\nvar parseUrl = function parseUrl(url) {\\n  var props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];\\n\\n  // add the url to an anchor and let the browser parse the URL\\n  var a = _globalDocument2['default'].createElement('a');\\n  a.href = url;\\n\\n  // IE8 (and 9?) Fix\\n  // ie8 doesn't parse the URL correctly until the anchor is actually\\n  // added to the body, and an innerHTML is needed to trigger the parsing\\n  var addToBody = a.host === '' && a.protocol !== 'file:';\\n  var div = undefined;\\n  if (addToBody) {\\n    div = _globalDocument2['default'].createElement('div');\\n    div.innerHTML = '<a href=\\\"' + url + '\\\"></a>';\\n    a = div.firstChild;\\n    // prevent the div from affecting layout\\n    div.setAttribute('style', 'display:none; position:absolute;');\\n    _globalDocument2['default'].body.appendChild(div);\\n  }\\n\\n  // Copy the specific URL properties to a new object\\n  // This is also needed for IE8 because the anchor loses its\\n  // properties when it's removed from the dom\\n  var details = {};\\n  for (var i = 0; i < props.length; i++) {\\n    details[props[i]] = a[props[i]];\\n  }\\n\\n  // IE9 adds the port to the host property unlike everyone else. If\\n  // a port identifier is added for standard ports, strip it.\\n  if (details.protocol === 'http:') {\\n    details.host = details.host.replace(/:80$/, '');\\n  }\\n  if (details.protocol === 'https:') {\\n    details.host = details.host.replace(/:443$/, '');\\n  }\\n\\n  if (addToBody) {\\n    _globalDocument2['default'].body.removeChild(div);\\n  }\\n\\n  return details;\\n};\\n\\nexports.parseUrl = parseUrl;\\n/**\\n * Get absolute version of relative URL. Used to tell flash correct URL.\\n * http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue\\n *\\n * @param  {String} url URL to make absolute\\n * @return {String}     Absolute URL\\n * @private\\n * @method getAbsoluteURL\\n */\\nvar getAbsoluteURL = function getAbsoluteURL(url) {\\n  // Check if absolute URL\\n  if (!url.match(/^https?:\\\\/\\\\//)) {\\n    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.\\n    var div = _globalDocument2['default'].createElement('div');\\n    div.innerHTML = '<a href=\\\"' + url + '\\\">x</a>';\\n    url = div.firstChild.href;\\n  }\\n\\n  return url;\\n};\\n\\nexports.getAbsoluteURL = getAbsoluteURL;\\n/**\\n * Returns the extension of the passed file name. It will return an empty string if you pass an invalid path\\n *\\n * @param {String}    path    The fileName path like '/path/to/file.mp4'\\n * @returns {String}          The extension in lower case or an empty string if no extension could be found.\\n * @method getFileExtension\\n */\\nvar getFileExtension = function getFileExtension(path) {\\n  if (typeof path === 'string') {\\n    var splitPathRe = /^(\\\\/?)([\\\\s\\\\S]*?)((?:\\\\.{1,2}|[^\\\\/]+?)(\\\\.([^\\\\.\\\\/\\\\?]+)))(?:[\\\\/]*|[\\\\?].*)$/i;\\n    var pathParts = splitPathRe.exec(path);\\n\\n    if (pathParts) {\\n      return pathParts.pop().toLowerCase();\\n    }\\n  }\\n\\n  return '';\\n};\\n\\nexports.getFileExtension = getFileExtension;\\n/**\\n * Returns whether the url passed is a cross domain request or not.\\n *\\n * @param {String} url The url to check\\n * @return {Boolean}   Whether it is a cross domain request or not\\n * @method isCrossOrigin\\n */\\nvar isCrossOrigin = function isCrossOrigin(url) {\\n  var winLoc = _globalWindow2['default'].location;\\n  var urlInfo = parseUrl(url);\\n\\n  // IE8 protocol relative urls will return ':' for protocol\\n  var srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;\\n\\n  // Check if url is for another domain/origin\\n  // IE8 doesn't know location.origin, so we won't rely on it here\\n  var crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;\\n\\n  return crossOrigin;\\n};\\nexports.isCrossOrigin = isCrossOrigin;\\n\\n},{\\\"global/document\\\":1,\\\"global/window\\\":2}],153:[function(_dereq_,module,exports){\\n/**\\n * @file video.js\\n */\\n'use strict';\\n\\nexports.__esModule = true;\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _globalWindow = _dereq_('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _globalDocument = _dereq_('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _setup = _dereq_('./setup');\\n\\nvar setup = _interopRequireWildcard(_setup);\\n\\nvar _utilsStylesheetJs = _dereq_('./utils/stylesheet.js');\\n\\nvar stylesheet = _interopRequireWildcard(_utilsStylesheetJs);\\n\\nvar _component = _dereq_('./component');\\n\\nvar _component2 = _interopRequireDefault(_component);\\n\\nvar _eventTarget = _dereq_('./event-target');\\n\\nvar _eventTarget2 = _interopRequireDefault(_eventTarget);\\n\\nvar _utilsEventsJs = _dereq_('./utils/events.js');\\n\\nvar Events = _interopRequireWildcard(_utilsEventsJs);\\n\\nvar _player = _dereq_('./player');\\n\\nvar _player2 = _interopRequireDefault(_player);\\n\\nvar _pluginsJs = _dereq_('./plugins.js');\\n\\nvar _pluginsJs2 = _interopRequireDefault(_pluginsJs);\\n\\nvar _srcJsUtilsMergeOptionsJs = _dereq_('../../src/js/utils/merge-options.js');\\n\\nvar _srcJsUtilsMergeOptionsJs2 = _interopRequireDefault(_srcJsUtilsMergeOptionsJs);\\n\\nvar _utilsFnJs = _dereq_('./utils/fn.js');\\n\\nvar Fn = _interopRequireWildcard(_utilsFnJs);\\n\\nvar _tracksTextTrackJs = _dereq_('./tracks/text-track.js');\\n\\nvar _tracksTextTrackJs2 = _interopRequireDefault(_tracksTextTrackJs);\\n\\nvar _tracksAudioTrackJs = _dereq_('./tracks/audio-track.js');\\n\\nvar _tracksAudioTrackJs2 = _interopRequireDefault(_tracksAudioTrackJs);\\n\\nvar _tracksVideoTrackJs = _dereq_('./tracks/video-track.js');\\n\\nvar _tracksVideoTrackJs2 = _interopRequireDefault(_tracksVideoTrackJs);\\n\\nvar _utilsTimeRangesJs = _dereq_('./utils/time-ranges.js');\\n\\nvar _utilsFormatTimeJs = _dereq_('./utils/format-time.js');\\n\\nvar _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);\\n\\nvar _utilsLogJs = _dereq_('./utils/log.js');\\n\\nvar _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);\\n\\nvar _utilsDomJs = _dereq_('./utils/dom.js');\\n\\nvar Dom = _interopRequireWildcard(_utilsDomJs);\\n\\nvar _utilsBrowserJs = _dereq_('./utils/browser.js');\\n\\nvar browser = _interopRequireWildcard(_utilsBrowserJs);\\n\\nvar _utilsUrlJs = _dereq_('./utils/url.js');\\n\\nvar Url = _interopRequireWildcard(_utilsUrlJs);\\n\\nvar _extendJs = _dereq_('./extend.js');\\n\\nvar _extendJs2 = _interopRequireDefault(_extendJs);\\n\\nvar _lodashCompatObjectMerge = _dereq_('lodash-compat/object/merge');\\n\\nvar _lodashCompatObjectMerge2 = _interopRequireDefault(_lodashCompatObjectMerge);\\n\\nvar _xhr = _dereq_('xhr');\\n\\nvar _xhr2 = _interopRequireDefault(_xhr);\\n\\n// Include the built-in techs\\n\\nvar _techTechJs = _dereq_('./tech/tech.js');\\n\\nvar _techTechJs2 = _interopRequireDefault(_techTechJs);\\n\\nvar _techHtml5Js = _dereq_('./tech/html5.js');\\n\\nvar _techHtml5Js2 = _interopRequireDefault(_techHtml5Js);\\n\\nvar _techFlashJs = _dereq_('./tech/flash.js');\\n\\nvar _techFlashJs2 = _interopRequireDefault(_techFlashJs);\\n\\n// HTML5 Element Shim for IE8\\nif (typeof HTMLVideoElement === 'undefined') {\\n  _globalDocument2['default'].createElement('video');\\n  _globalDocument2['default'].createElement('audio');\\n  _globalDocument2['default'].createElement('track');\\n}\\n\\n/**\\n * Doubles as the main function for users to create a player instance and also\\n * the main library object.\\n * The `videojs` function can be used to initialize or retrieve a player.\\n * ```js\\n *     var myPlayer = videojs('my_video_id');\\n * ```\\n *\\n * @param  {String|Element} id      Video element or video element ID\\n * @param  {Object=} options        Optional options object for config/settings\\n * @param  {Function=} ready        Optional ready callback\\n * @return {Player}                 A player instance\\n * @mixes videojs\\n * @method videojs\\n */\\nfunction videojs(id, options, ready) {\\n  var tag = undefined; // Element of ID\\n\\n  // Allow for element or ID to be passed in\\n  // String ID\\n  if (typeof id === 'string') {\\n\\n    // Adjust for jQuery ID syntax\\n    if (id.indexOf('#') === 0) {\\n      id = id.slice(1);\\n    }\\n\\n    // If a player instance has already been created for this ID return it.\\n    if (videojs.getPlayers()[id]) {\\n\\n      // If options or ready funtion are passed, warn\\n      if (options) {\\n        _utilsLogJs2['default'].warn('Player \\\"' + id + '\\\" is already initialised. Options will not be applied.');\\n      }\\n\\n      if (ready) {\\n        videojs.getPlayers()[id].ready(ready);\\n      }\\n\\n      return videojs.getPlayers()[id];\\n\\n      // Otherwise get element for ID\\n    } else {\\n        tag = Dom.getEl(id);\\n      }\\n\\n    // ID is a media element\\n  } else {\\n      tag = id;\\n    }\\n\\n  // Check for a useable element\\n  if (!tag || !tag.nodeName) {\\n    // re: nodeName, could be a box div also\\n    throw new TypeError('The element or ID supplied is not valid. (videojs)'); // Returns\\n  }\\n\\n  // Element may have a player attr referring to an already created player instance.\\n  // If not, set up a new player and return the instance.\\n  return tag['player'] || _player2['default'].players[tag.playerId] || new _player2['default'](tag, options, ready);\\n}\\n\\n// Add default styles\\nif (_globalWindow2['default'].VIDEOJS_NO_DYNAMIC_STYLE !== true) {\\n  var style = Dom.$('.vjs-styles-defaults');\\n\\n  if (!style) {\\n    style = stylesheet.createStyleElement('vjs-styles-defaults');\\n    var head = Dom.$('head');\\n    head.insertBefore(style, head.firstChild);\\n    stylesheet.setTextContent(style, '\\\\n      .video-js {\\\\n        width: 300px;\\\\n        height: 150px;\\\\n      }\\\\n\\\\n      .vjs-fluid {\\\\n        padding-top: 56.25%\\\\n      }\\\\n    ');\\n  }\\n}\\n\\n// Run Auto-load players\\n// You have to wait at least once in case this script is loaded after your video in the DOM (weird behavior only with minified version)\\nsetup.autoSetupTimeout(1, videojs);\\n\\n/*\\n * Current software version (semver)\\n *\\n * @type {String}\\n */\\nvideojs.VERSION = '5.11.6';\\n\\n/**\\n * The global options object. These are the settings that take effect\\n * if no overrides are specified when the player is created.\\n *\\n * ```js\\n *     videojs.options.autoplay = true\\n *     // -> all players will autoplay by default\\n * ```\\n *\\n * @type {Object}\\n */\\nvideojs.options = _player2['default'].prototype.options_;\\n\\n/**\\n * Get an object with the currently created players, keyed by player ID\\n *\\n * @return {Object} The created players\\n * @mixes videojs\\n * @method getPlayers\\n */\\nvideojs.getPlayers = function () {\\n  return _player2['default'].players;\\n};\\n\\n/**\\n * Expose players object.\\n *\\n * @memberOf videojs\\n * @property {Object} players\\n */\\nvideojs.players = _player2['default'].players;\\n\\n/**\\n * Get a component class object by name\\n * ```js\\n *     var VjsButton = videojs.getComponent('Button');\\n *     // Create a new instance of the component\\n *     var myButton = new VjsButton(myPlayer);\\n * ```\\n *\\n * @return {Component} Component identified by name\\n * @mixes videojs\\n * @method getComponent\\n */\\nvideojs.getComponent = _component2['default'].getComponent;\\n\\n/**\\n * Register a component so it can referred to by name\\n * Used when adding to other\\n * components, either through addChild\\n * `component.addChild('myComponent')`\\n * or through default children options\\n * `{ children: ['myComponent'] }`.\\n * ```js\\n *     // Get a component to subclass\\n *     var VjsButton = videojs.getComponent('Button');\\n *     // Subclass the component (see 'extend' doc for more info)\\n *     var MySpecialButton = videojs.extend(VjsButton, {});\\n *     // Register the new component\\n *     VjsButton.registerComponent('MySepcialButton', MySepcialButton);\\n *     // (optionally) add the new component as a default player child\\n *     myPlayer.addChild('MySepcialButton');\\n * ```\\n * NOTE: You could also just initialize the component before adding.\\n * `component.addChild(new MyComponent());`\\n *\\n * @param {String} The class name of the component\\n * @param {Component} The component class\\n * @return {Component} The newly registered component\\n * @mixes videojs\\n * @method registerComponent\\n */\\nvideojs.registerComponent = function (name, comp) {\\n  if (_techTechJs2['default'].isTech(comp)) {\\n    _utilsLogJs2['default'].warn('The ' + name + ' tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)');\\n  }\\n\\n  _component2['default'].registerComponent.call(_component2['default'], name, comp);\\n};\\n\\n/**\\n * Get a Tech class object by name\\n * ```js\\n *     var Html5 = videojs.getTech('Html5');\\n *     // Create a new instance of the component\\n *     var html5 = new Html5(options);\\n * ```\\n *\\n * @return {Tech} Tech identified by name\\n * @mixes videojs\\n * @method getComponent\\n */\\nvideojs.getTech = _techTechJs2['default'].getTech;\\n\\n/**\\n * Register a Tech so it can referred to by name.\\n * This is used in the tech order for the player.\\n *\\n * ```js\\n *     // get the Html5 Tech\\n *     var Html5 = videojs.getTech('Html5');\\n *     var MyTech = videojs.extend(Html5, {});\\n *     // Register the new Tech\\n *     VjsButton.registerTech('Tech', MyTech);\\n *     var player = videojs('myplayer', {\\n *       techOrder: ['myTech', 'html5']\\n *     });\\n * ```\\n *\\n * @param {String} The class name of the tech\\n * @param {Tech} The tech class\\n * @return {Tech} The newly registered Tech\\n * @mixes videojs\\n * @method registerTech\\n */\\nvideojs.registerTech = _techTechJs2['default'].registerTech;\\n\\n/**\\n * A suite of browser and device tests\\n *\\n * @type {Object}\\n * @private\\n */\\nvideojs.browser = browser;\\n\\n/**\\n * Whether or not the browser supports touch events. Included for backward\\n * compatibility with 4.x, but deprecated. Use `videojs.browser.TOUCH_ENABLED`\\n * instead going forward.\\n *\\n * @deprecated\\n * @type {Boolean}\\n */\\nvideojs.TOUCH_ENABLED = browser.TOUCH_ENABLED;\\n\\n/**\\n * Subclass an existing class\\n * Mimics ES6 subclassing with the `extend` keyword\\n * ```js\\n *     // Create a basic javascript 'class'\\n *     function MyClass(name){\\n *       // Set a property at initialization\\n *       this.myName = name;\\n *     }\\n *     // Create an instance method\\n *     MyClass.prototype.sayMyName = function(){\\n *       alert(this.myName);\\n *     };\\n *     // Subclass the exisitng class and change the name\\n *     // when initializing\\n *     var MySubClass = videojs.extend(MyClass, {\\n *       constructor: function(name) {\\n *         // Call the super class constructor for the subclass\\n *         MyClass.call(this, name)\\n *       }\\n *     });\\n *     // Create an instance of the new sub class\\n *     var myInstance = new MySubClass('John');\\n *     myInstance.sayMyName(); // -> should alert \\\"John\\\"\\n * ```\\n *\\n * @param {Function} The Class to subclass\\n * @param {Object} An object including instace methods for the new class\\n *                   Optionally including a `constructor` function\\n * @return {Function} The newly created subclass\\n * @mixes videojs\\n * @method extend\\n */\\nvideojs.extend = _extendJs2['default'];\\n\\n/**\\n * Merge two options objects recursively\\n * Performs a deep merge like lodash.merge but **only merges plain objects**\\n * (not arrays, elements, anything else)\\n * Other values will be copied directly from the second object.\\n * ```js\\n *     var defaultOptions = {\\n *       foo: true,\\n *       bar: {\\n *         a: true,\\n *         b: [1,2,3]\\n *       }\\n *     };\\n *     var newOptions = {\\n *       foo: false,\\n *       bar: {\\n *         b: [4,5,6]\\n *       }\\n *     };\\n *     var result = videojs.mergeOptions(defaultOptions, newOptions);\\n *     // result.foo = false;\\n *     // result.bar.a = true;\\n *     // result.bar.b = [4,5,6];\\n * ```\\n *\\n * @param {Object} defaults  The options object whose values will be overriden\\n * @param {Object} overrides The options object with values to override the first\\n * @param {Object} etc       Any number of additional options objects\\n *\\n * @return {Object} a new object with the merged values\\n * @mixes videojs\\n * @method mergeOptions\\n */\\nvideojs.mergeOptions = _srcJsUtilsMergeOptionsJs2['default'];\\n\\n/**\\n * Change the context (this) of a function\\n *\\n *     videojs.bind(newContext, function(){\\n *       this === newContext\\n *     });\\n *\\n * NOTE: as of v5.0 we require an ES5 shim, so you should use the native\\n * `function(){}.bind(newContext);` instead of this.\\n *\\n * @param  {*}        context The object to bind as scope\\n * @param  {Function} fn      The function to be bound to a scope\\n * @param  {Number=}  uid     An optional unique ID for the function to be set\\n * @return {Function}\\n */\\nvideojs.bind = Fn.bind;\\n\\n/**\\n * Create a Video.js player plugin\\n * Plugins are only initialized when options for the plugin are included\\n * in the player options, or the plugin function on the player instance is\\n * called.\\n * **See the plugin guide in the docs for a more detailed example**\\n * ```js\\n *     // Make a plugin that alerts when the player plays\\n *     videojs.plugin('myPlugin', function(myPluginOptions) {\\n *       myPluginOptions = myPluginOptions || {};\\n *\\n *       var player = this;\\n *       var alertText = myPluginOptions.text || 'Player is playing!'\\n *\\n *       player.on('play', function(){\\n *         alert(alertText);\\n *       });\\n *     });\\n *     // USAGE EXAMPLES\\n *     // EXAMPLE 1: New player with plugin options, call plugin immediately\\n *     var player1 = videojs('idOne', {\\n *       myPlugin: {\\n *         text: 'Custom text!'\\n *       }\\n *     });\\n *     // Click play\\n *     // --> Should alert 'Custom text!'\\n *     // EXAMPLE 3: New player, initialize plugin later\\n *     var player3 = videojs('idThree');\\n *     // Click play\\n *     // --> NO ALERT\\n *     // Click pause\\n *     // Initialize plugin using the plugin function on the player instance\\n *     player3.myPlugin({\\n *       text: 'Plugin added later!'\\n *     });\\n *     // Click play\\n *     // --> Should alert 'Plugin added later!'\\n * ```\\n *\\n * @param {String} name The plugin name\\n * @param {Function} fn The plugin function that will be called with options\\n * @mixes videojs\\n * @method plugin\\n */\\nvideojs.plugin = _pluginsJs2['default'];\\n\\n/**\\n * Adding languages so that they're available to all players.\\n * ```js\\n *     videojs.addLanguage('es', { 'Hello': 'Hola' });\\n * ```\\n *\\n * @param  {String} code The language code or dictionary property\\n * @param  {Object} data The data values to be translated\\n * @return {Object} The resulting language dictionary object\\n * @mixes videojs\\n * @method addLanguage\\n */\\nvideojs.addLanguage = function (code, data) {\\n  var _merge;\\n\\n  code = ('' + code).toLowerCase();\\n  return _lodashCompatObjectMerge2['default'](videojs.options.languages, (_merge = {}, _merge[code] = data, _merge))[code];\\n};\\n\\n/**\\n * Log debug messages.\\n *\\n * @param {...Object} messages One or more messages to log\\n */\\nvideojs.log = _utilsLogJs2['default'];\\n\\n/**\\n * Creates an emulated TimeRange object.\\n *\\n * @param  {Number|Array} start Start time in seconds or an array of ranges\\n * @param  {Number} end   End time in seconds\\n * @return {Object}       Fake TimeRange object\\n * @method createTimeRange\\n */\\nvideojs.createTimeRange = videojs.createTimeRanges = _utilsTimeRangesJs.createTimeRanges;\\n\\n/**\\n * Format seconds as a time string, H:MM:SS or M:SS\\n * Supplying a guide (in seconds) will force a number of leading zeros\\n * to cover the length of the guide\\n *\\n * @param  {Number} seconds Number of seconds to be turned into a string\\n * @param  {Number} guide   Number (in seconds) to model the string after\\n * @return {String}         Time formatted as H:MM:SS or M:SS\\n * @method formatTime\\n */\\nvideojs.formatTime = _utilsFormatTimeJs2['default'];\\n\\n/**\\n * Resolve and parse the elements of a URL\\n *\\n * @param  {String} url The url to parse\\n * @return {Object}     An object of url details\\n * @method parseUrl\\n */\\nvideojs.parseUrl = Url.parseUrl;\\n\\n/**\\n * Returns whether the url passed is a cross domain request or not.\\n *\\n * @param {String} url The url to check\\n * @return {Boolean}   Whether it is a cross domain request or not\\n * @method isCrossOrigin\\n */\\nvideojs.isCrossOrigin = Url.isCrossOrigin;\\n\\n/**\\n * Event target class.\\n *\\n * @type {Function}\\n */\\nvideojs.EventTarget = _eventTarget2['default'];\\n\\n/**\\n * Add an event listener to element\\n * It stores the handler function in a separate cache object\\n * and adds a generic handler to the element's event,\\n * along with a unique id (guid) to the element.\\n *\\n * @param  {Element|Object}   elem Element or object to bind listeners to\\n * @param  {String|Array}   type Type of event to bind to.\\n * @param  {Function} fn   Event listener.\\n * @method on\\n */\\nvideojs.on = Events.on;\\n\\n/**\\n * Trigger a listener only once for an event\\n *\\n * @param  {Element|Object}   elem Element or object to\\n * @param  {String|Array}   type Name/type of event\\n * @param  {Function} fn Event handler function\\n * @method one\\n */\\nvideojs.one = Events.one;\\n\\n/**\\n * Removes event listeners from an element\\n *\\n * @param  {Element|Object}   elem Object to remove listeners from\\n * @param  {String|Array=}   type Type of listener to remove. Don't include to remove all events from element.\\n * @param  {Function} fn   Specific listener to remove. Don't include to remove listeners for an event type.\\n * @method off\\n */\\nvideojs.off = Events.off;\\n\\n/**\\n * Trigger an event for an element\\n *\\n * @param  {Element|Object}      elem  Element to trigger an event on\\n * @param  {Event|Object|String} event A string (the type) or an event object with a type attribute\\n * @param  {Object} [hash] data hash to pass along with the event\\n * @return {Boolean=} Returned only if default was prevented\\n * @method trigger\\n */\\nvideojs.trigger = Events.trigger;\\n\\n/**\\n * A cross-browser XMLHttpRequest wrapper. Here's a simple example:\\n *\\n *     videojs.xhr({\\n *       body: someJSONString,\\n *       uri: \\\"/foo\\\",\\n *       headers: {\\n *         \\\"Content-Type\\\": \\\"application/json\\\"\\n *       }\\n *     }, function (err, resp, body) {\\n *       // check resp.statusCode\\n *     });\\n *\\n * Check out the [full\\n * documentation](https://github.com/Raynos/xhr/blob/v2.1.0/README.md)\\n * for more options.\\n *\\n * @param {Object} options settings for the request.\\n * @return {XMLHttpRequest|XDomainRequest} the request object.\\n * @see https://github.com/Raynos/xhr\\n */\\nvideojs.xhr = _xhr2['default'];\\n\\n/**\\n * TextTrack class\\n *\\n * @type {Function}\\n */\\nvideojs.TextTrack = _tracksTextTrackJs2['default'];\\n\\n/**\\n * export the AudioTrack class so that source handlers can create\\n * AudioTracks and then add them to the players AudioTrackList\\n *\\n * @type {Function}\\n */\\nvideojs.AudioTrack = _tracksAudioTrackJs2['default'];\\n\\n/**\\n * export the VideoTrack class so that source handlers can create\\n * VideoTracks and then add them to the players VideoTrackList\\n *\\n * @type {Function}\\n */\\nvideojs.VideoTrack = _tracksVideoTrackJs2['default'];\\n\\n/**\\n * Determines, via duck typing, whether or not a value is a DOM element.\\n *\\n * @method isEl\\n * @param  {Mixed} value\\n * @return {Boolean}\\n */\\nvideojs.isEl = Dom.isEl;\\n\\n/**\\n * Determines, via duck typing, whether or not a value is a text node.\\n *\\n * @method isTextNode\\n * @param  {Mixed} value\\n * @return {Boolean}\\n */\\nvideojs.isTextNode = Dom.isTextNode;\\n\\n/**\\n * Creates an element and applies properties.\\n *\\n * @method createEl\\n * @param  {String} [tagName='div'] Name of tag to be created.\\n * @param  {Object} [properties={}] Element properties to be applied.\\n * @param  {Object} [attributes={}] Element attributes to be applied.\\n * @return {Element}\\n */\\nvideojs.createEl = Dom.createEl;\\n\\n/**\\n * Check if an element has a CSS class\\n *\\n * @method hasClass\\n * @param {Element} element Element to check\\n * @param {String} classToCheck Classname to check\\n */\\nvideojs.hasClass = Dom.hasElClass;\\n\\n/**\\n * Add a CSS class name to an element\\n *\\n * @method addClass\\n * @param {Element} element    Element to add class name to\\n * @param {String} classToAdd Classname to add\\n */\\nvideojs.addClass = Dom.addElClass;\\n\\n/**\\n * Remove a CSS class name from an element\\n *\\n * @method removeClass\\n * @param {Element} element    Element to remove from class name\\n * @param {String} classToRemove Classname to remove\\n */\\nvideojs.removeClass = Dom.removeElClass;\\n\\n/**\\n * Adds or removes a CSS class name on an element depending on an optional\\n * condition or the presence/absence of the class name.\\n *\\n * @method toggleElClass\\n * @param  {Element} element\\n * @param  {String} classToToggle\\n * @param  {Boolean|Function} [predicate]\\n *         Can be a function that returns a Boolean. If `true`, the class\\n *         will be added; if `false`, the class will be removed. If not\\n *         given, the class will be added if not present and vice versa.\\n */\\nvideojs.toggleClass = Dom.toggleElClass;\\n\\n/**\\n * Apply attributes to an HTML element.\\n *\\n * @method setAttributes\\n * @param  {Element} el         Target element.\\n * @param  {Object=} attributes Element attributes to be applied.\\n */\\nvideojs.setAttributes = Dom.setElAttributes;\\n\\n/**\\n * Get an element's attribute values, as defined on the HTML tag\\n * Attributes are not the same as properties. They're defined on the tag\\n * or with setAttribute (which shouldn't be used with HTML)\\n * This will return true or false for boolean attributes.\\n *\\n * @method getAttributes\\n * @param  {Element} tag Element from which to get tag attributes\\n * @return {Object}\\n */\\nvideojs.getAttributes = Dom.getElAttributes;\\n\\n/**\\n * Empties the contents of an element.\\n *\\n * @method emptyEl\\n * @param  {Element} el\\n * @return {Element}\\n */\\nvideojs.emptyEl = Dom.emptyEl;\\n\\n/**\\n * Normalizes and appends content to an element.\\n *\\n * The content for an element can be passed in multiple types and\\n * combinations, whose behavior is as follows:\\n *\\n * - String\\n *   Normalized into a text node.\\n *\\n * - Element, TextNode\\n *   Passed through.\\n *\\n * - Array\\n *   A one-dimensional array of strings, elements, nodes, or functions (which\\n *   return single strings, elements, or nodes).\\n *\\n * - Function\\n *   If the sole argument, is expected to produce a string, element,\\n *   node, or array.\\n *\\n * @method appendContent\\n * @param  {Element} el\\n * @param  {String|Element|TextNode|Array|Function} content\\n * @return {Element}\\n */\\nvideojs.appendContent = Dom.appendContent;\\n\\n/**\\n * Normalizes and inserts content into an element; this is identical to\\n * `appendContent()`, except it empties the element first.\\n *\\n * The content for an element can be passed in multiple types and\\n * combinations, whose behavior is as follows:\\n *\\n * - String\\n *   Normalized into a text node.\\n *\\n * - Element, TextNode\\n *   Passed through.\\n *\\n * - Array\\n *   A one-dimensional array of strings, elements, nodes, or functions (which\\n *   return single strings, elements, or nodes).\\n *\\n * - Function\\n *   If the sole argument, is expected to produce a string, element,\\n *   node, or array.\\n *\\n * @method insertContent\\n * @param  {Element} el\\n * @param  {String|Element|TextNode|Array|Function} content\\n * @return {Element}\\n */\\nvideojs.insertContent = Dom.insertContent;\\n\\n/*\\n * Custom Universal Module Definition (UMD)\\n *\\n * Video.js will never be a non-browser lib so we can simplify UMD a bunch and\\n * still support requirejs and browserify. This also needs to be closure\\n * compiler compatible, so string keys are used.\\n */\\nif (typeof define === 'function' && define['amd']) {\\n  define('videojs', [], function () {\\n    return videojs;\\n  });\\n\\n  // checking that module is an object too because of umdjs/umd#35\\n} else if (typeof exports === 'object' && typeof module === 'object') {\\n    module['exports'] = videojs;\\n  }\\n\\nexports['default'] = videojs;\\nmodule.exports = exports['default'];\\n\\n},{\\\"../../src/js/utils/merge-options.js\\\":148,\\\"./component\\\":67,\\\"./event-target\\\":104,\\\"./extend.js\\\":105,\\\"./player\\\":113,\\\"./plugins.js\\\":114,\\\"./setup\\\":118,\\\"./tech/flash.js\\\":121,\\\"./tech/html5.js\\\":122,\\\"./tech/tech.js\\\":124,\\\"./tracks/audio-track.js\\\":126,\\\"./tracks/text-track.js\\\":134,\\\"./tracks/video-track.js\\\":139,\\\"./utils/browser.js\\\":140,\\\"./utils/dom.js\\\":142,\\\"./utils/events.js\\\":143,\\\"./utils/fn.js\\\":144,\\\"./utils/format-time.js\\\":145,\\\"./utils/log.js\\\":147,\\\"./utils/stylesheet.js\\\":149,\\\"./utils/time-ranges.js\\\":150,\\\"./utils/url.js\\\":152,\\\"global/document\\\":1,\\\"global/window\\\":2,\\\"lodash-compat/object/merge\\\":40,\\\"xhr\\\":56}]},{},[153])(153)\\n});\\n\\n\\n//# sourceMappingURL=video.js.map\\n/* vtt.js - v0.12.1 (https://github.com/mozilla/vtt.js) built on 08-07-2015 */\\n\\n(function(root) {\\n  var vttjs = root.vttjs = {};\\n  var cueShim = vttjs.VTTCue;\\n  var regionShim = vttjs.VTTRegion;\\n  var oldVTTCue = root.VTTCue;\\n  var oldVTTRegion = root.VTTRegion;\\n\\n  vttjs.shim = function() {\\n    vttjs.VTTCue = cueShim;\\n    vttjs.VTTRegion = regionShim;\\n  };\\n\\n  vttjs.restore = function() {\\n    vttjs.VTTCue = oldVTTCue;\\n    vttjs.VTTRegion = oldVTTRegion;\\n  };\\n}(this));\\n\\n/**\\n * Copyright 2013 vtt.js Contributors\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *   http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n(function(root, vttjs) {\\n\\n  var autoKeyword = \\\"auto\\\";\\n  var directionSetting = {\\n    \\\"\\\": true,\\n    \\\"lr\\\": true,\\n    \\\"rl\\\": true\\n  };\\n  var alignSetting = {\\n    \\\"start\\\": true,\\n    \\\"middle\\\": true,\\n    \\\"end\\\": true,\\n    \\\"left\\\": true,\\n    \\\"right\\\": true\\n  };\\n\\n  function findDirectionSetting(value) {\\n    if (typeof value !== \\\"string\\\") {\\n      return false;\\n    }\\n    var dir = directionSetting[value.toLowerCase()];\\n    return dir ? value.toLowerCase() : false;\\n  }\\n\\n  function findAlignSetting(value) {\\n    if (typeof value !== \\\"string\\\") {\\n      return false;\\n    }\\n    var align = alignSetting[value.toLowerCase()];\\n    return align ? value.toLowerCase() : false;\\n  }\\n\\n  function extend(obj) {\\n    var i = 1;\\n    for (; i < arguments.length; i++) {\\n      var cobj = arguments[i];\\n      for (var p in cobj) {\\n        obj[p] = cobj[p];\\n      }\\n    }\\n\\n    return obj;\\n  }\\n\\n  function VTTCue(startTime, endTime, text) {\\n    var cue = this;\\n    var isIE8 = (/MSIE\\\\s8\\\\.0/).test(navigator.userAgent);\\n    var baseObj = {};\\n\\n    if (isIE8) {\\n      cue = document.createElement('custom');\\n    } else {\\n      baseObj.enumerable = true;\\n    }\\n\\n    /**\\n     * Shim implementation specific properties. These properties are not in\\n     * the spec.\\n     */\\n\\n    // Lets us know when the VTTCue's data has changed in such a way that we need\\n    // to recompute its display state. This lets us compute its display state\\n    // lazily.\\n    cue.hasBeenReset = false;\\n\\n    /**\\n     * VTTCue and TextTrackCue properties\\n     * http://dev.w3.org/html5/webvtt/#vttcue-interface\\n     */\\n\\n    var _id = \\\"\\\";\\n    var _pauseOnExit = false;\\n    var _startTime = startTime;\\n    var _endTime = endTime;\\n    var _text = text;\\n    var _region = null;\\n    var _vertical = \\\"\\\";\\n    var _snapToLines = true;\\n    var _line = \\\"auto\\\";\\n    var _lineAlign = \\\"start\\\";\\n    var _position = 50;\\n    var _positionAlign = \\\"middle\\\";\\n    var _size = 50;\\n    var _align = \\\"middle\\\";\\n\\n    Object.defineProperty(cue,\\n      \\\"id\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _id;\\n        },\\n        set: function(value) {\\n          _id = \\\"\\\" + value;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"pauseOnExit\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _pauseOnExit;\\n        },\\n        set: function(value) {\\n          _pauseOnExit = !!value;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"startTime\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _startTime;\\n        },\\n        set: function(value) {\\n          if (typeof value !== \\\"number\\\") {\\n            throw new TypeError(\\\"Start time must be set to a number.\\\");\\n          }\\n          _startTime = value;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"endTime\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _endTime;\\n        },\\n        set: function(value) {\\n          if (typeof value !== \\\"number\\\") {\\n            throw new TypeError(\\\"End time must be set to a number.\\\");\\n          }\\n          _endTime = value;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"text\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _text;\\n        },\\n        set: function(value) {\\n          _text = \\\"\\\" + value;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"region\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _region;\\n        },\\n        set: function(value) {\\n          _region = value;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"vertical\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _vertical;\\n        },\\n        set: function(value) {\\n          var setting = findDirectionSetting(value);\\n          // Have to check for false because the setting an be an empty string.\\n          if (setting === false) {\\n            throw new SyntaxError(\\\"An invalid or illegal string was specified.\\\");\\n          }\\n          _vertical = setting;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"snapToLines\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _snapToLines;\\n        },\\n        set: function(value) {\\n          _snapToLines = !!value;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"line\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _line;\\n        },\\n        set: function(value) {\\n          if (typeof value !== \\\"number\\\" && value !== autoKeyword) {\\n            throw new SyntaxError(\\\"An invalid number or illegal string was specified.\\\");\\n          }\\n          _line = value;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"lineAlign\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _lineAlign;\\n        },\\n        set: function(value) {\\n          var setting = findAlignSetting(value);\\n          if (!setting) {\\n            throw new SyntaxError(\\\"An invalid or illegal string was specified.\\\");\\n          }\\n          _lineAlign = setting;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"position\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _position;\\n        },\\n        set: function(value) {\\n          if (value < 0 || value > 100) {\\n            throw new Error(\\\"Position must be between 0 and 100.\\\");\\n          }\\n          _position = value;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"positionAlign\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _positionAlign;\\n        },\\n        set: function(value) {\\n          var setting = findAlignSetting(value);\\n          if (!setting) {\\n            throw new SyntaxError(\\\"An invalid or illegal string was specified.\\\");\\n          }\\n          _positionAlign = setting;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"size\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _size;\\n        },\\n        set: function(value) {\\n          if (value < 0 || value > 100) {\\n            throw new Error(\\\"Size must be between 0 and 100.\\\");\\n          }\\n          _size = value;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    Object.defineProperty(cue,\\n      \\\"align\\\", extend({}, baseObj, {\\n        get: function() {\\n          return _align;\\n        },\\n        set: function(value) {\\n          var setting = findAlignSetting(value);\\n          if (!setting) {\\n            throw new SyntaxError(\\\"An invalid or illegal string was specified.\\\");\\n          }\\n          _align = setting;\\n          this.hasBeenReset = true;\\n        }\\n      }));\\n\\n    /**\\n     * Other <track> spec defined properties\\n     */\\n\\n    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\\n    cue.displayState = undefined;\\n\\n    if (isIE8) {\\n      return cue;\\n    }\\n  }\\n\\n  /**\\n   * VTTCue methods\\n   */\\n\\n  VTTCue.prototype.getCueAsHTML = function() {\\n    // Assume WebVTT.convertCueToDOMTree is on the global.\\n    return WebVTT.convertCueToDOMTree(window, this.text);\\n  };\\n\\n  root.VTTCue = root.VTTCue || VTTCue;\\n  vttjs.VTTCue = VTTCue;\\n}(this, (this.vttjs || {})));\\n\\n/**\\n * Copyright 2013 vtt.js Contributors\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *   http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n(function(root, vttjs) {\\n\\n  var scrollSetting = {\\n    \\\"\\\": true,\\n    \\\"up\\\": true\\n  };\\n\\n  function findScrollSetting(value) {\\n    if (typeof value !== \\\"string\\\") {\\n      return false;\\n    }\\n    var scroll = scrollSetting[value.toLowerCase()];\\n    return scroll ? value.toLowerCase() : false;\\n  }\\n\\n  function isValidPercentValue(value) {\\n    return typeof value === \\\"number\\\" && (value >= 0 && value <= 100);\\n  }\\n\\n  // VTTRegion shim http://dev.w3.org/html5/webvtt/#vttregion-interface\\n  function VTTRegion() {\\n    var _width = 100;\\n    var _lines = 3;\\n    var _regionAnchorX = 0;\\n    var _regionAnchorY = 100;\\n    var _viewportAnchorX = 0;\\n    var _viewportAnchorY = 100;\\n    var _scroll = \\\"\\\";\\n\\n    Object.defineProperties(this, {\\n      \\\"width\\\": {\\n        enumerable: true,\\n        get: function() {\\n          return _width;\\n        },\\n        set: function(value) {\\n          if (!isValidPercentValue(value)) {\\n            throw new Error(\\\"Width must be between 0 and 100.\\\");\\n          }\\n          _width = value;\\n        }\\n      },\\n      \\\"lines\\\": {\\n        enumerable: true,\\n        get: function() {\\n          return _lines;\\n        },\\n        set: function(value) {\\n          if (typeof value !== \\\"number\\\") {\\n            throw new TypeError(\\\"Lines must be set to a number.\\\");\\n          }\\n          _lines = value;\\n        }\\n      },\\n      \\\"regionAnchorY\\\": {\\n        enumerable: true,\\n        get: function() {\\n          return _regionAnchorY;\\n        },\\n        set: function(value) {\\n          if (!isValidPercentValue(value)) {\\n            throw new Error(\\\"RegionAnchorX must be between 0 and 100.\\\");\\n          }\\n          _regionAnchorY = value;\\n        }\\n      },\\n      \\\"regionAnchorX\\\": {\\n        enumerable: true,\\n        get: function() {\\n          return _regionAnchorX;\\n        },\\n        set: function(value) {\\n          if(!isValidPercentValue(value)) {\\n            throw new Error(\\\"RegionAnchorY must be between 0 and 100.\\\");\\n          }\\n          _regionAnchorX = value;\\n        }\\n      },\\n      \\\"viewportAnchorY\\\": {\\n        enumerable: true,\\n        get: function() {\\n          return _viewportAnchorY;\\n        },\\n        set: function(value) {\\n          if (!isValidPercentValue(value)) {\\n            throw new Error(\\\"ViewportAnchorY must be between 0 and 100.\\\");\\n          }\\n          _viewportAnchorY = value;\\n        }\\n      },\\n      \\\"viewportAnchorX\\\": {\\n        enumerable: true,\\n        get: function() {\\n          return _viewportAnchorX;\\n        },\\n        set: function(value) {\\n          if (!isValidPercentValue(value)) {\\n            throw new Error(\\\"ViewportAnchorX must be between 0 and 100.\\\");\\n          }\\n          _viewportAnchorX = value;\\n        }\\n      },\\n      \\\"scroll\\\": {\\n        enumerable: true,\\n        get: function() {\\n          return _scroll;\\n        },\\n        set: function(value) {\\n          var setting = findScrollSetting(value);\\n          // Have to check for false as an empty string is a legal value.\\n          if (setting === false) {\\n            throw new SyntaxError(\\\"An invalid or illegal string was specified.\\\");\\n          }\\n          _scroll = setting;\\n        }\\n      }\\n    });\\n  }\\n\\n  root.VTTRegion = root.VTTRegion || VTTRegion;\\n  vttjs.VTTRegion = VTTRegion;\\n}(this, (this.vttjs || {})));\\n\\n/**\\n * Copyright 2013 vtt.js Contributors\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *   http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\\n\\n(function(global) {\\n\\n  var _objCreate = Object.create || (function() {\\n    function F() {}\\n    return function(o) {\\n      if (arguments.length !== 1) {\\n        throw new Error('Object.create shim only accepts one parameter.');\\n      }\\n      F.prototype = o;\\n      return new F();\\n    };\\n  })();\\n\\n  // Creates a new ParserError object from an errorData object. The errorData\\n  // object should have default code and message properties. The default message\\n  // property can be overriden by passing in a message parameter.\\n  // See ParsingError.Errors below for acceptable errors.\\n  function ParsingError(errorData, message) {\\n    this.name = \\\"ParsingError\\\";\\n    this.code = errorData.code;\\n    this.message = message || errorData.message;\\n  }\\n  ParsingError.prototype = _objCreate(Error.prototype);\\n  ParsingError.prototype.constructor = ParsingError;\\n\\n  // ParsingError metadata for acceptable ParsingErrors.\\n  ParsingError.Errors = {\\n    BadSignature: {\\n      code: 0,\\n      message: \\\"Malformed WebVTT signature.\\\"\\n    },\\n    BadTimeStamp: {\\n      code: 1,\\n      message: \\\"Malformed time stamp.\\\"\\n    }\\n  };\\n\\n  // Try to parse input as a time stamp.\\n  function parseTimeStamp(input) {\\n\\n    function computeSeconds(h, m, s, f) {\\n      return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;\\n    }\\n\\n    var m = input.match(/^(\\\\d+):(\\\\d{2})(:\\\\d{2})?\\\\.(\\\\d{3})/);\\n    if (!m) {\\n      return null;\\n    }\\n\\n    if (m[3]) {\\n      // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]\\n      return computeSeconds(m[1], m[2], m[3].replace(\\\":\\\", \\\"\\\"), m[4]);\\n    } else if (m[1] > 59) {\\n      // Timestamp takes the form of [hours]:[minutes].[milliseconds]\\n      // First position is hours as it's over 59.\\n      return computeSeconds(m[1], m[2], 0,  m[4]);\\n    } else {\\n      // Timestamp takes the form of [minutes]:[seconds].[milliseconds]\\n      return computeSeconds(0, m[1], m[2], m[4]);\\n    }\\n  }\\n\\n  // A settings object holds key/value pairs and will ignore anything but the first\\n  // assignment to a specific key.\\n  function Settings() {\\n    this.values = _objCreate(null);\\n  }\\n\\n  Settings.prototype = {\\n    // Only accept the first assignment to any key.\\n    set: function(k, v) {\\n      if (!this.get(k) && v !== \\\"\\\") {\\n        this.values[k] = v;\\n      }\\n    },\\n    // Return the value for a key, or a default value.\\n    // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\\n    // a number of possible default values as properties where 'defaultKey' is\\n    // the key of the property that will be chosen; otherwise it's assumed to be\\n    // a single value.\\n    get: function(k, dflt, defaultKey) {\\n      if (defaultKey) {\\n        return this.has(k) ? this.values[k] : dflt[defaultKey];\\n      }\\n      return this.has(k) ? this.values[k] : dflt;\\n    },\\n    // Check whether we have a value for a key.\\n    has: function(k) {\\n      return k in this.values;\\n    },\\n    // Accept a setting if its one of the given alternatives.\\n    alt: function(k, v, a) {\\n      for (var n = 0; n < a.length; ++n) {\\n        if (v === a[n]) {\\n          this.set(k, v);\\n          break;\\n        }\\n      }\\n    },\\n    // Accept a setting if its a valid (signed) integer.\\n    integer: function(k, v) {\\n      if (/^-?\\\\d+$/.test(v)) { // integer\\n        this.set(k, parseInt(v, 10));\\n      }\\n    },\\n    // Accept a setting if its a valid percentage.\\n    percent: function(k, v) {\\n      var m;\\n      if ((m = v.match(/^([\\\\d]{1,3})(\\\\.[\\\\d]*)?%$/))) {\\n        v = parseFloat(v);\\n        if (v >= 0 && v <= 100) {\\n          this.set(k, v);\\n          return true;\\n        }\\n      }\\n      return false;\\n    }\\n  };\\n\\n  // Helper function to parse input into groups separated by 'groupDelim', and\\n  // interprete each group as a key/value pair separated by 'keyValueDelim'.\\n  function parseOptions(input, callback, keyValueDelim, groupDelim) {\\n    var groups = groupDelim ? input.split(groupDelim) : [input];\\n    for (var i in groups) {\\n      if (typeof groups[i] !== \\\"string\\\") {\\n        continue;\\n      }\\n      var kv = groups[i].split(keyValueDelim);\\n      if (kv.length !== 2) {\\n        continue;\\n      }\\n      var k = kv[0];\\n      var v = kv[1];\\n      callback(k, v);\\n    }\\n  }\\n\\n  function parseCue(input, cue, regionList) {\\n    // Remember the original input if we need to throw an error.\\n    var oInput = input;\\n    // 4.1 WebVTT timestamp\\n    function consumeTimeStamp() {\\n      var ts = parseTimeStamp(input);\\n      if (ts === null) {\\n        throw new ParsingError(ParsingError.Errors.BadTimeStamp,\\n                              \\\"Malformed timestamp: \\\" + oInput);\\n      }\\n      // Remove time stamp from input.\\n      input = input.replace(/^[^\\\\sa-zA-Z-]+/, \\\"\\\");\\n      return ts;\\n    }\\n\\n    // 4.4.2 WebVTT cue settings\\n    function consumeCueSettings(input, cue) {\\n      var settings = new Settings();\\n\\n      parseOptions(input, function (k, v) {\\n        switch (k) {\\n        case \\\"region\\\":\\n          // Find the last region we parsed with the same region id.\\n          for (var i = regionList.length - 1; i >= 0; i--) {\\n            if (regionList[i].id === v) {\\n              settings.set(k, regionList[i].region);\\n              break;\\n            }\\n          }\\n          break;\\n        case \\\"vertical\\\":\\n          settings.alt(k, v, [\\\"rl\\\", \\\"lr\\\"]);\\n          break;\\n        case \\\"line\\\":\\n          var vals = v.split(\\\",\\\"),\\n              vals0 = vals[0];\\n          settings.integer(k, vals0);\\n          settings.percent(k, vals0) ? settings.set(\\\"snapToLines\\\", false) : null;\\n          settings.alt(k, vals0, [\\\"auto\\\"]);\\n          if (vals.length === 2) {\\n            settings.alt(\\\"lineAlign\\\", vals[1], [\\\"start\\\", \\\"middle\\\", \\\"end\\\"]);\\n          }\\n          break;\\n        case \\\"position\\\":\\n          vals = v.split(\\\",\\\");\\n          settings.percent(k, vals[0]);\\n          if (vals.length === 2) {\\n            settings.alt(\\\"positionAlign\\\", vals[1], [\\\"start\\\", \\\"middle\\\", \\\"end\\\"]);\\n          }\\n          break;\\n        case \\\"size\\\":\\n          settings.percent(k, v);\\n          break;\\n        case \\\"align\\\":\\n          settings.alt(k, v, [\\\"start\\\", \\\"middle\\\", \\\"end\\\", \\\"left\\\", \\\"right\\\"]);\\n          break;\\n        }\\n      }, /:/, /\\\\s/);\\n\\n      // Apply default values for any missing fields.\\n      cue.region = settings.get(\\\"region\\\", null);\\n      cue.vertical = settings.get(\\\"vertical\\\", \\\"\\\");\\n      cue.line = settings.get(\\\"line\\\", \\\"auto\\\");\\n      cue.lineAlign = settings.get(\\\"lineAlign\\\", \\\"start\\\");\\n      cue.snapToLines = settings.get(\\\"snapToLines\\\", true);\\n      cue.size = settings.get(\\\"size\\\", 100);\\n      cue.align = settings.get(\\\"align\\\", \\\"middle\\\");\\n      cue.position = settings.get(\\\"position\\\", {\\n        start: 0,\\n        left: 0,\\n        middle: 50,\\n        end: 100,\\n        right: 100\\n      }, cue.align);\\n      cue.positionAlign = settings.get(\\\"positionAlign\\\", {\\n        start: \\\"start\\\",\\n        left: \\\"start\\\",\\n        middle: \\\"middle\\\",\\n        end: \\\"end\\\",\\n        right: \\\"end\\\"\\n      }, cue.align);\\n    }\\n\\n    function skipWhitespace() {\\n      input = input.replace(/^\\\\s+/, \\\"\\\");\\n    }\\n\\n    // 4.1 WebVTT cue timings.\\n    skipWhitespace();\\n    cue.startTime = consumeTimeStamp();   // (1) collect cue start time\\n    skipWhitespace();\\n    if (input.substr(0, 3) !== \\\"-->\\\") {     // (3) next characters must match \\\"-->\\\"\\n      throw new ParsingError(ParsingError.Errors.BadTimeStamp,\\n                             \\\"Malformed time stamp (time stamps must be separated by '-->'): \\\" +\\n                             oInput);\\n    }\\n    input = input.substr(3);\\n    skipWhitespace();\\n    cue.endTime = consumeTimeStamp();     // (5) collect cue end time\\n\\n    // 4.1 WebVTT cue settings list.\\n    skipWhitespace();\\n    consumeCueSettings(input, cue);\\n  }\\n\\n  var ESCAPE = {\\n    \\\"&amp;\\\": \\\"&\\\",\\n    \\\"&lt;\\\": \\\"<\\\",\\n    \\\"&gt;\\\": \\\">\\\",\\n    \\\"&lrm;\\\": \\\"\\\\u200e\\\",\\n    \\\"&rlm;\\\": \\\"\\\\u200f\\\",\\n    \\\"&nbsp;\\\": \\\"\\\\u00a0\\\"\\n  };\\n\\n  var TAG_NAME = {\\n    c: \\\"span\\\",\\n    i: \\\"i\\\",\\n    b: \\\"b\\\",\\n    u: \\\"u\\\",\\n    ruby: \\\"ruby\\\",\\n    rt: \\\"rt\\\",\\n    v: \\\"span\\\",\\n    lang: \\\"span\\\"\\n  };\\n\\n  var TAG_ANNOTATION = {\\n    v: \\\"title\\\",\\n    lang: \\\"lang\\\"\\n  };\\n\\n  var NEEDS_PARENT = {\\n    rt: \\\"ruby\\\"\\n  };\\n\\n  // Parse content into a document fragment.\\n  function parseContent(window, input) {\\n    function nextToken() {\\n      // Check for end-of-string.\\n      if (!input) {\\n        return null;\\n      }\\n\\n      // Consume 'n' characters from the input.\\n      function consume(result) {\\n        input = input.substr(result.length);\\n        return result;\\n      }\\n\\n      var m = input.match(/^([^<]*)(<[^>]+>?)?/);\\n      // If there is some text before the next tag, return it, otherwise return\\n      // the tag.\\n      return consume(m[1] ? m[1] : m[2]);\\n    }\\n\\n    // Unescape a string 's'.\\n    function unescape1(e) {\\n      return ESCAPE[e];\\n    }\\n    function unescape(s) {\\n      while ((m = s.match(/&(amp|lt|gt|lrm|rlm|nbsp);/))) {\\n        s = s.replace(m[0], unescape1);\\n      }\\n      return s;\\n    }\\n\\n    function shouldAdd(current, element) {\\n      return !NEEDS_PARENT[element.localName] ||\\n             NEEDS_PARENT[element.localName] === current.localName;\\n    }\\n\\n    // Create an element for this tag.\\n    function createElement(type, annotation) {\\n      var tagName = TAG_NAME[type];\\n      if (!tagName) {\\n        return null;\\n      }\\n      var element = window.document.createElement(tagName);\\n      element.localName = tagName;\\n      var name = TAG_ANNOTATION[type];\\n      if (name && annotation) {\\n        element[name] = annotation.trim();\\n      }\\n      return element;\\n    }\\n\\n    var rootDiv = window.document.createElement(\\\"div\\\"),\\n        current = rootDiv,\\n        t,\\n        tagStack = [];\\n\\n    while ((t = nextToken()) !== null) {\\n      if (t[0] === '<') {\\n        if (t[1] === \\\"/\\\") {\\n          // If the closing tag matches, move back up to the parent node.\\n          if (tagStack.length &&\\n              tagStack[tagStack.length - 1] === t.substr(2).replace(\\\">\\\", \\\"\\\")) {\\n            tagStack.pop();\\n            current = current.parentNode;\\n          }\\n          // Otherwise just ignore the end tag.\\n          continue;\\n        }\\n        var ts = parseTimeStamp(t.substr(1, t.length - 2));\\n        var node;\\n        if (ts) {\\n          // Timestamps are lead nodes as well.\\n          node = window.document.createProcessingInstruction(\\\"timestamp\\\", ts);\\n          current.appendChild(node);\\n          continue;\\n        }\\n        var m = t.match(/^<([^.\\\\s/0-9>]+)(\\\\.[^\\\\s\\\\\\\\>]+)?([^>\\\\\\\\]+)?(\\\\\\\\?)>?$/);\\n        // If we can't parse the tag, skip to the next tag.\\n        if (!m) {\\n          continue;\\n        }\\n        // Try to construct an element, and ignore the tag if we couldn't.\\n        node = createElement(m[1], m[3]);\\n        if (!node) {\\n          continue;\\n        }\\n        // Determine if the tag should be added based on the context of where it\\n        // is placed in the cuetext.\\n        if (!shouldAdd(current, node)) {\\n          continue;\\n        }\\n        // Set the class list (as a list of classes, separated by space).\\n        if (m[2]) {\\n          node.className = m[2].substr(1).replace('.', ' ');\\n        }\\n        // Append the node to the current node, and enter the scope of the new\\n        // node.\\n        tagStack.push(m[1]);\\n        current.appendChild(node);\\n        current = node;\\n        continue;\\n      }\\n\\n      // Text nodes are leaf nodes.\\n      current.appendChild(window.document.createTextNode(unescape(t)));\\n    }\\n\\n    return rootDiv;\\n  }\\n\\n  // This is a list of all the Unicode characters that have a strong\\n  // right-to-left category. What this means is that these characters are\\n  // written right-to-left for sure. It was generated by pulling all the strong\\n  // right-to-left characters out of the Unicode data table. That table can\\n  // found at: http://www.unicode.org/Public/UNIDATA/UnicodeData.txt\\n  var strongRTLChars = [0x05BE, 0x05C0, 0x05C3, 0x05C6, 0x05D0, 0x05D1,\\n      0x05D2, 0x05D3, 0x05D4, 0x05D5, 0x05D6, 0x05D7, 0x05D8, 0x05D9, 0x05DA,\\n      0x05DB, 0x05DC, 0x05DD, 0x05DE, 0x05DF, 0x05E0, 0x05E1, 0x05E2, 0x05E3,\\n      0x05E4, 0x05E5, 0x05E6, 0x05E7, 0x05E8, 0x05E9, 0x05EA, 0x05F0, 0x05F1,\\n      0x05F2, 0x05F3, 0x05F4, 0x0608, 0x060B, 0x060D, 0x061B, 0x061E, 0x061F,\\n      0x0620, 0x0621, 0x0622, 0x0623, 0x0624, 0x0625, 0x0626, 0x0627, 0x0628,\\n      0x0629, 0x062A, 0x062B, 0x062C, 0x062D, 0x062E, 0x062F, 0x0630, 0x0631,\\n      0x0632, 0x0633, 0x0634, 0x0635, 0x0636, 0x0637, 0x0638, 0x0639, 0x063A,\\n      0x063B, 0x063C, 0x063D, 0x063E, 0x063F, 0x0640, 0x0641, 0x0642, 0x0643,\\n      0x0644, 0x0645, 0x0646, 0x0647, 0x0648, 0x0649, 0x064A, 0x066D, 0x066E,\\n      0x066F, 0x0671, 0x0672, 0x0673, 0x0674, 0x0675, 0x0676, 0x0677, 0x0678,\\n      0x0679, 0x067A, 0x067B, 0x067C, 0x067D, 0x067E, 0x067F, 0x0680, 0x0681,\\n      0x0682, 0x0683, 0x0684, 0x0685, 0x0686, 0x0687, 0x0688, 0x0689, 0x068A,\\n      0x068B, 0x068C, 0x068D, 0x068E, 0x068F, 0x0690, 0x0691, 0x0692, 0x0693,\\n      0x0694, 0x0695, 0x0696, 0x0697, 0x0698, 0x0699, 0x069A, 0x069B, 0x069C,\\n      0x069D, 0x069E, 0x069F, 0x06A0, 0x06A1, 0x06A2, 0x06A3, 0x06A4, 0x06A5,\\n      0x06A6, 0x06A7, 0x06A8, 0x06A9, 0x06AA, 0x06AB, 0x06AC, 0x06AD, 0x06AE,\\n      0x06AF, 0x06B0, 0x06B1, 0x06B2, 0x06B3, 0x06B4, 0x06B5, 0x06B6, 0x06B7,\\n      0x06B8, 0x06B9, 0x06BA, 0x06BB, 0x06BC, 0x06BD, 0x06BE, 0x06BF, 0x06C0,\\n      0x06C1, 0x06C2, 0x06C3, 0x06C4, 0x06C5, 0x06C6, 0x06C7, 0x06C8, 0x06C9,\\n      0x06CA, 0x06CB, 0x06CC, 0x06CD, 0x06CE, 0x06CF, 0x06D0, 0x06D1, 0x06D2,\\n      0x06D3, 0x06D4, 0x06D5, 0x06E5, 0x06E6, 0x06EE, 0x06EF, 0x06FA, 0x06FB,\\n      0x06FC, 0x06FD, 0x06FE, 0x06FF, 0x0700, 0x0701, 0x0702, 0x0703, 0x0704,\\n      0x0705, 0x0706, 0x0707, 0x0708, 0x0709, 0x070A, 0x070B, 0x070C, 0x070D,\\n      0x070F, 0x0710, 0x0712, 0x0713, 0x0714, 0x0715, 0x0716, 0x0717, 0x0718,\\n      0x0719, 0x071A, 0x071B, 0x071C, 0x071D, 0x071E, 0x071F, 0x0720, 0x0721,\\n      0x0722, 0x0723, 0x0724, 0x0725, 0x0726, 0x0727, 0x0728, 0x0729, 0x072A,\\n      0x072B, 0x072C, 0x072D, 0x072E, 0x072F, 0x074D, 0x074E, 0x074F, 0x0750,\\n      0x0751, 0x0752, 0x0753, 0x0754, 0x0755, 0x0756, 0x0757, 0x0758, 0x0759,\\n      0x075A, 0x075B, 0x075C, 0x075D, 0x075E, 0x075F, 0x0760, 0x0761, 0x0762,\\n      0x0763, 0x0764, 0x0765, 0x0766, 0x0767, 0x0768, 0x0769, 0x076A, 0x076B,\\n      0x076C, 0x076D, 0x076E, 0x076F, 0x0770, 0x0771, 0x0772, 0x0773, 0x0774,\\n      0x0775, 0x0776, 0x0777, 0x0778, 0x0779, 0x077A, 0x077B, 0x077C, 0x077D,\\n      0x077E, 0x077F, 0x0780, 0x0781, 0x0782, 0x0783, 0x0784, 0x0785, 0x0786,\\n      0x0787, 0x0788, 0x0789, 0x078A, 0x078B, 0x078C, 0x078D, 0x078E, 0x078F,\\n      0x0790, 0x0791, 0x0792, 0x0793, 0x0794, 0x0795, 0x0796, 0x0797, 0x0798,\\n      0x0799, 0x079A, 0x079B, 0x079C, 0x079D, 0x079E, 0x079F, 0x07A0, 0x07A1,\\n      0x07A2, 0x07A3, 0x07A4, 0x07A5, 0x07B1, 0x07C0, 0x07C1, 0x07C2, 0x07C3,\\n      0x07C4, 0x07C5, 0x07C6, 0x07C7, 0x07C8, 0x07C9, 0x07CA, 0x07CB, 0x07CC,\\n      0x07CD, 0x07CE, 0x07CF, 0x07D0, 0x07D1, 0x07D2, 0x07D3, 0x07D4, 0x07D5,\\n      0x07D6, 0x07D7, 0x07D8, 0x07D9, 0x07DA, 0x07DB, 0x07DC, 0x07DD, 0x07DE,\\n      0x07DF, 0x07E0, 0x07E1, 0x07E2, 0x07E3, 0x07E4, 0x07E5, 0x07E6, 0x07E7,\\n      0x07E8, 0x07E9, 0x07EA, 0x07F4, 0x07F5, 0x07FA, 0x0800, 0x0801, 0x0802,\\n      0x0803, 0x0804, 0x0805, 0x0806, 0x0807, 0x0808, 0x0809, 0x080A, 0x080B,\\n      0x080C, 0x080D, 0x080E, 0x080F, 0x0810, 0x0811, 0x0812, 0x0813, 0x0814,\\n      0x0815, 0x081A, 0x0824, 0x0828, 0x0830, 0x0831, 0x0832, 0x0833, 0x0834,\\n      0x0835, 0x0836, 0x0837, 0x0838, 0x0839, 0x083A, 0x083B, 0x083C, 0x083D,\\n      0x083E, 0x0840, 0x0841, 0x0842, 0x0843, 0x0844, 0x0845, 0x0846, 0x0847,\\n      0x0848, 0x0849, 0x084A, 0x084B, 0x084C, 0x084D, 0x084E, 0x084F, 0x0850,\\n      0x0851, 0x0852, 0x0853, 0x0854, 0x0855, 0x0856, 0x0857, 0x0858, 0x085E,\\n      0x08A0, 0x08A2, 0x08A3, 0x08A4, 0x08A5, 0x08A6, 0x08A7, 0x08A8, 0x08A9,\\n      0x08AA, 0x08AB, 0x08AC, 0x200F, 0xFB1D, 0xFB1F, 0xFB20, 0xFB21, 0xFB22,\\n      0xFB23, 0xFB24, 0xFB25, 0xFB26, 0xFB27, 0xFB28, 0xFB2A, 0xFB2B, 0xFB2C,\\n      0xFB2D, 0xFB2E, 0xFB2F, 0xFB30, 0xFB31, 0xFB32, 0xFB33, 0xFB34, 0xFB35,\\n      0xFB36, 0xFB38, 0xFB39, 0xFB3A, 0xFB3B, 0xFB3C, 0xFB3E, 0xFB40, 0xFB41,\\n      0xFB43, 0xFB44, 0xFB46, 0xFB47, 0xFB48, 0xFB49, 0xFB4A, 0xFB4B, 0xFB4C,\\n      0xFB4D, 0xFB4E, 0xFB4F, 0xFB50, 0xFB51, 0xFB52, 0xFB53, 0xFB54, 0xFB55,\\n      0xFB56, 0xFB57, 0xFB58, 0xFB59, 0xFB5A, 0xFB5B, 0xFB5C, 0xFB5D, 0xFB5E,\\n      0xFB5F, 0xFB60, 0xFB61, 0xFB62, 0xFB63, 0xFB64, 0xFB65, 0xFB66, 0xFB67,\\n      0xFB68, 0xFB69, 0xFB6A, 0xFB6B, 0xFB6C, 0xFB6D, 0xFB6E, 0xFB6F, 0xFB70,\\n      0xFB71, 0xFB72, 0xFB73, 0xFB74, 0xFB75, 0xFB76, 0xFB77, 0xFB78, 0xFB79,\\n      0xFB7A, 0xFB7B, 0xFB7C, 0xFB7D, 0xFB7E, 0xFB7F, 0xFB80, 0xFB81, 0xFB82,\\n      0xFB83, 0xFB84, 0xFB85, 0xFB86, 0xFB87, 0xFB88, 0xFB89, 0xFB8A, 0xFB8B,\\n      0xFB8C, 0xFB8D, 0xFB8E, 0xFB8F, 0xFB90, 0xFB91, 0xFB92, 0xFB93, 0xFB94,\\n      0xFB95, 0xFB96, 0xFB97, 0xFB98, 0xFB99, 0xFB9A, 0xFB9B, 0xFB9C, 0xFB9D,\\n      0xFB9E, 0xFB9F, 0xFBA0, 0xFBA1, 0xFBA2, 0xFBA3, 0xFBA4, 0xFBA5, 0xFBA6,\\n      0xFBA7, 0xFBA8, 0xFBA9, 0xFBAA, 0xFBAB, 0xFBAC, 0xFBAD, 0xFBAE, 0xFBAF,\\n      0xFBB0, 0xFBB1, 0xFBB2, 0xFBB3, 0xFBB4, 0xFBB5, 0xFBB6, 0xFBB7, 0xFBB8,\\n      0xFBB9, 0xFBBA, 0xFBBB, 0xFBBC, 0xFBBD, 0xFBBE, 0xFBBF, 0xFBC0, 0xFBC1,\\n      0xFBD3, 0xFBD4, 0xFBD5, 0xFBD6, 0xFBD7, 0xFBD8, 0xFBD9, 0xFBDA, 0xFBDB,\\n      0xFBDC, 0xFBDD, 0xFBDE, 0xFBDF, 0xFBE0, 0xFBE1, 0xFBE2, 0xFBE3, 0xFBE4,\\n      0xFBE5, 0xFBE6, 0xFBE7, 0xFBE8, 0xFBE9, 0xFBEA, 0xFBEB, 0xFBEC, 0xFBED,\\n      0xFBEE, 0xFBEF, 0xFBF0, 0xFBF1, 0xFBF2, 0xFBF3, 0xFBF4, 0xFBF5, 0xFBF6,\\n      0xFBF7, 0xFBF8, 0xFBF9, 0xFBFA, 0xFBFB, 0xFBFC, 0xFBFD, 0xFBFE, 0xFBFF,\\n      0xFC00, 0xFC01, 0xFC02, 0xFC03, 0xFC04, 0xFC05, 0xFC06, 0xFC07, 0xFC08,\\n      0xFC09, 0xFC0A, 0xFC0B, 0xFC0C, 0xFC0D, 0xFC0E, 0xFC0F, 0xFC10, 0xFC11,\\n      0xFC12, 0xFC13, 0xFC14, 0xFC15, 0xFC16, 0xFC17, 0xFC18, 0xFC19, 0xFC1A,\\n      0xFC1B, 0xFC1C, 0xFC1D, 0xFC1E, 0xFC1F, 0xFC20, 0xFC21, 0xFC22, 0xFC23,\\n      0xFC24, 0xFC25, 0xFC26, 0xFC27, 0xFC28, 0xFC29, 0xFC2A, 0xFC2B, 0xFC2C,\\n      0xFC2D, 0xFC2E, 0xFC2F, 0xFC30, 0xFC31, 0xFC32, 0xFC33, 0xFC34, 0xFC35,\\n      0xFC36, 0xFC37, 0xFC38, 0xFC39, 0xFC3A, 0xFC3B, 0xFC3C, 0xFC3D, 0xFC3E,\\n      0xFC3F, 0xFC40, 0xFC41, 0xFC42, 0xFC43, 0xFC44, 0xFC45, 0xFC46, 0xFC47,\\n      0xFC48, 0xFC49, 0xFC4A, 0xFC4B, 0xFC4C, 0xFC4D, 0xFC4E, 0xFC4F, 0xFC50,\\n      0xFC51, 0xFC52, 0xFC53, 0xFC54, 0xFC55, 0xFC56, 0xFC57, 0xFC58, 0xFC59,\\n      0xFC5A, 0xFC5B, 0xFC5C, 0xFC5D, 0xFC5E, 0xFC5F, 0xFC60, 0xFC61, 0xFC62,\\n      0xFC63, 0xFC64, 0xFC65, 0xFC66, 0xFC67, 0xFC68, 0xFC69, 0xFC6A, 0xFC6B,\\n      0xFC6C, 0xFC6D, 0xFC6E, 0xFC6F, 0xFC70, 0xFC71, 0xFC72, 0xFC73, 0xFC74,\\n      0xFC75, 0xFC76, 0xFC77, 0xFC78, 0xFC79, 0xFC7A, 0xFC7B, 0xFC7C, 0xFC7D,\\n      0xFC7E, 0xFC7F, 0xFC80, 0xFC81, 0xFC82, 0xFC83, 0xFC84, 0xFC85, 0xFC86,\\n      0xFC87, 0xFC88, 0xFC89, 0xFC8A, 0xFC8B, 0xFC8C, 0xFC8D, 0xFC8E, 0xFC8F,\\n      0xFC90, 0xFC91, 0xFC92, 0xFC93, 0xFC94, 0xFC95, 0xFC96, 0xFC97, 0xFC98,\\n      0xFC99, 0xFC9A, 0xFC9B, 0xFC9C, 0xFC9D, 0xFC9E, 0xFC9F, 0xFCA0, 0xFCA1,\\n      0xFCA2, 0xFCA3, 0xFCA4, 0xFCA5, 0xFCA6, 0xFCA7, 0xFCA8, 0xFCA9, 0xFCAA,\\n      0xFCAB, 0xFCAC, 0xFCAD, 0xFCAE, 0xFCAF, 0xFCB0, 0xFCB1, 0xFCB2, 0xFCB3,\\n      0xFCB4, 0xFCB5, 0xFCB6, 0xFCB7, 0xFCB8, 0xFCB9, 0xFCBA, 0xFCBB, 0xFCBC,\\n      0xFCBD, 0xFCBE, 0xFCBF, 0xFCC0, 0xFCC1, 0xFCC2, 0xFCC3, 0xFCC4, 0xFCC5,\\n      0xFCC6, 0xFCC7, 0xFCC8, 0xFCC9, 0xFCCA, 0xFCCB, 0xFCCC, 0xFCCD, 0xFCCE,\\n      0xFCCF, 0xFCD0, 0xFCD1, 0xFCD2, 0xFCD3, 0xFCD4, 0xFCD5, 0xFCD6, 0xFCD7,\\n      0xFCD8, 0xFCD9, 0xFCDA, 0xFCDB, 0xFCDC, 0xFCDD, 0xFCDE, 0xFCDF, 0xFCE0,\\n      0xFCE1, 0xFCE2, 0xFCE3, 0xFCE4, 0xFCE5, 0xFCE6, 0xFCE7, 0xFCE8, 0xFCE9,\\n      0xFCEA, 0xFCEB, 0xFCEC, 0xFCED, 0xFCEE, 0xFCEF, 0xFCF0, 0xFCF1, 0xFCF2,\\n      0xFCF3, 0xFCF4, 0xFCF5, 0xFCF6, 0xFCF7, 0xFCF8, 0xFCF9, 0xFCFA, 0xFCFB,\\n      0xFCFC, 0xFCFD, 0xFCFE, 0xFCFF, 0xFD00, 0xFD01, 0xFD02, 0xFD03, 0xFD04,\\n      0xFD05, 0xFD06, 0xFD07, 0xFD08, 0xFD09, 0xFD0A, 0xFD0B, 0xFD0C, 0xFD0D,\\n      0xFD0E, 0xFD0F, 0xFD10, 0xFD11, 0xFD12, 0xFD13, 0xFD14, 0xFD15, 0xFD16,\\n      0xFD17, 0xFD18, 0xFD19, 0xFD1A, 0xFD1B, 0xFD1C, 0xFD1D, 0xFD1E, 0xFD1F,\\n      0xFD20, 0xFD21, 0xFD22, 0xFD23, 0xFD24, 0xFD25, 0xFD26, 0xFD27, 0xFD28,\\n      0xFD29, 0xFD2A, 0xFD2B, 0xFD2C, 0xFD2D, 0xFD2E, 0xFD2F, 0xFD30, 0xFD31,\\n      0xFD32, 0xFD33, 0xFD34, 0xFD35, 0xFD36, 0xFD37, 0xFD38, 0xFD39, 0xFD3A,\\n      0xFD3B, 0xFD3C, 0xFD3D, 0xFD50, 0xFD51, 0xFD52, 0xFD53, 0xFD54, 0xFD55,\\n      0xFD56, 0xFD57, 0xFD58, 0xFD59, 0xFD5A, 0xFD5B, 0xFD5C, 0xFD5D, 0xFD5E,\\n      0xFD5F, 0xFD60, 0xFD61, 0xFD62, 0xFD63, 0xFD64, 0xFD65, 0xFD66, 0xFD67,\\n      0xFD68, 0xFD69, 0xFD6A, 0xFD6B, 0xFD6C, 0xFD6D, 0xFD6E, 0xFD6F, 0xFD70,\\n      0xFD71, 0xFD72, 0xFD73, 0xFD74, 0xFD75, 0xFD76, 0xFD77, 0xFD78, 0xFD79,\\n      0xFD7A, 0xFD7B, 0xFD7C, 0xFD7D, 0xFD7E, 0xFD7F, 0xFD80, 0xFD81, 0xFD82,\\n      0xFD83, 0xFD84, 0xFD85, 0xFD86, 0xFD87, 0xFD88, 0xFD89, 0xFD8A, 0xFD8B,\\n      0xFD8C, 0xFD8D, 0xFD8E, 0xFD8F, 0xFD92, 0xFD93, 0xFD94, 0xFD95, 0xFD96,\\n      0xFD97, 0xFD98, 0xFD99, 0xFD9A, 0xFD9B, 0xFD9C, 0xFD9D, 0xFD9E, 0xFD9F,\\n      0xFDA0, 0xFDA1, 0xFDA2, 0xFDA3, 0xFDA4, 0xFDA5, 0xFDA6, 0xFDA7, 0xFDA8,\\n      0xFDA9, 0xFDAA, 0xFDAB, 0xFDAC, 0xFDAD, 0xFDAE, 0xFDAF, 0xFDB0, 0xFDB1,\\n      0xFDB2, 0xFDB3, 0xFDB4, 0xFDB5, 0xFDB6, 0xFDB7, 0xFDB8, 0xFDB9, 0xFDBA,\\n      0xFDBB, 0xFDBC, 0xFDBD, 0xFDBE, 0xFDBF, 0xFDC0, 0xFDC1, 0xFDC2, 0xFDC3,\\n      0xFDC4, 0xFDC5, 0xFDC6, 0xFDC7, 0xFDF0, 0xFDF1, 0xFDF2, 0xFDF3, 0xFDF4,\\n      0xFDF5, 0xFDF6, 0xFDF7, 0xFDF8, 0xFDF9, 0xFDFA, 0xFDFB, 0xFDFC, 0xFE70,\\n      0xFE71, 0xFE72, 0xFE73, 0xFE74, 0xFE76, 0xFE77, 0xFE78, 0xFE79, 0xFE7A,\\n      0xFE7B, 0xFE7C, 0xFE7D, 0xFE7E, 0xFE7F, 0xFE80, 0xFE81, 0xFE82, 0xFE83,\\n      0xFE84, 0xFE85, 0xFE86, 0xFE87, 0xFE88, 0xFE89, 0xFE8A, 0xFE8B, 0xFE8C,\\n      0xFE8D, 0xFE8E, 0xFE8F, 0xFE90, 0xFE91, 0xFE92, 0xFE93, 0xFE94, 0xFE95,\\n      0xFE96, 0xFE97, 0xFE98, 0xFE99, 0xFE9A, 0xFE9B, 0xFE9C, 0xFE9D, 0xFE9E,\\n      0xFE9F, 0xFEA0, 0xFEA1, 0xFEA2, 0xFEA3, 0xFEA4, 0xFEA5, 0xFEA6, 0xFEA7,\\n      0xFEA8, 0xFEA9, 0xFEAA, 0xFEAB, 0xFEAC, 0xFEAD, 0xFEAE, 0xFEAF, 0xFEB0,\\n      0xFEB1, 0xFEB2, 0xFEB3, 0xFEB4, 0xFEB5, 0xFEB6, 0xFEB7, 0xFEB8, 0xFEB9,\\n      0xFEBA, 0xFEBB, 0xFEBC, 0xFEBD, 0xFEBE, 0xFEBF, 0xFEC0, 0xFEC1, 0xFEC2,\\n      0xFEC3, 0xFEC4, 0xFEC5, 0xFEC6, 0xFEC7, 0xFEC8, 0xFEC9, 0xFECA, 0xFECB,\\n      0xFECC, 0xFECD, 0xFECE, 0xFECF, 0xFED0, 0xFED1, 0xFED2, 0xFED3, 0xFED4,\\n      0xFED5, 0xFED6, 0xFED7, 0xFED8, 0xFED9, 0xFEDA, 0xFEDB, 0xFEDC, 0xFEDD,\\n      0xFEDE, 0xFEDF, 0xFEE0, 0xFEE1, 0xFEE2, 0xFEE3, 0xFEE4, 0xFEE5, 0xFEE6,\\n      0xFEE7, 0xFEE8, 0xFEE9, 0xFEEA, 0xFEEB, 0xFEEC, 0xFEED, 0xFEEE, 0xFEEF,\\n      0xFEF0, 0xFEF1, 0xFEF2, 0xFEF3, 0xFEF4, 0xFEF5, 0xFEF6, 0xFEF7, 0xFEF8,\\n      0xFEF9, 0xFEFA, 0xFEFB, 0xFEFC, 0x10800, 0x10801, 0x10802, 0x10803,\\n      0x10804, 0x10805, 0x10808, 0x1080A, 0x1080B, 0x1080C, 0x1080D, 0x1080E,\\n      0x1080F, 0x10810, 0x10811, 0x10812, 0x10813, 0x10814, 0x10815, 0x10816,\\n      0x10817, 0x10818, 0x10819, 0x1081A, 0x1081B, 0x1081C, 0x1081D, 0x1081E,\\n      0x1081F, 0x10820, 0x10821, 0x10822, 0x10823, 0x10824, 0x10825, 0x10826,\\n      0x10827, 0x10828, 0x10829, 0x1082A, 0x1082B, 0x1082C, 0x1082D, 0x1082E,\\n      0x1082F, 0x10830, 0x10831, 0x10832, 0x10833, 0x10834, 0x10835, 0x10837,\\n      0x10838, 0x1083C, 0x1083F, 0x10840, 0x10841, 0x10842, 0x10843, 0x10844,\\n      0x10845, 0x10846, 0x10847, 0x10848, 0x10849, 0x1084A, 0x1084B, 0x1084C,\\n      0x1084D, 0x1084E, 0x1084F, 0x10850, 0x10851, 0x10852, 0x10853, 0x10854,\\n      0x10855, 0x10857, 0x10858, 0x10859, 0x1085A, 0x1085B, 0x1085C, 0x1085D,\\n      0x1085E, 0x1085F, 0x10900, 0x10901, 0x10902, 0x10903, 0x10904, 0x10905,\\n      0x10906, 0x10907, 0x10908, 0x10909, 0x1090A, 0x1090B, 0x1090C, 0x1090D,\\n      0x1090E, 0x1090F, 0x10910, 0x10911, 0x10912, 0x10913, 0x10914, 0x10915,\\n      0x10916, 0x10917, 0x10918, 0x10919, 0x1091A, 0x1091B, 0x10920, 0x10921,\\n      0x10922, 0x10923, 0x10924, 0x10925, 0x10926, 0x10927, 0x10928, 0x10929,\\n      0x1092A, 0x1092B, 0x1092C, 0x1092D, 0x1092E, 0x1092F, 0x10930, 0x10931,\\n      0x10932, 0x10933, 0x10934, 0x10935, 0x10936, 0x10937, 0x10938, 0x10939,\\n      0x1093F, 0x10980, 0x10981, 0x10982, 0x10983, 0x10984, 0x10985, 0x10986,\\n      0x10987, 0x10988, 0x10989, 0x1098A, 0x1098B, 0x1098C, 0x1098D, 0x1098E,\\n      0x1098F, 0x10990, 0x10991, 0x10992, 0x10993, 0x10994, 0x10995, 0x10996,\\n      0x10997, 0x10998, 0x10999, 0x1099A, 0x1099B, 0x1099C, 0x1099D, 0x1099E,\\n      0x1099F, 0x109A0, 0x109A1, 0x109A2, 0x109A3, 0x109A4, 0x109A5, 0x109A6,\\n      0x109A7, 0x109A8, 0x109A9, 0x109AA, 0x109AB, 0x109AC, 0x109AD, 0x109AE,\\n      0x109AF, 0x109B0, 0x109B1, 0x109B2, 0x109B3, 0x109B4, 0x109B5, 0x109B6,\\n      0x109B7, 0x109BE, 0x109BF, 0x10A00, 0x10A10, 0x10A11, 0x10A12, 0x10A13,\\n      0x10A15, 0x10A16, 0x10A17, 0x10A19, 0x10A1A, 0x10A1B, 0x10A1C, 0x10A1D,\\n      0x10A1E, 0x10A1F, 0x10A20, 0x10A21, 0x10A22, 0x10A23, 0x10A24, 0x10A25,\\n      0x10A26, 0x10A27, 0x10A28, 0x10A29, 0x10A2A, 0x10A2B, 0x10A2C, 0x10A2D,\\n      0x10A2E, 0x10A2F, 0x10A30, 0x10A31, 0x10A32, 0x10A33, 0x10A40, 0x10A41,\\n      0x10A42, 0x10A43, 0x10A44, 0x10A45, 0x10A46, 0x10A47, 0x10A50, 0x10A51,\\n      0x10A52, 0x10A53, 0x10A54, 0x10A55, 0x10A56, 0x10A57, 0x10A58, 0x10A60,\\n      0x10A61, 0x10A62, 0x10A63, 0x10A64, 0x10A65, 0x10A66, 0x10A67, 0x10A68,\\n      0x10A69, 0x10A6A, 0x10A6B, 0x10A6C, 0x10A6D, 0x10A6E, 0x10A6F, 0x10A70,\\n      0x10A71, 0x10A72, 0x10A73, 0x10A74, 0x10A75, 0x10A76, 0x10A77, 0x10A78,\\n      0x10A79, 0x10A7A, 0x10A7B, 0x10A7C, 0x10A7D, 0x10A7E, 0x10A7F, 0x10B00,\\n      0x10B01, 0x10B02, 0x10B03, 0x10B04, 0x10B05, 0x10B06, 0x10B07, 0x10B08,\\n      0x10B09, 0x10B0A, 0x10B0B, 0x10B0C, 0x10B0D, 0x10B0E, 0x10B0F, 0x10B10,\\n      0x10B11, 0x10B12, 0x10B13, 0x10B14, 0x10B15, 0x10B16, 0x10B17, 0x10B18,\\n      0x10B19, 0x10B1A, 0x10B1B, 0x10B1C, 0x10B1D, 0x10B1E, 0x10B1F, 0x10B20,\\n      0x10B21, 0x10B22, 0x10B23, 0x10B24, 0x10B25, 0x10B26, 0x10B27, 0x10B28,\\n      0x10B29, 0x10B2A, 0x10B2B, 0x10B2C, 0x10B2D, 0x10B2E, 0x10B2F, 0x10B30,\\n      0x10B31, 0x10B32, 0x10B33, 0x10B34, 0x10B35, 0x10B40, 0x10B41, 0x10B42,\\n      0x10B43, 0x10B44, 0x10B45, 0x10B46, 0x10B47, 0x10B48, 0x10B49, 0x10B4A,\\n      0x10B4B, 0x10B4C, 0x10B4D, 0x10B4E, 0x10B4F, 0x10B50, 0x10B51, 0x10B52,\\n      0x10B53, 0x10B54, 0x10B55, 0x10B58, 0x10B59, 0x10B5A, 0x10B5B, 0x10B5C,\\n      0x10B5D, 0x10B5E, 0x10B5F, 0x10B60, 0x10B61, 0x10B62, 0x10B63, 0x10B64,\\n      0x10B65, 0x10B66, 0x10B67, 0x10B68, 0x10B69, 0x10B6A, 0x10B6B, 0x10B6C,\\n      0x10B6D, 0x10B6E, 0x10B6F, 0x10B70, 0x10B71, 0x10B72, 0x10B78, 0x10B79,\\n      0x10B7A, 0x10B7B, 0x10B7C, 0x10B7D, 0x10B7E, 0x10B7F, 0x10C00, 0x10C01,\\n      0x10C02, 0x10C03, 0x10C04, 0x10C05, 0x10C06, 0x10C07, 0x10C08, 0x10C09,\\n      0x10C0A, 0x10C0B, 0x10C0C, 0x10C0D, 0x10C0E, 0x10C0F, 0x10C10, 0x10C11,\\n      0x10C12, 0x10C13, 0x10C14, 0x10C15, 0x10C16, 0x10C17, 0x10C18, 0x10C19,\\n      0x10C1A, 0x10C1B, 0x10C1C, 0x10C1D, 0x10C1E, 0x10C1F, 0x10C20, 0x10C21,\\n      0x10C22, 0x10C23, 0x10C24, 0x10C25, 0x10C26, 0x10C27, 0x10C28, 0x10C29,\\n      0x10C2A, 0x10C2B, 0x10C2C, 0x10C2D, 0x10C2E, 0x10C2F, 0x10C30, 0x10C31,\\n      0x10C32, 0x10C33, 0x10C34, 0x10C35, 0x10C36, 0x10C37, 0x10C38, 0x10C39,\\n      0x10C3A, 0x10C3B, 0x10C3C, 0x10C3D, 0x10C3E, 0x10C3F, 0x10C40, 0x10C41,\\n      0x10C42, 0x10C43, 0x10C44, 0x10C45, 0x10C46, 0x10C47, 0x10C48, 0x1EE00,\\n      0x1EE01, 0x1EE02, 0x1EE03, 0x1EE05, 0x1EE06, 0x1EE07, 0x1EE08, 0x1EE09,\\n      0x1EE0A, 0x1EE0B, 0x1EE0C, 0x1EE0D, 0x1EE0E, 0x1EE0F, 0x1EE10, 0x1EE11,\\n      0x1EE12, 0x1EE13, 0x1EE14, 0x1EE15, 0x1EE16, 0x1EE17, 0x1EE18, 0x1EE19,\\n      0x1EE1A, 0x1EE1B, 0x1EE1C, 0x1EE1D, 0x1EE1E, 0x1EE1F, 0x1EE21, 0x1EE22,\\n      0x1EE24, 0x1EE27, 0x1EE29, 0x1EE2A, 0x1EE2B, 0x1EE2C, 0x1EE2D, 0x1EE2E,\\n      0x1EE2F, 0x1EE30, 0x1EE31, 0x1EE32, 0x1EE34, 0x1EE35, 0x1EE36, 0x1EE37,\\n      0x1EE39, 0x1EE3B, 0x1EE42, 0x1EE47, 0x1EE49, 0x1EE4B, 0x1EE4D, 0x1EE4E,\\n      0x1EE4F, 0x1EE51, 0x1EE52, 0x1EE54, 0x1EE57, 0x1EE59, 0x1EE5B, 0x1EE5D,\\n      0x1EE5F, 0x1EE61, 0x1EE62, 0x1EE64, 0x1EE67, 0x1EE68, 0x1EE69, 0x1EE6A,\\n      0x1EE6C, 0x1EE6D, 0x1EE6E, 0x1EE6F, 0x1EE70, 0x1EE71, 0x1EE72, 0x1EE74,\\n      0x1EE75, 0x1EE76, 0x1EE77, 0x1EE79, 0x1EE7A, 0x1EE7B, 0x1EE7C, 0x1EE7E,\\n      0x1EE80, 0x1EE81, 0x1EE82, 0x1EE83, 0x1EE84, 0x1EE85, 0x1EE86, 0x1EE87,\\n      0x1EE88, 0x1EE89, 0x1EE8B, 0x1EE8C, 0x1EE8D, 0x1EE8E, 0x1EE8F, 0x1EE90,\\n      0x1EE91, 0x1EE92, 0x1EE93, 0x1EE94, 0x1EE95, 0x1EE96, 0x1EE97, 0x1EE98,\\n      0x1EE99, 0x1EE9A, 0x1EE9B, 0x1EEA1, 0x1EEA2, 0x1EEA3, 0x1EEA5, 0x1EEA6,\\n      0x1EEA7, 0x1EEA8, 0x1EEA9, 0x1EEAB, 0x1EEAC, 0x1EEAD, 0x1EEAE, 0x1EEAF,\\n      0x1EEB0, 0x1EEB1, 0x1EEB2, 0x1EEB3, 0x1EEB4, 0x1EEB5, 0x1EEB6, 0x1EEB7,\\n      0x1EEB8, 0x1EEB9, 0x1EEBA, 0x1EEBB, 0x10FFFD];\\n\\n  function determineBidi(cueDiv) {\\n    var nodeStack = [],\\n        text = \\\"\\\",\\n        charCode;\\n\\n    if (!cueDiv || !cueDiv.childNodes) {\\n      return \\\"ltr\\\";\\n    }\\n\\n    function pushNodes(nodeStack, node) {\\n      for (var i = node.childNodes.length - 1; i >= 0; i--) {\\n        nodeStack.push(node.childNodes[i]);\\n      }\\n    }\\n\\n    function nextTextNode(nodeStack) {\\n      if (!nodeStack || !nodeStack.length) {\\n        return null;\\n      }\\n\\n      var node = nodeStack.pop(),\\n          text = node.textContent || node.innerText;\\n      if (text) {\\n        // TODO: This should match all unicode type B characters (paragraph\\n        // separator characters). See issue #115.\\n        var m = text.match(/^.*(\\\\n|\\\\r)/);\\n        if (m) {\\n          nodeStack.length = 0;\\n          return m[0];\\n        }\\n        return text;\\n      }\\n      if (node.tagName === \\\"ruby\\\") {\\n        return nextTextNode(nodeStack);\\n      }\\n      if (node.childNodes) {\\n        pushNodes(nodeStack, node);\\n        return nextTextNode(nodeStack);\\n      }\\n    }\\n\\n    pushNodes(nodeStack, cueDiv);\\n    while ((text = nextTextNode(nodeStack))) {\\n      for (var i = 0; i < text.length; i++) {\\n        charCode = text.charCodeAt(i);\\n        for (var j = 0; j < strongRTLChars.length; j++) {\\n          if (strongRTLChars[j] === charCode) {\\n            return \\\"rtl\\\";\\n          }\\n        }\\n      }\\n    }\\n    return \\\"ltr\\\";\\n  }\\n\\n  function computeLinePos(cue) {\\n    if (typeof cue.line === \\\"number\\\" &&\\n        (cue.snapToLines || (cue.line >= 0 && cue.line <= 100))) {\\n      return cue.line;\\n    }\\n    if (!cue.track || !cue.track.textTrackList ||\\n        !cue.track.textTrackList.mediaElement) {\\n      return -1;\\n    }\\n    var track = cue.track,\\n        trackList = track.textTrackList,\\n        count = 0;\\n    for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {\\n      if (trackList[i].mode === \\\"showing\\\") {\\n        count++;\\n      }\\n    }\\n    return ++count * -1;\\n  }\\n\\n  function StyleBox() {\\n  }\\n\\n  // Apply styles to a div. If there is no div passed then it defaults to the\\n  // div on 'this'.\\n  StyleBox.prototype.applyStyles = function(styles, div) {\\n    div = div || this.div;\\n    for (var prop in styles) {\\n      if (styles.hasOwnProperty(prop)) {\\n        div.style[prop] = styles[prop];\\n      }\\n    }\\n  };\\n\\n  StyleBox.prototype.formatStyle = function(val, unit) {\\n    return val === 0 ? 0 : val + unit;\\n  };\\n\\n  // Constructs the computed display state of the cue (a div). Places the div\\n  // into the overlay which should be a block level element (usually a div).\\n  function CueStyleBox(window, cue, styleOptions) {\\n    var isIE8 = (/MSIE\\\\s8\\\\.0/).test(navigator.userAgent);\\n    var color = \\\"rgba(255, 255, 255, 1)\\\";\\n    var backgroundColor = \\\"rgba(0, 0, 0, 0.8)\\\";\\n\\n    if (isIE8) {\\n      color = \\\"rgb(255, 255, 255)\\\";\\n      backgroundColor = \\\"rgb(0, 0, 0)\\\";\\n    }\\n\\n    StyleBox.call(this);\\n    this.cue = cue;\\n\\n    // Parse our cue's text into a DOM tree rooted at 'cueDiv'. This div will\\n    // have inline positioning and will function as the cue background box.\\n    this.cueDiv = parseContent(window, cue.text);\\n    var styles = {\\n      color: color,\\n      backgroundColor: backgroundColor,\\n      position: \\\"relative\\\",\\n      left: 0,\\n      right: 0,\\n      top: 0,\\n      bottom: 0,\\n      display: \\\"inline\\\"\\n    };\\n\\n    if (!isIE8) {\\n      styles.writingMode = cue.vertical === \\\"\\\" ? \\\"horizontal-tb\\\"\\n                                               : cue.vertical === \\\"lr\\\" ? \\\"vertical-lr\\\"\\n                                                                       : \\\"vertical-rl\\\";\\n      styles.unicodeBidi = \\\"plaintext\\\";\\n    }\\n    this.applyStyles(styles, this.cueDiv);\\n\\n    // Create an absolutely positioned div that will be used to position the cue\\n    // div. Note, all WebVTT cue-setting alignments are equivalent to the CSS\\n    // mirrors of them except \\\"middle\\\" which is \\\"center\\\" in CSS.\\n    this.div = window.document.createElement(\\\"div\\\");\\n    styles = {\\n      textAlign: cue.align === \\\"middle\\\" ? \\\"center\\\" : cue.align,\\n      font: styleOptions.font,\\n      whiteSpace: \\\"pre-line\\\",\\n      position: \\\"absolute\\\"\\n    };\\n\\n    if (!isIE8) {\\n      styles.direction = determineBidi(this.cueDiv);\\n      styles.writingMode = cue.vertical === \\\"\\\" ? \\\"horizontal-tb\\\"\\n                                               : cue.vertical === \\\"lr\\\" ? \\\"vertical-lr\\\"\\n                                                                       : \\\"vertical-rl\\\".\\n      stylesunicodeBidi =  \\\"plaintext\\\";\\n    }\\n\\n    this.applyStyles(styles);\\n\\n    this.div.appendChild(this.cueDiv);\\n\\n    // Calculate the distance from the reference edge of the viewport to the text\\n    // position of the cue box. The reference edge will be resolved later when\\n    // the box orientation styles are applied.\\n    var textPos = 0;\\n    switch (cue.positionAlign) {\\n    case \\\"start\\\":\\n      textPos = cue.position;\\n      break;\\n    case \\\"middle\\\":\\n      textPos = cue.position - (cue.size / 2);\\n      break;\\n    case \\\"end\\\":\\n      textPos = cue.position - cue.size;\\n      break;\\n    }\\n\\n    // Horizontal box orientation; textPos is the distance from the left edge of the\\n    // area to the left edge of the box and cue.size is the distance extending to\\n    // the right from there.\\n    if (cue.vertical === \\\"\\\") {\\n      this.applyStyles({\\n        left:  this.formatStyle(textPos, \\\"%\\\"),\\n        width: this.formatStyle(cue.size, \\\"%\\\")\\n      });\\n    // Vertical box orientation; textPos is the distance from the top edge of the\\n    // area to the top edge of the box and cue.size is the height extending\\n    // downwards from there.\\n    } else {\\n      this.applyStyles({\\n        top: this.formatStyle(textPos, \\\"%\\\"),\\n        height: this.formatStyle(cue.size, \\\"%\\\")\\n      });\\n    }\\n\\n    this.move = function(box) {\\n      this.applyStyles({\\n        top: this.formatStyle(box.top, \\\"px\\\"),\\n        bottom: this.formatStyle(box.bottom, \\\"px\\\"),\\n        left: this.formatStyle(box.left, \\\"px\\\"),\\n        right: this.formatStyle(box.right, \\\"px\\\"),\\n        height: this.formatStyle(box.height, \\\"px\\\"),\\n        width: this.formatStyle(box.width, \\\"px\\\")\\n      });\\n    };\\n  }\\n  CueStyleBox.prototype = _objCreate(StyleBox.prototype);\\n  CueStyleBox.prototype.constructor = CueStyleBox;\\n\\n  // Represents the co-ordinates of an Element in a way that we can easily\\n  // compute things with such as if it overlaps or intersects with another Element.\\n  // Can initialize it with either a StyleBox or another BoxPosition.\\n  function BoxPosition(obj) {\\n    var isIE8 = (/MSIE\\\\s8\\\\.0/).test(navigator.userAgent);\\n\\n    // Either a BoxPosition was passed in and we need to copy it, or a StyleBox\\n    // was passed in and we need to copy the results of 'getBoundingClientRect'\\n    // as the object returned is readonly. All co-ordinate values are in reference\\n    // to the viewport origin (top left).\\n    var lh, height, width, top;\\n    if (obj.div) {\\n      height = obj.div.offsetHeight;\\n      width = obj.div.offsetWidth;\\n      top = obj.div.offsetTop;\\n\\n      var rects = (rects = obj.div.childNodes) && (rects = rects[0]) &&\\n                  rects.getClientRects && rects.getClientRects();\\n      obj = obj.div.getBoundingClientRect();\\n      // In certain cases the outter div will be slightly larger then the sum of\\n      // the inner div's lines. This could be due to bold text, etc, on some platforms.\\n      // In this case we should get the average line height and use that. This will\\n      // result in the desired behaviour.\\n      lh = rects ? Math.max((rects[0] && rects[0].height) || 0, obj.height / rects.length)\\n                 : 0;\\n\\n    }\\n    this.left = obj.left;\\n    this.right = obj.right;\\n    this.top = obj.top || top;\\n    this.height = obj.height || height;\\n    this.bottom = obj.bottom || (top + (obj.height || height));\\n    this.width = obj.width || width;\\n    this.lineHeight = lh !== undefined ? lh : obj.lineHeight;\\n\\n    if (isIE8 && !this.lineHeight) {\\n      this.lineHeight = 13;\\n    }\\n  }\\n\\n  // Move the box along a particular axis. Optionally pass in an amount to move\\n  // the box. If no amount is passed then the default is the line height of the\\n  // box.\\n  BoxPosition.prototype.move = function(axis, toMove) {\\n    toMove = toMove !== undefined ? toMove : this.lineHeight;\\n    switch (axis) {\\n    case \\\"+x\\\":\\n      this.left += toMove;\\n      this.right += toMove;\\n      break;\\n    case \\\"-x\\\":\\n      this.left -= toMove;\\n      this.right -= toMove;\\n      break;\\n    case \\\"+y\\\":\\n      this.top += toMove;\\n      this.bottom += toMove;\\n      break;\\n    case \\\"-y\\\":\\n      this.top -= toMove;\\n      this.bottom -= toMove;\\n      break;\\n    }\\n  };\\n\\n  // Check if this box overlaps another box, b2.\\n  BoxPosition.prototype.overlaps = function(b2) {\\n    return this.left < b2.right &&\\n           this.right > b2.left &&\\n           this.top < b2.bottom &&\\n           this.bottom > b2.top;\\n  };\\n\\n  // Check if this box overlaps any other boxes in boxes.\\n  BoxPosition.prototype.overlapsAny = function(boxes) {\\n    for (var i = 0; i < boxes.length; i++) {\\n      if (this.overlaps(boxes[i])) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  };\\n\\n  // Check if this box is within another box.\\n  BoxPosition.prototype.within = function(container) {\\n    return this.top >= container.top &&\\n           this.bottom <= container.bottom &&\\n           this.left >= container.left &&\\n           this.right <= container.right;\\n  };\\n\\n  // Check if this box is entirely within the container or it is overlapping\\n  // on the edge opposite of the axis direction passed. For example, if \\\"+x\\\" is\\n  // passed and the box is overlapping on the left edge of the container, then\\n  // return true.\\n  BoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {\\n    switch (axis) {\\n    case \\\"+x\\\":\\n      return this.left < container.left;\\n    case \\\"-x\\\":\\n      return this.right > container.right;\\n    case \\\"+y\\\":\\n      return this.top < container.top;\\n    case \\\"-y\\\":\\n      return this.bottom > container.bottom;\\n    }\\n  };\\n\\n  // Find the percentage of the area that this box is overlapping with another\\n  // box.\\n  BoxPosition.prototype.intersectPercentage = function(b2) {\\n    var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)),\\n        y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)),\\n        intersectArea = x * y;\\n    return intersectArea / (this.height * this.width);\\n  };\\n\\n  // Convert the positions from this box to CSS compatible positions using\\n  // the reference container's positions. This has to be done because this\\n  // box's positions are in reference to the viewport origin, whereas, CSS\\n  // values are in referecne to their respective edges.\\n  BoxPosition.prototype.toCSSCompatValues = function(reference) {\\n    return {\\n      top: this.top - reference.top,\\n      bottom: reference.bottom - this.bottom,\\n      left: this.left - reference.left,\\n      right: reference.right - this.right,\\n      height: this.height,\\n      width: this.width\\n    };\\n  };\\n\\n  // Get an object that represents the box's position without anything extra.\\n  // Can pass a StyleBox, HTMLElement, or another BoxPositon.\\n  BoxPosition.getSimpleBoxPosition = function(obj) {\\n    var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;\\n    var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;\\n    var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;\\n\\n    obj = obj.div ? obj.div.getBoundingClientRect() :\\n                  obj.tagName ? obj.getBoundingClientRect() : obj;\\n    var ret = {\\n      left: obj.left,\\n      right: obj.right,\\n      top: obj.top || top,\\n      height: obj.height || height,\\n      bottom: obj.bottom || (top + (obj.height || height)),\\n      width: obj.width || width\\n    };\\n    return ret;\\n  };\\n\\n  // Move a StyleBox to its specified, or next best, position. The containerBox\\n  // is the box that contains the StyleBox, such as a div. boxPositions are\\n  // a list of other boxes that the styleBox can't overlap with.\\n  function moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {\\n\\n    // Find the best position for a cue box, b, on the video. The axis parameter\\n    // is a list of axis, the order of which, it will move the box along. For example:\\n    // Passing [\\\"+x\\\", \\\"-x\\\"] will move the box first along the x axis in the positive\\n    // direction. If it doesn't find a good position for it there it will then move\\n    // it along the x axis in the negative direction.\\n    function findBestPosition(b, axis) {\\n      var bestPosition,\\n          specifiedPosition = new BoxPosition(b),\\n          percentage = 1; // Highest possible so the first thing we get is better.\\n\\n      for (var i = 0; i < axis.length; i++) {\\n        while (b.overlapsOppositeAxis(containerBox, axis[i]) ||\\n               (b.within(containerBox) && b.overlapsAny(boxPositions))) {\\n          b.move(axis[i]);\\n        }\\n        // We found a spot where we aren't overlapping anything. This is our\\n        // best position.\\n        if (b.within(containerBox)) {\\n          return b;\\n        }\\n        var p = b.intersectPercentage(containerBox);\\n        // If we're outside the container box less then we were on our last try\\n        // then remember this position as the best position.\\n        if (percentage > p) {\\n          bestPosition = new BoxPosition(b);\\n          percentage = p;\\n        }\\n        // Reset the box position to the specified position.\\n        b = new BoxPosition(specifiedPosition);\\n      }\\n      return bestPosition || specifiedPosition;\\n    }\\n\\n    var boxPosition = new BoxPosition(styleBox),\\n        cue = styleBox.cue,\\n        linePos = computeLinePos(cue),\\n        axis = [];\\n\\n    // If we have a line number to align the cue to.\\n    if (cue.snapToLines) {\\n      var size;\\n      switch (cue.vertical) {\\n      case \\\"\\\":\\n        axis = [ \\\"+y\\\", \\\"-y\\\" ];\\n        size = \\\"height\\\";\\n        break;\\n      case \\\"rl\\\":\\n        axis = [ \\\"+x\\\", \\\"-x\\\" ];\\n        size = \\\"width\\\";\\n        break;\\n      case \\\"lr\\\":\\n        axis = [ \\\"-x\\\", \\\"+x\\\" ];\\n        size = \\\"width\\\";\\n        break;\\n      }\\n\\n      var step = boxPosition.lineHeight,\\n          position = step * Math.round(linePos),\\n          maxPosition = containerBox[size] + step,\\n          initialAxis = axis[0];\\n\\n      // If the specified intial position is greater then the max position then\\n      // clamp the box to the amount of steps it would take for the box to\\n      // reach the max position.\\n      if (Math.abs(position) > maxPosition) {\\n        position = position < 0 ? -1 : 1;\\n        position *= Math.ceil(maxPosition / step) * step;\\n      }\\n\\n      // If computed line position returns negative then line numbers are\\n      // relative to the bottom of the video instead of the top. Therefore, we\\n      // need to increase our initial position by the length or width of the\\n      // video, depending on the writing direction, and reverse our axis directions.\\n      if (linePos < 0) {\\n        position += cue.vertical === \\\"\\\" ? containerBox.height : containerBox.width;\\n        axis = axis.reverse();\\n      }\\n\\n      // Move the box to the specified position. This may not be its best\\n      // position.\\n      boxPosition.move(initialAxis, position);\\n\\n    } else {\\n      // If we have a percentage line value for the cue.\\n      var calculatedPercentage = (boxPosition.lineHeight / containerBox.height) * 100;\\n\\n      switch (cue.lineAlign) {\\n      case \\\"middle\\\":\\n        linePos -= (calculatedPercentage / 2);\\n        break;\\n      case \\\"end\\\":\\n        linePos -= calculatedPercentage;\\n        break;\\n      }\\n\\n      // Apply initial line position to the cue box.\\n      switch (cue.vertical) {\\n      case \\\"\\\":\\n        styleBox.applyStyles({\\n          top: styleBox.formatStyle(linePos, \\\"%\\\")\\n        });\\n        break;\\n      case \\\"rl\\\":\\n        styleBox.applyStyles({\\n          left: styleBox.formatStyle(linePos, \\\"%\\\")\\n        });\\n        break;\\n      case \\\"lr\\\":\\n        styleBox.applyStyles({\\n          right: styleBox.formatStyle(linePos, \\\"%\\\")\\n        });\\n        break;\\n      }\\n\\n      axis = [ \\\"+y\\\", \\\"-x\\\", \\\"+x\\\", \\\"-y\\\" ];\\n\\n      // Get the box position again after we've applied the specified positioning\\n      // to it.\\n      boxPosition = new BoxPosition(styleBox);\\n    }\\n\\n    var bestPosition = findBestPosition(boxPosition, axis);\\n    styleBox.move(bestPosition.toCSSCompatValues(containerBox));\\n  }\\n\\n  function WebVTT() {\\n    // Nothing\\n  }\\n\\n  // Helper to allow strings to be decoded instead of the default binary utf8 data.\\n  WebVTT.StringDecoder = function() {\\n    return {\\n      decode: function(data) {\\n        if (!data) {\\n          return \\\"\\\";\\n        }\\n        if (typeof data !== \\\"string\\\") {\\n          throw new Error(\\\"Error - expected string data.\\\");\\n        }\\n        return decodeURIComponent(encodeURIComponent(data));\\n      }\\n    };\\n  };\\n\\n  WebVTT.convertCueToDOMTree = function(window, cuetext) {\\n    if (!window || !cuetext) {\\n      return null;\\n    }\\n    return parseContent(window, cuetext);\\n  };\\n\\n  var FONT_SIZE_PERCENT = 0.05;\\n  var FONT_STYLE = \\\"sans-serif\\\";\\n  var CUE_BACKGROUND_PADDING = \\\"1.5%\\\";\\n\\n  // Runs the processing model over the cues and regions passed to it.\\n  // @param overlay A block level element (usually a div) that the computed cues\\n  //                and regions will be placed into.\\n  WebVTT.processCues = function(window, cues, overlay) {\\n    if (!window || !cues || !overlay) {\\n      return null;\\n    }\\n\\n    // Remove all previous children.\\n    while (overlay.firstChild) {\\n      overlay.removeChild(overlay.firstChild);\\n    }\\n\\n    var paddedOverlay = window.document.createElement(\\\"div\\\");\\n    paddedOverlay.style.position = \\\"absolute\\\";\\n    paddedOverlay.style.left = \\\"0\\\";\\n    paddedOverlay.style.right = \\\"0\\\";\\n    paddedOverlay.style.top = \\\"0\\\";\\n    paddedOverlay.style.bottom = \\\"0\\\";\\n    paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;\\n    overlay.appendChild(paddedOverlay);\\n\\n    // Determine if we need to compute the display states of the cues. This could\\n    // be the case if a cue's state has been changed since the last computation or\\n    // if it has not been computed yet.\\n    function shouldCompute(cues) {\\n      for (var i = 0; i < cues.length; i++) {\\n        if (cues[i].hasBeenReset || !cues[i].displayState) {\\n          return true;\\n        }\\n      }\\n      return false;\\n    }\\n\\n    // We don't need to recompute the cues' display states. Just reuse them.\\n    if (!shouldCompute(cues)) {\\n      for (var i = 0; i < cues.length; i++) {\\n        paddedOverlay.appendChild(cues[i].displayState);\\n      }\\n      return;\\n    }\\n\\n    var boxPositions = [],\\n        containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay),\\n        fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;\\n    var styleOptions = {\\n      font: fontSize + \\\"px \\\" + FONT_STYLE\\n    };\\n\\n    (function() {\\n      var styleBox, cue;\\n\\n      for (var i = 0; i < cues.length; i++) {\\n        cue = cues[i];\\n\\n        // Compute the intial position and styles of the cue div.\\n        styleBox = new CueStyleBox(window, cue, styleOptions);\\n        paddedOverlay.appendChild(styleBox.div);\\n\\n        // Move the cue div to it's correct line position.\\n        moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);\\n\\n        // Remember the computed div so that we don't have to recompute it later\\n        // if we don't have too.\\n        cue.displayState = styleBox.div;\\n\\n        boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));\\n      }\\n    })();\\n  };\\n\\n  WebVTT.Parser = function(window, vttjs, decoder) {\\n    if (!decoder) {\\n      decoder = vttjs;\\n      vttjs = {};\\n    }\\n    if (!vttjs) {\\n      vttjs = {};\\n    }\\n\\n    this.window = window;\\n    this.vttjs = vttjs;\\n    this.state = \\\"INITIAL\\\";\\n    this.buffer = \\\"\\\";\\n    this.decoder = decoder || new TextDecoder(\\\"utf8\\\");\\n    this.regionList = [];\\n  };\\n\\n  WebVTT.Parser.prototype = {\\n    // If the error is a ParsingError then report it to the consumer if\\n    // possible. If it's not a ParsingError then throw it like normal.\\n    reportOrThrowError: function(e) {\\n      if (e instanceof ParsingError) {\\n        this.onparsingerror && this.onparsingerror(e);\\n      } else {\\n        throw e;\\n      }\\n    },\\n    parse: function (data) {\\n      var self = this;\\n\\n      // If there is no data then we won't decode it, but will just try to parse\\n      // whatever is in buffer already. This may occur in circumstances, for\\n      // example when flush() is called.\\n      if (data) {\\n        // Try to decode the data that we received.\\n        self.buffer += self.decoder.decode(data, {stream: true});\\n      }\\n\\n      function collectNextLine() {\\n        var buffer = self.buffer;\\n        var pos = 0;\\n        while (pos < buffer.length && buffer[pos] !== '\\\\r' && buffer[pos] !== '\\\\n') {\\n          ++pos;\\n        }\\n        var line = buffer.substr(0, pos);\\n        // Advance the buffer early in case we fail below.\\n        if (buffer[pos] === '\\\\r') {\\n          ++pos;\\n        }\\n        if (buffer[pos] === '\\\\n') {\\n          ++pos;\\n        }\\n        self.buffer = buffer.substr(pos);\\n        return line;\\n      }\\n\\n      // 3.4 WebVTT region and WebVTT region settings syntax\\n      function parseRegion(input) {\\n        var settings = new Settings();\\n\\n        parseOptions(input, function (k, v) {\\n          switch (k) {\\n          case \\\"id\\\":\\n            settings.set(k, v);\\n            break;\\n          case \\\"width\\\":\\n            settings.percent(k, v);\\n            break;\\n          case \\\"lines\\\":\\n            settings.integer(k, v);\\n            break;\\n          case \\\"regionanchor\\\":\\n          case \\\"viewportanchor\\\":\\n            var xy = v.split(',');\\n            if (xy.length !== 2) {\\n              break;\\n            }\\n            // We have to make sure both x and y parse, so use a temporary\\n            // settings object here.\\n            var anchor = new Settings();\\n            anchor.percent(\\\"x\\\", xy[0]);\\n            anchor.percent(\\\"y\\\", xy[1]);\\n            if (!anchor.has(\\\"x\\\") || !anchor.has(\\\"y\\\")) {\\n              break;\\n            }\\n            settings.set(k + \\\"X\\\", anchor.get(\\\"x\\\"));\\n            settings.set(k + \\\"Y\\\", anchor.get(\\\"y\\\"));\\n            break;\\n          case \\\"scroll\\\":\\n            settings.alt(k, v, [\\\"up\\\"]);\\n            break;\\n          }\\n        }, /=/, /\\\\s/);\\n\\n        // Create the region, using default values for any values that were not\\n        // specified.\\n        if (settings.has(\\\"id\\\")) {\\n          var region = new (self.vttjs.VTTRegion || self.window.VTTRegion)();\\n          region.width = settings.get(\\\"width\\\", 100);\\n          region.lines = settings.get(\\\"lines\\\", 3);\\n          region.regionAnchorX = settings.get(\\\"regionanchorX\\\", 0);\\n          region.regionAnchorY = settings.get(\\\"regionanchorY\\\", 100);\\n          region.viewportAnchorX = settings.get(\\\"viewportanchorX\\\", 0);\\n          region.viewportAnchorY = settings.get(\\\"viewportanchorY\\\", 100);\\n          region.scroll = settings.get(\\\"scroll\\\", \\\"\\\");\\n          // Register the region.\\n          self.onregion && self.onregion(region);\\n          // Remember the VTTRegion for later in case we parse any VTTCues that\\n          // reference it.\\n          self.regionList.push({\\n            id: settings.get(\\\"id\\\"),\\n            region: region\\n          });\\n        }\\n      }\\n\\n      // 3.2 WebVTT metadata header syntax\\n      function parseHeader(input) {\\n        parseOptions(input, function (k, v) {\\n          switch (k) {\\n          case \\\"Region\\\":\\n            // 3.3 WebVTT region metadata header syntax\\n            parseRegion(v);\\n            break;\\n          }\\n        }, /:/);\\n      }\\n\\n      // 5.1 WebVTT file parsing.\\n      try {\\n        var line;\\n        if (self.state === \\\"INITIAL\\\") {\\n          // We can't start parsing until we have the first line.\\n          if (!/\\\\r\\\\n|\\\\n/.test(self.buffer)) {\\n            return this;\\n          }\\n\\n          line = collectNextLine();\\n\\n          var m = line.match(/^WEBVTT([ \\\\t].*)?$/);\\n          if (!m || !m[0]) {\\n            throw new ParsingError(ParsingError.Errors.BadSignature);\\n          }\\n\\n          self.state = \\\"HEADER\\\";\\n        }\\n\\n        var alreadyCollectedLine = false;\\n        while (self.buffer) {\\n          // We can't parse a line until we have the full line.\\n          if (!/\\\\r\\\\n|\\\\n/.test(self.buffer)) {\\n            return this;\\n          }\\n\\n          if (!alreadyCollectedLine) {\\n            line = collectNextLine();\\n          } else {\\n            alreadyCollectedLine = false;\\n          }\\n\\n          switch (self.state) {\\n          case \\\"HEADER\\\":\\n            // 13-18 - Allow a header (metadata) under the WEBVTT line.\\n            if (/:/.test(line)) {\\n              parseHeader(line);\\n            } else if (!line) {\\n              // An empty line terminates the header and starts the body (cues).\\n              self.state = \\\"ID\\\";\\n            }\\n            continue;\\n          case \\\"NOTE\\\":\\n            // Ignore NOTE blocks.\\n            if (!line) {\\n              self.state = \\\"ID\\\";\\n            }\\n            continue;\\n          case \\\"ID\\\":\\n            // Check for the start of NOTE blocks.\\n            if (/^NOTE($|[ \\\\t])/.test(line)) {\\n              self.state = \\\"NOTE\\\";\\n              break;\\n            }\\n            // 19-29 - Allow any number of line terminators, then initialize new cue values.\\n            if (!line) {\\n              continue;\\n            }\\n            self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, \\\"\\\");\\n            self.state = \\\"CUE\\\";\\n            // 30-39 - Check if self line contains an optional identifier or timing data.\\n            if (line.indexOf(\\\"-->\\\") === -1) {\\n              self.cue.id = line;\\n              continue;\\n            }\\n            // Process line as start of a cue.\\n            /*falls through*/\\n          case \\\"CUE\\\":\\n            // 40 - Collect cue timings and settings.\\n            try {\\n              parseCue(line, self.cue, self.regionList);\\n            } catch (e) {\\n              self.reportOrThrowError(e);\\n              // In case of an error ignore rest of the cue.\\n              self.cue = null;\\n              self.state = \\\"BADCUE\\\";\\n              continue;\\n            }\\n            self.state = \\\"CUETEXT\\\";\\n            continue;\\n          case \\\"CUETEXT\\\":\\n            var hasSubstring = line.indexOf(\\\"-->\\\") !== -1;\\n            // 34 - If we have an empty line then report the cue.\\n            // 35 - If we have the special substring '-->' then report the cue,\\n            // but do not collect the line as we need to process the current\\n            // one as a new cue.\\n            if (!line || hasSubstring && (alreadyCollectedLine = true)) {\\n              // We are done parsing self cue.\\n              self.oncue && self.oncue(self.cue);\\n              self.cue = null;\\n              self.state = \\\"ID\\\";\\n              continue;\\n            }\\n            if (self.cue.text) {\\n              self.cue.text += \\\"\\\\n\\\";\\n            }\\n            self.cue.text += line;\\n            continue;\\n          case \\\"BADCUE\\\": // BADCUE\\n            // 54-62 - Collect and discard the remaining cue.\\n            if (!line) {\\n              self.state = \\\"ID\\\";\\n            }\\n            continue;\\n          }\\n        }\\n      } catch (e) {\\n        self.reportOrThrowError(e);\\n\\n        // If we are currently parsing a cue, report what we have.\\n        if (self.state === \\\"CUETEXT\\\" && self.cue && self.oncue) {\\n          self.oncue(self.cue);\\n        }\\n        self.cue = null;\\n        // Enter BADWEBVTT state if header was not parsed correctly otherwise\\n        // another exception occurred so enter BADCUE state.\\n        self.state = self.state === \\\"INITIAL\\\" ? \\\"BADWEBVTT\\\" : \\\"BADCUE\\\";\\n      }\\n      return this;\\n    },\\n    flush: function () {\\n      var self = this;\\n      try {\\n        // Finish decoding the stream.\\n        self.buffer += self.decoder.decode();\\n        // Synthesize the end of the current cue or region.\\n        if (self.cue || self.state === \\\"HEADER\\\") {\\n          self.buffer += \\\"\\\\n\\\\n\\\";\\n          self.parse();\\n        }\\n        // If we've flushed, parsed, and we're still on the INITIAL state then\\n        // that means we don't have enough of the stream to parse the first\\n        // line.\\n        if (self.state === \\\"INITIAL\\\") {\\n          throw new ParsingError(ParsingError.Errors.BadSignature);\\n        }\\n      } catch(e) {\\n        self.reportOrThrowError(e);\\n      }\\n      self.onflush && self.onflush();\\n      return this;\\n    }\\n  };\\n\\n  global.WebVTT = WebVTT;\\n\\n}(this, (this.vttjs || {})));\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/francoisdagostini/Projects/infiniteUx-prototype/~/raw-loader!/Users/francoisdagostini/Projects/infiniteUx-prototype/~/source-map-loader!/Users/francoisdagostini/Projects/infiniteUx-prototype/src/assets/videojs/video.js\n// module id = 829\n// module chunks = 3","module.exports = \"/**\\n * videojs-contrib-hls\\n * @version 3.5.3\\n * @copyright 2016 Brightcove, Inc\\n * @license Apache-2.0\\n */\\n(function(f){if(typeof exports===\\\"object\\\"&&typeof module!==\\\"undefined\\\"){module.exports=f()}else if(typeof define===\\\"function\\\"&&define.amd){define([],f)}else{var g;if(typeof window!==\\\"undefined\\\"){g=window}else if(typeof global!==\\\"undefined\\\"){g=global}else if(typeof self!==\\\"undefined\\\"){g=self}else{g=this}g.videojsContribHls = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\\\"function\\\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\\\"Cannot find module '\\\"+o+\\\"'\\\");throw f.code=\\\"MODULE_NOT_FOUND\\\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\\\"function\\\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\\n/**\\n * @file ad-cue-tags.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _globalWindow = require('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\n/**\\n * Searches for an ad cue that overlaps with the given mediaTime\\n */\\nvar findAdCue = function findAdCue(track, mediaTime) {\\n  var cues = track.cues;\\n\\n  for (var i = 0; i < cues.length; i++) {\\n    var cue = cues[i];\\n\\n    if (mediaTime >= cue.adStartTime && mediaTime <= cue.adEndTime) {\\n      return cue;\\n    }\\n  }\\n  return null;\\n};\\n\\nvar updateAdCues = function updateAdCues(media, track) {\\n  var offset = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\\n\\n  if (!media.segments) {\\n    return;\\n  }\\n\\n  var mediaTime = offset;\\n  var cue = undefined;\\n\\n  for (var i = 0; i < media.segments.length; i++) {\\n    var segment = media.segments[i];\\n\\n    if (!cue) {\\n      // Since the cues will span for at least the segment duration, adding a fudge\\n      // factor of half segment duration will prevent duplicate cues from being\\n      // created when timing info is not exact (e.g. cue start time initialized\\n      // at 10.006677, but next call mediaTime is 10.003332 )\\n      cue = findAdCue(track, mediaTime + segment.duration / 2);\\n    }\\n\\n    if (cue) {\\n      if ('cueIn' in segment) {\\n        // Found a CUE-IN so end the cue\\n        cue.endTime = mediaTime;\\n        cue.adEndTime = mediaTime;\\n        mediaTime += segment.duration;\\n        cue = null;\\n        continue;\\n      }\\n\\n      if (mediaTime < cue.endTime) {\\n        // Already processed this mediaTime for this cue\\n        mediaTime += segment.duration;\\n        continue;\\n      }\\n\\n      // otherwise extend cue until a CUE-IN is found\\n      cue.endTime += segment.duration;\\n    } else {\\n      if ('cueOut' in segment) {\\n        cue = new _globalWindow2['default'].VTTCue(mediaTime, mediaTime + segment.duration, segment.cueOut);\\n        cue.adStartTime = mediaTime;\\n        // Assumes tag format to be\\n        // #EXT-X-CUE-OUT:30\\n        cue.adEndTime = mediaTime + parseFloat(segment.cueOut);\\n        track.addCue(cue);\\n      }\\n\\n      if ('cueOutCont' in segment) {\\n        // Entered into the middle of an ad cue\\n        var adOffset = undefined;\\n        var adTotal = undefined;\\n\\n        // Assumes tag formate to be\\n        // #EXT-X-CUE-OUT-CONT:10/30\\n\\n        var _segment$cueOutCont$split$map = segment.cueOutCont.split('/').map(parseFloat);\\n\\n        var _segment$cueOutCont$split$map2 = _slicedToArray(_segment$cueOutCont$split$map, 2);\\n\\n        adOffset = _segment$cueOutCont$split$map2[0];\\n        adTotal = _segment$cueOutCont$split$map2[1];\\n\\n        cue = new _globalWindow2['default'].VTTCue(mediaTime, mediaTime + segment.duration, '');\\n        cue.adStartTime = mediaTime - adOffset;\\n        cue.adEndTime = cue.adStartTime + adTotal;\\n        track.addCue(cue);\\n      }\\n    }\\n    mediaTime += segment.duration;\\n  }\\n};\\n\\nexports['default'] = {\\n  updateAdCues: updateAdCues,\\n  findAdCue: findAdCue\\n};\\nmodule.exports = exports['default'];\\n},{\\\"global/window\\\":26}],2:[function(require,module,exports){\\n/**\\n * @file bin-utils.js\\n */\\n\\n/**\\n * convert a TimeRange to text\\n *\\n * @param {TimeRange} range the timerange to use for conversion\\n * @param {Number} i the iterator on the range to convert\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\nvar textRange = function textRange(range, i) {\\n  return range.start(i) + '-' + range.end(i);\\n};\\n\\n/**\\n * format a number as hex string\\n *\\n * @param {Number} e The number\\n * @param {Number} i the iterator\\n */\\nvar formatHexString = function formatHexString(e, i) {\\n  var value = e.toString(16);\\n\\n  return '00'.substring(0, 2 - value.length) + value + (i % 2 ? ' ' : '');\\n};\\nvar formatAsciiString = function formatAsciiString(e) {\\n  if (e >= 0x20 && e < 0x7e) {\\n    return String.fromCharCode(e);\\n  }\\n  return '.';\\n};\\n\\n/**\\n * utils to help dump binary data to the console\\n */\\nvar utils = {\\n  hexDump: function hexDump(data) {\\n    var bytes = Array.prototype.slice.call(data);\\n    var step = 16;\\n    var result = '';\\n    var hex = undefined;\\n    var ascii = undefined;\\n\\n    for (var j = 0; j < bytes.length / step; j++) {\\n      hex = bytes.slice(j * step, j * step + step).map(formatHexString).join('');\\n      ascii = bytes.slice(j * step, j * step + step).map(formatAsciiString).join('');\\n      result += hex + ' ' + ascii + '\\\\n';\\n    }\\n    return result;\\n  },\\n  tagDump: function tagDump(tag) {\\n    return utils.hexDump(tag.bytes);\\n  },\\n  textRanges: function textRanges(ranges) {\\n    var result = '';\\n    var i = undefined;\\n\\n    for (i = 0; i < ranges.length; i++) {\\n      result += textRange(ranges, i) + ' ';\\n    }\\n    return result;\\n  }\\n};\\n\\nexports['default'] = utils;\\nmodule.exports = exports['default'];\\n},{}],3:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports[\\\"default\\\"] = {\\n  GOAL_BUFFER_LENGTH: 30\\n};\\nmodule.exports = exports[\\\"default\\\"];\\n},{}],4:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file gap-skipper.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nvar _ranges = require('./ranges');\\n\\nvar _ranges2 = _interopRequireDefault(_ranges);\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\n// Set of events that reset the gap-skipper logic and clear the timeout\\nvar timerCancelEvents = ['seeking', 'seeked', 'pause', 'playing', 'error'];\\n\\n/**\\n * The gap skipper object handles all scenarios\\n * where the player runs into the end of a buffered\\n * region and there is a buffered region ahead.\\n *\\n * It then handles the skipping behavior by setting a\\n * timer to the size (in time) of the gap. This gives\\n * the hls segment fetcher time to close the gap and\\n * resume playing before the timer is triggered and\\n * the gap skipper simply seeks over the gap as a\\n * last resort to resume playback.\\n *\\n * @class GapSkipper\\n */\\n\\nvar GapSkipper = (function () {\\n  /**\\n   * Represents a GapSKipper object.\\n   * @constructor\\n   * @param {object} options an object that includes the tech and settings\\n   */\\n\\n  function GapSkipper(options) {\\n    var _this = this;\\n\\n    _classCallCheck(this, GapSkipper);\\n\\n    this.tech_ = options.tech;\\n    this.consecutiveUpdates = 0;\\n    this.lastRecordedTime = null;\\n    this.timer_ = null;\\n\\n    if (options.debug) {\\n      this.logger_ = _videoJs2['default'].log.bind(_videoJs2['default'], 'gap-skipper ->');\\n    }\\n    this.logger_('initialize');\\n\\n    var waitingHandler = function waitingHandler() {\\n      return _this.waiting_();\\n    };\\n    var timeupdateHandler = function timeupdateHandler() {\\n      return _this.timeupdate_();\\n    };\\n    var cancelTimerHandler = function cancelTimerHandler() {\\n      return _this.cancelTimer_();\\n    };\\n\\n    this.tech_.on('waiting', waitingHandler);\\n    this.tech_.on('timeupdate', timeupdateHandler);\\n    this.tech_.on(timerCancelEvents, cancelTimerHandler);\\n\\n    // Define the dispose function to clean up our events\\n    this.dispose = function () {\\n      _this.logger_('dispose');\\n      _this.tech_.off('waiting', waitingHandler);\\n      _this.tech_.off('timeupdate', timeupdateHandler);\\n      _this.tech_.off(timerCancelEvents, cancelTimerHandler);\\n      _this.cancelTimer_();\\n    };\\n  }\\n\\n  /**\\n   * Handler for `waiting` events from the player\\n   *\\n   * @private\\n   */\\n\\n  _createClass(GapSkipper, [{\\n    key: 'waiting_',\\n    value: function waiting_() {\\n      if (!this.tech_.seeking()) {\\n        this.setTimer_();\\n      }\\n    }\\n\\n    /**\\n     * The purpose of this function is to emulate the \\\"waiting\\\" event on\\n     * browsers that do not emit it when they are waiting for more\\n     * data to continue playback\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'timeupdate_',\\n    value: function timeupdate_() {\\n      if (this.tech_.paused() || this.tech_.seeking()) {\\n        return;\\n      }\\n\\n      var currentTime = this.tech_.currentTime();\\n\\n      if (this.consecutiveUpdates === 5 && currentTime === this.lastRecordedTime) {\\n        this.consecutiveUpdates++;\\n        this.waiting_();\\n      } else if (currentTime === this.lastRecordedTime) {\\n        this.consecutiveUpdates++;\\n      } else {\\n        this.consecutiveUpdates = 0;\\n        this.lastRecordedTime = currentTime;\\n      }\\n    }\\n\\n    /**\\n     * Cancels any pending timers and resets the 'timeupdate' mechanism\\n     * designed to detect that we are stalled\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'cancelTimer_',\\n    value: function cancelTimer_() {\\n      this.consecutiveUpdates = 0;\\n\\n      if (this.timer_) {\\n        this.logger_('cancelTimer_');\\n        clearTimeout(this.timer_);\\n      }\\n\\n      this.timer_ = null;\\n    }\\n\\n    /**\\n     * Timer callback. If playback still has not proceeded, then we seek\\n     * to the start of the next buffered region.\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'skipTheGap_',\\n    value: function skipTheGap_(scheduledCurrentTime) {\\n      var buffered = this.tech_.buffered();\\n      var currentTime = this.tech_.currentTime();\\n      var nextRange = _ranges2['default'].findNextRange(buffered, currentTime);\\n\\n      this.consecutiveUpdates = 0;\\n      this.timer_ = null;\\n\\n      if (nextRange.length === 0 || currentTime !== scheduledCurrentTime) {\\n        return;\\n      }\\n\\n      this.logger_('skipTheGap_:', 'currentTime:', currentTime, 'scheduled currentTime:', scheduledCurrentTime, 'nextRange start:', nextRange.start(0));\\n\\n      // only seek if we still have not played\\n      this.tech_.setCurrentTime(nextRange.start(0) + _ranges2['default'].TIME_FUDGE_FACTOR);\\n    }\\n  }, {\\n    key: 'gapFromVideoUnderflow_',\\n    value: function gapFromVideoUnderflow_(buffered, currentTime) {\\n      // At least in Chrome, if there is a gap in the video buffer, the audio will continue\\n      // playing for ~3 seconds after the video gap starts. This is done to account for\\n      // video buffer underflow/underrun (note that this is not done when there is audio\\n      // buffer underflow/underrun -- in that case the video will stop as soon as it\\n      // encounters the gap, as audio stalls are more noticeable/jarring to a user than\\n      // video stalls). The player's time will reflect the playthrough of audio, so the\\n      // time will appear as if we are in a buffered region, even if we are stuck in a\\n      // \\\"gap.\\\"\\n      //\\n      // Example:\\n      // video buffer:   0 => 10.1, 10.2 => 20\\n      // audio buffer:   0 => 20\\n      // overall buffer: 0 => 10.1, 10.2 => 20\\n      // current time: 13\\n      //\\n      // Chrome's video froze at 10 seconds, where the video buffer encountered the gap,\\n      // however, the audio continued playing until it reached ~3 seconds past the gap\\n      // (13 seconds), at which point it stops as well. Since current time is past the\\n      // gap, findNextRange will return no ranges.\\n      //\\n      // To check for this issue, we see if there is a gap that starts somewhere within\\n      // a 3 second range (3 seconds +/- 1 second) back from our current time.\\n      var gaps = _ranges2['default'].findGaps(buffered);\\n\\n      for (var i = 0; i < gaps.length; i++) {\\n        var start = gaps.start(i);\\n        var end = gaps.end(i);\\n\\n        // gap is starts no more than 4 seconds back\\n        if (currentTime - start < 4 && currentTime - start > 2) {\\n          return {\\n            start: start,\\n            end: end\\n          };\\n        }\\n      }\\n\\n      return null;\\n    }\\n\\n    /**\\n     * Set a timer to skip the unbuffered region.\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'setTimer_',\\n    value: function setTimer_() {\\n      var buffered = this.tech_.buffered();\\n      var currentTime = this.tech_.currentTime();\\n      var nextRange = _ranges2['default'].findNextRange(buffered, currentTime);\\n\\n      if (this.timer_ !== null) {\\n        return;\\n      }\\n\\n      if (nextRange.length === 0) {\\n        // Even if there is no available next range, there is still a possibility we are\\n        // stuck in a gap due to video underflow.\\n        var gap = this.gapFromVideoUnderflow_(buffered, currentTime);\\n\\n        if (gap) {\\n          this.logger_('setTimer_:', 'Encountered a gap in video', 'from: ', gap.start, 'to: ', gap.end, 'seeking to current time: ', currentTime);\\n          // Even though the video underflowed and was stuck in a gap, the audio overplayed\\n          // the gap, leading currentTime into a buffered range. Seeking to currentTime\\n          // allows the video to catch up to the audio position without losing any audio\\n          // (only suffering ~3 seconds of frozen video and a pause in audio playback).\\n          this.tech_.setCurrentTime(currentTime);\\n        }\\n        return;\\n      }\\n\\n      var difference = nextRange.start(0) - currentTime;\\n\\n      this.logger_('setTimer_:', 'stopped at:', currentTime, 'setting timer for:', difference, 'seeking to:', nextRange.start(0));\\n\\n      this.timer_ = setTimeout(this.skipTheGap_.bind(this), difference * 1000, currentTime);\\n    }\\n\\n    /**\\n     * A debugging logger noop that is set to console.log only if debugging\\n     * is enabled globally\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'logger_',\\n    value: function logger_() {}\\n  }]);\\n\\n  return GapSkipper;\\n})();\\n\\nexports['default'] = GapSkipper;\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./ranges\\\":9}],5:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file hls-audio-track.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _playlistLoader = require('./playlist-loader');\\n\\nvar _playlistLoader2 = _interopRequireDefault(_playlistLoader);\\n\\n/**\\n * HlsAudioTrack extends video.js audio tracks but adds HLS\\n * specific data storage such as playlist loaders, mediaGroups\\n * and default/autoselect\\n *\\n * @param {Object} options options to create HlsAudioTrack with\\n * @class HlsAudioTrack\\n * @extends AudioTrack\\n */\\n\\nvar HlsAudioTrack = (function (_AudioTrack) {\\n  _inherits(HlsAudioTrack, _AudioTrack);\\n\\n  function HlsAudioTrack(options) {\\n    _classCallCheck(this, HlsAudioTrack);\\n\\n    _get(Object.getPrototypeOf(HlsAudioTrack.prototype), 'constructor', this).call(this, {\\n      kind: options['default'] ? 'main' : 'alternative',\\n      enabled: options['default'] || false,\\n      language: options.language,\\n      label: options.label\\n    });\\n\\n    this.hls = options.hls;\\n    this.autoselect = options.autoselect || false;\\n    this['default'] = options['default'] || false;\\n    this.withCredentials = options.withCredentials || false;\\n    this.mediaGroups_ = [];\\n    this.addLoader(options.mediaGroup, options.resolvedUri);\\n  }\\n\\n  /**\\n   * get a PlaylistLoader from this track given a mediaGroup name\\n   *\\n   * @param {String} mediaGroup the mediaGroup to get the loader for\\n   * @return {PlaylistLoader|Null} the PlaylistLoader or null\\n   */\\n\\n  _createClass(HlsAudioTrack, [{\\n    key: 'getLoader',\\n    value: function getLoader(mediaGroup) {\\n      for (var i = 0; i < this.mediaGroups_.length; i++) {\\n        var mgl = this.mediaGroups_[i];\\n\\n        if (mgl.mediaGroup === mediaGroup) {\\n          return mgl.loader;\\n        }\\n      }\\n    }\\n\\n    /**\\n     * add a PlaylistLoader given a mediaGroup, and a uri. for a combined track\\n     * we store null for the playlistloader\\n     *\\n     * @param {String} mediaGroup the mediaGroup to get the loader for\\n     * @param {String} uri the uri to get the audio track/mediaGroup from\\n     */\\n  }, {\\n    key: 'addLoader',\\n    value: function addLoader(mediaGroup) {\\n      var uri = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\\n\\n      var loader = null;\\n\\n      if (uri) {\\n        // TODO: this should probably happen upstream in Master Playlist\\n        // Controller when we can switch PlaylistLoader sources\\n        // then we can just store the uri here instead\\n        loader = new _playlistLoader2['default'](uri, this.hls, this.withCredentials);\\n      }\\n      this.mediaGroups_.push({ mediaGroup: mediaGroup, loader: loader });\\n    }\\n\\n    /**\\n     * remove a playlist loader from a track given the mediaGroup\\n     *\\n     * @param {String} mediaGroup the mediaGroup to remove\\n     */\\n  }, {\\n    key: 'removeLoader',\\n    value: function removeLoader(mediaGroup) {\\n      for (var i = 0; i < this.mediaGroups_.length; i++) {\\n        var mgl = this.mediaGroups_[i];\\n\\n        if (mgl.mediaGroup === mediaGroup) {\\n          if (mgl.loader) {\\n            mgl.loader.dispose();\\n          }\\n          this.mediaGroups_.splice(i, 1);\\n          return;\\n        }\\n      }\\n    }\\n\\n    /**\\n     * Dispose of this audio track and\\n     * the playlist loader that it holds inside\\n     */\\n  }, {\\n    key: 'dispose',\\n    value: function dispose() {\\n      var i = this.mediaGroups_.length;\\n\\n      while (i--) {\\n        this.removeLoader(this.mediaGroups_[i].mediaGroup);\\n      }\\n    }\\n  }]);\\n\\n  return HlsAudioTrack;\\n})(_videoJs.AudioTrack);\\n\\nexports['default'] = HlsAudioTrack;\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./playlist-loader\\\":7}],6:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file master-playlist-controller.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _playlistLoader = require('./playlist-loader');\\n\\nvar _playlistLoader2 = _interopRequireDefault(_playlistLoader);\\n\\nvar _segmentLoader = require('./segment-loader');\\n\\nvar _segmentLoader2 = _interopRequireDefault(_segmentLoader);\\n\\nvar _ranges = require('./ranges');\\n\\nvar _ranges2 = _interopRequireDefault(_ranges);\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\nvar _hlsAudioTrack = require('./hls-audio-track');\\n\\nvar _hlsAudioTrack2 = _interopRequireDefault(_hlsAudioTrack);\\n\\nvar _adCueTags = require('./ad-cue-tags');\\n\\nvar _adCueTags2 = _interopRequireDefault(_adCueTags);\\n\\n// 5 minute blacklist\\nvar BLACKLIST_DURATION = 5 * 60 * 1000;\\nvar Hls = undefined;\\n\\nvar parseCodecs = function parseCodecs(codecs) {\\n  var result = {\\n    codecCount: 0,\\n    videoCodec: null,\\n    audioProfile: null\\n  };\\n\\n  result.codecCount = codecs.split(',').length;\\n  result.codecCount = result.codecCount || 2;\\n\\n  // parse the video codec but ignore the version\\n  result.videoCodec = /(^|\\\\s|,)+(avc1)[^ ,]*/i.exec(codecs);\\n  result.videoCodec = result.videoCodec && result.videoCodec[2];\\n\\n  // parse the last field of the audio codec\\n  result.audioProfile = /(^|\\\\s|,)+mp4a.\\\\d+\\\\.(\\\\d+)/i.exec(codecs);\\n  result.audioProfile = result.audioProfile && result.audioProfile[2];\\n\\n  return result;\\n};\\n\\n/**\\n * the master playlist controller controller all interactons\\n * between playlists and segmentloaders. At this time this mainly\\n * involves a master playlist and a series of audio playlists\\n * if they are available\\n *\\n * @class MasterPlaylistController\\n * @extends videojs.EventTarget\\n */\\n\\nvar MasterPlaylistController = (function (_videojs$EventTarget) {\\n  _inherits(MasterPlaylistController, _videojs$EventTarget);\\n\\n  function MasterPlaylistController(_ref) {\\n    var _this = this;\\n\\n    var url = _ref.url;\\n    var withCredentials = _ref.withCredentials;\\n    var mode = _ref.mode;\\n    var tech = _ref.tech;\\n    var bandwidth = _ref.bandwidth;\\n    var externHls = _ref.externHls;\\n    var useCueTags = _ref.useCueTags;\\n\\n    _classCallCheck(this, MasterPlaylistController);\\n\\n    _get(Object.getPrototypeOf(MasterPlaylistController.prototype), 'constructor', this).call(this);\\n\\n    Hls = externHls;\\n\\n    this.withCredentials = withCredentials;\\n    this.tech_ = tech;\\n    this.hls_ = tech.hls;\\n    this.mode_ = mode;\\n    this.useCueTags_ = useCueTags;\\n    if (this.useCueTags_) {\\n      this.cueTagsTrack_ = this.tech_.addTextTrack('metadata', 'ad-cues');\\n      this.cueTagsTrack_.inBandMetadataTrackDispatchType = '';\\n      this.tech_.textTracks().addTrack_(this.cueTagsTrack_);\\n    }\\n\\n    this.audioTracks_ = [];\\n    this.requestOptions_ = {\\n      withCredentials: this.withCredentials,\\n      timeout: null\\n    };\\n\\n    this.mediaSource = new _videoJs2['default'].MediaSource({ mode: mode });\\n    this.mediaSource.on('audioinfo', function (e) {\\n      return _this.trigger(e);\\n    });\\n    // load the media source into the player\\n    this.mediaSource.addEventListener('sourceopen', this.handleSourceOpen_.bind(this));\\n\\n    var segmentLoaderOptions = {\\n      hls: this.hls_,\\n      mediaSource: this.mediaSource,\\n      currentTime: this.tech_.currentTime.bind(this.tech_),\\n      seekable: function seekable() {\\n        return _this.seekable();\\n      },\\n      seeking: function seeking() {\\n        return _this.tech_.seeking();\\n      },\\n      setCurrentTime: function setCurrentTime(a) {\\n        return _this.tech_.setCurrentTime(a);\\n      },\\n      hasPlayed: function hasPlayed() {\\n        return _this.tech_.played().length !== 0;\\n      },\\n      bandwidth: bandwidth\\n    };\\n\\n    // combined audio/video or just video when alternate audio track is selected\\n    this.mainSegmentLoader_ = new _segmentLoader2['default'](segmentLoaderOptions);\\n    // alternate audio track\\n    this.audioSegmentLoader_ = new _segmentLoader2['default'](segmentLoaderOptions);\\n\\n    if (!url) {\\n      throw new Error('A non-empty playlist URL is required');\\n    }\\n\\n    this.masterPlaylistLoader_ = new _playlistLoader2['default'](url, this.hls_, this.withCredentials);\\n\\n    this.masterPlaylistLoader_.on('loadedmetadata', function () {\\n      var media = _this.masterPlaylistLoader_.media();\\n      var requestTimeout = _this.masterPlaylistLoader_.targetDuration * 1.5 * 1000;\\n\\n      _this.requestOptions_.timeout = requestTimeout;\\n\\n      // if this isn't a live video and preload permits, start\\n      // downloading segments\\n      if (media.endList && _this.tech_.preload() !== 'none') {\\n        _this.mainSegmentLoader_.playlist(media, _this.requestOptions_);\\n        _this.mainSegmentLoader_.expired(_this.masterPlaylistLoader_.expired_);\\n        _this.mainSegmentLoader_.load();\\n      }\\n\\n      _this.setupSourceBuffer_();\\n      _this.setupFirstPlay();\\n      _this.useAudio();\\n    });\\n\\n    this.masterPlaylistLoader_.on('loadedplaylist', function () {\\n      var updatedPlaylist = _this.masterPlaylistLoader_.media();\\n      var seekable = undefined;\\n\\n      if (!updatedPlaylist) {\\n        // select the initial variant\\n        _this.initialMedia_ = _this.selectPlaylist();\\n        _this.masterPlaylistLoader_.media(_this.initialMedia_);\\n        _this.fillAudioTracks_();\\n\\n        _this.trigger('selectedinitialmedia');\\n        return;\\n      }\\n\\n      if (_this.useCueTags_) {\\n        _this.updateAdCues_(updatedPlaylist, _this.masterPlaylistLoader_.expired_);\\n      }\\n\\n      // TODO: Create a new event on the PlaylistLoader that signals\\n      // that the segments have changed in some way and use that to\\n      // update the SegmentLoader instead of doing it twice here and\\n      // on `mediachange`\\n      _this.mainSegmentLoader_.playlist(updatedPlaylist, _this.requestOptions_);\\n      _this.mainSegmentLoader_.expired(_this.masterPlaylistLoader_.expired_);\\n      _this.updateDuration();\\n\\n      // update seekable\\n      seekable = _this.seekable();\\n      if (!updatedPlaylist.endList && seekable.length !== 0) {\\n        _this.mediaSource.addSeekableRange_(seekable.start(0), seekable.end(0));\\n      }\\n    });\\n\\n    this.masterPlaylistLoader_.on('error', function () {\\n      _this.blacklistCurrentPlaylist(_this.masterPlaylistLoader_.error);\\n    });\\n\\n    this.masterPlaylistLoader_.on('mediachanging', function () {\\n      _this.mainSegmentLoader_.abort();\\n      _this.mainSegmentLoader_.pause();\\n    });\\n\\n    this.masterPlaylistLoader_.on('mediachange', function () {\\n      var media = _this.masterPlaylistLoader_.media();\\n      var requestTimeout = _this.masterPlaylistLoader_.targetDuration * 1.5 * 1000;\\n\\n      // If we don't have any more available playlists, we don't want to\\n      // timeout the request.\\n      if (_this.masterPlaylistLoader_.isLowestEnabledRendition_()) {\\n        _this.requestOptions_.timeout = 0;\\n      } else {\\n        _this.requestOptions_.timeout = requestTimeout;\\n      }\\n\\n      // TODO: Create a new event on the PlaylistLoader that signals\\n      // that the segments have changed in some way and use that to\\n      // update the SegmentLoader instead of doing it twice here and\\n      // on `loadedplaylist`\\n      _this.mainSegmentLoader_.playlist(media, _this.requestOptions_);\\n      _this.mainSegmentLoader_.expired(_this.masterPlaylistLoader_.expired_);\\n      _this.mainSegmentLoader_.load();\\n\\n      _this.tech_.trigger({\\n        type: 'mediachange',\\n        bubbles: true\\n      });\\n    });\\n\\n    this.mainSegmentLoader_.on('progress', function () {\\n      // figure out what stream the next segment should be downloaded from\\n      // with the updated bandwidth information\\n      _this.masterPlaylistLoader_.media(_this.selectPlaylist());\\n\\n      _this.trigger('progress');\\n    });\\n\\n    this.mainSegmentLoader_.on('error', function () {\\n      _this.blacklistCurrentPlaylist(_this.mainSegmentLoader_.error());\\n    });\\n\\n    this.audioSegmentLoader_.on('error', function () {\\n      _videoJs2['default'].log.warn('Problem encountered with the current alternate audio track' + '. Switching back to default.');\\n      _this.audioSegmentLoader_.abort();\\n      _this.audioPlaylistLoader_ = null;\\n      _this.useAudio();\\n    });\\n\\n    this.masterPlaylistLoader_.load();\\n  }\\n\\n  /**\\n   * get the total number of media requests from the `audiosegmentloader_`\\n   * and the `mainSegmentLoader_`\\n   *\\n   * @private\\n   */\\n\\n  _createClass(MasterPlaylistController, [{\\n    key: 'mediaRequests_',\\n    value: function mediaRequests_() {\\n      return this.audioSegmentLoader_.mediaRequests + this.mainSegmentLoader_.mediaRequests;\\n    }\\n\\n    /**\\n     * get the total time that media requests have spent trnasfering\\n     * from the `audiosegmentloader_` and the `mainSegmentLoader_`\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'mediaTransferDuration_',\\n    value: function mediaTransferDuration_() {\\n      return this.audioSegmentLoader_.mediaTransferDuration + this.mainSegmentLoader_.mediaTransferDuration;\\n    }\\n\\n    /**\\n     * get the total number of bytes transfered during media requests\\n     * from the `audiosegmentloader_` and the `mainSegmentLoader_`\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'mediaBytesTransferred_',\\n    value: function mediaBytesTransferred_() {\\n      return this.audioSegmentLoader_.mediaBytesTransferred + this.mainSegmentLoader_.mediaBytesTransferred;\\n    }\\n\\n    /**\\n     * fill our internal list of HlsAudioTracks with data from\\n     * the master playlist or use a default\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'fillAudioTracks_',\\n    value: function fillAudioTracks_() {\\n      var master = this.master();\\n      var mediaGroups = master.mediaGroups || {};\\n\\n      // force a default if we have none or we are not\\n      // in html5 mode (the only mode to support more than one\\n      // audio track)\\n      if (!mediaGroups || !mediaGroups.AUDIO || Object.keys(mediaGroups.AUDIO).length === 0 || this.mode_ !== 'html5') {\\n        // \\\"main\\\" audio group, track name \\\"default\\\"\\n        mediaGroups.AUDIO = { main: { 'default': { 'default': true } } };\\n      }\\n\\n      var tracks = {};\\n\\n      for (var mediaGroup in mediaGroups.AUDIO) {\\n        for (var label in mediaGroups.AUDIO[mediaGroup]) {\\n          var properties = mediaGroups.AUDIO[mediaGroup][label];\\n\\n          // if the track already exists add a new \\\"location\\\"\\n          // since tracks in different mediaGroups are actually the same\\n          // track with different locations to download them from\\n          if (tracks[label]) {\\n            tracks[label].addLoader(mediaGroup, properties.resolvedUri);\\n            continue;\\n          }\\n\\n          var track = new _hlsAudioTrack2['default'](_videoJs2['default'].mergeOptions(properties, {\\n            hls: this.hls_,\\n            withCredentials: this.withCredential,\\n            mediaGroup: mediaGroup,\\n            label: label\\n          }));\\n\\n          tracks[label] = track;\\n          this.audioTracks_.push(track);\\n        }\\n      }\\n    }\\n\\n    /**\\n     * Call load on our SegmentLoaders\\n     */\\n  }, {\\n    key: 'load',\\n    value: function load() {\\n      this.mainSegmentLoader_.load();\\n      if (this.audioPlaylistLoader_) {\\n        this.audioSegmentLoader_.load();\\n      }\\n    }\\n\\n    /**\\n     * Get the current active Media Group for Audio\\n     * given the selected playlist and its attributes\\n     */\\n  }, {\\n    key: 'activeAudioGroup',\\n    value: function activeAudioGroup() {\\n      var media = this.masterPlaylistLoader_.media();\\n      var mediaGroup = 'main';\\n\\n      if (media && media.attributes && media.attributes.AUDIO) {\\n        mediaGroup = media.attributes.AUDIO;\\n      }\\n\\n      return mediaGroup;\\n    }\\n\\n    /**\\n     * Use any audio track that we have, and start to load it\\n     */\\n  }, {\\n    key: 'useAudio',\\n    value: function useAudio() {\\n      var _this2 = this;\\n\\n      var track = undefined;\\n\\n      this.audioTracks_.forEach(function (t) {\\n        if (!track && t.enabled) {\\n          track = t;\\n        }\\n      });\\n\\n      // called too early or no track is enabled\\n      if (!track) {\\n        return;\\n      }\\n\\n      // Pause any alternative audio\\n      if (this.audioPlaylistLoader_) {\\n        this.audioPlaylistLoader_.pause();\\n        this.audioPlaylistLoader_ = null;\\n        this.audioSegmentLoader_.pause();\\n      }\\n\\n      // If the audio track for the active audio group has\\n      // a playlist loader than it is an alterative audio track\\n      // otherwise it is a part of the mainSegmenLoader\\n      var loader = track.getLoader(this.activeAudioGroup());\\n\\n      if (!loader) {\\n        this.mainSegmentLoader_.clearBuffer();\\n        return;\\n      }\\n\\n      // TODO: it may be better to create the playlist loader here\\n      // when we can change an audioPlaylistLoaders src\\n      this.audioPlaylistLoader_ = loader;\\n\\n      if (this.audioPlaylistLoader_.started) {\\n        this.audioPlaylistLoader_.load();\\n        this.audioSegmentLoader_.load();\\n        this.audioSegmentLoader_.clearBuffer();\\n        return;\\n      }\\n\\n      this.audioPlaylistLoader_.on('loadedmetadata', function () {\\n        /* eslint-disable no-shadow */\\n        var media = _this2.audioPlaylistLoader_.media();\\n        /* eslint-enable no-shadow */\\n\\n        _this2.audioSegmentLoader_.playlist(media, _this2.requestOptions_);\\n        _this2.addMimeType_(_this2.audioSegmentLoader_, 'mp4a.40.2', media);\\n\\n        // if the video is already playing, or if this isn't a live video and preload\\n        // permits, start downloading segments\\n        if (!_this2.tech_.paused() || media.endList && _this2.tech_.preload() !== 'none') {\\n          _this2.audioSegmentLoader_.load();\\n        }\\n\\n        if (!media.endList) {\\n          // trigger the playlist loader to start \\\"expired time\\\"-tracking\\n          _this2.audioPlaylistLoader_.trigger('firstplay');\\n        }\\n      });\\n\\n      this.audioPlaylistLoader_.on('loadedplaylist', function () {\\n        var updatedPlaylist = undefined;\\n\\n        if (_this2.audioPlaylistLoader_) {\\n          updatedPlaylist = _this2.audioPlaylistLoader_.media();\\n        }\\n\\n        if (!updatedPlaylist) {\\n          // only one playlist to select\\n          _this2.audioPlaylistLoader_.media(_this2.audioPlaylistLoader_.playlists.master.playlists[0]);\\n          return;\\n        }\\n\\n        _this2.audioSegmentLoader_.playlist(updatedPlaylist, _this2.requestOptions_);\\n      });\\n\\n      this.audioPlaylistLoader_.on('error', function () {\\n        _videoJs2['default'].log.warn('Problem encountered loading the alternate audio track' + '. Switching back to default.');\\n        _this2.audioSegmentLoader_.abort();\\n        _this2.audioPlaylistLoader_ = null;\\n        _this2.useAudio();\\n      });\\n\\n      this.audioSegmentLoader_.clearBuffer();\\n      this.audioPlaylistLoader_.start();\\n    }\\n\\n    /**\\n     * Re-tune playback quality level for the current player\\n     * conditions. This method may perform destructive actions, like\\n     * removing already buffered content, to readjust the currently\\n     * active playlist quickly.\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'fastQualityChange_',\\n    value: function fastQualityChange_() {\\n      var media = this.selectPlaylist();\\n\\n      if (media !== this.masterPlaylistLoader_.media()) {\\n        this.masterPlaylistLoader_.media(media);\\n        this.mainSegmentLoader_.sourceUpdater_.remove(this.tech_.currentTime() + 5, Infinity);\\n      }\\n    }\\n\\n    /**\\n     * Begin playback.\\n     */\\n  }, {\\n    key: 'play',\\n    value: function play() {\\n      if (this.setupFirstPlay()) {\\n        return;\\n      }\\n\\n      if (this.tech_.ended()) {\\n        this.tech_.setCurrentTime(0);\\n      }\\n\\n      this.load();\\n\\n      // if the viewer has paused and we fell out of the live window,\\n      // seek forward to the earliest available position\\n      if (this.tech_.duration() === Infinity) {\\n        if (this.tech_.currentTime() < this.tech_.seekable().start(0)) {\\n          return this.tech_.setCurrentTime(this.tech_.seekable().start(0));\\n        }\\n      }\\n    }\\n\\n    /**\\n     * Seek to the latest media position if this is a live video and the\\n     * player and video are loaded and initialized.\\n     */\\n  }, {\\n    key: 'setupFirstPlay',\\n    value: function setupFirstPlay() {\\n      var seekable = undefined;\\n      var media = this.masterPlaylistLoader_.media();\\n\\n      // check that everything is ready to begin buffering\\n      // 1) the active media playlist is available\\n      if (media &&\\n      // 2) the video is a live stream\\n      !media.endList &&\\n\\n      // 3) the player is not paused\\n      !this.tech_.paused() &&\\n\\n      // 4) the player has not started playing\\n      !this.hasPlayed_) {\\n\\n        this.load();\\n\\n        // trigger the playlist loader to start \\\"expired time\\\"-tracking\\n        this.masterPlaylistLoader_.trigger('firstplay');\\n        this.hasPlayed_ = true;\\n\\n        // seek to the latest media position for live videos\\n        seekable = this.seekable();\\n        if (seekable.length) {\\n          this.tech_.setCurrentTime(seekable.end(0));\\n        }\\n\\n        return true;\\n      }\\n      return false;\\n    }\\n\\n    /**\\n     * handle the sourceopen event on the MediaSource\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'handleSourceOpen_',\\n    value: function handleSourceOpen_() {\\n      // Only attempt to create the source buffer if none already exist.\\n      // handleSourceOpen is also called when we are \\\"re-opening\\\" a source buffer\\n      // after `endOfStream` has been called (in response to a seek for instance)\\n      this.setupSourceBuffer_();\\n\\n      // if autoplay is enabled, begin playback. This is duplicative of\\n      // code in video.js but is required because play() must be invoked\\n      // *after* the media source has opened.\\n      if (this.tech_.autoplay()) {\\n        this.tech_.play();\\n      }\\n\\n      this.trigger('sourceopen');\\n    }\\n\\n    /**\\n     * Blacklists a playlist when an error occurs for a set amount of time\\n     * making it unavailable for selection by the rendition selection algorithm\\n     * and then forces a new playlist (rendition) selection.\\n     *\\n     * @param {Object=} error an optional error that may include the playlist\\n     * to blacklist\\n     */\\n  }, {\\n    key: 'blacklistCurrentPlaylist',\\n    value: function blacklistCurrentPlaylist() {\\n      var error = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\\n\\n      var currentPlaylist = undefined;\\n      var nextPlaylist = undefined;\\n\\n      // If the `error` was generated by the playlist loader, it will contain\\n      // the playlist we were trying to load (but failed) and that should be\\n      // blacklisted instead of the currently selected playlist which is likely\\n      // out-of-date in this scenario\\n      currentPlaylist = error.playlist || this.masterPlaylistLoader_.media();\\n\\n      // If there is no current playlist, then an error occurred while we were\\n      // trying to load the master OR while we were disposing of the tech\\n      if (!currentPlaylist) {\\n        this.error = error;\\n        return this.mediaSource.endOfStream('network');\\n      }\\n\\n      // Blacklist this playlist\\n      currentPlaylist.excludeUntil = Date.now() + BLACKLIST_DURATION;\\n\\n      // Select a new playlist\\n      nextPlaylist = this.selectPlaylist();\\n\\n      if (nextPlaylist) {\\n        _videoJs2['default'].log.warn('Problem encountered with the current ' + 'HLS playlist. Switching to another playlist.');\\n\\n        return this.masterPlaylistLoader_.media(nextPlaylist);\\n      }\\n      _videoJs2['default'].log.warn('Problem encountered with the current ' + 'HLS playlist. No suitable alternatives found.');\\n      // We have no more playlists we can select so we must fail\\n      this.error = error;\\n      return this.mediaSource.endOfStream('network');\\n    }\\n\\n    /**\\n     * Pause all segment loaders\\n     */\\n  }, {\\n    key: 'pauseLoading',\\n    value: function pauseLoading() {\\n      this.mainSegmentLoader_.pause();\\n      if (this.audioPlaylistLoader_) {\\n        this.audioSegmentLoader_.pause();\\n      }\\n    }\\n\\n    /**\\n     * set the current time on all segment loaders\\n     *\\n     * @param {TimeRange} currentTime the current time to set\\n     * @return {TimeRange} the current time\\n     */\\n  }, {\\n    key: 'setCurrentTime',\\n    value: function setCurrentTime(currentTime) {\\n      var buffered = _ranges2['default'].findRange(this.tech_.buffered(), currentTime);\\n\\n      if (!(this.masterPlaylistLoader_ && this.masterPlaylistLoader_.media())) {\\n        // return immediately if the metadata is not ready yet\\n        return 0;\\n      }\\n\\n      // it's clearly an edge-case but don't thrown an error if asked to\\n      // seek within an empty playlist\\n      if (!this.masterPlaylistLoader_.media().segments) {\\n        return 0;\\n      }\\n\\n      // if the seek location is already buffered, continue buffering as\\n      // usual\\n      if (buffered && buffered.length) {\\n        return currentTime;\\n      }\\n\\n      // cancel outstanding requests so we begin buffering at the new\\n      // location\\n      this.mainSegmentLoader_.abort();\\n      if (this.audioPlaylistLoader_) {\\n        this.audioSegmentLoader_.abort();\\n      }\\n\\n      if (!this.tech_.paused()) {\\n        this.mainSegmentLoader_.load();\\n        if (this.audioPlaylistLoader_) {\\n          this.audioSegmentLoader_.load();\\n        }\\n      }\\n    }\\n\\n    /**\\n     * get the current duration\\n     *\\n     * @return {TimeRange} the duration\\n     */\\n  }, {\\n    key: 'duration',\\n    value: function duration() {\\n      if (!this.masterPlaylistLoader_) {\\n        return 0;\\n      }\\n\\n      if (this.mediaSource) {\\n        return this.mediaSource.duration;\\n      }\\n\\n      return Hls.Playlist.duration(this.masterPlaylistLoader_.media());\\n    }\\n\\n    /**\\n     * check the seekable range\\n     *\\n     * @return {TimeRange} the seekable range\\n     */\\n  }, {\\n    key: 'seekable',\\n    value: function seekable() {\\n      var media = undefined;\\n      var mainSeekable = undefined;\\n      var audioSeekable = undefined;\\n\\n      if (!this.masterPlaylistLoader_) {\\n        return _videoJs2['default'].createTimeRanges();\\n      }\\n      media = this.masterPlaylistLoader_.media();\\n      if (!media) {\\n        return _videoJs2['default'].createTimeRanges();\\n      }\\n\\n      mainSeekable = Hls.Playlist.seekable(media, this.masterPlaylistLoader_.expired_);\\n      if (mainSeekable.length === 0) {\\n        return mainSeekable;\\n      }\\n\\n      if (this.audioPlaylistLoader_) {\\n        audioSeekable = Hls.Playlist.seekable(this.audioPlaylistLoader_.media(), this.audioPlaylistLoader_.expired_);\\n        if (audioSeekable.length === 0) {\\n          return audioSeekable;\\n        }\\n      }\\n\\n      if (!audioSeekable) {\\n        // seekable has been calculated based on buffering video data so it\\n        // can be returned directly\\n        return mainSeekable;\\n      }\\n\\n      return _videoJs2['default'].createTimeRanges([[audioSeekable.start(0) > mainSeekable.start(0) ? audioSeekable.start(0) : mainSeekable.start(0), audioSeekable.end(0) < mainSeekable.end(0) ? audioSeekable.end(0) : mainSeekable.end(0)]]);\\n    }\\n\\n    /**\\n     * Update the player duration\\n     */\\n  }, {\\n    key: 'updateDuration',\\n    value: function updateDuration() {\\n      var _this3 = this;\\n\\n      var oldDuration = this.mediaSource.duration;\\n      var newDuration = Hls.Playlist.duration(this.masterPlaylistLoader_.media());\\n      var buffered = this.tech_.buffered();\\n      var setDuration = function setDuration() {\\n        _this3.mediaSource.duration = newDuration;\\n        _this3.tech_.trigger('durationchange');\\n\\n        _this3.mediaSource.removeEventListener('sourceopen', setDuration);\\n      };\\n\\n      if (buffered.length > 0) {\\n        newDuration = Math.max(newDuration, buffered.end(buffered.length - 1));\\n      }\\n\\n      // if the duration has changed, invalidate the cached value\\n      if (oldDuration !== newDuration) {\\n        // update the duration\\n        if (this.mediaSource.readyState !== 'open') {\\n          this.mediaSource.addEventListener('sourceopen', setDuration);\\n        } else {\\n          setDuration();\\n        }\\n      }\\n    }\\n\\n    /**\\n     * dispose of the MasterPlaylistController and everything\\n     * that it controls\\n     */\\n  }, {\\n    key: 'dispose',\\n    value: function dispose() {\\n      this.masterPlaylistLoader_.dispose();\\n      this.audioTracks_.forEach(function (track) {\\n        track.dispose();\\n      });\\n      this.audioTracks_.length = 0;\\n      this.mainSegmentLoader_.dispose();\\n      this.audioSegmentLoader_.dispose();\\n    }\\n\\n    /**\\n     * return the master playlist object if we have one\\n     *\\n     * @return {Object} the master playlist object that we parsed\\n     */\\n  }, {\\n    key: 'master',\\n    value: function master() {\\n      return this.masterPlaylistLoader_.master;\\n    }\\n\\n    /**\\n     * return the currently selected playlist\\n     *\\n     * @return {Object} the currently selected playlist object that we parsed\\n     */\\n  }, {\\n    key: 'media',\\n    value: function media() {\\n      // playlist loader will not return media if it has not been fully loaded\\n      return this.masterPlaylistLoader_.media() || this.initialMedia_;\\n    }\\n\\n    /**\\n     * setup our internal source buffers on our segment Loaders\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'setupSourceBuffer_',\\n    value: function setupSourceBuffer_() {\\n      var media = this.masterPlaylistLoader_.media();\\n\\n      // wait until a media playlist is available and the Media Source is\\n      // attached\\n      if (!media || this.mediaSource.readyState !== 'open') {\\n        return;\\n      }\\n\\n      this.addMimeType_(this.mainSegmentLoader_, 'avc1.4d400d, mp4a.40.2', media);\\n\\n      // exclude any incompatible variant streams from future playlist\\n      // selection\\n      this.excludeIncompatibleVariants_(media);\\n    }\\n\\n    /**\\n     * add a time type to a segmentLoader\\n     *\\n     * @param {SegmentLoader} segmentLoader the segmentloader to work on\\n     * @param {String} codecs to use by default\\n     * @param {Object} the parsed media object\\n     * @private\\n     */\\n  }, {\\n    key: 'addMimeType_',\\n    value: function addMimeType_(segmentLoader, defaultCodecs, media) {\\n      var mimeType = 'video/mp2t';\\n\\n      // if the codecs were explicitly specified, pass them along to the\\n      // source buffer\\n      if (media.attributes && media.attributes.CODECS) {\\n        mimeType += '; codecs=\\\"' + media.attributes.CODECS + '\\\"';\\n      } else {\\n        mimeType += '; codecs=\\\"' + defaultCodecs + '\\\"';\\n      }\\n      segmentLoader.mimeType(mimeType);\\n    }\\n\\n    /**\\n     * Blacklist playlists that are known to be codec or\\n     * stream-incompatible with the SourceBuffer configuration. For\\n     * instance, Media Source Extensions would cause the video element to\\n     * stall waiting for video data if you switched from a variant with\\n     * video and audio to an audio-only one.\\n     *\\n     * @param {Object} media a media playlist compatible with the current\\n     * set of SourceBuffers. Variants in the current master playlist that\\n     * do not appear to have compatible codec or stream configurations\\n     * will be excluded from the default playlist selection algorithm\\n     * indefinitely.\\n     * @private\\n     */\\n  }, {\\n    key: 'excludeIncompatibleVariants_',\\n    value: function excludeIncompatibleVariants_(media) {\\n      var master = this.masterPlaylistLoader_.master;\\n      var codecCount = 2;\\n      var videoCodec = null;\\n      var audioProfile = null;\\n      var codecs = undefined;\\n\\n      if (media.attributes && media.attributes.CODECS) {\\n        codecs = parseCodecs(media.attributes.CODECS);\\n        videoCodec = codecs.videoCodec;\\n        audioProfile = codecs.audioProfile;\\n        codecCount = codecs.codecCount;\\n      }\\n      master.playlists.forEach(function (variant) {\\n        var variantCodecs = {\\n          codecCount: 2,\\n          videoCodec: null,\\n          audioProfile: null\\n        };\\n\\n        if (variant.attributes && variant.attributes.CODECS) {\\n          variantCodecs = parseCodecs(variant.attributes.CODECS);\\n        }\\n\\n        // if the streams differ in the presence or absence of audio or\\n        // video, they are incompatible\\n        if (variantCodecs.codecCount !== codecCount) {\\n          variant.excludeUntil = Infinity;\\n        }\\n\\n        // if h.264 is specified on the current playlist, some flavor of\\n        // it must be specified on all compatible variants\\n        if (variantCodecs.videoCodec !== videoCodec) {\\n          variant.excludeUntil = Infinity;\\n        }\\n        // HE-AAC (\\\"mp4a.40.5\\\") is incompatible with all other versions of\\n        // AAC audio in Chrome 46. Don't mix the two.\\n        if (variantCodecs.audioProfile === '5' && audioProfile !== '5' || audioProfile === '5' && variantCodecs.audioProfile !== '5') {\\n          variant.excludeUntil = Infinity;\\n        }\\n      });\\n    }\\n  }, {\\n    key: 'updateAdCues_',\\n    value: function updateAdCues_(media) {\\n      var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\\n\\n      _adCueTags2['default'].updateAdCues(media, this.cueTagsTrack_, offset);\\n    }\\n  }]);\\n\\n  return MasterPlaylistController;\\n})(_videoJs2['default'].EventTarget);\\n\\nexports['default'] = MasterPlaylistController;\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./ad-cue-tags\\\":1,\\\"./hls-audio-track\\\":5,\\\"./playlist-loader\\\":7,\\\"./ranges\\\":9,\\\"./segment-loader\\\":12}],7:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file playlist-loader.js\\n *\\n * A state machine that manages the loading, caching, and updating of\\n * M3U8 playlists.\\n *\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _resolveUrl = require('./resolve-url');\\n\\nvar _resolveUrl2 = _interopRequireDefault(_resolveUrl);\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _stream = require('./stream');\\n\\nvar _stream2 = _interopRequireDefault(_stream);\\n\\nvar _m3u8Parser = require('m3u8-parser');\\n\\nvar _m3u8Parser2 = _interopRequireDefault(_m3u8Parser);\\n\\nvar _globalWindow = require('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\n/**\\n  * Returns a new array of segments that is the result of merging\\n  * properties from an older list of segments onto an updated\\n  * list. No properties on the updated playlist will be overridden.\\n  *\\n  * @param {Array} original the outdated list of segments\\n  * @param {Array} update the updated list of segments\\n  * @param {Number=} offset the index of the first update\\n  * segment in the original segment list. For non-live playlists,\\n  * this should always be zero and does not need to be\\n  * specified. For live playlists, it should be the difference\\n  * between the media sequence numbers in the original and updated\\n  * playlists.\\n  * @return a list of merged segment objects\\n  */\\nvar updateSegments = function updateSegments(original, update, offset) {\\n  var result = update.slice();\\n  var length = undefined;\\n  var i = undefined;\\n\\n  offset = offset || 0;\\n  length = Math.min(original.length, update.length + offset);\\n\\n  for (i = offset; i < length; i++) {\\n    result[i - offset] = (0, _videoJs.mergeOptions)(original[i], result[i - offset]);\\n  }\\n  return result;\\n};\\n\\n/**\\n  * Returns a new master playlist that is the result of merging an\\n  * updated media playlist into the original version. If the\\n  * updated media playlist does not match any of the playlist\\n  * entries in the original master playlist, null is returned.\\n  *\\n  * @param {Object} master a parsed master M3U8 object\\n  * @param {Object} media a parsed media M3U8 object\\n  * @return {Object} a new object that represents the original\\n  * master playlist with the updated media playlist merged in, or\\n  * null if the merge produced no change.\\n  */\\nvar updateMaster = function updateMaster(master, media) {\\n  var changed = false;\\n  var result = (0, _videoJs.mergeOptions)(master, {});\\n  var i = master.playlists.length;\\n  var playlist = undefined;\\n  var segment = undefined;\\n  var j = undefined;\\n\\n  while (i--) {\\n    playlist = result.playlists[i];\\n    if (playlist.uri === media.uri) {\\n      // consider the playlist unchanged if the number of segments\\n      // are equal and the media sequence number is unchanged\\n      if (playlist.segments && media.segments && playlist.segments.length === media.segments.length && playlist.mediaSequence === media.mediaSequence) {\\n        continue;\\n      }\\n\\n      result.playlists[i] = (0, _videoJs.mergeOptions)(playlist, media);\\n      result.playlists[media.uri] = result.playlists[i];\\n\\n      // if the update could overlap existing segment information,\\n      // merge the two lists\\n      if (playlist.segments) {\\n        result.playlists[i].segments = updateSegments(playlist.segments, media.segments, media.mediaSequence - playlist.mediaSequence);\\n      }\\n      // resolve any missing segment and key URIs\\n      j = 0;\\n      if (result.playlists[i].segments) {\\n        j = result.playlists[i].segments.length;\\n      }\\n      while (j--) {\\n        segment = result.playlists[i].segments[j];\\n        if (!segment.resolvedUri) {\\n          segment.resolvedUri = (0, _resolveUrl2['default'])(playlist.resolvedUri, segment.uri);\\n        }\\n        if (segment.key && !segment.key.resolvedUri) {\\n          segment.key.resolvedUri = (0, _resolveUrl2['default'])(playlist.resolvedUri, segment.key.uri);\\n        }\\n      }\\n      changed = true;\\n    }\\n  }\\n  return changed ? result : null;\\n};\\n\\n/**\\n * Load a playlist from a remote loacation\\n *\\n * @class PlaylistLoader\\n * @extends Stream\\n * @param {String} srcUrl the url to start with\\n * @param {Boolean} withCredentials the withCredentials xhr option\\n * @constructor\\n */\\nvar PlaylistLoader = function PlaylistLoader(srcUrl, hls, withCredentials) {\\n  var _this = this;\\n\\n  /* eslint-disable consistent-this */\\n  var loader = this;\\n  /* eslint-enable consistent-this */\\n  var dispose = undefined;\\n  var mediaUpdateTimeout = undefined;\\n  var request = undefined;\\n  var playlistRequestError = undefined;\\n  var haveMetadata = undefined;\\n\\n  PlaylistLoader.prototype.constructor.call(this);\\n\\n  this.hls_ = hls;\\n\\n  // a flag that disables \\\"expired time\\\"-tracking this setting has\\n  // no effect when not playing a live stream\\n  this.trackExpiredTime_ = false;\\n\\n  if (!srcUrl) {\\n    throw new Error('A non-empty playlist URL is required');\\n  }\\n\\n  playlistRequestError = function (xhr, url, startingState) {\\n    loader.setBandwidth(request || xhr);\\n\\n    // any in-flight request is now finished\\n    request = null;\\n\\n    if (startingState) {\\n      loader.state = startingState;\\n    }\\n\\n    loader.error = {\\n      playlist: loader.master.playlists[url],\\n      status: xhr.status,\\n      message: 'HLS playlist request error at URL: ' + url,\\n      responseText: xhr.responseText,\\n      code: xhr.status >= 500 ? 4 : 2\\n    };\\n\\n    loader.trigger('error');\\n  };\\n\\n  // update the playlist loader's state in response to a new or\\n  // updated playlist.\\n  haveMetadata = function (xhr, url) {\\n    var parser = undefined;\\n    var refreshDelay = undefined;\\n    var update = undefined;\\n\\n    loader.setBandwidth(request || xhr);\\n\\n    // any in-flight request is now finished\\n    request = null;\\n\\n    loader.state = 'HAVE_METADATA';\\n\\n    parser = new _m3u8Parser2['default'].Parser();\\n\\n    parser.push(xhr.responseText);\\n    parser.end();\\n    parser.manifest.uri = url;\\n\\n    // merge this playlist into the master\\n    update = updateMaster(loader.master, parser.manifest);\\n    refreshDelay = (parser.manifest.targetDuration || 10) * 1000;\\n    loader.targetDuration = parser.manifest.targetDuration;\\n    if (update) {\\n      loader.master = update;\\n      loader.updateMediaPlaylist_(parser.manifest);\\n    } else {\\n      // if the playlist is unchanged since the last reload,\\n      // try again after half the target duration\\n      refreshDelay /= 2;\\n    }\\n\\n    // refresh live playlists after a target duration passes\\n    if (!loader.media().endList) {\\n      _globalWindow2['default'].clearTimeout(mediaUpdateTimeout);\\n      mediaUpdateTimeout = _globalWindow2['default'].setTimeout(function () {\\n        loader.trigger('mediaupdatetimeout');\\n      }, refreshDelay);\\n    }\\n\\n    loader.trigger('loadedplaylist');\\n  };\\n\\n  // initialize the loader state\\n  loader.state = 'HAVE_NOTHING';\\n\\n  // track the time that has expired from the live window\\n  // this allows the seekable start range to be calculated even if\\n  // all segments with timing information have expired\\n  this.expired_ = 0;\\n\\n  // capture the prototype dispose function\\n  dispose = this.dispose;\\n\\n  /**\\n   * Abort any outstanding work and clean up.\\n   */\\n  loader.dispose = function () {\\n    loader.stopRequest();\\n    _globalWindow2['default'].clearTimeout(mediaUpdateTimeout);\\n    dispose.call(this);\\n  };\\n\\n  loader.stopRequest = function () {\\n    if (request) {\\n      var oldRequest = request;\\n\\n      request = null;\\n      oldRequest.onreadystatechange = null;\\n      oldRequest.abort();\\n    }\\n  };\\n\\n  /**\\n   * Returns the number of enabled playlists on the master playlist object\\n   *\\n   * @return {Number} number of eneabled playlists\\n   */\\n  loader.enabledPlaylists_ = function () {\\n    return loader.master.playlists.filter(function (element, index, array) {\\n      return !element.excludeUntil || element.excludeUntil <= Date.now();\\n    }).length;\\n  };\\n\\n  /**\\n   * Returns whether the current playlist is the lowest rendition\\n   *\\n   * @return {Boolean} true if on lowest rendition\\n   */\\n  loader.isLowestEnabledRendition_ = function () {\\n    if (!loader.media()) {\\n      return false;\\n    }\\n\\n    var currentPlaylist = loader.media().attributes.BANDWIDTH;\\n\\n    return !(loader.master.playlists.filter(function (element, index, array) {\\n      var enabled = typeof element.excludeUntil === 'undefined' || element.excludeUntil <= Date.now();\\n\\n      if (!enabled) {\\n        return false;\\n      }\\n\\n      var item = element.attributes.BANDWIDTH;\\n\\n      return item <= currentPlaylist;\\n    }).length > 1);\\n  };\\n\\n  /**\\n   * When called without any arguments, returns the currently\\n   * active media playlist. When called with a single argument,\\n   * triggers the playlist loader to asynchronously switch to the\\n   * specified media playlist. Calling this method while the\\n   * loader is in the HAVE_NOTHING causes an error to be emitted\\n   * but otherwise has no effect.\\n   *\\n   * @param {Object=} playlis tthe parsed media playlist\\n   * object to switch to\\n   * @return {Playlist} the current loaded media\\n   */\\n  loader.media = function (playlist) {\\n    var startingState = loader.state;\\n    var mediaChange = undefined;\\n\\n    // getter\\n    if (!playlist) {\\n      return loader.media_;\\n    }\\n\\n    // setter\\n    if (loader.state === 'HAVE_NOTHING') {\\n      throw new Error('Cannot switch media playlist from ' + loader.state);\\n    }\\n\\n    // find the playlist object if the target playlist has been\\n    // specified by URI\\n    if (typeof playlist === 'string') {\\n      if (!loader.master.playlists[playlist]) {\\n        throw new Error('Unknown playlist URI: ' + playlist);\\n      }\\n      playlist = loader.master.playlists[playlist];\\n    }\\n\\n    mediaChange = !loader.media_ || playlist.uri !== loader.media_.uri;\\n\\n    // switch to fully loaded playlists immediately\\n    if (loader.master.playlists[playlist.uri].endList) {\\n      // abort outstanding playlist requests\\n      if (request) {\\n        request.onreadystatechange = null;\\n        request.abort();\\n        request = null;\\n      }\\n      loader.state = 'HAVE_METADATA';\\n      loader.media_ = playlist;\\n\\n      // trigger media change if the active media has been updated\\n      if (mediaChange) {\\n        loader.trigger('mediachanging');\\n        loader.trigger('mediachange');\\n      }\\n      return;\\n    }\\n\\n    // switching to the active playlist is a no-op\\n    if (!mediaChange) {\\n      return;\\n    }\\n\\n    loader.state = 'SWITCHING_MEDIA';\\n\\n    // there is already an outstanding playlist request\\n    if (request) {\\n      if ((0, _resolveUrl2['default'])(loader.master.uri, playlist.uri) === request.url) {\\n        // requesting to switch to the same playlist multiple times\\n        // has no effect after the first\\n        return;\\n      }\\n      request.onreadystatechange = null;\\n      request.abort();\\n      request = null;\\n    }\\n\\n    // request the new playlist\\n    if (this.media_) {\\n      this.trigger('mediachanging');\\n    }\\n    request = this.hls_.xhr({\\n      uri: (0, _resolveUrl2['default'])(loader.master.uri, playlist.uri),\\n      withCredentials: withCredentials\\n    }, function (error, req) {\\n      // disposed\\n      if (!request) {\\n        return;\\n      }\\n\\n      if (error) {\\n        return playlistRequestError(request, playlist.uri, startingState);\\n      }\\n\\n      haveMetadata(req, playlist.uri);\\n\\n      // fire loadedmetadata the first time a media playlist is loaded\\n      if (startingState === 'HAVE_MASTER') {\\n        loader.trigger('loadedmetadata');\\n      } else {\\n        loader.trigger('mediachange');\\n      }\\n    });\\n  };\\n\\n  /**\\n   * set the bandwidth on an xhr to the bandwidth on the playlist\\n   */\\n  loader.setBandwidth = function (xhr) {\\n    loader.bandwidth = xhr.bandwidth;\\n  };\\n\\n  // In a live playlist, don't keep track of the expired time\\n  // until HLS tells us that \\\"first play\\\" has commenced\\n  loader.on('firstplay', function () {\\n    this.trackExpiredTime_ = true;\\n  });\\n\\n  // live playlist staleness timeout\\n  loader.on('mediaupdatetimeout', function () {\\n    if (loader.state !== 'HAVE_METADATA') {\\n      // only refresh the media playlist if no other activity is going on\\n      return;\\n    }\\n\\n    loader.state = 'HAVE_CURRENT_METADATA';\\n    request = this.hls_.xhr({\\n      uri: (0, _resolveUrl2['default'])(loader.master.uri, loader.media().uri),\\n      withCredentials: withCredentials\\n    }, function (error, req) {\\n      // disposed\\n      if (!request) {\\n        return;\\n      }\\n\\n      if (error) {\\n        return playlistRequestError(request, loader.media().uri);\\n      }\\n      haveMetadata(request, loader.media().uri);\\n    });\\n  });\\n\\n  /**\\n   * pause loading of the playlist\\n   */\\n  loader.pause = function () {\\n    loader.stopRequest();\\n    _globalWindow2['default'].clearTimeout(mediaUpdateTimeout);\\n  };\\n\\n  /**\\n   * start loading of the playlist\\n   */\\n  loader.load = function () {\\n    if (loader.started) {\\n      if (!loader.media().endList) {\\n        loader.trigger('mediaupdatetimeout');\\n      } else {\\n        loader.trigger('loadedplaylist');\\n      }\\n    } else {\\n      loader.start();\\n    }\\n  };\\n\\n  /**\\n   * start loading of the playlist\\n   */\\n  loader.start = function () {\\n    loader.started = true;\\n\\n    // request the specified URL\\n    request = _this.hls_.xhr({\\n      uri: srcUrl,\\n      withCredentials: withCredentials\\n    }, function (error, req) {\\n      var parser = undefined;\\n      var playlist = undefined;\\n      var i = undefined;\\n\\n      // disposed\\n      if (!request) {\\n        return;\\n      }\\n\\n      // clear the loader's request reference\\n      request = null;\\n\\n      if (error) {\\n        loader.error = {\\n          status: req.status,\\n          message: 'HLS playlist request error at URL: ' + srcUrl,\\n          responseText: req.responseText,\\n          // MEDIA_ERR_NETWORK\\n          code: 2\\n        };\\n        return loader.trigger('error');\\n      }\\n\\n      parser = new _m3u8Parser2['default'].Parser();\\n      parser.push(req.responseText);\\n      parser.end();\\n\\n      loader.state = 'HAVE_MASTER';\\n\\n      parser.manifest.uri = srcUrl;\\n\\n      // loaded a master playlist\\n      if (parser.manifest.playlists) {\\n        loader.master = parser.manifest;\\n\\n        // setup by-URI lookups and resolve media playlist URIs\\n        i = loader.master.playlists.length;\\n        while (i--) {\\n          playlist = loader.master.playlists[i];\\n          loader.master.playlists[playlist.uri] = playlist;\\n          playlist.resolvedUri = (0, _resolveUrl2['default'])(loader.master.uri, playlist.uri);\\n        }\\n\\n        // resolve any media group URIs\\n        for (var groupKey in loader.master.mediaGroups.AUDIO) {\\n          for (var labelKey in loader.master.mediaGroups.AUDIO[groupKey]) {\\n            var alternateAudio = loader.master.mediaGroups.AUDIO[groupKey][labelKey];\\n\\n            if (alternateAudio.uri) {\\n              alternateAudio.resolvedUri = (0, _resolveUrl2['default'])(loader.master.uri, alternateAudio.uri);\\n            }\\n          }\\n        }\\n\\n        loader.trigger('loadedplaylist');\\n        if (!request) {\\n          // no media playlist was specifically selected so start\\n          // from the first listed one\\n          loader.media(parser.manifest.playlists[0]);\\n        }\\n        return;\\n      }\\n\\n      // loaded a media playlist\\n      // infer a master playlist if none was previously requested\\n      loader.master = {\\n        uri: _globalWindow2['default'].location.href,\\n        playlists: [{\\n          uri: srcUrl\\n        }]\\n      };\\n      loader.master.playlists[srcUrl] = loader.master.playlists[0];\\n      loader.master.playlists[0].resolvedUri = srcUrl;\\n      haveMetadata(req, srcUrl);\\n      return loader.trigger('loadedmetadata');\\n    });\\n  };\\n};\\n\\nPlaylistLoader.prototype = new _stream2['default']();\\n\\n/**\\n * Update the PlaylistLoader state to reflect the changes in an\\n * update to the current media playlist.\\n *\\n * @param {Object} update the updated media playlist object\\n */\\nPlaylistLoader.prototype.updateMediaPlaylist_ = function (update) {\\n  var outdated = undefined;\\n  var i = undefined;\\n  var segment = undefined;\\n\\n  outdated = this.media_;\\n  this.media_ = this.master.playlists[update.uri];\\n\\n  if (!outdated) {\\n    return;\\n  }\\n\\n  // don't track expired time until this flag is truthy\\n  if (!this.trackExpiredTime_) {\\n    return;\\n  }\\n\\n  // if the update was the result of a rendition switch do not\\n  // attempt to calculate expired_ since media-sequences need not\\n  // correlate between renditions/variants\\n  if (update.uri !== outdated.uri) {\\n    return;\\n  }\\n\\n  // try using precise timing from first segment of the updated\\n  // playlist\\n  if (update.segments.length) {\\n    if (typeof update.segments[0].start !== 'undefined') {\\n      this.expired_ = update.segments[0].start;\\n      return;\\n    } else if (typeof update.segments[0].end !== 'undefined') {\\n      this.expired_ = update.segments[0].end - update.segments[0].duration;\\n      return;\\n    }\\n  }\\n\\n  // calculate expired by walking the outdated playlist\\n  i = update.mediaSequence - outdated.mediaSequence - 1;\\n\\n  for (; i >= 0; i--) {\\n    segment = outdated.segments[i];\\n\\n    if (!segment) {\\n      // we missed information on this segment completely between\\n      // playlist updates so we'll have to take an educated guess\\n      // once we begin buffering again, any error we introduce can\\n      // be corrected\\n      this.expired_ += outdated.targetDuration || 10;\\n      continue;\\n    }\\n\\n    if (typeof segment.end !== 'undefined') {\\n      this.expired_ = segment.end;\\n      return;\\n    }\\n    if (typeof segment.start !== 'undefined') {\\n      this.expired_ = segment.start + segment.duration;\\n      return;\\n    }\\n    this.expired_ += segment.duration;\\n  }\\n};\\n\\nexports['default'] = PlaylistLoader;\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./resolve-url\\\":11,\\\"./stream\\\":14,\\\"global/window\\\":26,\\\"m3u8-parser\\\":63}],8:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file playlist.js\\n *\\n * Playlist related utilities.\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _globalWindow = require('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar Playlist = {\\n  /**\\n   * The number of segments that are unsafe to start playback at in\\n   * a live stream. Changing this value can cause playback stalls.\\n   * See HTTP Live Streaming, \\\"Playing the Media Playlist File\\\"\\n   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-18#section-6.3.3\\n   */\\n  UNSAFE_LIVE_SEGMENTS: 3\\n};\\n\\n/**\\n * walk backward until we find a duration we can use\\n * or return a failure\\n *\\n * @param {Playlist} playlist the playlist to walk through\\n * @param {Number} endSequence the mediaSequence to stop walking on\\n */\\n\\nvar backwardDuration = function backwardDuration(playlist, endSequence) {\\n  var result = 0;\\n  var i = endSequence - playlist.mediaSequence;\\n  // if a start time is available for segment immediately following\\n  // the interval, use it\\n  var segment = playlist.segments[i];\\n\\n  // Walk backward until we find the latest segment with timeline\\n  // information that is earlier than endSequence\\n  if (segment) {\\n    if (typeof segment.start !== 'undefined') {\\n      return { result: segment.start, precise: true };\\n    }\\n    if (typeof segment.end !== 'undefined') {\\n      return {\\n        result: segment.end - segment.duration,\\n        precise: true\\n      };\\n    }\\n  }\\n  while (i--) {\\n    segment = playlist.segments[i];\\n    if (typeof segment.end !== 'undefined') {\\n      return { result: result + segment.end, precise: true };\\n    }\\n\\n    result += segment.duration;\\n\\n    if (typeof segment.start !== 'undefined') {\\n      return { result: result + segment.start, precise: true };\\n    }\\n  }\\n  return { result: result, precise: false };\\n};\\n\\n/**\\n * walk forward until we find a duration we can use\\n * or return a failure\\n *\\n * @param {Playlist} playlist the playlist to walk through\\n * @param {Number} endSequence the mediaSequence to stop walking on\\n */\\nvar forwardDuration = function forwardDuration(playlist, endSequence) {\\n  var result = 0;\\n  var segment = undefined;\\n  var i = endSequence - playlist.mediaSequence;\\n  // Walk forward until we find the earliest segment with timeline\\n  // information\\n\\n  for (; i < playlist.segments.length; i++) {\\n    segment = playlist.segments[i];\\n    if (typeof segment.start !== 'undefined') {\\n      return {\\n        result: segment.start - result,\\n        precise: true\\n      };\\n    }\\n\\n    result += segment.duration;\\n\\n    if (typeof segment.end !== 'undefined') {\\n      return {\\n        result: segment.end - result,\\n        precise: true\\n      };\\n    }\\n  }\\n  // indicate we didn't find a useful duration estimate\\n  return { result: -1, precise: false };\\n};\\n\\n/**\\n  * Calculate the media duration from the segments associated with a\\n  * playlist. The duration of a subinterval of the available segments\\n  * may be calculated by specifying an end index.\\n  *\\n  * @param {Object} playlist a media playlist object\\n  * @param {Number=} endSequence an exclusive upper boundary\\n  * for the playlist.  Defaults to playlist length.\\n  * @param {Number} expired the amount of time that has dropped\\n  * off the front of the playlist in a live scenario\\n  * @return {Number} the duration between the first available segment\\n  * and end index.\\n  */\\nvar intervalDuration = function intervalDuration(playlist, endSequence, expired) {\\n  var backward = undefined;\\n  var forward = undefined;\\n\\n  if (typeof endSequence === 'undefined') {\\n    endSequence = playlist.mediaSequence + playlist.segments.length;\\n  }\\n\\n  if (endSequence < playlist.mediaSequence) {\\n    return 0;\\n  }\\n\\n  // do a backward walk to estimate the duration\\n  backward = backwardDuration(playlist, endSequence);\\n  if (backward.precise) {\\n    // if we were able to base our duration estimate on timing\\n    // information provided directly from the Media Source, return\\n    // it\\n    return backward.result;\\n  }\\n\\n  // walk forward to see if a precise duration estimate can be made\\n  // that way\\n  forward = forwardDuration(playlist, endSequence);\\n  if (forward.precise) {\\n    // we found a segment that has been buffered and so it's\\n    // position is known precisely\\n    return forward.result;\\n  }\\n\\n  // return the less-precise, playlist-based duration estimate\\n  return backward.result + expired;\\n};\\n\\n/**\\n  * Calculates the duration of a playlist. If a start and end index\\n  * are specified, the duration will be for the subset of the media\\n  * timeline between those two indices. The total duration for live\\n  * playlists is always Infinity.\\n  *\\n  * @param {Object} playlist a media playlist object\\n  * @param {Number=} endSequence an exclusive upper\\n  * boundary for the playlist. Defaults to the playlist media\\n  * sequence number plus its length.\\n  * @param {Number=} expired the amount of time that has\\n  * dropped off the front of the playlist in a live scenario\\n  * @return {Number} the duration between the start index and end\\n  * index.\\n  */\\nvar duration = function duration(playlist, endSequence, expired) {\\n  if (!playlist) {\\n    return 0;\\n  }\\n\\n  if (typeof expired !== 'number') {\\n    expired = 0;\\n  }\\n\\n  // if a slice of the total duration is not requested, use\\n  // playlist-level duration indicators when they're present\\n  if (typeof endSequence === 'undefined') {\\n    // if present, use the duration specified in the playlist\\n    if (playlist.totalDuration) {\\n      return playlist.totalDuration;\\n    }\\n\\n    // duration should be Infinity for live playlists\\n    if (!playlist.endList) {\\n      return _globalWindow2['default'].Infinity;\\n    }\\n  }\\n\\n  // calculate the total duration based on the segment durations\\n  return intervalDuration(playlist, endSequence, expired);\\n};\\n\\nexports.duration = duration;\\n/**\\n  * Calculates the interval of time that is currently seekable in a\\n  * playlist. The returned time ranges are relative to the earliest\\n  * moment in the specified playlist that is still available. A full\\n  * seekable implementation for live streams would need to offset\\n  * these values by the duration of content that has expired from the\\n  * stream.\\n  *\\n  * @param {Object} playlist a media playlist object\\n  * @param {Number=} expired the amount of time that has\\n  * dropped off the front of the playlist in a live scenario\\n  * @return {TimeRanges} the periods of time that are valid targets\\n  * for seeking\\n  */\\nvar seekable = function seekable(playlist, expired) {\\n  var start = undefined;\\n  var end = undefined;\\n  var endSequence = undefined;\\n\\n  if (typeof expired !== 'number') {\\n    expired = 0;\\n  }\\n\\n  // without segments, there are no seekable ranges\\n  if (!playlist || !playlist.segments) {\\n    return (0, _videoJs.createTimeRange)();\\n  }\\n  // when the playlist is complete, the entire duration is seekable\\n  if (playlist.endList) {\\n    return (0, _videoJs.createTimeRange)(0, duration(playlist));\\n  }\\n\\n  // live playlists should not expose three segment durations worth\\n  // of content from the end of the playlist\\n  // https://tools.ietf.org/html/draft-pantos-http-live-streaming-16#section-6.3.3\\n  start = intervalDuration(playlist, playlist.mediaSequence, expired);\\n  endSequence = Math.max(0, playlist.segments.length - Playlist.UNSAFE_LIVE_SEGMENTS);\\n  end = intervalDuration(playlist, playlist.mediaSequence + endSequence, expired);\\n  return (0, _videoJs.createTimeRange)(start, end);\\n};\\n\\nexports.seekable = seekable;\\n/**\\n * Determine the index of the segment that contains a specified\\n * playback position in a media playlist.\\n *\\n * @param {Object} playlist the media playlist to query\\n * @param {Number} time The number of seconds since the earliest\\n * possible position to determine the containing segment for\\n * @param {Number=} expired the duration of content, in\\n * seconds, that has been removed from this playlist because it\\n * expired\\n * @return {Number} The number of the media segment that contains\\n * that time position.\\n */\\nvar getMediaIndexForTime_ = function getMediaIndexForTime_(playlist, time, expired) {\\n  var i = undefined;\\n  var segment = undefined;\\n  var originalTime = time;\\n  var numSegments = playlist.segments.length;\\n  var lastSegment = numSegments - 1;\\n  var startIndex = undefined;\\n  var endIndex = undefined;\\n  var knownStart = undefined;\\n  var knownEnd = undefined;\\n\\n  if (!playlist) {\\n    return 0;\\n  }\\n\\n  // when the requested position is earlier than the current set of\\n  // segments, return the earliest segment index\\n  if (time < 0) {\\n    return 0;\\n  }\\n\\n  if (time === 0 && !expired) {\\n    return 0;\\n  }\\n\\n  expired = expired || 0;\\n\\n  // find segments with known timing information that bound the\\n  // target time\\n  for (i = 0; i < numSegments; i++) {\\n    segment = playlist.segments[i];\\n    if (segment.end) {\\n      if (segment.end > time) {\\n        knownEnd = segment.end;\\n        endIndex = i;\\n        break;\\n      } else {\\n        knownStart = segment.end;\\n        startIndex = i + 1;\\n      }\\n    }\\n  }\\n\\n  // time was equal to or past the end of the last segment in the playlist\\n  if (startIndex === numSegments) {\\n    return numSegments;\\n  }\\n\\n  // use the bounds we just found and playlist information to\\n  // estimate the segment that contains the time we are looking for\\n  if (typeof startIndex !== 'undefined') {\\n    // We have a known-start point that is before our desired time so\\n    // walk from that point forwards\\n    time = time - knownStart;\\n    for (i = startIndex; i < (endIndex || numSegments); i++) {\\n      segment = playlist.segments[i];\\n      time -= segment.duration;\\n\\n      if (time < 0) {\\n        return i;\\n      }\\n    }\\n\\n    if (i >= endIndex) {\\n      // We haven't found a segment but we did hit a known end point\\n      // so fallback to interpolating between the segment index\\n      // based on the known span of the timeline we are dealing with\\n      // and the number of segments inside that span\\n      return startIndex + Math.floor((originalTime - knownStart) / (knownEnd - knownStart) * (endIndex - startIndex));\\n    }\\n\\n    // We _still_ haven't found a segment so load the last one\\n    return lastSegment;\\n  } else if (typeof endIndex !== 'undefined') {\\n    // We _only_ have a known-end point that is after our desired time so\\n    // walk from that point backwards\\n    time = knownEnd - time;\\n    for (i = endIndex; i >= 0; i--) {\\n      segment = playlist.segments[i];\\n      time -= segment.duration;\\n\\n      if (time < 0) {\\n        return i;\\n      }\\n    }\\n\\n    // We haven't found a segment so load the first one if time is zero\\n    if (time === 0) {\\n      return 0;\\n    }\\n    return -1;\\n  }\\n  // We known nothing so walk from the front of the playlist,\\n  // subtracting durations until we find a segment that contains\\n  // time and return it\\n  time = time - expired;\\n\\n  if (time < 0) {\\n    return -1;\\n  }\\n\\n  for (i = 0; i < numSegments; i++) {\\n    segment = playlist.segments[i];\\n    time -= segment.duration;\\n    if (time < 0) {\\n      return i;\\n    }\\n  }\\n  // We are out of possible candidates so load the last one...\\n  // The last one is the least likely to overlap a buffer and therefore\\n  // the one most likely to tell us something about the timeline\\n  return lastSegment;\\n};\\n\\nexports.getMediaIndexForTime_ = getMediaIndexForTime_;\\nPlaylist.duration = duration;\\nPlaylist.seekable = seekable;\\nPlaylist.getMediaIndexForTime_ = getMediaIndexForTime_;\\n\\n// exports\\nexports['default'] = Playlist;\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"global/window\\\":26}],9:[function(require,module,exports){\\n(function (global){\\n/**\\n * ranges\\n *\\n * Utilities for working with TimeRanges.\\n *\\n */\\n\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\n// Fudge factor to account for TimeRanges rounding\\nvar TIME_FUDGE_FACTOR = 1 / 30;\\n\\n/**\\n * Clamps a value to within a range\\n * @param {Number} num - the value to clamp\\n * @param {Number} start - the start of the range to clamp within, inclusive\\n * @param {Number} end - the end of the range to clamp within, inclusive\\n * @return {Number}\\n */\\nvar clamp = function clamp(num, _ref) {\\n  var _ref2 = _slicedToArray(_ref, 2);\\n\\n  var start = _ref2[0];\\n  var end = _ref2[1];\\n\\n  return Math.min(Math.max(start, num), end);\\n};\\nvar filterRanges = function filterRanges(timeRanges, predicate) {\\n  var results = [];\\n  var i = undefined;\\n\\n  if (timeRanges && timeRanges.length) {\\n    // Search for ranges that match the predicate\\n    for (i = 0; i < timeRanges.length; i++) {\\n      if (predicate(timeRanges.start(i), timeRanges.end(i))) {\\n        results.push([timeRanges.start(i), timeRanges.end(i)]);\\n      }\\n    }\\n  }\\n\\n  return _videoJs2['default'].createTimeRanges(results);\\n};\\n\\n/**\\n * Attempts to find the buffered TimeRange that contains the specified\\n * time.\\n * @param {TimeRanges} buffered - the TimeRanges object to query\\n * @param {number} time  - the time to filter on.\\n * @returns {TimeRanges} a new TimeRanges object\\n */\\nvar findRange = function findRange(buffered, time) {\\n  return filterRanges(buffered, function (start, end) {\\n    return start - TIME_FUDGE_FACTOR <= time && end + TIME_FUDGE_FACTOR >= time;\\n  });\\n};\\n\\n/**\\n * Returns the TimeRanges that begin later than the specified time.\\n * @param {TimeRanges} timeRanges - the TimeRanges object to query\\n * @param {number} time - the time to filter on.\\n * @returns {TimeRanges} a new TimeRanges object.\\n */\\nvar findNextRange = function findNextRange(timeRanges, time) {\\n  return filterRanges(timeRanges, function (start) {\\n    return start - TIME_FUDGE_FACTOR >= time;\\n  });\\n};\\n\\n/**\\n * Returns gaps within a list of TimeRanges\\n * @param {TimeRanges} buffered - the TimeRanges object\\n * @return {TimeRanges} a TimeRanges object of gaps\\n */\\nvar findGaps = function findGaps(buffered) {\\n  if (buffered.length < 2) {\\n    return _videoJs2['default'].createTimeRanges();\\n  }\\n\\n  var ranges = [];\\n\\n  for (var i = 1; i < buffered.length; i++) {\\n    var start = buffered.end(i - 1);\\n    var end = buffered.start(i);\\n\\n    ranges.push([start, end]);\\n  }\\n\\n  return _videoJs2['default'].createTimeRanges(ranges);\\n};\\n\\n/**\\n * Search for a likely end time for the segment that was just appened\\n * based on the state of the `buffered` property before and after the\\n * append. If we fin only one such uncommon end-point return it.\\n * @param {TimeRanges} original - the buffered time ranges before the update\\n * @param {TimeRanges} update - the buffered time ranges after the update\\n * @returns {Number|null} the end time added between `original` and `update`,\\n * or null if one cannot be unambiguously determined.\\n */\\nvar findSoleUncommonTimeRangesEnd = function findSoleUncommonTimeRangesEnd(original, update) {\\n  var i = undefined;\\n  var start = undefined;\\n  var end = undefined;\\n  var result = [];\\n  var edges = [];\\n\\n  // In order to qualify as a possible candidate, the end point must:\\n  //  1) Not have already existed in the `original` ranges\\n  //  2) Not result from the shrinking of a range that already existed\\n  //     in the `original` ranges\\n  //  3) Not be contained inside of a range that existed in `original`\\n  var overlapsCurrentEnd = function overlapsCurrentEnd(span) {\\n    return span[0] <= end && span[1] >= end;\\n  };\\n\\n  if (original) {\\n    // Save all the edges in the `original` TimeRanges object\\n    for (i = 0; i < original.length; i++) {\\n      start = original.start(i);\\n      end = original.end(i);\\n\\n      edges.push([start, end]);\\n    }\\n  }\\n\\n  if (update) {\\n    // Save any end-points in `update` that are not in the `original`\\n    // TimeRanges object\\n    for (i = 0; i < update.length; i++) {\\n      start = update.start(i);\\n      end = update.end(i);\\n\\n      if (edges.some(overlapsCurrentEnd)) {\\n        continue;\\n      }\\n\\n      // at this point it must be a unique non-shrinking end edge\\n      result.push(end);\\n    }\\n  }\\n\\n  // we err on the side of caution and return null if didn't find\\n  // exactly *one* differing end edge in the search above\\n  if (result.length !== 1) {\\n    return null;\\n  }\\n\\n  return result[0];\\n};\\n\\n/**\\n * Calculate the intersection of two TimeRanges\\n * @param {TimeRanges} bufferA\\n * @param {TimeRanges} bufferB\\n * @returns {TimeRanges} The interesection of `bufferA` with `bufferB`\\n */\\nvar bufferIntersection = function bufferIntersection(bufferA, bufferB) {\\n  var start = null;\\n  var end = null;\\n  var arity = 0;\\n  var extents = [];\\n  var ranges = [];\\n\\n  if (!bufferA || !bufferA.length || !bufferB || !bufferB.length) {\\n    return _videoJs2['default'].createTimeRange();\\n  }\\n\\n  // Handle the case where we have both buffers and create an\\n  // intersection of the two\\n  var count = bufferA.length;\\n\\n  // A) Gather up all start and end times\\n  while (count--) {\\n    extents.push({ time: bufferA.start(count), type: 'start' });\\n    extents.push({ time: bufferA.end(count), type: 'end' });\\n  }\\n  count = bufferB.length;\\n  while (count--) {\\n    extents.push({ time: bufferB.start(count), type: 'start' });\\n    extents.push({ time: bufferB.end(count), type: 'end' });\\n  }\\n  // B) Sort them by time\\n  extents.sort(function (a, b) {\\n    return a.time - b.time;\\n  });\\n\\n  // C) Go along one by one incrementing arity for start and decrementing\\n  //    arity for ends\\n  for (count = 0; count < extents.length; count++) {\\n    if (extents[count].type === 'start') {\\n      arity++;\\n\\n      // D) If arity is ever incremented to 2 we are entering an\\n      //    overlapping range\\n      if (arity === 2) {\\n        start = extents[count].time;\\n      }\\n    } else if (extents[count].type === 'end') {\\n      arity--;\\n\\n      // E) If arity is ever decremented to 1 we leaving an\\n      //    overlapping range\\n      if (arity === 1) {\\n        end = extents[count].time;\\n      }\\n    }\\n\\n    // F) Record overlapping ranges\\n    if (start !== null && end !== null) {\\n      ranges.push([start, end]);\\n      start = null;\\n      end = null;\\n    }\\n  }\\n\\n  return _videoJs2['default'].createTimeRanges(ranges);\\n};\\n\\n/**\\n * Calculates the percentage of `segmentRange` that overlaps the\\n * `buffered` time ranges.\\n * @param {TimeRanges} segmentRange - the time range that the segment\\n * covers adjusted according to currentTime\\n * @param {TimeRanges} referenceRange - the original time range that the\\n * segment covers\\n * @param {Number} currentTime - time in seconds where the current playback\\n * is at\\n * @param {TimeRanges} buffered - the currently buffered time ranges\\n * @returns {Number} percent of the segment currently buffered\\n */\\nvar calculateBufferedPercent = function calculateBufferedPercent(adjustedRange, referenceRange, currentTime, buffered) {\\n  var referenceDuration = referenceRange.end(0) - referenceRange.start(0);\\n  var adjustedDuration = adjustedRange.end(0) - adjustedRange.start(0);\\n  var bufferMissingFromAdjusted = referenceDuration - adjustedDuration;\\n  var adjustedIntersection = bufferIntersection(adjustedRange, buffered);\\n  var referenceIntersection = bufferIntersection(referenceRange, buffered);\\n  var adjustedOverlap = 0;\\n  var referenceOverlap = 0;\\n\\n  var count = adjustedIntersection.length;\\n\\n  while (count--) {\\n    adjustedOverlap += adjustedIntersection.end(count) - adjustedIntersection.start(count);\\n\\n    // If the current overlap segment starts at currentTime, then increase the\\n    // overlap duration so that it actually starts at the beginning of referenceRange\\n    // by including the difference between the two Range's durations\\n    // This is a work around for the way Flash has no buffer before currentTime\\n    if (adjustedIntersection.start(count) === currentTime) {\\n      adjustedOverlap += bufferMissingFromAdjusted;\\n    }\\n  }\\n\\n  count = referenceIntersection.length;\\n\\n  while (count--) {\\n    referenceOverlap += referenceIntersection.end(count) - referenceIntersection.start(count);\\n  }\\n\\n  // Use whichever value is larger for the percentage-buffered since that value\\n  // is likely more accurate because the only way\\n  return Math.max(adjustedOverlap, referenceOverlap) / referenceDuration * 100;\\n};\\n\\n/**\\n * Return the amount of a range specified by the startOfSegment and segmentDuration\\n * overlaps the current buffered content.\\n *\\n * @param {Number} startOfSegment - the time where the segment begins\\n * @param {Number} segmentDuration - the duration of the segment in seconds\\n * @param {Number} currentTime - time in seconds where the current playback\\n * is at\\n * @param {TimeRanges} buffered - the state of the buffer\\n * @returns {Number} percentage of the segment's time range that is\\n * already in `buffered`\\n */\\nvar getSegmentBufferedPercent = function getSegmentBufferedPercent(startOfSegment, segmentDuration, currentTime, buffered) {\\n  var endOfSegment = startOfSegment + segmentDuration;\\n\\n  // The entire time range of the segment\\n  var originalSegmentRange = _videoJs2['default'].createTimeRanges([[startOfSegment, endOfSegment]]);\\n\\n  // The adjusted segment time range that is setup such that it starts\\n  // no earlier than currentTime\\n  // Flash has no notion of a back-buffer so adjustedSegmentRange adjusts\\n  // for that and the function will still return 100% if a only half of a\\n  // segment is actually in the buffer as long as the currentTime is also\\n  // half-way through the segment\\n  var adjustedSegmentRange = _videoJs2['default'].createTimeRanges([[clamp(startOfSegment, [currentTime, endOfSegment]), endOfSegment]]);\\n\\n  // This condition happens when the currentTime is beyond the segment's\\n  // end time\\n  if (adjustedSegmentRange.start(0) === adjustedSegmentRange.end(0)) {\\n    return 0;\\n  }\\n\\n  var percent = calculateBufferedPercent(adjustedSegmentRange, originalSegmentRange, currentTime, buffered);\\n\\n  // If the segment is reported as having a zero duration, return 0%\\n  // since it is likely that we will need to fetch the segment\\n  if (isNaN(percent) || percent === Infinity || percent === -Infinity) {\\n    return 0;\\n  }\\n\\n  return percent;\\n};\\n\\nexports['default'] = {\\n  findRange: findRange,\\n  findNextRange: findNextRange,\\n  findGaps: findGaps,\\n  findSoleUncommonTimeRangesEnd: findSoleUncommonTimeRangesEnd,\\n  getSegmentBufferedPercent: getSegmentBufferedPercent,\\n  TIME_FUDGE_FACTOR: TIME_FUDGE_FACTOR\\n};\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{}],10:[function(require,module,exports){\\n/**\\n * Enable/disable playlist function. It is intended to have the first two\\n * arguments partially-applied in order to create the final per-playlist\\n * function.\\n *\\n * @param {PlaylistLoader} playlist - The rendition or media-playlist\\n * @param {Function} changePlaylistFn - A function to be called after a\\n * playlist's enabled-state has been changed. Will NOT be called if a\\n * playlist's enabled-state is unchanged\\n * @param {Boolean=} enable - Value to set the playlist enabled-state to\\n * or if undefined returns the current enabled-state for the playlist\\n * @return {Boolean} The current enabled-state of the playlist\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nvar enableFunction = function enableFunction(playlist, changePlaylistFn, enable) {\\n  var currentlyEnabled = typeof playlist.excludeUntil === 'undefined' || playlist.excludeUntil <= Date.now();\\n\\n  if (typeof enable === 'undefined') {\\n    return currentlyEnabled;\\n  }\\n\\n  if (enable !== currentlyEnabled) {\\n    if (enable) {\\n      delete playlist.excludeUntil;\\n    } else {\\n      playlist.excludeUntil = Infinity;\\n    }\\n\\n    // Ensure the outside world knows about our changes\\n    changePlaylistFn();\\n  }\\n\\n  return enable;\\n};\\n\\n/**\\n * The representation object encapsulates the publicly visible information\\n * in a media playlist along with a setter/getter-type function (enabled)\\n * for changing the enabled-state of a particular playlist entry\\n *\\n * @class Representation\\n */\\n\\nvar Representation = function Representation(hlsHandler, playlist, id) {\\n  _classCallCheck(this, Representation);\\n\\n  // Get a reference to a bound version of fastQualityChange_\\n  var fastChangeFunction = hlsHandler.masterPlaylistController_.fastQualityChange_.bind(hlsHandler.masterPlaylistController_);\\n\\n  // Carefully descend into the playlist's attributes since most\\n  // properties are optional\\n  if (playlist.attributes) {\\n    var attributes = playlist.attributes;\\n\\n    if (attributes.RESOLUTION) {\\n      var resolution = attributes.RESOLUTION;\\n\\n      this.width = resolution.width;\\n      this.height = resolution.height;\\n    }\\n\\n    this.bandwidth = attributes.BANDWIDTH;\\n  }\\n\\n  // The id is simply the ordinality of the media playlist\\n  // within the master playlist\\n  this.id = id;\\n\\n  // Partially-apply the enableFunction to create a playlist-\\n  // specific variant\\n  this.enabled = enableFunction.bind(this, playlist, fastChangeFunction);\\n}\\n\\n/**\\n * A mixin function that adds the `representations` api to an instance\\n * of the HlsHandler class\\n * @param {HlsHandler} hlsHandler - An instance of HlsHandler to add the\\n * representation API into\\n */\\n;\\n\\nvar renditionSelectionMixin = function renditionSelectionMixin(hlsHandler) {\\n  var playlists = hlsHandler.playlists;\\n\\n  // Add a single API-specific function to the HlsHandler instance\\n  hlsHandler.representations = function () {\\n    return playlists.master.playlists.map(function (e, i) {\\n      return new Representation(hlsHandler, e, i);\\n    });\\n  };\\n};\\n\\nexports['default'] = renditionSelectionMixin;\\nmodule.exports = exports['default'];\\n},{}],11:[function(require,module,exports){\\n/**\\n * @file resolve-url.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _globalDocument = require('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\n/**\\n * Constructs a new URI by interpreting a path relative to another\\n * URI.\\n *\\n * @see http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue\\n * @param {String} basePath a relative or absolute URI\\n * @param {String} path a path part to combine with the base\\n * @return {String} a URI that is equivalent to composing `base`\\n * with `path`\\n */\\nvar resolveUrl = function resolveUrl(basePath, path) {\\n  // use the base element to get the browser to handle URI resolution\\n  var oldBase = _globalDocument2['default'].querySelector('base');\\n  var docHead = _globalDocument2['default'].querySelector('head');\\n  var a = _globalDocument2['default'].createElement('a');\\n  var base = oldBase;\\n  var oldHref = undefined;\\n  var result = undefined;\\n\\n  // prep the document\\n  if (oldBase) {\\n    oldHref = oldBase.href;\\n  } else {\\n    base = docHead.appendChild(_globalDocument2['default'].createElement('base'));\\n  }\\n\\n  base.href = basePath;\\n  a.href = path;\\n  result = a.href;\\n\\n  // clean up\\n  if (oldBase) {\\n    oldBase.href = oldHref;\\n  } else {\\n    docHead.removeChild(base);\\n  }\\n  return result;\\n};\\n\\nexports['default'] = resolveUrl;\\nmodule.exports = exports['default'];\\n},{\\\"global/document\\\":25}],12:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file segment-loader.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _ranges = require('./ranges');\\n\\nvar _ranges2 = _interopRequireDefault(_ranges);\\n\\nvar _playlist = require('./playlist');\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\nvar _sourceUpdater = require('./source-updater');\\n\\nvar _sourceUpdater2 = _interopRequireDefault(_sourceUpdater);\\n\\nvar _aesDecrypter = require('aes-decrypter');\\n\\nvar _config = require('./config');\\n\\nvar _config2 = _interopRequireDefault(_config);\\n\\nvar _globalWindow = require('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\n// in ms\\nvar CHECK_BUFFER_DELAY = 500;\\n\\n/**\\n * Updates segment with information about its end-point in time and, optionally,\\n * the segment duration if we have enough information to determine a segment duration\\n * accurately.\\n *\\n * @param {Object} playlist a media playlist object\\n * @param {Number} segmentIndex the index of segment we last appended\\n * @param {Number} segmentEnd the known of the segment referenced by segmentIndex\\n */\\nvar updateSegmentMetadata = function updateSegmentMetadata(playlist, segmentIndex, segmentEnd) {\\n  if (!playlist) {\\n    return false;\\n  }\\n\\n  var segment = playlist.segments[segmentIndex];\\n  var previousSegment = playlist.segments[segmentIndex - 1];\\n\\n  if (segmentEnd && segment) {\\n    segment.end = segmentEnd;\\n\\n    // fix up segment durations based on segment end data\\n    if (!previousSegment) {\\n      // first segment is always has a start time of 0 making its duration\\n      // equal to the segment end\\n      segment.duration = segment.end;\\n    } else if (previousSegment.end) {\\n      segment.duration = segment.end - previousSegment.end;\\n    }\\n    return true;\\n  }\\n  return false;\\n};\\n\\n/**\\n * Determines if we should call endOfStream on the media source based\\n * on the state of the buffer or if appened segment was the final\\n * segment in the playlist.\\n *\\n * @param {Object} playlist a media playlist object\\n * @param {Object} mediaSource the MediaSource object\\n * @param {Number} segmentIndex the index of segment we last appended\\n * @param {Object} currentBuffered buffered region that currentTime resides in\\n * @returns {Boolean} do we need to call endOfStream on the MediaSource\\n */\\nvar detectEndOfStream = function detectEndOfStream(playlist, mediaSource, segmentIndex, currentBuffered) {\\n  if (!playlist) {\\n    return false;\\n  }\\n\\n  var segments = playlist.segments;\\n\\n  // determine a few boolean values to help make the branch below easier\\n  // to read\\n  var appendedLastSegment = segmentIndex === segments.length - 1;\\n  var bufferedToEnd = currentBuffered.length && segments[segments.length - 1].end <= currentBuffered.end(0);\\n\\n  // if we've buffered to the end of the video, we need to call endOfStream\\n  // so that MediaSources can trigger the `ended` event when it runs out of\\n  // buffered data instead of waiting for me\\n  return playlist.endList && mediaSource.readyState === 'open' && (appendedLastSegment || bufferedToEnd);\\n};\\n\\n/**\\n * Turns segment byterange into a string suitable for use in\\n * HTTP Range requests\\n */\\nvar byterangeStr = function byterangeStr(byterange) {\\n  var byterangeStart = undefined;\\n  var byterangeEnd = undefined;\\n\\n  // `byterangeEnd` is one less than `offset + length` because the HTTP range\\n  // header uses inclusive ranges\\n  byterangeEnd = byterange.offset + byterange.length - 1;\\n  byterangeStart = byterange.offset;\\n  return 'bytes=' + byterangeStart + '-' + byterangeEnd;\\n};\\n\\n/**\\n * Defines headers for use in the xhr request for a particular segment.\\n */\\nvar segmentXhrHeaders = function segmentXhrHeaders(segment) {\\n  var headers = {};\\n\\n  if ('byterange' in segment) {\\n    headers.Range = byterangeStr(segment.byterange);\\n  }\\n  return headers;\\n};\\n\\n/**\\n * An object that manages segment loading and appending.\\n *\\n * @class SegmentLoader\\n * @param {Object} options required and optional options\\n * @extends videojs.EventTarget\\n */\\n\\nvar SegmentLoader = (function (_videojs$EventTarget) {\\n  _inherits(SegmentLoader, _videojs$EventTarget);\\n\\n  function SegmentLoader(options) {\\n    _classCallCheck(this, SegmentLoader);\\n\\n    _get(Object.getPrototypeOf(SegmentLoader.prototype), 'constructor', this).call(this);\\n    var settings = undefined;\\n\\n    // check pre-conditions\\n    if (!options) {\\n      throw new TypeError('Initialization options are required');\\n    }\\n    if (typeof options.currentTime !== 'function') {\\n      throw new TypeError('No currentTime getter specified');\\n    }\\n    if (!options.mediaSource) {\\n      throw new TypeError('No MediaSource specified');\\n    }\\n    settings = _videoJs2['default'].mergeOptions(_videoJs2['default'].options.hls, options);\\n\\n    // public properties\\n    this.state = 'INIT';\\n    this.bandwidth = settings.bandwidth;\\n    this.roundTrip = NaN;\\n    this.resetStats_();\\n\\n    // private properties\\n    this.hasPlayed_ = settings.hasPlayed;\\n    this.currentTime_ = settings.currentTime;\\n    this.seekable_ = settings.seekable;\\n    this.seeking_ = settings.seeking;\\n    this.setCurrentTime_ = settings.setCurrentTime;\\n    this.mediaSource_ = settings.mediaSource;\\n    this.checkBufferTimeout_ = null;\\n    this.error_ = void 0;\\n    this.expired_ = 0;\\n    this.timeCorrection_ = 0;\\n    this.currentTimeline_ = -1;\\n    this.xhr_ = null;\\n    this.pendingSegment_ = null;\\n    this.sourceUpdater_ = null;\\n    this.hls_ = settings.hls;\\n    this.xhrOptions_ = null;\\n  }\\n\\n  /**\\n   * reset all of our media stats\\n   *\\n   * @private\\n   */\\n\\n  _createClass(SegmentLoader, [{\\n    key: 'resetStats_',\\n    value: function resetStats_() {\\n      this.mediaBytesTransferred = 0;\\n      this.mediaRequests = 0;\\n      this.mediaTransferDuration = 0;\\n    }\\n\\n    /**\\n     * dispose of the SegmentLoader and reset to the default state\\n     */\\n  }, {\\n    key: 'dispose',\\n    value: function dispose() {\\n      this.state = 'DISPOSED';\\n      this.abort_();\\n      if (this.sourceUpdater_) {\\n        this.sourceUpdater_.dispose();\\n      }\\n      this.resetStats_();\\n    }\\n\\n    /**\\n     * abort anything that is currently doing on with the SegmentLoader\\n     * and reset to a default state\\n     */\\n  }, {\\n    key: 'abort',\\n    value: function abort() {\\n      if (this.state !== 'WAITING') {\\n        return;\\n      }\\n\\n      this.abort_();\\n\\n      // don't wait for buffer check timeouts to begin fetching the\\n      // next segment\\n      if (!this.paused()) {\\n        this.state = 'READY';\\n        this.fillBuffer_();\\n      }\\n    }\\n\\n    /**\\n     * set an error on the segment loader and null out any pending segements\\n     *\\n     * @param {Error} error the error to set on the SegmentLoader\\n     * @return {Error} the error that was set or that is currently set\\n     */\\n  }, {\\n    key: 'error',\\n    value: function error(_error) {\\n      if (typeof _error !== 'undefined') {\\n        this.error_ = _error;\\n      }\\n\\n      this.pendingSegment_ = null;\\n      return this.error_;\\n    }\\n\\n    /**\\n     * load a playlist and start to fill the buffer\\n     */\\n  }, {\\n    key: 'load',\\n    value: function load() {\\n      this.monitorBuffer_();\\n\\n      // if we don't have a playlist yet, keep waiting for one to be\\n      // specified\\n      if (!this.playlist_) {\\n        return;\\n      }\\n\\n      // if we're in the middle of processing a segment already, don't\\n      // kick off an additional segment request\\n      if (!this.sourceUpdater_ || this.state !== 'READY' && this.state !== 'INIT') {\\n        return;\\n      }\\n\\n      this.state = 'READY';\\n      this.fillBuffer_();\\n    }\\n\\n    /**\\n     * set a playlist on the segment loader\\n     *\\n     * @param {PlaylistLoader} media the playlist to set on the segment loader\\n     */\\n  }, {\\n    key: 'playlist',\\n    value: function playlist(media) {\\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n\\n      this.playlist_ = media;\\n      this.xhrOptions_ = options;\\n\\n      // if we were unpaused but waiting for a playlist, start\\n      // buffering now\\n      if (this.sourceUpdater_ && media && this.state === 'INIT' && !this.paused()) {\\n        this.state = 'READY';\\n        return this.fillBuffer_();\\n      }\\n    }\\n\\n    /**\\n     * Prevent the loader from fetching additional segments. If there\\n     * is a segment request outstanding, it will finish processing\\n     * before the loader halts. A segment loader can be unpaused by\\n     * calling load().\\n     */\\n  }, {\\n    key: 'pause',\\n    value: function pause() {\\n      if (this.checkBufferTimeout_) {\\n        _globalWindow2['default'].clearTimeout(this.checkBufferTimeout_);\\n\\n        this.checkBufferTimeout_ = null;\\n      }\\n    }\\n\\n    /**\\n     * Returns whether the segment loader is fetching additional\\n     * segments when given the opportunity. This property can be\\n     * modified through calls to pause() and load().\\n     */\\n  }, {\\n    key: 'paused',\\n    value: function paused() {\\n      return this.checkBufferTimeout_ === null;\\n    }\\n\\n    /**\\n     * setter for expired time on the SegmentLoader\\n     *\\n     * @param {Number} expired the exired time to set\\n     */\\n  }, {\\n    key: 'expired',\\n    value: function expired(_expired) {\\n      this.expired_ = _expired;\\n    }\\n\\n    /**\\n     * create/set the following mimetype on the SourceBuffer through a\\n     * SourceUpdater\\n     *\\n     * @param {String} mimeType the mime type string to use\\n     */\\n  }, {\\n    key: 'mimeType',\\n    value: function mimeType(_mimeType) {\\n      // TODO Allow source buffers to be re-created with different mime-types\\n      if (!this.sourceUpdater_) {\\n        this.sourceUpdater_ = new _sourceUpdater2['default'](this.mediaSource_, _mimeType);\\n        this.clearBuffer();\\n\\n        // if we were unpaused but waiting for a sourceUpdater, start\\n        // buffering now\\n        if (this.playlist_ && this.state === 'INIT' && !this.paused()) {\\n          this.state = 'READY';\\n          return this.fillBuffer_();\\n        }\\n      }\\n    }\\n\\n    /**\\n     * asynchronously/recursively monitor the buffer\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'monitorBuffer_',\\n    value: function monitorBuffer_() {\\n      if (this.state === 'READY') {\\n        this.fillBuffer_();\\n      }\\n\\n      if (this.checkBufferTimeout_) {\\n        _globalWindow2['default'].clearTimeout(this.checkBufferTimeout_);\\n      }\\n\\n      this.checkBufferTimeout_ = _globalWindow2['default'].setTimeout(this.monitorBuffer_.bind(this), CHECK_BUFFER_DELAY);\\n    }\\n\\n    /**\\n     * Determines what segment request should be made, given current\\n     * playback state.\\n     *\\n     * @param {TimeRanges} buffered - the state of the buffer\\n     * @param {Object} playlist - the playlist object to fetch segments from\\n     * @param {Number} currentTime - the playback position in seconds\\n     * @returns {Object} a segment info object that describes the\\n     * request that should be made or null if no request is necessary\\n     */\\n  }, {\\n    key: 'checkBuffer_',\\n    value: function checkBuffer_(buffered, playlist, currentTime) {\\n      var currentBuffered = _ranges2['default'].findRange(buffered, currentTime);\\n\\n      // There are times when MSE reports the first segment as starting a\\n      // little after 0-time so add a fudge factor to try and fix those cases\\n      // or we end up fetching the same first segment over and over\\n      if (currentBuffered.length === 0 && currentTime === 0) {\\n        currentBuffered = _ranges2['default'].findRange(buffered, currentTime + _ranges2['default'].TIME_FUDGE_FACTOR);\\n      }\\n\\n      var bufferedTime = undefined;\\n      var currentBufferedEnd = undefined;\\n      var timestampOffset = this.sourceUpdater_.timestampOffset();\\n      var segment = undefined;\\n      var mediaIndex = undefined;\\n\\n      if (!playlist.segments.length) {\\n        return;\\n      }\\n\\n      if (currentBuffered.length === 0) {\\n        // find the segment containing currentTime\\n        mediaIndex = (0, _playlist.getMediaIndexForTime_)(playlist, currentTime + this.timeCorrection_, this.expired_);\\n      } else {\\n        // find the segment adjacent to the end of the current\\n        // buffered region\\n        currentBufferedEnd = currentBuffered.end(0);\\n        bufferedTime = Math.max(0, currentBufferedEnd - currentTime);\\n\\n        // if the video has not yet played only, and we already have\\n        // one segment downloaded do nothing\\n        if (!this.hasPlayed_() && bufferedTime >= 1) {\\n          return null;\\n        }\\n\\n        // if there is plenty of content buffered, and the video has\\n        // been played before relax for awhile\\n        if (this.hasPlayed_() && bufferedTime >= _config2['default'].GOAL_BUFFER_LENGTH) {\\n          return null;\\n        }\\n        mediaIndex = (0, _playlist.getMediaIndexForTime_)(playlist, currentBufferedEnd + this.timeCorrection_, this.expired_);\\n      }\\n\\n      if (mediaIndex < 0 || mediaIndex === playlist.segments.length) {\\n        return null;\\n      }\\n\\n      segment = playlist.segments[mediaIndex];\\n      var startOfSegment = (0, _playlist.duration)(playlist, playlist.mediaSequence + mediaIndex, this.expired_);\\n\\n      // We will need to change timestampOffset of the sourceBuffer if either of\\n      // the following conditions are true:\\n      // - The segment.timeline !== this.currentTimeline\\n      //   (we are crossing a discontinuity somehow)\\n      // - The \\\"timestampOffset\\\" for the start of this segment is less than\\n      //   the currently set timestampOffset\\n      if (segment.timeline !== this.currentTimeline_ || startOfSegment < this.sourceUpdater_.timestampOffset()) {\\n        timestampOffset = startOfSegment;\\n      }\\n\\n      return {\\n        // resolve the segment URL relative to the playlist\\n        uri: segment.resolvedUri,\\n        // the segment's mediaIndex at the time it was requested\\n        mediaIndex: mediaIndex,\\n        // the segment's playlist\\n        playlist: playlist,\\n        // unencrypted bytes of the segment\\n        bytes: null,\\n        // when a key is defined for this segment, the encrypted bytes\\n        encryptedBytes: null,\\n        // the state of the buffer before a segment is appended will be\\n        // stored here so that the actual segment duration can be\\n        // determined after it has been appended\\n        buffered: null,\\n        // The target timestampOffset for this segment when we append it\\n        // to the source buffer\\n        timestampOffset: timestampOffset,\\n        // The timeline that the segment is in\\n        timeline: segment.timeline,\\n        // The expected duration of the segment in seconds\\n        duration: segment.duration\\n      };\\n    }\\n\\n    /**\\n     * abort all pending xhr requests and null any pending segements\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'abort_',\\n    value: function abort_() {\\n      if (this.xhr_) {\\n        this.xhr_.abort();\\n      }\\n\\n      // clear out the segment being processed\\n      this.pendingSegment_ = null;\\n    }\\n\\n    /**\\n     * fill the buffer with segements unless the\\n     * sourceBuffers are currently updating\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'fillBuffer_',\\n    value: function fillBuffer_() {\\n      if (this.sourceUpdater_.updating()) {\\n        return;\\n      }\\n\\n      // see if we need to begin loading immediately\\n      var request = this.checkBuffer_(this.sourceUpdater_.buffered(), this.playlist_, this.currentTime_(), this.timestampOffset_);\\n\\n      if (!request) {\\n        return;\\n      }\\n\\n      if (request.mediaIndex === this.playlist_.segments.length - 1 && this.mediaSource_.readyState === 'ended' && !this.seeking_()) {\\n        return;\\n      }\\n\\n      var segment = this.playlist_.segments[request.mediaIndex];\\n      var startOfSegment = (0, _playlist.duration)(this.playlist_, this.playlist_.mediaSequence + request.mediaIndex, this.expired_);\\n\\n      // Sanity check the segment-index determining logic by calcuating the\\n      // percentage of the chosen segment that is buffered. If more than 90%\\n      // of the segment is buffered then fetching it will likely not help in\\n      // any way\\n      var percentBuffered = _ranges2['default'].getSegmentBufferedPercent(startOfSegment, segment.duration, this.currentTime_(), this.sourceUpdater_.buffered());\\n\\n      if (percentBuffered >= 90) {\\n        // Increment the timeCorrection_ variable to push the fetcher forward\\n        // in time and hopefully skip any gaps or flaws in our understanding\\n        // of the media\\n        var correctionApplied = this.incrementTimeCorrection_(this.playlist_.targetDuration / 2, 1);\\n\\n        if (correctionApplied && !this.paused()) {\\n          this.fillBuffer_();\\n        }\\n\\n        return;\\n      }\\n\\n      this.loadSegment_(request);\\n    }\\n\\n    /**\\n     * trim the back buffer so we only remove content\\n     * on segment boundaries\\n     *\\n     * @private\\n     *\\n     * @param {Object} segmentInfo - the current segment\\n     * @returns {Number} removeToTime - the end point in time, in seconds\\n     * that the the buffer should be trimmed.\\n     */\\n  }, {\\n    key: 'trimBuffer_',\\n    value: function trimBuffer_(segmentInfo) {\\n      var seekable = this.seekable_();\\n      var currentTime = this.currentTime_();\\n      var removeToTime = 0;\\n\\n      // Chrome has a hard limit of 150mb of\\n      // buffer and a very conservative \\\"garbage collector\\\"\\n      // We manually clear out the old buffer to ensure\\n      // we don't trigger the QuotaExceeded error\\n      // on the source buffer during subsequent appends\\n\\n      // If we have a seekable range use that as the limit for what can be removed safely\\n      // otherwise remove anything older than 1 minute before the current play head\\n      if (seekable.length && seekable.start(0) > 0 && seekable.start(0) < currentTime) {\\n        removeToTime = seekable.start(0);\\n      } else {\\n        removeToTime = currentTime - 60;\\n      }\\n\\n      // If we are going to remove time from the front of the buffer, make\\n      // sure we aren't discarding a partial segment to avoid throwing\\n      // PLAYER_ERR_TIMEOUT while trying to read a partially discarded segment\\n      for (var i = 0; i <= segmentInfo.playlist.segments.length; i++) {\\n        // Loop through the segments and calculate the duration to compare\\n        // against the removeToTime\\n        var removeDuration = (0, _playlist.duration)(segmentInfo.playlist, segmentInfo.playlist.mediaSequence + i, this.expired_);\\n\\n        // If we are close to next segment begining, remove to end of previous\\n        // segment instead\\n        var previousDuration = (0, _playlist.duration)(segmentInfo.playlist, segmentInfo.playlist.mediaSequence + (i - 1), this.expired_);\\n\\n        if (removeDuration >= removeToTime) {\\n          removeToTime = previousDuration;\\n          break;\\n        }\\n      }\\n      return removeToTime;\\n    }\\n\\n    /**\\n     * load a specific segment from a request into the buffer\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'loadSegment_',\\n    value: function loadSegment_(segmentInfo) {\\n      var segment = undefined;\\n      var keyXhr = undefined;\\n      var segmentXhr = undefined;\\n      var removeToTime = 0;\\n\\n      removeToTime = this.trimBuffer_(segmentInfo);\\n\\n      if (removeToTime > 0) {\\n        this.sourceUpdater_.remove(0, removeToTime);\\n      }\\n\\n      segment = segmentInfo.playlist.segments[segmentInfo.mediaIndex];\\n\\n      if (segment.key) {\\n        var keyRequestOptions = _videoJs2['default'].mergeOptions(this.xhrOptions_, {\\n          uri: segment.key.resolvedUri,\\n          responseType: 'arraybuffer'\\n        });\\n\\n        keyXhr = this.hls_.xhr(keyRequestOptions, this.handleResponse_.bind(this));\\n      }\\n\\n      this.pendingSegment_ = segmentInfo;\\n\\n      var segmentRequestOptions = _videoJs2['default'].mergeOptions(this.xhrOptions_, {\\n        uri: segmentInfo.uri,\\n        responseType: 'arraybuffer',\\n        headers: segmentXhrHeaders(segment)\\n      });\\n\\n      segmentXhr = this.hls_.xhr(segmentRequestOptions, this.handleResponse_.bind(this));\\n\\n      this.xhr_ = {\\n        keyXhr: keyXhr,\\n        segmentXhr: segmentXhr,\\n        abort: function abort() {\\n          if (this.segmentXhr) {\\n            // Prevent error handler from running.\\n            this.segmentXhr.onreadystatechange = null;\\n            this.segmentXhr.abort();\\n            this.segmentXhr = null;\\n          }\\n          if (this.keyXhr) {\\n            // Prevent error handler from running.\\n            this.keyXhr.onreadystatechange = null;\\n            this.keyXhr.abort();\\n            this.keyXhr = null;\\n          }\\n        }\\n      };\\n\\n      this.state = 'WAITING';\\n    }\\n\\n    /**\\n     * triggered when a segment response is received\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'handleResponse_',\\n    value: function handleResponse_(error, request) {\\n      var segmentInfo = undefined;\\n      var segment = undefined;\\n      var keyXhrRequest = undefined;\\n      var view = undefined;\\n\\n      // timeout of previously aborted request\\n      if (!this.xhr_ || request !== this.xhr_.segmentXhr && request !== this.xhr_.keyXhr) {\\n        return;\\n      }\\n\\n      segmentInfo = this.pendingSegment_;\\n      segment = segmentInfo.playlist.segments[segmentInfo.mediaIndex];\\n\\n      // if a request times out, reset bandwidth tracking\\n      if (request.timedout) {\\n        this.abort_();\\n        this.bandwidth = 1;\\n        this.roundTrip = NaN;\\n        this.state = 'READY';\\n        return this.trigger('progress');\\n      }\\n\\n      // trigger an event for other errors\\n      if (!request.aborted && error) {\\n        // abort will clear xhr_\\n        keyXhrRequest = this.xhr_.keyXhr;\\n        this.abort_();\\n        this.error({\\n          status: request.status,\\n          message: request === keyXhrRequest ? 'HLS key request error at URL: ' + segment.key.uri : 'HLS segment request error at URL: ' + segmentInfo.uri,\\n          code: 2,\\n          xhr: request\\n        });\\n        this.state = 'READY';\\n        this.pause();\\n        return this.trigger('error');\\n      }\\n\\n      // stop processing if the request was aborted\\n      if (!request.response) {\\n        this.abort_();\\n        return;\\n      }\\n\\n      if (request === this.xhr_.segmentXhr) {\\n        // the segment request is no longer outstanding\\n        this.xhr_.segmentXhr = null;\\n\\n        // calculate the download bandwidth based on segment request\\n        this.roundTrip = request.roundTripTime;\\n        this.bandwidth = request.bandwidth;\\n        this.mediaBytesTransferred += request.bytesReceived || 0;\\n        this.mediaRequests += 1;\\n        this.mediaTransferDuration += request.roundTripTime || 0;\\n\\n        if (segment.key) {\\n          segmentInfo.encryptedBytes = new Uint8Array(request.response);\\n        } else {\\n          segmentInfo.bytes = new Uint8Array(request.response);\\n        }\\n      }\\n\\n      if (request === this.xhr_.keyXhr) {\\n        keyXhrRequest = this.xhr_.segmentXhr;\\n        // the key request is no longer outstanding\\n        this.xhr_.keyXhr = null;\\n\\n        if (request.response.byteLength !== 16) {\\n          this.abort_();\\n          this.error({\\n            status: request.status,\\n            message: 'Invalid HLS key at URL: ' + segment.key.uri,\\n            code: 2,\\n            xhr: request\\n          });\\n          this.state = 'READY';\\n          this.pause();\\n          return this.trigger('error');\\n        }\\n\\n        view = new DataView(request.response);\\n        segment.key.bytes = new Uint32Array([view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12)]);\\n\\n        // if the media sequence is greater than 2^32, the IV will be incorrect\\n        // assuming 10s segments, that would be about 1300 years\\n        segment.key.iv = segment.key.iv || new Uint32Array([0, 0, 0, segmentInfo.mediaIndex + segmentInfo.playlist.mediaSequence]);\\n      }\\n\\n      if (!this.xhr_.segmentXhr && !this.xhr_.keyXhr) {\\n        this.xhr_ = null;\\n        this.processResponse_();\\n      }\\n    }\\n\\n    /**\\n     * clear anything that is currently in the buffer and throw it away\\n     */\\n  }, {\\n    key: 'clearBuffer',\\n    value: function clearBuffer() {\\n      if (this.sourceUpdater_ && this.sourceUpdater_.buffered().length) {\\n        this.sourceUpdater_.remove(0, Infinity);\\n      }\\n    }\\n\\n    /**\\n     * Decrypt the segment that is being loaded if necessary\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'processResponse_',\\n    value: function processResponse_() {\\n      var segmentInfo = undefined;\\n      var segment = undefined;\\n\\n      this.state = 'DECRYPTING';\\n\\n      segmentInfo = this.pendingSegment_;\\n      segment = segmentInfo.playlist.segments[segmentInfo.mediaIndex];\\n\\n      if (segment.key) {\\n        // this is an encrypted segment\\n        // incrementally decrypt the segment\\n        /* eslint-disable no-new, handle-callback-err */\\n        new _aesDecrypter.Decrypter(segmentInfo.encryptedBytes, segment.key.bytes, segment.key.iv, (function (err, bytes) {\\n          // err always null\\n          segmentInfo.bytes = bytes;\\n          this.handleSegment_();\\n        }).bind(this));\\n        /* eslint-enable */\\n      } else {\\n          this.handleSegment_();\\n        }\\n    }\\n\\n    /**\\n     * append a decrypted segement to the SourceBuffer through a SourceUpdater\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'handleSegment_',\\n    value: function handleSegment_() {\\n      var segmentInfo = undefined;\\n\\n      this.state = 'APPENDING';\\n      segmentInfo = this.pendingSegment_;\\n      segmentInfo.buffered = this.sourceUpdater_.buffered();\\n      this.currentTimeline_ = segmentInfo.timeline;\\n\\n      if (segmentInfo.timestampOffset !== this.sourceUpdater_.timestampOffset()) {\\n        this.sourceUpdater_.timestampOffset(segmentInfo.timestampOffset);\\n      }\\n\\n      this.sourceUpdater_.appendBuffer(segmentInfo.bytes, this.handleUpdateEnd_.bind(this));\\n    }\\n\\n    /**\\n     * callback to run when appendBuffer is finished. detects if we are\\n     * in a good state to do things with the data we got, or if we need\\n     * to wait for more\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'handleUpdateEnd_',\\n    value: function handleUpdateEnd_() {\\n      var segmentInfo = this.pendingSegment_;\\n      var currentTime = this.currentTime_();\\n\\n      this.pendingSegment_ = null;\\n\\n      // add segment metadata if it we have gained information during the\\n      // last append\\n      var timelineUpdated = this.updateTimeline_(segmentInfo);\\n\\n      this.trigger('progress');\\n\\n      var currentMediaIndex = segmentInfo.mediaIndex;\\n\\n      currentMediaIndex += segmentInfo.playlist.mediaSequence - this.playlist_.mediaSequence;\\n\\n      var currentBuffered = _ranges2['default'].findRange(this.sourceUpdater_.buffered(), currentTime);\\n\\n      // any time an update finishes and the last segment is in the\\n      // buffer, end the stream. this ensures the \\\"ended\\\" event will\\n      // fire if playback reaches that point.\\n      var isEndOfStream = detectEndOfStream(segmentInfo.playlist, this.mediaSource_, currentMediaIndex, currentBuffered);\\n\\n      if (isEndOfStream) {\\n        this.mediaSource_.endOfStream();\\n      }\\n\\n      // when seeking to the beginning of the seekable range, it's\\n      // possible that imprecise timing information may cause the seek to\\n      // end up earlier than the start of the range\\n      // in that case, seek again\\n      var seekable = this.seekable_();\\n      var next = _ranges2['default'].findNextRange(this.sourceUpdater_.buffered(), currentTime);\\n\\n      if (this.seeking_() && currentBuffered.length === 0) {\\n        if (seekable.length && currentTime < seekable.start(0)) {\\n\\n          if (next.length) {\\n            _videoJs2['default'].log('tried seeking to', currentTime, 'but that was too early, retrying at', next.start(0));\\n            this.setCurrentTime_(next.start(0) + _ranges2['default'].TIME_FUDGE_FACTOR);\\n          }\\n        }\\n      }\\n\\n      this.state = 'READY';\\n\\n      if (timelineUpdated) {\\n        this.timeCorrection_ = 0;\\n        if (!this.paused()) {\\n          this.fillBuffer_();\\n        }\\n        return;\\n      }\\n\\n      // the last segment append must have been entirely in the\\n      // already buffered time ranges. adjust the timeCorrection\\n      // offset to fetch forward until we find a segment that adds\\n      // to the buffered time ranges and improves subsequent media\\n      // index calculations.\\n      var correctionApplied = this.incrementTimeCorrection_(segmentInfo.duration, 4);\\n\\n      if (correctionApplied && !this.paused()) {\\n        this.fillBuffer_();\\n      }\\n    }\\n\\n    /**\\n     * annotate the segment with any start and end time information\\n     * added by the media processing\\n     *\\n     * @private\\n     * @param {Object} segmentInfo annotate a segment with time info\\n     */\\n  }, {\\n    key: 'updateTimeline_',\\n    value: function updateTimeline_(segmentInfo) {\\n      var segment = undefined;\\n      var segmentEnd = undefined;\\n      var timelineUpdated = false;\\n      var playlist = segmentInfo.playlist;\\n      var currentMediaIndex = segmentInfo.mediaIndex;\\n\\n      currentMediaIndex += playlist.mediaSequence - this.playlist_.mediaSequence;\\n      segment = playlist.segments[currentMediaIndex];\\n\\n      // Update segment meta-data (duration and end-point) based on timeline\\n      if (segment && segmentInfo && segmentInfo.playlist.uri === this.playlist_.uri) {\\n        segmentEnd = _ranges2['default'].findSoleUncommonTimeRangesEnd(segmentInfo.buffered, this.sourceUpdater_.buffered());\\n        timelineUpdated = updateSegmentMetadata(playlist, currentMediaIndex, segmentEnd);\\n      }\\n\\n      return timelineUpdated;\\n    }\\n\\n    /**\\n     * add a number of seconds to the currentTime when determining which\\n     * segment to fetch in order to force the fetcher to advance in cases\\n     * where it may get stuck on the same segment due to buffer gaps or\\n     * missing segment annotation after a rendition switch (especially\\n     * during a live stream)\\n     *\\n     * @private\\n     * @param {Number} secondsToIncrement number of seconds to add to the\\n     * timeCorrection_ variable\\n     * @param {Number} maxSegmentsToWalk maximum number of times we allow this\\n     * function to walk forward\\n     */\\n  }, {\\n    key: 'incrementTimeCorrection_',\\n    value: function incrementTimeCorrection_(secondsToIncrement, maxSegmentsToWalk) {\\n      // If we have already incremented timeCorrection_ beyond the limit,\\n      // stop searching for a segment and reset timeCorrection_\\n      if (this.timeCorrection_ >= this.playlist_.targetDuration * maxSegmentsToWalk) {\\n        this.timeCorrection_ = 0;\\n        return false;\\n      }\\n\\n      this.timeCorrection_ += secondsToIncrement;\\n      return true;\\n    }\\n  }]);\\n\\n  return SegmentLoader;\\n})(_videoJs2['default'].EventTarget);\\n\\nexports['default'] = SegmentLoader;\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./config\\\":3,\\\"./playlist\\\":8,\\\"./ranges\\\":9,\\\"./source-updater\\\":13,\\\"aes-decrypter\\\":19,\\\"global/window\\\":26}],13:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file source-updater.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\n/**\\n * A queue of callbacks to be serialized and applied when a\\n * MediaSource and its associated SourceBuffers are not in the\\n * updating state. It is used by the segment loader to update the\\n * underlying SourceBuffers when new data is loaded, for instance.\\n *\\n * @class SourceUpdater\\n * @param {MediaSource} mediaSource the MediaSource to create the\\n * SourceBuffer from\\n * @param {String} mimeType the desired MIME type of the underlying\\n * SourceBuffer\\n */\\n\\nvar SourceUpdater = (function () {\\n  function SourceUpdater(mediaSource, mimeType) {\\n    var _this = this;\\n\\n    _classCallCheck(this, SourceUpdater);\\n\\n    var createSourceBuffer = function createSourceBuffer() {\\n      _this.sourceBuffer_ = mediaSource.addSourceBuffer(mimeType);\\n\\n      // run completion handlers and process callbacks as updateend\\n      // events fire\\n      _this.onUpdateendCallback_ = function () {\\n        var pendingCallback = _this.pendingCallback_;\\n\\n        _this.pendingCallback_ = null;\\n\\n        if (pendingCallback) {\\n          pendingCallback();\\n        }\\n\\n        _this.runCallback_();\\n      };\\n\\n      _this.sourceBuffer_.addEventListener('updateend', _this.onUpdateendCallback_);\\n\\n      _this.runCallback_();\\n    };\\n\\n    this.callbacks_ = [];\\n    this.pendingCallback_ = null;\\n    this.timestampOffset_ = 0;\\n    this.mediaSource = mediaSource;\\n\\n    if (mediaSource.readyState === 'closed') {\\n      mediaSource.addEventListener('sourceopen', createSourceBuffer);\\n    } else {\\n      createSourceBuffer();\\n    }\\n  }\\n\\n  /**\\n   * Aborts the current segment and resets the segment parser.\\n   *\\n   * @param {Function} done function to call when done\\n   * @see http://w3c.github.io/media-source/#widl-SourceBuffer-abort-void\\n   */\\n\\n  _createClass(SourceUpdater, [{\\n    key: 'abort',\\n    value: function abort(done) {\\n      var _this2 = this;\\n\\n      this.queueCallback_(function () {\\n        _this2.sourceBuffer_.abort();\\n      }, done);\\n    }\\n\\n    /**\\n     * Queue an update to append an ArrayBuffer.\\n     *\\n     * @param {ArrayBuffer} bytes\\n     * @param {Function} done the function to call when done\\n     * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-appendBuffer-void-ArrayBuffer-data\\n     */\\n  }, {\\n    key: 'appendBuffer',\\n    value: function appendBuffer(bytes, done) {\\n      var _this3 = this;\\n\\n      this.queueCallback_(function () {\\n        _this3.sourceBuffer_.appendBuffer(bytes);\\n      }, done);\\n    }\\n\\n    /**\\n     * Indicates what TimeRanges are buffered in the managed SourceBuffer.\\n     *\\n     * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-buffered\\n     */\\n  }, {\\n    key: 'buffered',\\n    value: function buffered() {\\n      if (!this.sourceBuffer_) {\\n        return _videoJs2['default'].createTimeRanges();\\n      }\\n      return this.sourceBuffer_.buffered;\\n    }\\n\\n    /**\\n     * Queue an update to set the duration.\\n     *\\n     * @param {Double} duration what to set the duration to\\n     * @see http://www.w3.org/TR/media-source/#widl-MediaSource-duration\\n     */\\n  }, {\\n    key: 'duration',\\n    value: function duration(_duration) {\\n      var _this4 = this;\\n\\n      this.queueCallback_(function () {\\n        _this4.sourceBuffer_.duration = _duration;\\n      });\\n    }\\n\\n    /**\\n     * Queue an update to remove a time range from the buffer.\\n     *\\n     * @param {Number} start where to start the removal\\n     * @param {Number} end where to end the removal\\n     * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-remove-void-double-start-unrestricted-double-end\\n     */\\n  }, {\\n    key: 'remove',\\n    value: function remove(start, end) {\\n      var _this5 = this;\\n\\n      this.queueCallback_(function () {\\n        _this5.sourceBuffer_.remove(start, end);\\n      });\\n    }\\n\\n    /**\\n     * wether the underlying sourceBuffer is updating or not\\n     *\\n     * @return {Boolean} the updating status of the SourceBuffer\\n     */\\n  }, {\\n    key: 'updating',\\n    value: function updating() {\\n      return !this.sourceBuffer_ || this.sourceBuffer_.updating;\\n    }\\n\\n    /**\\n     * Set/get the timestampoffset on the SourceBuffer\\n     *\\n     * @return {Number} the timestamp offset\\n     */\\n  }, {\\n    key: 'timestampOffset',\\n    value: function timestampOffset(offset) {\\n      var _this6 = this;\\n\\n      if (typeof offset !== 'undefined') {\\n        this.queueCallback_(function () {\\n          _this6.sourceBuffer_.timestampOffset = offset;\\n        });\\n        this.timestampOffset_ = offset;\\n      }\\n      return this.timestampOffset_;\\n    }\\n\\n    /**\\n     * que a callback to run\\n     */\\n  }, {\\n    key: 'queueCallback_',\\n    value: function queueCallback_(callback, done) {\\n      this.callbacks_.push([callback.bind(this), done]);\\n      this.runCallback_();\\n    }\\n\\n    /**\\n     * run a queued callback\\n     */\\n  }, {\\n    key: 'runCallback_',\\n    value: function runCallback_() {\\n      var callbacks = undefined;\\n\\n      if (this.sourceBuffer_ && !this.sourceBuffer_.updating && this.callbacks_.length) {\\n        callbacks = this.callbacks_.shift();\\n        this.pendingCallback_ = callbacks[1];\\n        callbacks[0]();\\n      }\\n    }\\n\\n    /**\\n     * dispose of the source updater and the underlying sourceBuffer\\n     */\\n  }, {\\n    key: 'dispose',\\n    value: function dispose() {\\n      this.sourceBuffer_.removeEventListener('updateend', this.onUpdateendCallback_);\\n      if (this.sourceBuffer_ && this.mediaSource.readyState === 'open') {\\n        this.sourceBuffer_.abort();\\n      }\\n    }\\n  }]);\\n\\n  return SourceUpdater;\\n})();\\n\\nexports['default'] = SourceUpdater;\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{}],14:[function(require,module,exports){\\n/**\\n * @file stream.js\\n */\\n/**\\n * A lightweight readable stream implemention that handles event dispatching.\\n *\\n * @class Stream\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nvar Stream = (function () {\\n  function Stream() {\\n    _classCallCheck(this, Stream);\\n\\n    this.listeners = {};\\n  }\\n\\n  /**\\n   * Add a listener for a specified event type.\\n   *\\n   * @param {String} type the event name\\n   * @param {Function} listener the callback to be invoked when an event of\\n   * the specified type occurs\\n   */\\n\\n  _createClass(Stream, [{\\n    key: 'on',\\n    value: function on(type, listener) {\\n      if (!this.listeners[type]) {\\n        this.listeners[type] = [];\\n      }\\n      this.listeners[type].push(listener);\\n    }\\n\\n    /**\\n     * Remove a listener for a specified event type.\\n     *\\n     * @param {String} type the event name\\n     * @param {Function} listener  a function previously registered for this\\n     * type of event through `on`\\n     * @return {Boolean} if we could turn it off or not\\n     */\\n  }, {\\n    key: 'off',\\n    value: function off(type, listener) {\\n      var index = undefined;\\n\\n      if (!this.listeners[type]) {\\n        return false;\\n      }\\n      index = this.listeners[type].indexOf(listener);\\n      this.listeners[type].splice(index, 1);\\n      return index > -1;\\n    }\\n\\n    /**\\n     * Trigger an event of the specified type on this stream. Any additional\\n     * arguments to this function are passed as parameters to event listeners.\\n     *\\n     * @param {String} type the event name\\n     */\\n  }, {\\n    key: 'trigger',\\n    value: function trigger(type) {\\n      var callbacks = undefined;\\n      var i = undefined;\\n      var length = undefined;\\n      var args = undefined;\\n\\n      callbacks = this.listeners[type];\\n      if (!callbacks) {\\n        return;\\n      }\\n      // Slicing the arguments on every invocation of this method\\n      // can add a significant amount of overhead. Avoid the\\n      // intermediate object creation for the common case of a\\n      // single callback argument\\n      if (arguments.length === 2) {\\n        length = callbacks.length;\\n        for (i = 0; i < length; ++i) {\\n          callbacks[i].call(this, arguments[1]);\\n        }\\n      } else {\\n        args = Array.prototype.slice.call(arguments, 1);\\n        length = callbacks.length;\\n        for (i = 0; i < length; ++i) {\\n          callbacks[i].apply(this, args);\\n        }\\n      }\\n    }\\n\\n    /**\\n     * Destroys the stream and cleans up.\\n     */\\n  }, {\\n    key: 'dispose',\\n    value: function dispose() {\\n      this.listeners = {};\\n    }\\n\\n    /**\\n     * Forwards all `data` events on this stream to the destination stream. The\\n     * destination stream should provide a method `push` to receive the data\\n     * events as they arrive.\\n     *\\n     * @param {Stream} destination the stream that will receive all `data` events\\n     * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\\n     */\\n  }, {\\n    key: 'pipe',\\n    value: function pipe(destination) {\\n      this.on('data', function (data) {\\n        destination.push(data);\\n      });\\n    }\\n  }]);\\n\\n  return Stream;\\n})();\\n\\nexports['default'] = Stream;\\nmodule.exports = exports['default'];\\n},{}],15:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file xhr.js\\n */\\n\\n/**\\n * A wrapper for videojs.xhr that tracks bandwidth.\\n *\\n * @param {Object} options options for the XHR\\n * @param {Function} callback the callback to call when done\\n * @return {Request} the xhr request that is going to be made\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar xhrFactory = function xhrFactory() {\\n  var xhr = function XhrFunction(options, callback) {\\n    // Add a default timeout for all hls requests\\n    options = (0, _videoJs.mergeOptions)({\\n      timeout: 45e3\\n    }, options);\\n\\n    // Allow an optional user-specified function to modify the option\\n    // object before we construct the xhr request\\n    if (XhrFunction.beforeRequest && typeof XhrFunction.beforeRequest === 'function') {\\n      var newOptions = XhrFunction.beforeRequest(options);\\n\\n      if (newOptions) {\\n        options = newOptions;\\n      }\\n    }\\n\\n    var request = (0, _videoJs.xhr)(options, function (error, response) {\\n      if (!error && request.response) {\\n        request.responseTime = new Date().getTime();\\n        request.roundTripTime = request.responseTime - request.requestTime;\\n        request.bytesReceived = request.response.byteLength || request.response.length;\\n        if (!request.bandwidth) {\\n          request.bandwidth = Math.floor(request.bytesReceived / request.roundTripTime * 8 * 1000);\\n        }\\n      }\\n\\n      // videojs.xhr now uses a specific code\\n      // on the error object to signal that a request has\\n      // timed out errors of setting a boolean on the request object\\n      if (error || request.timedout) {\\n        request.timedout = request.timedout || error.code === 'ETIMEDOUT';\\n      } else {\\n        request.timedout = false;\\n      }\\n\\n      // videojs.xhr no longer considers status codes outside of 200 and 0\\n      // (for file uris) to be errors, but the old XHR did, so emulate that\\n      // behavior. Status 206 may be used in response to byterange requests.\\n      if (!error && response.statusCode !== 200 && response.statusCode !== 206 && response.statusCode !== 0) {\\n        error = new Error('XHR Failed with a response of: ' + (request && (request.response || request.responseText)));\\n      }\\n\\n      callback(error, request);\\n    });\\n\\n    request.requestTime = new Date().getTime();\\n    return request;\\n  };\\n\\n  return xhr;\\n};\\n\\nexports['default'] = xhrFactory;\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{}],16:[function(require,module,exports){\\n/**\\n * @file aes.js\\n *\\n * This file contains an adaptation of the AES decryption algorithm\\n * from the Standford Javascript Cryptography Library. That work is\\n * covered by the following copyright and permissions notice:\\n *\\n * Copyright 2009-2010 Emily Stark, Mike Hamburg, Dan Boneh.\\n * All rights reserved.\\n *\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are\\n * met:\\n *\\n * 1. Redistributions of source code must retain the above copyright\\n *    notice, this list of conditions and the following disclaimer.\\n *\\n * 2. Redistributions in binary form must reproduce the above\\n *    copyright notice, this list of conditions and the following\\n *    disclaimer in the documentation and/or other materials provided\\n *    with the distribution.\\n *\\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR\\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR CONTRIBUTORS BE\\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n *\\n * The views and conclusions contained in the software and documentation\\n * are those of the authors and should not be interpreted as representing\\n * official policies, either expressed or implied, of the authors.\\n */\\n\\n/**\\n * Expand the S-box tables.\\n *\\n * @private\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nvar precompute = function precompute() {\\n  var tables = [[[], [], [], [], []], [[], [], [], [], []]];\\n  var encTable = tables[0];\\n  var decTable = tables[1];\\n  var sbox = encTable[4];\\n  var sboxInv = decTable[4];\\n  var i = undefined;\\n  var x = undefined;\\n  var xInv = undefined;\\n  var d = [];\\n  var th = [];\\n  var x2 = undefined;\\n  var x4 = undefined;\\n  var x8 = undefined;\\n  var s = undefined;\\n  var tEnc = undefined;\\n  var tDec = undefined;\\n\\n  // Compute double and third tables\\n  for (i = 0; i < 256; i++) {\\n    th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;\\n  }\\n\\n  for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {\\n    // Compute sbox\\n    s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;\\n    s = s >> 8 ^ s & 255 ^ 99;\\n    sbox[x] = s;\\n    sboxInv[s] = x;\\n\\n    // Compute MixColumns\\n    x8 = d[x4 = d[x2 = d[x]]];\\n    tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\\n    tEnc = d[s] * 0x101 ^ s * 0x1010100;\\n\\n    for (i = 0; i < 4; i++) {\\n      encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\\n      decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;\\n    }\\n  }\\n\\n  // Compactify. Considerable speedup on Firefox.\\n  for (i = 0; i < 5; i++) {\\n    encTable[i] = encTable[i].slice(0);\\n    decTable[i] = decTable[i].slice(0);\\n  }\\n  return tables;\\n};\\nvar aesTables = null;\\n\\n/**\\n * Schedule out an AES key for both encryption and decryption. This\\n * is a low-level class. Use a cipher mode to do bulk encryption.\\n *\\n * @class AES\\n * @param key {Array} The key as an array of 4, 6 or 8 words.\\n */\\n\\nvar AES = (function () {\\n  function AES(key) {\\n    _classCallCheck(this, AES);\\n\\n    /**\\n     * The expanded S-box and inverse S-box tables. These will be computed\\n     * on the client so that we don't have to send them down the wire.\\n     *\\n     * There are two tables, _tables[0] is for encryption and\\n     * _tables[1] is for decryption.\\n     *\\n     * The first 4 sub-tables are the expanded S-box with MixColumns. The\\n     * last (_tables[01][4]) is the S-box itself.\\n     *\\n     * @private\\n     */\\n    // if we have yet to precompute the S-box tables\\n    // do so now\\n    if (!aesTables) {\\n      aesTables = precompute();\\n    }\\n    // then make a copy of that object for use\\n    this._tables = [[aesTables[0][0].slice(), aesTables[0][1].slice(), aesTables[0][2].slice(), aesTables[0][3].slice(), aesTables[0][4].slice()], [aesTables[1][0].slice(), aesTables[1][1].slice(), aesTables[1][2].slice(), aesTables[1][3].slice(), aesTables[1][4].slice()]];\\n    var i = undefined;\\n    var j = undefined;\\n    var tmp = undefined;\\n    var encKey = undefined;\\n    var decKey = undefined;\\n    var sbox = this._tables[0][4];\\n    var decTable = this._tables[1];\\n    var keyLen = key.length;\\n    var rcon = 1;\\n\\n    if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {\\n      throw new Error('Invalid aes key size');\\n    }\\n\\n    encKey = key.slice(0);\\n    decKey = [];\\n    this._key = [encKey, decKey];\\n\\n    // schedule encryption keys\\n    for (i = keyLen; i < 4 * keyLen + 28; i++) {\\n      tmp = encKey[i - 1];\\n\\n      // apply sbox\\n      if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {\\n        tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];\\n\\n        // shift rows and add rcon\\n        if (i % keyLen === 0) {\\n          tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;\\n          rcon = rcon << 1 ^ (rcon >> 7) * 283;\\n        }\\n      }\\n\\n      encKey[i] = encKey[i - keyLen] ^ tmp;\\n    }\\n\\n    // schedule decryption keys\\n    for (j = 0; i; j++, i--) {\\n      tmp = encKey[j & 3 ? i : i - 4];\\n      if (i <= 4 || j < 4) {\\n        decKey[j] = tmp;\\n      } else {\\n        decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Decrypt 16 bytes, specified as four 32-bit words.\\n   *\\n   * @param {Number} encrypted0 the first word to decrypt\\n   * @param {Number} encrypted1 the second word to decrypt\\n   * @param {Number} encrypted2 the third word to decrypt\\n   * @param {Number} encrypted3 the fourth word to decrypt\\n   * @param {Int32Array} out the array to write the decrypted words\\n   * into\\n   * @param {Number} offset the offset into the output array to start\\n   * writing results\\n   * @return {Array} The plaintext.\\n   */\\n\\n  _createClass(AES, [{\\n    key: 'decrypt',\\n    value: function decrypt(encrypted0, encrypted1, encrypted2, encrypted3, out, offset) {\\n      var key = this._key[1];\\n      // state variables a,b,c,d are loaded with pre-whitened data\\n      var a = encrypted0 ^ key[0];\\n      var b = encrypted3 ^ key[1];\\n      var c = encrypted2 ^ key[2];\\n      var d = encrypted1 ^ key[3];\\n      var a2 = undefined;\\n      var b2 = undefined;\\n      var c2 = undefined;\\n\\n      // key.length === 2 ?\\n      var nInnerRounds = key.length / 4 - 2;\\n      var i = undefined;\\n      var kIndex = 4;\\n      var table = this._tables[1];\\n\\n      // load up the tables\\n      var table0 = table[0];\\n      var table1 = table[1];\\n      var table2 = table[2];\\n      var table3 = table[3];\\n      var sbox = table[4];\\n\\n      // Inner rounds. Cribbed from OpenSSL.\\n      for (i = 0; i < nInnerRounds; i++) {\\n        a2 = table0[a >>> 24] ^ table1[b >> 16 & 255] ^ table2[c >> 8 & 255] ^ table3[d & 255] ^ key[kIndex];\\n        b2 = table0[b >>> 24] ^ table1[c >> 16 & 255] ^ table2[d >> 8 & 255] ^ table3[a & 255] ^ key[kIndex + 1];\\n        c2 = table0[c >>> 24] ^ table1[d >> 16 & 255] ^ table2[a >> 8 & 255] ^ table3[b & 255] ^ key[kIndex + 2];\\n        d = table0[d >>> 24] ^ table1[a >> 16 & 255] ^ table2[b >> 8 & 255] ^ table3[c & 255] ^ key[kIndex + 3];\\n        kIndex += 4;\\n        a = a2;b = b2;c = c2;\\n      }\\n\\n      // Last round.\\n      for (i = 0; i < 4; i++) {\\n        out[(3 & -i) + offset] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];\\n        a2 = a;a = b;b = c;c = d;d = a2;\\n      }\\n    }\\n  }]);\\n\\n  return AES;\\n})();\\n\\nexports['default'] = AES;\\nmodule.exports = exports['default'];\\n},{}],17:[function(require,module,exports){\\n/**\\n * @file async-stream.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _stream = require('./stream');\\n\\nvar _stream2 = _interopRequireDefault(_stream);\\n\\n/**\\n * A wrapper around the Stream class to use setTiemout\\n * and run stream \\\"jobs\\\" Asynchronously\\n *\\n * @class AsyncStream\\n * @extends Stream\\n */\\n\\nvar AsyncStream = (function (_Stream) {\\n  _inherits(AsyncStream, _Stream);\\n\\n  function AsyncStream() {\\n    _classCallCheck(this, AsyncStream);\\n\\n    _get(Object.getPrototypeOf(AsyncStream.prototype), 'constructor', this).call(this, _stream2['default']);\\n    this.jobs = [];\\n    this.delay = 1;\\n    this.timeout_ = null;\\n  }\\n\\n  /**\\n   * process an async job\\n   *\\n   * @private\\n   */\\n\\n  _createClass(AsyncStream, [{\\n    key: 'processJob_',\\n    value: function processJob_() {\\n      this.jobs.shift()();\\n      if (this.jobs.length) {\\n        this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);\\n      } else {\\n        this.timeout_ = null;\\n      }\\n    }\\n\\n    /**\\n     * push a job into the stream\\n     *\\n     * @param {Function} job the job to push into the stream\\n     */\\n  }, {\\n    key: 'push',\\n    value: function push(job) {\\n      this.jobs.push(job);\\n      if (!this.timeout_) {\\n        this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);\\n      }\\n    }\\n  }]);\\n\\n  return AsyncStream;\\n})(_stream2['default']);\\n\\nexports['default'] = AsyncStream;\\nmodule.exports = exports['default'];\\n},{\\\"./stream\\\":20}],18:[function(require,module,exports){\\n/**\\n * @file decrypter.js\\n *\\n * An asynchronous implementation of AES-128 CBC decryption with\\n * PKCS#7 padding.\\n */\\n\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nvar _aes = require('./aes');\\n\\nvar _aes2 = _interopRequireDefault(_aes);\\n\\nvar _asyncStream = require('./async-stream');\\n\\nvar _asyncStream2 = _interopRequireDefault(_asyncStream);\\n\\nvar _pkcs7 = require('pkcs7');\\n\\n/**\\n * Convert network-order (big-endian) bytes into their little-endian\\n * representation.\\n */\\nvar ntoh = function ntoh(word) {\\n  return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\\n};\\n\\n/**\\n * Decrypt bytes using AES-128 with CBC and PKCS#7 padding.\\n *\\n * @param {Uint8Array} encrypted the encrypted bytes\\n * @param {Uint32Array} key the bytes of the decryption key\\n * @param {Uint32Array} initVector the initialization vector (IV) to\\n * use for the first round of CBC.\\n * @return {Uint8Array} the decrypted bytes\\n *\\n * @see http://en.wikipedia.org/wiki/Advanced_Encryption_Standard\\n * @see http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_.28CBC.29\\n * @see https://tools.ietf.org/html/rfc2315\\n */\\nvar decrypt = function decrypt(encrypted, key, initVector) {\\n  // word-level access to the encrypted bytes\\n  var encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2);\\n\\n  var decipher = new _aes2['default'](Array.prototype.slice.call(key));\\n\\n  // byte and word-level access for the decrypted output\\n  var decrypted = new Uint8Array(encrypted.byteLength);\\n  var decrypted32 = new Int32Array(decrypted.buffer);\\n\\n  // temporary variables for working with the IV, encrypted, and\\n  // decrypted data\\n  var init0 = undefined;\\n  var init1 = undefined;\\n  var init2 = undefined;\\n  var init3 = undefined;\\n  var encrypted0 = undefined;\\n  var encrypted1 = undefined;\\n  var encrypted2 = undefined;\\n  var encrypted3 = undefined;\\n\\n  // iteration variable\\n  var wordIx = undefined;\\n\\n  // pull out the words of the IV to ensure we don't modify the\\n  // passed-in reference and easier access\\n  init0 = initVector[0];\\n  init1 = initVector[1];\\n  init2 = initVector[2];\\n  init3 = initVector[3];\\n\\n  // decrypt four word sequences, applying cipher-block chaining (CBC)\\n  // to each decrypted block\\n  for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {\\n    // convert big-endian (network order) words into little-endian\\n    // (javascript order)\\n    encrypted0 = ntoh(encrypted32[wordIx]);\\n    encrypted1 = ntoh(encrypted32[wordIx + 1]);\\n    encrypted2 = ntoh(encrypted32[wordIx + 2]);\\n    encrypted3 = ntoh(encrypted32[wordIx + 3]);\\n\\n    // decrypt the block\\n    decipher.decrypt(encrypted0, encrypted1, encrypted2, encrypted3, decrypted32, wordIx);\\n\\n    // XOR with the IV, and restore network byte-order to obtain the\\n    // plaintext\\n    decrypted32[wordIx] = ntoh(decrypted32[wordIx] ^ init0);\\n    decrypted32[wordIx + 1] = ntoh(decrypted32[wordIx + 1] ^ init1);\\n    decrypted32[wordIx + 2] = ntoh(decrypted32[wordIx + 2] ^ init2);\\n    decrypted32[wordIx + 3] = ntoh(decrypted32[wordIx + 3] ^ init3);\\n\\n    // setup the IV for the next round\\n    init0 = encrypted0;\\n    init1 = encrypted1;\\n    init2 = encrypted2;\\n    init3 = encrypted3;\\n  }\\n\\n  return decrypted;\\n};\\n\\nexports.decrypt = decrypt;\\n/**\\n * The `Decrypter` class that manages decryption of AES\\n * data through `AsyncStream` objects and the `decrypt`\\n * function\\n *\\n * @param {Uint8Array} encrypted the encrypted bytes\\n * @param {Uint32Array} key the bytes of the decryption key\\n * @param {Uint32Array} initVector the initialization vector (IV) to\\n * @param {Function} done the function to run when done\\n * @class Decrypter\\n */\\n\\nvar Decrypter = (function () {\\n  function Decrypter(encrypted, key, initVector, done) {\\n    _classCallCheck(this, Decrypter);\\n\\n    var step = Decrypter.STEP;\\n    var encrypted32 = new Int32Array(encrypted.buffer);\\n    var decrypted = new Uint8Array(encrypted.byteLength);\\n    var i = 0;\\n\\n    this.asyncStream_ = new _asyncStream2['default']();\\n\\n    // split up the encryption job and do the individual chunks asynchronously\\n    this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));\\n    for (i = step; i < encrypted32.length; i += step) {\\n      initVector = new Uint32Array([ntoh(encrypted32[i - 4]), ntoh(encrypted32[i - 3]), ntoh(encrypted32[i - 2]), ntoh(encrypted32[i - 1])]);\\n      this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));\\n    }\\n    // invoke the done() callback when everything is finished\\n    this.asyncStream_.push(function () {\\n      // remove pkcs#7 padding from the decrypted bytes\\n      done(null, (0, _pkcs7.unpad)(decrypted));\\n    });\\n  }\\n\\n  /**\\n   * a getter for step the maximum number of bytes to process at one time\\n   *\\n   * @return {Number} the value of step 32000\\n   */\\n\\n  _createClass(Decrypter, [{\\n    key: 'decryptChunk_',\\n\\n    /**\\n     * @private\\n     */\\n    value: function decryptChunk_(encrypted, key, initVector, decrypted) {\\n      return function () {\\n        var bytes = decrypt(encrypted, key, initVector);\\n\\n        decrypted.set(bytes, encrypted.byteOffset);\\n      };\\n    }\\n  }], [{\\n    key: 'STEP',\\n    get: function get() {\\n      // 4 * 8000;\\n      return 32000;\\n    }\\n  }]);\\n\\n  return Decrypter;\\n})();\\n\\nexports.Decrypter = Decrypter;\\nexports['default'] = {\\n  Decrypter: Decrypter,\\n  decrypt: decrypt\\n};\\n},{\\\"./aes\\\":16,\\\"./async-stream\\\":17,\\\"pkcs7\\\":22}],19:[function(require,module,exports){\\n/**\\n * @file index.js\\n *\\n * Index module to easily import the primary components of AES-128\\n * decryption. Like this:\\n *\\n * ```js\\n * import {Decrypter, decrypt, AsyncStream} from 'aes-decrypter';\\n * ```\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _decrypter = require('./decrypter');\\n\\nvar _asyncStream = require('./async-stream');\\n\\nvar _asyncStream2 = _interopRequireDefault(_asyncStream);\\n\\nexports['default'] = {\\n  decrypt: _decrypter.decrypt,\\n  Decrypter: _decrypter.Decrypter,\\n  AsyncStream: _asyncStream2['default']\\n};\\nmodule.exports = exports['default'];\\n},{\\\"./async-stream\\\":17,\\\"./decrypter\\\":18}],20:[function(require,module,exports){\\narguments[4][14][0].apply(exports,arguments)\\n},{\\\"dup\\\":14}],21:[function(require,module,exports){\\n/*\\n * pkcs7.pad\\n * https://github.com/brightcove/pkcs7\\n *\\n * Copyright (c) 2014 Brightcove\\n * Licensed under the apache2 license.\\n */\\n\\n'use strict';\\n\\nvar PADDING;\\n\\n/**\\n * Returns a new Uint8Array that is padded with PKCS#7 padding.\\n * @param plaintext {Uint8Array} the input bytes before encryption\\n * @return {Uint8Array} the padded bytes\\n * @see http://tools.ietf.org/html/rfc5652\\n */\\nmodule.exports = function pad(plaintext) {\\n  var padding = PADDING[(plaintext.byteLength % 16) || 0],\\n      result = new Uint8Array(plaintext.byteLength + padding.length);\\n  result.set(plaintext);\\n  result.set(padding, plaintext.byteLength);\\n  return result;\\n};\\n\\n// pre-define the padding values\\nPADDING = [\\n  [16, 16, 16, 16,\\n   16, 16, 16, 16,\\n   16, 16, 16, 16,\\n   16, 16, 16, 16],\\n\\n  [15, 15, 15, 15,\\n   15, 15, 15, 15,\\n   15, 15, 15, 15,\\n   15, 15, 15],\\n\\n  [14, 14, 14, 14,\\n   14, 14, 14, 14,\\n   14, 14, 14, 14,\\n   14, 14],\\n\\n  [13, 13, 13, 13,\\n   13, 13, 13, 13,\\n   13, 13, 13, 13,\\n   13],\\n\\n  [12, 12, 12, 12,\\n   12, 12, 12, 12,\\n   12, 12, 12, 12],\\n\\n  [11, 11, 11, 11,\\n   11, 11, 11, 11,\\n   11, 11, 11],\\n\\n  [10, 10, 10, 10,\\n   10, 10, 10, 10,\\n   10, 10],\\n\\n  [9, 9, 9, 9,\\n   9, 9, 9, 9,\\n   9],\\n\\n  [8, 8, 8, 8,\\n   8, 8, 8, 8],\\n\\n  [7, 7, 7, 7,\\n   7, 7, 7],\\n\\n  [6, 6, 6, 6,\\n   6, 6],\\n\\n  [5, 5, 5, 5,\\n   5],\\n\\n  [4, 4, 4, 4],\\n\\n  [3, 3, 3],\\n\\n  [2, 2],\\n\\n  [1]\\n];\\n\\n},{}],22:[function(require,module,exports){\\n/*\\n * pkcs7\\n * https://github.com/brightcove/pkcs7\\n *\\n * Copyright (c) 2014 Brightcove\\n * Licensed under the apache2 license.\\n */\\n\\n'use strict';\\n\\nexports.pad = require('./pad.js');\\nexports.unpad = require('./unpad.js');\\n\\n},{\\\"./pad.js\\\":21,\\\"./unpad.js\\\":23}],23:[function(require,module,exports){\\n/*\\n * pkcs7.unpad\\n * https://github.com/brightcove/pkcs7\\n *\\n * Copyright (c) 2014 Brightcove\\n * Licensed under the apache2 license.\\n */\\n\\n'use strict';\\n\\n/**\\n * Returns the subarray of a Uint8Array without PKCS#7 padding.\\n * @param padded {Uint8Array} unencrypted bytes that have been padded\\n * @return {Uint8Array} the unpadded bytes\\n * @see http://tools.ietf.org/html/rfc5652\\n */\\nmodule.exports = function unpad(padded) {\\n  return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);\\n};\\n\\n},{}],24:[function(require,module,exports){\\n\\n},{}],25:[function(require,module,exports){\\n(function (global){\\nvar topLevel = typeof global !== 'undefined' ? global :\\n    typeof window !== 'undefined' ? window : {}\\nvar minDoc = require('min-document');\\n\\nif (typeof document !== 'undefined') {\\n    module.exports = document;\\n} else {\\n    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\\n\\n    if (!doccy) {\\n        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\\n    }\\n\\n    module.exports = doccy;\\n}\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"min-document\\\":24}],26:[function(require,module,exports){\\n(function (global){\\nif (typeof window !== \\\"undefined\\\") {\\n    module.exports = window;\\n} else if (typeof global !== \\\"undefined\\\") {\\n    module.exports = global;\\n} else if (typeof self !== \\\"undefined\\\"){\\n    module.exports = self;\\n} else {\\n    module.exports = {};\\n}\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{}],27:[function(require,module,exports){\\n/** Used as the `TypeError` message for \\\"Functions\\\" methods. */\\nvar FUNC_ERROR_TEXT = 'Expected a function';\\n\\n/* Native method references for those with the same name as other `lodash` methods. */\\nvar nativeMax = Math.max;\\n\\n/**\\n * Creates a function that invokes `func` with the `this` binding of the\\n * created function and arguments from `start` and beyond provided as an array.\\n *\\n * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/Web/JavaScript/Reference/Functions/rest_parameters).\\n *\\n * @static\\n * @memberOf _\\n * @category Function\\n * @param {Function} func The function to apply a rest parameter to.\\n * @param {number} [start=func.length-1] The start position of the rest parameter.\\n * @returns {Function} Returns the new function.\\n * @example\\n *\\n * var say = _.restParam(function(what, names) {\\n *   return what + ' ' + _.initial(names).join(', ') +\\n *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\\n * });\\n *\\n * say('hello', 'fred', 'barney', 'pebbles');\\n * // => 'hello fred, barney, & pebbles'\\n */\\nfunction restParam(func, start) {\\n  if (typeof func != 'function') {\\n    throw new TypeError(FUNC_ERROR_TEXT);\\n  }\\n  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);\\n  return function() {\\n    var args = arguments,\\n        index = -1,\\n        length = nativeMax(args.length - start, 0),\\n        rest = Array(length);\\n\\n    while (++index < length) {\\n      rest[index] = args[start + index];\\n    }\\n    switch (start) {\\n      case 0: return func.call(this, rest);\\n      case 1: return func.call(this, args[0], rest);\\n      case 2: return func.call(this, args[0], args[1], rest);\\n    }\\n    var otherArgs = Array(start + 1);\\n    index = -1;\\n    while (++index < start) {\\n      otherArgs[index] = args[index];\\n    }\\n    otherArgs[start] = rest;\\n    return func.apply(this, otherArgs);\\n  };\\n}\\n\\nmodule.exports = restParam;\\n\\n},{}],28:[function(require,module,exports){\\n/**\\n * Copies the values of `source` to `array`.\\n *\\n * @private\\n * @param {Array} source The array to copy values from.\\n * @param {Array} [array=[]] The array to copy values to.\\n * @returns {Array} Returns `array`.\\n */\\nfunction arrayCopy(source, array) {\\n  var index = -1,\\n      length = source.length;\\n\\n  array || (array = Array(length));\\n  while (++index < length) {\\n    array[index] = source[index];\\n  }\\n  return array;\\n}\\n\\nmodule.exports = arrayCopy;\\n\\n},{}],29:[function(require,module,exports){\\n/**\\n * A specialized version of `_.forEach` for arrays without support for callback\\n * shorthands and `this` binding.\\n *\\n * @private\\n * @param {Array} array The array to iterate over.\\n * @param {Function} iteratee The function invoked per iteration.\\n * @returns {Array} Returns `array`.\\n */\\nfunction arrayEach(array, iteratee) {\\n  var index = -1,\\n      length = array.length;\\n\\n  while (++index < length) {\\n    if (iteratee(array[index], index, array) === false) {\\n      break;\\n    }\\n  }\\n  return array;\\n}\\n\\nmodule.exports = arrayEach;\\n\\n},{}],30:[function(require,module,exports){\\n/**\\n * Copies properties of `source` to `object`.\\n *\\n * @private\\n * @param {Object} source The object to copy properties from.\\n * @param {Array} props The property names to copy.\\n * @param {Object} [object={}] The object to copy properties to.\\n * @returns {Object} Returns `object`.\\n */\\nfunction baseCopy(source, props, object) {\\n  object || (object = {});\\n\\n  var index = -1,\\n      length = props.length;\\n\\n  while (++index < length) {\\n    var key = props[index];\\n    object[key] = source[key];\\n  }\\n  return object;\\n}\\n\\nmodule.exports = baseCopy;\\n\\n},{}],31:[function(require,module,exports){\\nvar createBaseFor = require('./createBaseFor');\\n\\n/**\\n * The base implementation of `baseForIn` and `baseForOwn` which iterates\\n * over `object` properties returned by `keysFunc` invoking `iteratee` for\\n * each property. Iteratee functions may exit iteration early by explicitly\\n * returning `false`.\\n *\\n * @private\\n * @param {Object} object The object to iterate over.\\n * @param {Function} iteratee The function invoked per iteration.\\n * @param {Function} keysFunc The function to get the keys of `object`.\\n * @returns {Object} Returns `object`.\\n */\\nvar baseFor = createBaseFor();\\n\\nmodule.exports = baseFor;\\n\\n},{\\\"./createBaseFor\\\":38}],32:[function(require,module,exports){\\nvar baseFor = require('./baseFor'),\\n    keysIn = require('../object/keysIn');\\n\\n/**\\n * The base implementation of `_.forIn` without support for callback\\n * shorthands and `this` binding.\\n *\\n * @private\\n * @param {Object} object The object to iterate over.\\n * @param {Function} iteratee The function invoked per iteration.\\n * @returns {Object} Returns `object`.\\n */\\nfunction baseForIn(object, iteratee) {\\n  return baseFor(object, iteratee, keysIn);\\n}\\n\\nmodule.exports = baseForIn;\\n\\n},{\\\"../object/keysIn\\\":59,\\\"./baseFor\\\":31}],33:[function(require,module,exports){\\nvar arrayEach = require('./arrayEach'),\\n    baseMergeDeep = require('./baseMergeDeep'),\\n    isArray = require('../lang/isArray'),\\n    isArrayLike = require('./isArrayLike'),\\n    isObject = require('../lang/isObject'),\\n    isObjectLike = require('./isObjectLike'),\\n    isTypedArray = require('../lang/isTypedArray'),\\n    keys = require('../object/keys');\\n\\n/**\\n * The base implementation of `_.merge` without support for argument juggling,\\n * multiple sources, and `this` binding `customizer` functions.\\n *\\n * @private\\n * @param {Object} object The destination object.\\n * @param {Object} source The source object.\\n * @param {Function} [customizer] The function to customize merged values.\\n * @param {Array} [stackA=[]] Tracks traversed source objects.\\n * @param {Array} [stackB=[]] Associates values with source counterparts.\\n * @returns {Object} Returns `object`.\\n */\\nfunction baseMerge(object, source, customizer, stackA, stackB) {\\n  if (!isObject(object)) {\\n    return object;\\n  }\\n  var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),\\n      props = isSrcArr ? undefined : keys(source);\\n\\n  arrayEach(props || source, function(srcValue, key) {\\n    if (props) {\\n      key = srcValue;\\n      srcValue = source[key];\\n    }\\n    if (isObjectLike(srcValue)) {\\n      stackA || (stackA = []);\\n      stackB || (stackB = []);\\n      baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);\\n    }\\n    else {\\n      var value = object[key],\\n          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\\n          isCommon = result === undefined;\\n\\n      if (isCommon) {\\n        result = srcValue;\\n      }\\n      if ((result !== undefined || (isSrcArr && !(key in object))) &&\\n          (isCommon || (result === result ? (result !== value) : (value === value)))) {\\n        object[key] = result;\\n      }\\n    }\\n  });\\n  return object;\\n}\\n\\nmodule.exports = baseMerge;\\n\\n},{\\\"../lang/isArray\\\":50,\\\"../lang/isObject\\\":53,\\\"../lang/isTypedArray\\\":56,\\\"../object/keys\\\":58,\\\"./arrayEach\\\":29,\\\"./baseMergeDeep\\\":34,\\\"./isArrayLike\\\":41,\\\"./isObjectLike\\\":46}],34:[function(require,module,exports){\\nvar arrayCopy = require('./arrayCopy'),\\n    isArguments = require('../lang/isArguments'),\\n    isArray = require('../lang/isArray'),\\n    isArrayLike = require('./isArrayLike'),\\n    isPlainObject = require('../lang/isPlainObject'),\\n    isTypedArray = require('../lang/isTypedArray'),\\n    toPlainObject = require('../lang/toPlainObject');\\n\\n/**\\n * A specialized version of `baseMerge` for arrays and objects which performs\\n * deep merges and tracks traversed objects enabling objects with circular\\n * references to be merged.\\n *\\n * @private\\n * @param {Object} object The destination object.\\n * @param {Object} source The source object.\\n * @param {string} key The key of the value to merge.\\n * @param {Function} mergeFunc The function to merge values.\\n * @param {Function} [customizer] The function to customize merged values.\\n * @param {Array} [stackA=[]] Tracks traversed source objects.\\n * @param {Array} [stackB=[]] Associates values with source counterparts.\\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\\n */\\nfunction baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {\\n  var length = stackA.length,\\n      srcValue = source[key];\\n\\n  while (length--) {\\n    if (stackA[length] == srcValue) {\\n      object[key] = stackB[length];\\n      return;\\n    }\\n  }\\n  var value = object[key],\\n      result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\\n      isCommon = result === undefined;\\n\\n  if (isCommon) {\\n    result = srcValue;\\n    if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {\\n      result = isArray(value)\\n        ? value\\n        : (isArrayLike(value) ? arrayCopy(value) : []);\\n    }\\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\\n      result = isArguments(value)\\n        ? toPlainObject(value)\\n        : (isPlainObject(value) ? value : {});\\n    }\\n    else {\\n      isCommon = false;\\n    }\\n  }\\n  // Add the source value to the stack of traversed objects and associate\\n  // it with its merged value.\\n  stackA.push(srcValue);\\n  stackB.push(result);\\n\\n  if (isCommon) {\\n    // Recursively merge objects and arrays (susceptible to call stack limits).\\n    object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);\\n  } else if (result === result ? (result !== value) : (value === value)) {\\n    object[key] = result;\\n  }\\n}\\n\\nmodule.exports = baseMergeDeep;\\n\\n},{\\\"../lang/isArguments\\\":49,\\\"../lang/isArray\\\":50,\\\"../lang/isPlainObject\\\":54,\\\"../lang/isTypedArray\\\":56,\\\"../lang/toPlainObject\\\":57,\\\"./arrayCopy\\\":28,\\\"./isArrayLike\\\":41}],35:[function(require,module,exports){\\nvar toObject = require('./toObject');\\n\\n/**\\n * The base implementation of `_.property` without support for deep paths.\\n *\\n * @private\\n * @param {string} key The key of the property to get.\\n * @returns {Function} Returns the new function.\\n */\\nfunction baseProperty(key) {\\n  return function(object) {\\n    return object == null ? undefined : toObject(object)[key];\\n  };\\n}\\n\\nmodule.exports = baseProperty;\\n\\n},{\\\"./toObject\\\":48}],36:[function(require,module,exports){\\nvar identity = require('../utility/identity');\\n\\n/**\\n * A specialized version of `baseCallback` which only supports `this` binding\\n * and specifying the number of arguments to provide to `func`.\\n *\\n * @private\\n * @param {Function} func The function to bind.\\n * @param {*} thisArg The `this` binding of `func`.\\n * @param {number} [argCount] The number of arguments to provide to `func`.\\n * @returns {Function} Returns the callback.\\n */\\nfunction bindCallback(func, thisArg, argCount) {\\n  if (typeof func != 'function') {\\n    return identity;\\n  }\\n  if (thisArg === undefined) {\\n    return func;\\n  }\\n  switch (argCount) {\\n    case 1: return function(value) {\\n      return func.call(thisArg, value);\\n    };\\n    case 3: return function(value, index, collection) {\\n      return func.call(thisArg, value, index, collection);\\n    };\\n    case 4: return function(accumulator, value, index, collection) {\\n      return func.call(thisArg, accumulator, value, index, collection);\\n    };\\n    case 5: return function(value, other, key, object, source) {\\n      return func.call(thisArg, value, other, key, object, source);\\n    };\\n  }\\n  return function() {\\n    return func.apply(thisArg, arguments);\\n  };\\n}\\n\\nmodule.exports = bindCallback;\\n\\n},{\\\"../utility/identity\\\":62}],37:[function(require,module,exports){\\nvar bindCallback = require('./bindCallback'),\\n    isIterateeCall = require('./isIterateeCall'),\\n    restParam = require('../function/restParam');\\n\\n/**\\n * Creates a `_.assign`, `_.defaults`, or `_.merge` function.\\n *\\n * @private\\n * @param {Function} assigner The function to assign values.\\n * @returns {Function} Returns the new assigner function.\\n */\\nfunction createAssigner(assigner) {\\n  return restParam(function(object, sources) {\\n    var index = -1,\\n        length = object == null ? 0 : sources.length,\\n        customizer = length > 2 ? sources[length - 2] : undefined,\\n        guard = length > 2 ? sources[2] : undefined,\\n        thisArg = length > 1 ? sources[length - 1] : undefined;\\n\\n    if (typeof customizer == 'function') {\\n      customizer = bindCallback(customizer, thisArg, 5);\\n      length -= 2;\\n    } else {\\n      customizer = typeof thisArg == 'function' ? thisArg : undefined;\\n      length -= (customizer ? 1 : 0);\\n    }\\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\\n      customizer = length < 3 ? undefined : customizer;\\n      length = 1;\\n    }\\n    while (++index < length) {\\n      var source = sources[index];\\n      if (source) {\\n        assigner(object, source, customizer);\\n      }\\n    }\\n    return object;\\n  });\\n}\\n\\nmodule.exports = createAssigner;\\n\\n},{\\\"../function/restParam\\\":27,\\\"./bindCallback\\\":36,\\\"./isIterateeCall\\\":44}],38:[function(require,module,exports){\\nvar toObject = require('./toObject');\\n\\n/**\\n * Creates a base function for `_.forIn` or `_.forInRight`.\\n *\\n * @private\\n * @param {boolean} [fromRight] Specify iterating from right to left.\\n * @returns {Function} Returns the new base function.\\n */\\nfunction createBaseFor(fromRight) {\\n  return function(object, iteratee, keysFunc) {\\n    var iterable = toObject(object),\\n        props = keysFunc(object),\\n        length = props.length,\\n        index = fromRight ? length : -1;\\n\\n    while ((fromRight ? index-- : ++index < length)) {\\n      var key = props[index];\\n      if (iteratee(iterable[key], key, iterable) === false) {\\n        break;\\n      }\\n    }\\n    return object;\\n  };\\n}\\n\\nmodule.exports = createBaseFor;\\n\\n},{\\\"./toObject\\\":48}],39:[function(require,module,exports){\\nvar baseProperty = require('./baseProperty');\\n\\n/**\\n * Gets the \\\"length\\\" property value of `object`.\\n *\\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\\n * that affects Safari on at least iOS 8.1-8.3 ARM64.\\n *\\n * @private\\n * @param {Object} object The object to query.\\n * @returns {*} Returns the \\\"length\\\" value.\\n */\\nvar getLength = baseProperty('length');\\n\\nmodule.exports = getLength;\\n\\n},{\\\"./baseProperty\\\":35}],40:[function(require,module,exports){\\nvar isNative = require('../lang/isNative');\\n\\n/**\\n * Gets the native function at `key` of `object`.\\n *\\n * @private\\n * @param {Object} object The object to query.\\n * @param {string} key The key of the method to get.\\n * @returns {*} Returns the function if it's native, else `undefined`.\\n */\\nfunction getNative(object, key) {\\n  var value = object == null ? undefined : object[key];\\n  return isNative(value) ? value : undefined;\\n}\\n\\nmodule.exports = getNative;\\n\\n},{\\\"../lang/isNative\\\":52}],41:[function(require,module,exports){\\nvar getLength = require('./getLength'),\\n    isLength = require('./isLength');\\n\\n/**\\n * Checks if `value` is array-like.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\\n */\\nfunction isArrayLike(value) {\\n  return value != null && isLength(getLength(value));\\n}\\n\\nmodule.exports = isArrayLike;\\n\\n},{\\\"./getLength\\\":39,\\\"./isLength\\\":45}],42:[function(require,module,exports){\\n/**\\n * Checks if `value` is a host object in IE < 9.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\\n */\\nvar isHostObject = (function() {\\n  try {\\n    Object({ 'toString': 0 } + '');\\n  } catch(e) {\\n    return function() { return false; };\\n  }\\n  return function(value) {\\n    // IE < 9 presents many host objects as `Object` objects that can coerce\\n    // to strings despite having improperly defined `toString` methods.\\n    return typeof value.toString != 'function' && typeof (value + '') == 'string';\\n  };\\n}());\\n\\nmodule.exports = isHostObject;\\n\\n},{}],43:[function(require,module,exports){\\n/** Used to detect unsigned integer values. */\\nvar reIsUint = /^\\\\d+$/;\\n\\n/**\\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\\n * of an array-like value.\\n */\\nvar MAX_SAFE_INTEGER = 9007199254740991;\\n\\n/**\\n * Checks if `value` is a valid array-like index.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\\n */\\nfunction isIndex(value, length) {\\n  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\\n  length = length == null ? MAX_SAFE_INTEGER : length;\\n  return value > -1 && value % 1 == 0 && value < length;\\n}\\n\\nmodule.exports = isIndex;\\n\\n},{}],44:[function(require,module,exports){\\nvar isArrayLike = require('./isArrayLike'),\\n    isIndex = require('./isIndex'),\\n    isObject = require('../lang/isObject');\\n\\n/**\\n * Checks if the provided arguments are from an iteratee call.\\n *\\n * @private\\n * @param {*} value The potential iteratee value argument.\\n * @param {*} index The potential iteratee index or key argument.\\n * @param {*} object The potential iteratee object argument.\\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\\n */\\nfunction isIterateeCall(value, index, object) {\\n  if (!isObject(object)) {\\n    return false;\\n  }\\n  var type = typeof index;\\n  if (type == 'number'\\n      ? (isArrayLike(object) && isIndex(index, object.length))\\n      : (type == 'string' && index in object)) {\\n    var other = object[index];\\n    return value === value ? (value === other) : (other !== other);\\n  }\\n  return false;\\n}\\n\\nmodule.exports = isIterateeCall;\\n\\n},{\\\"../lang/isObject\\\":53,\\\"./isArrayLike\\\":41,\\\"./isIndex\\\":43}],45:[function(require,module,exports){\\n/**\\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\\n * of an array-like value.\\n */\\nvar MAX_SAFE_INTEGER = 9007199254740991;\\n\\n/**\\n * Checks if `value` is a valid array-like length.\\n *\\n * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\\n */\\nfunction isLength(value) {\\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\\n}\\n\\nmodule.exports = isLength;\\n\\n},{}],46:[function(require,module,exports){\\n/**\\n * Checks if `value` is object-like.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\\n */\\nfunction isObjectLike(value) {\\n  return !!value && typeof value == 'object';\\n}\\n\\nmodule.exports = isObjectLike;\\n\\n},{}],47:[function(require,module,exports){\\nvar isArguments = require('../lang/isArguments'),\\n    isArray = require('../lang/isArray'),\\n    isIndex = require('./isIndex'),\\n    isLength = require('./isLength'),\\n    isString = require('../lang/isString'),\\n    keysIn = require('../object/keysIn');\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/** Used to check objects for own properties. */\\nvar hasOwnProperty = objectProto.hasOwnProperty;\\n\\n/**\\n * A fallback implementation of `Object.keys` which creates an array of the\\n * own enumerable property names of `object`.\\n *\\n * @private\\n * @param {Object} object The object to query.\\n * @returns {Array} Returns the array of property names.\\n */\\nfunction shimKeys(object) {\\n  var props = keysIn(object),\\n      propsLength = props.length,\\n      length = propsLength && object.length;\\n\\n  var allowIndexes = !!length && isLength(length) &&\\n    (isArray(object) || isArguments(object) || isString(object));\\n\\n  var index = -1,\\n      result = [];\\n\\n  while (++index < propsLength) {\\n    var key = props[index];\\n    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\\n      result.push(key);\\n    }\\n  }\\n  return result;\\n}\\n\\nmodule.exports = shimKeys;\\n\\n},{\\\"../lang/isArguments\\\":49,\\\"../lang/isArray\\\":50,\\\"../lang/isString\\\":55,\\\"../object/keysIn\\\":59,\\\"./isIndex\\\":43,\\\"./isLength\\\":45}],48:[function(require,module,exports){\\nvar isObject = require('../lang/isObject'),\\n    isString = require('../lang/isString'),\\n    support = require('../support');\\n\\n/**\\n * Converts `value` to an object if it's not one.\\n *\\n * @private\\n * @param {*} value The value to process.\\n * @returns {Object} Returns the object.\\n */\\nfunction toObject(value) {\\n  if (support.unindexedChars && isString(value)) {\\n    var index = -1,\\n        length = value.length,\\n        result = Object(value);\\n\\n    while (++index < length) {\\n      result[index] = value.charAt(index);\\n    }\\n    return result;\\n  }\\n  return isObject(value) ? value : Object(value);\\n}\\n\\nmodule.exports = toObject;\\n\\n},{\\\"../lang/isObject\\\":53,\\\"../lang/isString\\\":55,\\\"../support\\\":61}],49:[function(require,module,exports){\\nvar isArrayLike = require('../internal/isArrayLike'),\\n    isObjectLike = require('../internal/isObjectLike');\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/** Used to check objects for own properties. */\\nvar hasOwnProperty = objectProto.hasOwnProperty;\\n\\n/** Native method references. */\\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\\n\\n/**\\n * Checks if `value` is classified as an `arguments` object.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\\n * @example\\n *\\n * _.isArguments(function() { return arguments; }());\\n * // => true\\n *\\n * _.isArguments([1, 2, 3]);\\n * // => false\\n */\\nfunction isArguments(value) {\\n  return isObjectLike(value) && isArrayLike(value) &&\\n    hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\\n}\\n\\nmodule.exports = isArguments;\\n\\n},{\\\"../internal/isArrayLike\\\":41,\\\"../internal/isObjectLike\\\":46}],50:[function(require,module,exports){\\nvar getNative = require('../internal/getNative'),\\n    isLength = require('../internal/isLength'),\\n    isObjectLike = require('../internal/isObjectLike');\\n\\n/** `Object#toString` result references. */\\nvar arrayTag = '[object Array]';\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/* Native method references for those with the same name as other `lodash` methods. */\\nvar nativeIsArray = getNative(Array, 'isArray');\\n\\n/**\\n * Checks if `value` is classified as an `Array` object.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\\n * @example\\n *\\n * _.isArray([1, 2, 3]);\\n * // => true\\n *\\n * _.isArray(function() { return arguments; }());\\n * // => false\\n */\\nvar isArray = nativeIsArray || function(value) {\\n  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\\n};\\n\\nmodule.exports = isArray;\\n\\n},{\\\"../internal/getNative\\\":40,\\\"../internal/isLength\\\":45,\\\"../internal/isObjectLike\\\":46}],51:[function(require,module,exports){\\nvar isObject = require('./isObject');\\n\\n/** `Object#toString` result references. */\\nvar funcTag = '[object Function]';\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/**\\n * Checks if `value` is classified as a `Function` object.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\\n * @example\\n *\\n * _.isFunction(_);\\n * // => true\\n *\\n * _.isFunction(/abc/);\\n * // => false\\n */\\nfunction isFunction(value) {\\n  // The use of `Object#toString` avoids issues with the `typeof` operator\\n  // in older versions of Chrome and Safari which return 'function' for regexes\\n  // and Safari 8 which returns 'object' for typed array constructors.\\n  return isObject(value) && objToString.call(value) == funcTag;\\n}\\n\\nmodule.exports = isFunction;\\n\\n},{\\\"./isObject\\\":53}],52:[function(require,module,exports){\\nvar isFunction = require('./isFunction'),\\n    isHostObject = require('../internal/isHostObject'),\\n    isObjectLike = require('../internal/isObjectLike');\\n\\n/** Used to detect host constructors (Safari > 5). */\\nvar reIsHostCtor = /^\\\\[object .+?Constructor\\\\]$/;\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/** Used to resolve the decompiled source of functions. */\\nvar fnToString = Function.prototype.toString;\\n\\n/** Used to check objects for own properties. */\\nvar hasOwnProperty = objectProto.hasOwnProperty;\\n\\n/** Used to detect if a method is native. */\\nvar reIsNative = RegExp('^' +\\n  fnToString.call(hasOwnProperty).replace(/[\\\\\\\\^$.*+?()[\\\\]{}|]/g, '\\\\\\\\$&')\\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\\\\\\\()| for .+?(?=\\\\\\\\\\\\])/g, '$1.*?') + '$'\\n);\\n\\n/**\\n * Checks if `value` is a native function.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\\n * @example\\n *\\n * _.isNative(Array.prototype.push);\\n * // => true\\n *\\n * _.isNative(_);\\n * // => false\\n */\\nfunction isNative(value) {\\n  if (value == null) {\\n    return false;\\n  }\\n  if (isFunction(value)) {\\n    return reIsNative.test(fnToString.call(value));\\n  }\\n  return isObjectLike(value) && (isHostObject(value) ? reIsNative : reIsHostCtor).test(value);\\n}\\n\\nmodule.exports = isNative;\\n\\n},{\\\"../internal/isHostObject\\\":42,\\\"../internal/isObjectLike\\\":46,\\\"./isFunction\\\":51}],53:[function(require,module,exports){\\n/**\\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\\n * @example\\n *\\n * _.isObject({});\\n * // => true\\n *\\n * _.isObject([1, 2, 3]);\\n * // => true\\n *\\n * _.isObject(1);\\n * // => false\\n */\\nfunction isObject(value) {\\n  // Avoid a V8 JIT bug in Chrome 19-20.\\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\\n  var type = typeof value;\\n  return !!value && (type == 'object' || type == 'function');\\n}\\n\\nmodule.exports = isObject;\\n\\n},{}],54:[function(require,module,exports){\\nvar baseForIn = require('../internal/baseForIn'),\\n    isArguments = require('./isArguments'),\\n    isHostObject = require('../internal/isHostObject'),\\n    isObjectLike = require('../internal/isObjectLike'),\\n    support = require('../support');\\n\\n/** `Object#toString` result references. */\\nvar objectTag = '[object Object]';\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/** Used to check objects for own properties. */\\nvar hasOwnProperty = objectProto.hasOwnProperty;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/**\\n * Checks if `value` is a plain object, that is, an object created by the\\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\\n *\\n * **Note:** This method assumes objects created by the `Object` constructor\\n * have no inherited enumerable properties.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\\n * @example\\n *\\n * function Foo() {\\n *   this.a = 1;\\n * }\\n *\\n * _.isPlainObject(new Foo);\\n * // => false\\n *\\n * _.isPlainObject([1, 2, 3]);\\n * // => false\\n *\\n * _.isPlainObject({ 'x': 0, 'y': 0 });\\n * // => true\\n *\\n * _.isPlainObject(Object.create(null));\\n * // => true\\n */\\nfunction isPlainObject(value) {\\n  var Ctor;\\n\\n  // Exit early for non `Object` objects.\\n  if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isHostObject(value) && !isArguments(value)) ||\\n      (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {\\n    return false;\\n  }\\n  // IE < 9 iterates inherited properties before own properties. If the first\\n  // iterated property is an object's own property then there are no inherited\\n  // enumerable properties.\\n  var result;\\n  if (support.ownLast) {\\n    baseForIn(value, function(subValue, key, object) {\\n      result = hasOwnProperty.call(object, key);\\n      return false;\\n    });\\n    return result !== false;\\n  }\\n  // In most environments an object's own properties are iterated before\\n  // its inherited properties. If the last iterated property is an object's\\n  // own property then there are no inherited enumerable properties.\\n  baseForIn(value, function(subValue, key) {\\n    result = key;\\n  });\\n  return result === undefined || hasOwnProperty.call(value, result);\\n}\\n\\nmodule.exports = isPlainObject;\\n\\n},{\\\"../internal/baseForIn\\\":32,\\\"../internal/isHostObject\\\":42,\\\"../internal/isObjectLike\\\":46,\\\"../support\\\":61,\\\"./isArguments\\\":49}],55:[function(require,module,exports){\\nvar isObjectLike = require('../internal/isObjectLike');\\n\\n/** `Object#toString` result references. */\\nvar stringTag = '[object String]';\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/**\\n * Checks if `value` is classified as a `String` primitive or object.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\\n * @example\\n *\\n * _.isString('abc');\\n * // => true\\n *\\n * _.isString(1);\\n * // => false\\n */\\nfunction isString(value) {\\n  return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);\\n}\\n\\nmodule.exports = isString;\\n\\n},{\\\"../internal/isObjectLike\\\":46}],56:[function(require,module,exports){\\nvar isLength = require('../internal/isLength'),\\n    isObjectLike = require('../internal/isObjectLike');\\n\\n/** `Object#toString` result references. */\\nvar argsTag = '[object Arguments]',\\n    arrayTag = '[object Array]',\\n    boolTag = '[object Boolean]',\\n    dateTag = '[object Date]',\\n    errorTag = '[object Error]',\\n    funcTag = '[object Function]',\\n    mapTag = '[object Map]',\\n    numberTag = '[object Number]',\\n    objectTag = '[object Object]',\\n    regexpTag = '[object RegExp]',\\n    setTag = '[object Set]',\\n    stringTag = '[object String]',\\n    weakMapTag = '[object WeakMap]';\\n\\nvar arrayBufferTag = '[object ArrayBuffer]',\\n    float32Tag = '[object Float32Array]',\\n    float64Tag = '[object Float64Array]',\\n    int8Tag = '[object Int8Array]',\\n    int16Tag = '[object Int16Array]',\\n    int32Tag = '[object Int32Array]',\\n    uint8Tag = '[object Uint8Array]',\\n    uint8ClampedTag = '[object Uint8ClampedArray]',\\n    uint16Tag = '[object Uint16Array]',\\n    uint32Tag = '[object Uint32Array]';\\n\\n/** Used to identify `toStringTag` values of typed arrays. */\\nvar typedArrayTags = {};\\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\\ntypedArrayTags[uint32Tag] = true;\\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\\ntypedArrayTags[dateTag] = typedArrayTags[errorTag] =\\ntypedArrayTags[funcTag] = typedArrayTags[mapTag] =\\ntypedArrayTags[numberTag] = typedArrayTags[objectTag] =\\ntypedArrayTags[regexpTag] = typedArrayTags[setTag] =\\ntypedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\\n\\n/** Used for native method references. */\\nvar objectProto = Object.prototype;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/**\\n * Checks if `value` is classified as a typed array.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\\n * @example\\n *\\n * _.isTypedArray(new Uint8Array);\\n * // => true\\n *\\n * _.isTypedArray([]);\\n * // => false\\n */\\nfunction isTypedArray(value) {\\n  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];\\n}\\n\\nmodule.exports = isTypedArray;\\n\\n},{\\\"../internal/isLength\\\":45,\\\"../internal/isObjectLike\\\":46}],57:[function(require,module,exports){\\nvar baseCopy = require('../internal/baseCopy'),\\n    keysIn = require('../object/keysIn');\\n\\n/**\\n * Converts `value` to a plain object flattening inherited enumerable\\n * properties of `value` to own properties of the plain object.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to convert.\\n * @returns {Object} Returns the converted plain object.\\n * @example\\n *\\n * function Foo() {\\n *   this.b = 2;\\n * }\\n *\\n * Foo.prototype.c = 3;\\n *\\n * _.assign({ 'a': 1 }, new Foo);\\n * // => { 'a': 1, 'b': 2 }\\n *\\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\\n * // => { 'a': 1, 'b': 2, 'c': 3 }\\n */\\nfunction toPlainObject(value) {\\n  return baseCopy(value, keysIn(value));\\n}\\n\\nmodule.exports = toPlainObject;\\n\\n},{\\\"../internal/baseCopy\\\":30,\\\"../object/keysIn\\\":59}],58:[function(require,module,exports){\\nvar getNative = require('../internal/getNative'),\\n    isArrayLike = require('../internal/isArrayLike'),\\n    isObject = require('../lang/isObject'),\\n    shimKeys = require('../internal/shimKeys'),\\n    support = require('../support');\\n\\n/* Native method references for those with the same name as other `lodash` methods. */\\nvar nativeKeys = getNative(Object, 'keys');\\n\\n/**\\n * Creates an array of the own enumerable property names of `object`.\\n *\\n * **Note:** Non-object values are coerced to objects. See the\\n * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\\n * for more details.\\n *\\n * @static\\n * @memberOf _\\n * @category Object\\n * @param {Object} object The object to query.\\n * @returns {Array} Returns the array of property names.\\n * @example\\n *\\n * function Foo() {\\n *   this.a = 1;\\n *   this.b = 2;\\n * }\\n *\\n * Foo.prototype.c = 3;\\n *\\n * _.keys(new Foo);\\n * // => ['a', 'b'] (iteration order is not guaranteed)\\n *\\n * _.keys('hi');\\n * // => ['0', '1']\\n */\\nvar keys = !nativeKeys ? shimKeys : function(object) {\\n  var Ctor = object == null ? undefined : object.constructor;\\n  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\\n      (typeof object == 'function' ? support.enumPrototypes : isArrayLike(object))) {\\n    return shimKeys(object);\\n  }\\n  return isObject(object) ? nativeKeys(object) : [];\\n};\\n\\nmodule.exports = keys;\\n\\n},{\\\"../internal/getNative\\\":40,\\\"../internal/isArrayLike\\\":41,\\\"../internal/shimKeys\\\":47,\\\"../lang/isObject\\\":53,\\\"../support\\\":61}],59:[function(require,module,exports){\\nvar arrayEach = require('../internal/arrayEach'),\\n    isArguments = require('../lang/isArguments'),\\n    isArray = require('../lang/isArray'),\\n    isFunction = require('../lang/isFunction'),\\n    isIndex = require('../internal/isIndex'),\\n    isLength = require('../internal/isLength'),\\n    isObject = require('../lang/isObject'),\\n    isString = require('../lang/isString'),\\n    support = require('../support');\\n\\n/** `Object#toString` result references. */\\nvar arrayTag = '[object Array]',\\n    boolTag = '[object Boolean]',\\n    dateTag = '[object Date]',\\n    errorTag = '[object Error]',\\n    funcTag = '[object Function]',\\n    numberTag = '[object Number]',\\n    objectTag = '[object Object]',\\n    regexpTag = '[object RegExp]',\\n    stringTag = '[object String]';\\n\\n/** Used to fix the JScript `[[DontEnum]]` bug. */\\nvar shadowProps = [\\n  'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',\\n  'toLocaleString', 'toString', 'valueOf'\\n];\\n\\n/** Used for native method references. */\\nvar errorProto = Error.prototype,\\n    objectProto = Object.prototype,\\n    stringProto = String.prototype;\\n\\n/** Used to check objects for own properties. */\\nvar hasOwnProperty = objectProto.hasOwnProperty;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objToString = objectProto.toString;\\n\\n/** Used to avoid iterating over non-enumerable properties in IE < 9. */\\nvar nonEnumProps = {};\\nnonEnumProps[arrayTag] = nonEnumProps[dateTag] = nonEnumProps[numberTag] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };\\nnonEnumProps[boolTag] = nonEnumProps[stringTag] = { 'constructor': true, 'toString': true, 'valueOf': true };\\nnonEnumProps[errorTag] = nonEnumProps[funcTag] = nonEnumProps[regexpTag] = { 'constructor': true, 'toString': true };\\nnonEnumProps[objectTag] = { 'constructor': true };\\n\\narrayEach(shadowProps, function(key) {\\n  for (var tag in nonEnumProps) {\\n    if (hasOwnProperty.call(nonEnumProps, tag)) {\\n      var props = nonEnumProps[tag];\\n      props[key] = hasOwnProperty.call(props, key);\\n    }\\n  }\\n});\\n\\n/**\\n * Creates an array of the own and inherited enumerable property names of `object`.\\n *\\n * **Note:** Non-object values are coerced to objects.\\n *\\n * @static\\n * @memberOf _\\n * @category Object\\n * @param {Object} object The object to query.\\n * @returns {Array} Returns the array of property names.\\n * @example\\n *\\n * function Foo() {\\n *   this.a = 1;\\n *   this.b = 2;\\n * }\\n *\\n * Foo.prototype.c = 3;\\n *\\n * _.keysIn(new Foo);\\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\\n */\\nfunction keysIn(object) {\\n  if (object == null) {\\n    return [];\\n  }\\n  if (!isObject(object)) {\\n    object = Object(object);\\n  }\\n  var length = object.length;\\n\\n  length = (length && isLength(length) &&\\n    (isArray(object) || isArguments(object) || isString(object)) && length) || 0;\\n\\n  var Ctor = object.constructor,\\n      index = -1,\\n      proto = (isFunction(Ctor) && Ctor.prototype) || objectProto,\\n      isProto = proto === object,\\n      result = Array(length),\\n      skipIndexes = length > 0,\\n      skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error),\\n      skipProto = support.enumPrototypes && isFunction(object);\\n\\n  while (++index < length) {\\n    result[index] = (index + '');\\n  }\\n  // lodash skips the `constructor` property when it infers it's iterating\\n  // over a `prototype` object because IE < 9 can't set the `[[Enumerable]]`\\n  // attribute of an existing property and the `constructor` property of a\\n  // prototype defaults to non-enumerable.\\n  for (var key in object) {\\n    if (!(skipProto && key == 'prototype') &&\\n        !(skipErrorProps && (key == 'message' || key == 'name')) &&\\n        !(skipIndexes && isIndex(key, length)) &&\\n        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\\n      result.push(key);\\n    }\\n  }\\n  if (support.nonEnumShadows && object !== objectProto) {\\n    var tag = object === stringProto ? stringTag : (object === errorProto ? errorTag : objToString.call(object)),\\n        nonEnums = nonEnumProps[tag] || nonEnumProps[objectTag];\\n\\n    if (tag == objectTag) {\\n      proto = objectProto;\\n    }\\n    length = shadowProps.length;\\n    while (length--) {\\n      key = shadowProps[length];\\n      var nonEnum = nonEnums[key];\\n      if (!(isProto && nonEnum) &&\\n          (nonEnum ? hasOwnProperty.call(object, key) : object[key] !== proto[key])) {\\n        result.push(key);\\n      }\\n    }\\n  }\\n  return result;\\n}\\n\\nmodule.exports = keysIn;\\n\\n},{\\\"../internal/arrayEach\\\":29,\\\"../internal/isIndex\\\":43,\\\"../internal/isLength\\\":45,\\\"../lang/isArguments\\\":49,\\\"../lang/isArray\\\":50,\\\"../lang/isFunction\\\":51,\\\"../lang/isObject\\\":53,\\\"../lang/isString\\\":55,\\\"../support\\\":61}],60:[function(require,module,exports){\\nvar baseMerge = require('../internal/baseMerge'),\\n    createAssigner = require('../internal/createAssigner');\\n\\n/**\\n * Recursively merges own enumerable properties of the source object(s), that\\n * don't resolve to `undefined` into the destination object. Subsequent sources\\n * overwrite property assignments of previous sources. If `customizer` is\\n * provided it's invoked to produce the merged values of the destination and\\n * source properties. If `customizer` returns `undefined` merging is handled\\n * by the method instead. The `customizer` is bound to `thisArg` and invoked\\n * with five arguments: (objectValue, sourceValue, key, object, source).\\n *\\n * @static\\n * @memberOf _\\n * @category Object\\n * @param {Object} object The destination object.\\n * @param {...Object} [sources] The source objects.\\n * @param {Function} [customizer] The function to customize assigned values.\\n * @param {*} [thisArg] The `this` binding of `customizer`.\\n * @returns {Object} Returns `object`.\\n * @example\\n *\\n * var users = {\\n *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]\\n * };\\n *\\n * var ages = {\\n *   'data': [{ 'age': 36 }, { 'age': 40 }]\\n * };\\n *\\n * _.merge(users, ages);\\n * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }\\n *\\n * // using a customizer callback\\n * var object = {\\n *   'fruits': ['apple'],\\n *   'vegetables': ['beet']\\n * };\\n *\\n * var other = {\\n *   'fruits': ['banana'],\\n *   'vegetables': ['carrot']\\n * };\\n *\\n * _.merge(object, other, function(a, b) {\\n *   if (_.isArray(a)) {\\n *     return a.concat(b);\\n *   }\\n * });\\n * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }\\n */\\nvar merge = createAssigner(baseMerge);\\n\\nmodule.exports = merge;\\n\\n},{\\\"../internal/baseMerge\\\":33,\\\"../internal/createAssigner\\\":37}],61:[function(require,module,exports){\\n/** Used for native method references. */\\nvar arrayProto = Array.prototype,\\n    errorProto = Error.prototype,\\n    objectProto = Object.prototype;\\n\\n/** Native method references. */\\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable,\\n    splice = arrayProto.splice;\\n\\n/**\\n * An object environment feature flags.\\n *\\n * @static\\n * @memberOf _\\n * @type Object\\n */\\nvar support = {};\\n\\n(function(x) {\\n  var Ctor = function() { this.x = x; },\\n      object = { '0': x, 'length': x },\\n      props = [];\\n\\n  Ctor.prototype = { 'valueOf': x, 'y': x };\\n  for (var key in new Ctor) { props.push(key); }\\n\\n  /**\\n   * Detect if `name` or `message` properties of `Error.prototype` are\\n   * enumerable by default (IE < 9, Safari < 5.1).\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') ||\\n    propertyIsEnumerable.call(errorProto, 'name');\\n\\n  /**\\n   * Detect if `prototype` properties are enumerable by default.\\n   *\\n   * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1\\n   * (if the prototype or a property on the prototype has been set)\\n   * incorrectly set the `[[Enumerable]]` value of a function's `prototype`\\n   * property to `true`.\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.enumPrototypes = propertyIsEnumerable.call(Ctor, 'prototype');\\n\\n  /**\\n   * Detect if properties shadowing those on `Object.prototype` are non-enumerable.\\n   *\\n   * In IE < 9 an object's own properties, shadowing non-enumerable ones,\\n   * are made non-enumerable as well (a.k.a the JScript `[[DontEnum]]` bug).\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.nonEnumShadows = !/valueOf/.test(props);\\n\\n  /**\\n   * Detect if own properties are iterated after inherited properties (IE < 9).\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.ownLast = props[0] != 'x';\\n\\n  /**\\n   * Detect if `Array#shift` and `Array#splice` augment array-like objects\\n   * correctly.\\n   *\\n   * Firefox < 10, compatibility modes of IE 8, and IE < 9 have buggy Array\\n   * `shift()` and `splice()` functions that fail to remove the last element,\\n   * `value[0]`, of array-like objects even though the \\\"length\\\" property is\\n   * set to `0`. The `shift()` method is buggy in compatibility modes of IE 8,\\n   * while `splice()` is buggy regardless of mode in IE < 9.\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.spliceObjects = (splice.call(object, 0, 1), !object[0]);\\n\\n  /**\\n   * Detect lack of support for accessing string characters by index.\\n   *\\n   * IE < 8 can't access characters by index. IE 8 can only access characters\\n   * by index on string literals, not string objects.\\n   *\\n   * @memberOf _.support\\n   * @type boolean\\n   */\\n  support.unindexedChars = ('x'[0] + Object('x')[0]) != 'xx';\\n}(1, 0));\\n\\nmodule.exports = support;\\n\\n},{}],62:[function(require,module,exports){\\n/**\\n * This method returns the first argument provided to it.\\n *\\n * @static\\n * @memberOf _\\n * @category Utility\\n * @param {*} value Any value.\\n * @returns {*} Returns `value`.\\n * @example\\n *\\n * var object = { 'user': 'fred' };\\n *\\n * _.identity(object) === object;\\n * // => true\\n */\\nfunction identity(value) {\\n  return value;\\n}\\n\\nmodule.exports = identity;\\n\\n},{}],63:[function(require,module,exports){\\n/**\\n * @file m3u8/index.js\\n *\\n * Utilities for parsing M3U8 files. If the entire manifest is available,\\n * `Parser` will create an object representation with enough detail for managing\\n * playback. `ParseStream` and `LineStream` are lower-level parsing primitives\\n * that do not assume the entirety of the manifest is ready and expose a\\n * ReadableStream-like interface.\\n */\\n\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _lineStream = require('./line-stream');\\n\\nvar _lineStream2 = _interopRequireDefault(_lineStream);\\n\\nvar _parseStream = require('./parse-stream');\\n\\nvar _parseStream2 = _interopRequireDefault(_parseStream);\\n\\nvar _parser = require('./parser');\\n\\nvar _parser2 = _interopRequireDefault(_parser);\\n\\nexports['default'] = {\\n  LineStream: _lineStream2['default'],\\n  ParseStream: _parseStream2['default'],\\n  Parser: _parser2['default']\\n};\\nmodule.exports = exports['default'];\\n},{\\\"./line-stream\\\":64,\\\"./parse-stream\\\":65,\\\"./parser\\\":66}],64:[function(require,module,exports){\\n/**\\n * @file m3u8/line-stream.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _stream = require('./stream');\\n\\nvar _stream2 = _interopRequireDefault(_stream);\\n\\n/**\\n * A stream that buffers string input and generates a `data` event for each\\n * line.\\n *\\n * @class LineStream\\n * @extends Stream\\n */\\n\\nvar LineStream = (function (_Stream) {\\n  _inherits(LineStream, _Stream);\\n\\n  function LineStream() {\\n    _classCallCheck(this, LineStream);\\n\\n    _get(Object.getPrototypeOf(LineStream.prototype), 'constructor', this).call(this);\\n    this.buffer = '';\\n  }\\n\\n  /**\\n   * Add new data to be parsed.\\n   *\\n   * @param {String} data the text to process\\n   */\\n\\n  _createClass(LineStream, [{\\n    key: 'push',\\n    value: function push(data) {\\n      var nextNewline = undefined;\\n\\n      this.buffer += data;\\n      nextNewline = this.buffer.indexOf('\\\\n');\\n\\n      for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\\\\n')) {\\n        this.trigger('data', this.buffer.substring(0, nextNewline));\\n        this.buffer = this.buffer.substring(nextNewline + 1);\\n      }\\n    }\\n  }]);\\n\\n  return LineStream;\\n})(_stream2['default']);\\n\\nexports['default'] = LineStream;\\nmodule.exports = exports['default'];\\n},{\\\"./stream\\\":67}],65:[function(require,module,exports){\\n/**\\n * @file m3u8/parse-stream.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _stream = require('./stream');\\n\\nvar _stream2 = _interopRequireDefault(_stream);\\n\\n/**\\n * \\\"forgiving\\\" attribute list psuedo-grammar:\\n * attributes -> keyvalue (',' keyvalue)*\\n * keyvalue   -> key '=' value\\n * key        -> [^=]*\\n * value      -> '\\\"' [^\\\"]* '\\\"' | [^,]*\\n */\\nvar attributeSeparator = function attributeSeparator() {\\n  var key = '[^=]*';\\n  var value = '\\\"[^\\\"]*\\\"|[^,]*';\\n  var keyvalue = '(?:' + key + ')=(?:' + value + ')';\\n\\n  return new RegExp('(?:^|,)(' + keyvalue + ')');\\n};\\n\\n/**\\n * Parse attributes from a line given the seperator\\n *\\n * @param {String} attributes the attibute line to parse\\n */\\nvar parseAttributes = function parseAttributes(attributes) {\\n  // split the string using attributes as the separator\\n  var attrs = attributes.split(attributeSeparator());\\n  var i = attrs.length;\\n  var result = {};\\n  var attr = undefined;\\n\\n  while (i--) {\\n    // filter out unmatched portions of the string\\n    if (attrs[i] === '') {\\n      continue;\\n    }\\n\\n    // split the key and value\\n    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1);\\n    // trim whitespace and remove optional quotes around the value\\n    attr[0] = attr[0].replace(/^\\\\s+|\\\\s+$/g, '');\\n    attr[1] = attr[1].replace(/^\\\\s+|\\\\s+$/g, '');\\n    attr[1] = attr[1].replace(/^['\\\"](.*)['\\\"]$/g, '$1');\\n    result[attr[0]] = attr[1];\\n  }\\n  return result;\\n};\\n\\n/**\\n * A line-level M3U8 parser event stream. It expects to receive input one\\n * line at a time and performs a context-free parse of its contents. A stream\\n * interpretation of a manifest can be useful if the manifest is expected to\\n * be too large to fit comfortably into memory or the entirety of the input\\n * is not immediately available. Otherwise, it's probably much easier to work\\n * with a regular `Parser` object.\\n *\\n * Produces `data` events with an object that captures the parser's\\n * interpretation of the input. That object has a property `tag` that is one\\n * of `uri`, `comment`, or `tag`. URIs only have a single additional\\n * property, `line`, which captures the entirety of the input without\\n * interpretation. Comments similarly have a single additional property\\n * `text` which is the input without the leading `#`.\\n *\\n * Tags always have a property `tagType` which is the lower-cased version of\\n * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\\n * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\\n * tags are given the tag type `unknown` and a single additional property\\n * `data` with the remainder of the input.\\n *\\n * @class ParseStream\\n * @extends Stream\\n */\\n\\nvar ParseStream = (function (_Stream) {\\n  _inherits(ParseStream, _Stream);\\n\\n  function ParseStream() {\\n    _classCallCheck(this, ParseStream);\\n\\n    _get(Object.getPrototypeOf(ParseStream.prototype), 'constructor', this).call(this);\\n  }\\n\\n  /**\\n   * Parses an additional line of input.\\n   *\\n   * @param {String} line a single line of an M3U8 file to parse\\n   */\\n\\n  _createClass(ParseStream, [{\\n    key: 'push',\\n    value: function push(line) {\\n      var match = undefined;\\n      var event = undefined;\\n\\n      // strip whitespace\\n      line = line.replace(/^[\\\\u0000\\\\s]+|[\\\\u0000\\\\s]+$/g, '');\\n      if (line.length === 0) {\\n        // ignore empty lines\\n        return;\\n      }\\n\\n      // URIs\\n      if (line[0] !== '#') {\\n        this.trigger('data', {\\n          type: 'uri',\\n          uri: line\\n        });\\n        return;\\n      }\\n\\n      // Comments\\n      if (line.indexOf('#EXT') !== 0) {\\n        this.trigger('data', {\\n          type: 'comment',\\n          text: line.slice(1)\\n        });\\n        return;\\n      }\\n\\n      // strip off any carriage returns here so the regex matching\\n      // doesn't have to account for them.\\n      line = line.replace('\\\\r', '');\\n\\n      // Tags\\n      match = /^#EXTM3U/.exec(line);\\n      if (match) {\\n        this.trigger('data', {\\n          type: 'tag',\\n          tagType: 'm3u'\\n        });\\n        return;\\n      }\\n      match = /^#EXTINF:?([0-9\\\\.]*)?,?(.*)?$/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'inf'\\n        };\\n        if (match[1]) {\\n          event.duration = parseFloat(match[1]);\\n        }\\n        if (match[2]) {\\n          event.title = match[2];\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'targetduration'\\n        };\\n        if (match[1]) {\\n          event.duration = parseInt(match[1], 10);\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#ZEN-TOTAL-DURATION:?([0-9.]*)?/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'totalduration'\\n        };\\n        if (match[1]) {\\n          event.duration = parseInt(match[1], 10);\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'version'\\n        };\\n        if (match[1]) {\\n          event.version = parseInt(match[1], 10);\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-MEDIA-SEQUENCE:?(\\\\-?[0-9.]*)?/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'media-sequence'\\n        };\\n        if (match[1]) {\\n          event.number = parseInt(match[1], 10);\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\\\\-?[0-9.]*)?/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'discontinuity-sequence'\\n        };\\n        if (match[1]) {\\n          event.number = parseInt(match[1], 10);\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'playlist-type'\\n        };\\n        if (match[1]) {\\n          event.playlistType = match[1];\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-BYTERANGE:?([0-9.]*)?@?([0-9.]*)?/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'byterange'\\n        };\\n        if (match[1]) {\\n          event.length = parseInt(match[1], 10);\\n        }\\n        if (match[2]) {\\n          event.offset = parseInt(match[2], 10);\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'allow-cache'\\n        };\\n        if (match[1]) {\\n          event.allowed = !/NO/.test(match[1]);\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-MAP:?(.*)$/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'map'\\n        };\\n\\n        if (match[1]) {\\n          var attributes = parseAttributes(match[1]);\\n\\n          if (attributes.URI) {\\n            event.uri = attributes.URI;\\n          }\\n          if (attributes.BYTERANGE) {\\n            var _attributes$BYTERANGE$split = attributes.BYTERANGE.split('@');\\n\\n            var _attributes$BYTERANGE$split2 = _slicedToArray(_attributes$BYTERANGE$split, 2);\\n\\n            var _length = _attributes$BYTERANGE$split2[0];\\n            var offset = _attributes$BYTERANGE$split2[1];\\n\\n            event.byterange = {};\\n            if (_length) {\\n              event.byterange.length = parseInt(_length, 10);\\n            }\\n            if (offset) {\\n              event.byterange.offset = parseInt(offset, 10);\\n            }\\n          }\\n        }\\n\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-STREAM-INF:?(.*)$/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'stream-inf'\\n        };\\n        if (match[1]) {\\n          event.attributes = parseAttributes(match[1]);\\n\\n          if (event.attributes.RESOLUTION) {\\n            var split = event.attributes.RESOLUTION.split('x');\\n            var resolution = {};\\n\\n            if (split[0]) {\\n              resolution.width = parseInt(split[0], 10);\\n            }\\n            if (split[1]) {\\n              resolution.height = parseInt(split[1], 10);\\n            }\\n            event.attributes.RESOLUTION = resolution;\\n          }\\n          if (event.attributes.BANDWIDTH) {\\n            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\\n          }\\n          if (event.attributes['PROGRAM-ID']) {\\n            event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);\\n          }\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-MEDIA:?(.*)$/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'media'\\n        };\\n        if (match[1]) {\\n          event.attributes = parseAttributes(match[1]);\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-ENDLIST/.exec(line);\\n      if (match) {\\n        this.trigger('data', {\\n          type: 'tag',\\n          tagType: 'endlist'\\n        });\\n        return;\\n      }\\n      match = /^#EXT-X-DISCONTINUITY/.exec(line);\\n      if (match) {\\n        this.trigger('data', {\\n          type: 'tag',\\n          tagType: 'discontinuity'\\n        });\\n        return;\\n      }\\n      match = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'program-date-time'\\n        };\\n        if (match[1]) {\\n          event.dateTimeString = match[1];\\n          event.dateTimeObject = new Date(match[1]);\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-KEY:?(.*)$/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'key'\\n        };\\n        if (match[1]) {\\n          event.attributes = parseAttributes(match[1]);\\n          // parse the IV string into a Uint32Array\\n          if (event.attributes.IV) {\\n            if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {\\n              event.attributes.IV = event.attributes.IV.substring(2);\\n            }\\n\\n            event.attributes.IV = event.attributes.IV.match(/.{8}/g);\\n            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\\n            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\\n            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\\n            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\\n            event.attributes.IV = new Uint32Array(event.attributes.IV);\\n          }\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'cue-out-cont'\\n        };\\n        if (match[1]) {\\n          event.data = match[1];\\n        } else {\\n          event.data = '';\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'cue-out'\\n        };\\n        if (match[1]) {\\n          event.data = match[1];\\n        } else {\\n          event.data = '';\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n      match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(line);\\n      if (match) {\\n        event = {\\n          type: 'tag',\\n          tagType: 'cue-in'\\n        };\\n        if (match[1]) {\\n          event.data = match[1];\\n        } else {\\n          event.data = '';\\n        }\\n        this.trigger('data', event);\\n        return;\\n      }\\n\\n      // unknown tag type\\n      this.trigger('data', {\\n        type: 'tag',\\n        data: line.slice(4)\\n      });\\n    }\\n  }]);\\n\\n  return ParseStream;\\n})(_stream2['default']);\\n\\nexports['default'] = ParseStream;\\nmodule.exports = exports['default'];\\n},{\\\"./stream\\\":67}],66:[function(require,module,exports){\\n/**\\n * @file m3u8/parser.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _stream = require('./stream');\\n\\nvar _stream2 = _interopRequireDefault(_stream);\\n\\nvar _lineStream = require('./line-stream');\\n\\nvar _lineStream2 = _interopRequireDefault(_lineStream);\\n\\nvar _parseStream = require('./parse-stream');\\n\\nvar _parseStream2 = _interopRequireDefault(_parseStream);\\n\\nvar _lodashCompatObjectMerge = require('lodash-compat/object/merge');\\n\\nvar _lodashCompatObjectMerge2 = _interopRequireDefault(_lodashCompatObjectMerge);\\n\\n/**\\n * A parser for M3U8 files. The current interpretation of the input is\\n * exposed as a property `manifest` on parser objects. It's just two lines to\\n * create and parse a manifest once you have the contents available as a string:\\n *\\n * ```js\\n * var parser = new m3u8.Parser();\\n * parser.push(xhr.responseText);\\n * ```\\n *\\n * New input can later be applied to update the manifest object by calling\\n * `push` again.\\n *\\n * The parser attempts to create a usable manifest object even if the\\n * underlying input is somewhat nonsensical. It emits `info` and `warning`\\n * events during the parse if it encounters input that seems invalid or\\n * requires some property of the manifest object to be defaulted.\\n *\\n * @class Parser\\n * @extends Stream\\n */\\n\\nvar Parser = (function (_Stream) {\\n  _inherits(Parser, _Stream);\\n\\n  function Parser() {\\n    _classCallCheck(this, Parser);\\n\\n    _get(Object.getPrototypeOf(Parser.prototype), 'constructor', this).call(this);\\n    this.lineStream = new _lineStream2['default']();\\n    this.parseStream = new _parseStream2['default']();\\n    this.lineStream.pipe(this.parseStream);\\n    /* eslint-disable consistent-this */\\n    var self = this;\\n    /* eslint-enable consistent-this */\\n    var uris = [];\\n    var currentUri = {};\\n    // if specified, the active EXT-X-MAP definition\\n    var currentMap = undefined;\\n    // if specified, the active decryption key\\n    var _key = undefined;\\n    var noop = function noop() {};\\n    var defaultMediaGroups = {\\n      'AUDIO': {},\\n      'VIDEO': {},\\n      'CLOSED-CAPTIONS': {},\\n      'SUBTITLES': {}\\n    };\\n    // group segments into numbered timelines delineated by discontinuities\\n    var currentTimeline = 0;\\n\\n    // the manifest is empty until the parse stream begins delivering data\\n    this.manifest = {\\n      allowCache: true,\\n      discontinuityStarts: []\\n    };\\n\\n    // update the manifest with the m3u8 entry from the parse stream\\n    this.parseStream.on('data', function (entry) {\\n      var mediaGroup = undefined;\\n      var rendition = undefined;\\n\\n      ({\\n        tag: function tag() {\\n          // switch based on the tag type\\n          (({\\n            'allow-cache': function allowCache() {\\n              this.manifest.allowCache = entry.allowed;\\n              if (!('allowed' in entry)) {\\n                this.trigger('info', {\\n                  message: 'defaulting allowCache to YES'\\n                });\\n                this.manifest.allowCache = true;\\n              }\\n            },\\n            byterange: function byterange() {\\n              var byterange = {};\\n\\n              if ('length' in entry) {\\n                currentUri.byterange = byterange;\\n                byterange.length = entry.length;\\n\\n                if (!('offset' in entry)) {\\n                  this.trigger('info', {\\n                    message: 'defaulting offset to zero'\\n                  });\\n                  entry.offset = 0;\\n                }\\n              }\\n              if ('offset' in entry) {\\n                currentUri.byterange = byterange;\\n                byterange.offset = entry.offset;\\n              }\\n            },\\n            endlist: function endlist() {\\n              this.manifest.endList = true;\\n            },\\n            inf: function inf() {\\n              if (!('mediaSequence' in this.manifest)) {\\n                this.manifest.mediaSequence = 0;\\n                this.trigger('info', {\\n                  message: 'defaulting media sequence to zero'\\n                });\\n              }\\n              if (!('discontinuitySequence' in this.manifest)) {\\n                this.manifest.discontinuitySequence = 0;\\n                this.trigger('info', {\\n                  message: 'defaulting discontinuity sequence to zero'\\n                });\\n              }\\n              if (entry.duration > 0) {\\n                currentUri.duration = entry.duration;\\n              }\\n\\n              if (entry.duration === 0) {\\n                currentUri.duration = 0.01;\\n                this.trigger('info', {\\n                  message: 'updating zero segment duration to a small value'\\n                });\\n              }\\n\\n              this.manifest.segments = uris;\\n            },\\n            key: function key() {\\n              if (!entry.attributes) {\\n                this.trigger('warn', {\\n                  message: 'ignoring key declaration without attribute list'\\n                });\\n                return;\\n              }\\n              // clear the active encryption key\\n              if (entry.attributes.METHOD === 'NONE') {\\n                _key = null;\\n                return;\\n              }\\n              if (!entry.attributes.URI) {\\n                this.trigger('warn', {\\n                  message: 'ignoring key declaration without URI'\\n                });\\n                return;\\n              }\\n              if (!entry.attributes.METHOD) {\\n                this.trigger('warn', {\\n                  message: 'defaulting key method to AES-128'\\n                });\\n              }\\n\\n              // setup an encryption key for upcoming segments\\n              _key = {\\n                method: entry.attributes.METHOD || 'AES-128',\\n                uri: entry.attributes.URI\\n              };\\n\\n              if (typeof entry.attributes.IV !== 'undefined') {\\n                _key.iv = entry.attributes.IV;\\n              }\\n            },\\n            'media-sequence': function mediaSequence() {\\n              if (!isFinite(entry.number)) {\\n                this.trigger('warn', {\\n                  message: 'ignoring invalid media sequence: ' + entry.number\\n                });\\n                return;\\n              }\\n              this.manifest.mediaSequence = entry.number;\\n            },\\n            'discontinuity-sequence': function discontinuitySequence() {\\n              if (!isFinite(entry.number)) {\\n                this.trigger('warn', {\\n                  message: 'ignoring invalid discontinuity sequence: ' + entry.number\\n                });\\n                return;\\n              }\\n              this.manifest.discontinuitySequence = entry.number;\\n              currentTimeline = entry.number;\\n            },\\n            'playlist-type': function playlistType() {\\n              if (!/VOD|EVENT/.test(entry.playlistType)) {\\n                this.trigger('warn', {\\n                  message: 'ignoring unknown playlist type: ' + entry.playlist\\n                });\\n                return;\\n              }\\n              this.manifest.playlistType = entry.playlistType;\\n            },\\n            map: function map() {\\n              currentMap = {};\\n              if (entry.uri) {\\n                currentMap.uri = entry.uri;\\n              }\\n              if (entry.byterange) {\\n                currentMap.byterange = entry.byterange;\\n              }\\n            },\\n            'stream-inf': function streamInf() {\\n              this.manifest.playlists = uris;\\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\\n\\n              if (!entry.attributes) {\\n                this.trigger('warn', {\\n                  message: 'ignoring empty stream-inf attributes'\\n                });\\n                return;\\n              }\\n\\n              if (!currentUri.attributes) {\\n                currentUri.attributes = {};\\n              }\\n              currentUri.attributes = (0, _lodashCompatObjectMerge2['default'])(currentUri.attributes, entry.attributes);\\n            },\\n            media: function media() {\\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\\n\\n              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {\\n                this.trigger('warn', {\\n                  message: 'ignoring incomplete or missing media group'\\n                });\\n                return;\\n              }\\n\\n              // find the media group, creating defaults as necessary\\n              var mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\\n\\n              mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};\\n              mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']];\\n\\n              // collect the rendition metadata\\n              rendition = {\\n                'default': /yes/i.test(entry.attributes.DEFAULT)\\n              };\\n              if (rendition['default']) {\\n                rendition.autoselect = true;\\n              } else {\\n                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\\n              }\\n              if (entry.attributes.LANGUAGE) {\\n                rendition.language = entry.attributes.LANGUAGE;\\n              }\\n              if (entry.attributes.URI) {\\n                rendition.uri = entry.attributes.URI;\\n              }\\n              if (entry.attributes['INSTREAM-ID']) {\\n                rendition.instreamId = entry.attributes['INSTREAM-ID'];\\n              }\\n\\n              // insert the new rendition\\n              mediaGroup[entry.attributes.NAME] = rendition;\\n            },\\n            discontinuity: function discontinuity() {\\n              currentTimeline += 1;\\n              currentUri.discontinuity = true;\\n              this.manifest.discontinuityStarts.push(uris.length);\\n            },\\n            'program-date-time': function programDateTime() {\\n              this.manifest.dateTimeString = entry.dateTimeString;\\n              this.manifest.dateTimeObject = entry.dateTimeObject;\\n            },\\n            targetduration: function targetduration() {\\n              if (!isFinite(entry.duration) || entry.duration < 0) {\\n                this.trigger('warn', {\\n                  message: 'ignoring invalid target duration: ' + entry.duration\\n                });\\n                return;\\n              }\\n              this.manifest.targetDuration = entry.duration;\\n            },\\n            totalduration: function totalduration() {\\n              if (!isFinite(entry.duration) || entry.duration < 0) {\\n                this.trigger('warn', {\\n                  message: 'ignoring invalid total duration: ' + entry.duration\\n                });\\n                return;\\n              }\\n              this.manifest.totalDuration = entry.duration;\\n            },\\n            'cue-out': function cueOut() {\\n              currentUri.cueOut = entry.data;\\n            },\\n            'cue-out-cont': function cueOutCont() {\\n              currentUri.cueOutCont = entry.data;\\n            },\\n            'cue-in': function cueIn() {\\n              currentUri.cueIn = entry.data;\\n            }\\n          })[entry.tagType] || noop).call(self);\\n        },\\n        uri: function uri() {\\n          currentUri.uri = entry.uri;\\n          uris.push(currentUri);\\n\\n          // if no explicit duration was declared, use the target duration\\n          if (this.manifest.targetDuration && !('duration' in currentUri)) {\\n            this.trigger('warn', {\\n              message: 'defaulting segment duration to the target duration'\\n            });\\n            currentUri.duration = this.manifest.targetDuration;\\n          }\\n          // annotate with encryption information, if necessary\\n          if (_key) {\\n            currentUri.key = _key;\\n          }\\n          currentUri.timeline = currentTimeline;\\n          // annotate with initialization segment information, if necessary\\n          if (currentMap) {\\n            currentUri.map = currentMap;\\n          }\\n\\n          // prepare for the next URI\\n          currentUri = {};\\n        },\\n        comment: function comment() {\\n          // comments are not important for playback\\n        }\\n      })[entry.type].call(self);\\n    });\\n  }\\n\\n  /**\\n   * Parse the input string and update the manifest object.\\n   *\\n   * @param {String} chunk a potentially incomplete portion of the manifest\\n   */\\n\\n  _createClass(Parser, [{\\n    key: 'push',\\n    value: function push(chunk) {\\n      this.lineStream.push(chunk);\\n    }\\n\\n    /**\\n     * Flush any remaining input. This can be handy if the last line of an M3U8\\n     * manifest did not contain a trailing newline but the file has been\\n     * completely received.\\n     */\\n  }, {\\n    key: 'end',\\n    value: function end() {\\n      // flush any buffered input\\n      this.lineStream.push('\\\\n');\\n    }\\n  }]);\\n\\n  return Parser;\\n})(_stream2['default']);\\n\\nexports['default'] = Parser;\\nmodule.exports = exports['default'];\\n},{\\\"./line-stream\\\":64,\\\"./parse-stream\\\":65,\\\"./stream\\\":67,\\\"lodash-compat/object/merge\\\":60}],67:[function(require,module,exports){\\narguments[4][14][0].apply(exports,arguments)\\n},{\\\"dup\\\":14}],68:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file add-text-track-data.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _globalWindow = require('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\n/**\\n * Define properties on a cue for backwards compatability,\\n * but warn the user that the way that they are using it\\n * is depricated and will be removed at a later date.\\n *\\n * @param {Cue} cue the cue to add the properties on\\n * @private\\n */\\nvar deprecateOldCue = function deprecateOldCue(cue) {\\n  Object.defineProperties(cue.frame, {\\n    id: {\\n      get: function get() {\\n        _videoJs2['default'].log.warn('cue.frame.id is deprecated. Use cue.value.key instead.');\\n        return cue.value.key;\\n      }\\n    },\\n    value: {\\n      get: function get() {\\n        _videoJs2['default'].log.warn('cue.frame.value is deprecated. Use cue.value.data instead.');\\n        return cue.value.data;\\n      }\\n    },\\n    privateData: {\\n      get: function get() {\\n        _videoJs2['default'].log.warn('cue.frame.privateData is deprecated. Use cue.value.data instead.');\\n        return cue.value.data;\\n      }\\n    }\\n  });\\n};\\n\\n/**\\n * Add text track data to a source handler given the captions and\\n * metadata from the buffer.\\n *\\n * @param {Object} sourceHandler the flash or virtual source buffer\\n * @param {Array} captionArray an array of caption data\\n * @param {Array} cue an array of meta data\\n * @private\\n */\\nvar addTextTrackData = function addTextTrackData(sourceHandler, captionArray, metadataArray) {\\n  var Cue = _globalWindow2['default'].WebKitDataCue || _globalWindow2['default'].VTTCue;\\n\\n  if (captionArray) {\\n    captionArray.forEach(function (caption) {\\n      this.inbandTextTrack_.addCue(new Cue(caption.startTime + this.timestampOffset, caption.endTime + this.timestampOffset, caption.text));\\n    }, sourceHandler);\\n  }\\n\\n  if (metadataArray) {\\n    metadataArray.forEach(function (metadata) {\\n      var time = metadata.cueTime + this.timestampOffset;\\n\\n      metadata.frames.forEach(function (frame) {\\n        var cue = new Cue(time, time, frame.value || frame.url || frame.data || '');\\n\\n        cue.frame = frame;\\n        cue.value = frame;\\n        deprecateOldCue(cue);\\n        this.metadataTrack_.addCue(cue);\\n      }, this);\\n    }, sourceHandler);\\n  }\\n};\\n\\nexports['default'] = addTextTrackData;\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"global/window\\\":26}],69:[function(require,module,exports){\\n/**\\n * @file codec-utils.js\\n */\\n\\n/**\\n * Check if a codec string refers to an audio codec.\\n *\\n * @param {String} codec codec string to check\\n * @return {Boolean} if this is an audio codec\\n * @private\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\nvar isAudioCodec = function isAudioCodec(codec) {\\n  return (/mp4a\\\\.\\\\d+.\\\\d+/i.test(codec)\\n  );\\n};\\n\\n/**\\n * Check if a codec string refers to a video codec.\\n *\\n * @param {String} codec codec string to check\\n * @return {Boolean} if this is a video codec\\n * @private\\n */\\nvar isVideoCodec = function isVideoCodec(codec) {\\n  return (/avc1\\\\.[\\\\da-f]+/i.test(codec)\\n  );\\n};\\n\\n/**\\n * Parse a content type header into a type and parameters\\n * object\\n *\\n * @param {String} type the content type header\\n * @return {Object} the parsed content-type\\n * @private\\n */\\nvar parseContentType = function parseContentType(type) {\\n  var object = { type: '', parameters: {} };\\n  var parameters = type.trim().split(';');\\n\\n  // first parameter should always be content-type\\n  object.type = parameters.shift().trim();\\n  parameters.forEach(function (parameter) {\\n    var pair = parameter.trim().split('=');\\n\\n    if (pair.length > 1) {\\n      var _name = pair[0].replace(/\\\"/g, '').trim();\\n      var value = pair[1].replace(/\\\"/g, '').trim();\\n\\n      object.parameters[_name] = value;\\n    }\\n  });\\n\\n  return object;\\n};\\n\\nexports['default'] = {\\n  isAudioCodec: isAudioCodec,\\n  parseContentType: parseContentType,\\n  isVideoCodec: isVideoCodec\\n};\\nmodule.exports = exports['default'];\\n},{}],70:[function(require,module,exports){\\n/**\\n * @file create-text-tracks-if-necessary.js\\n */\\n\\n/**\\n * Create text tracks on video.js if they exist on a segment.\\n *\\n * @param {Object} sourceBuffer the VSB or FSB\\n * @param {Object} mediaSource the HTML or Flash media source\\n * @param {Object} segment the segment that may contain the text track\\n * @private\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\nvar createTextTracksIfNecessary = function createTextTracksIfNecessary(sourceBuffer, mediaSource, segment) {\\n  // create an in-band caption track if one is present in the segment\\n  if (segment.captions && segment.captions.length && !sourceBuffer.inbandTextTrack_) {\\n    sourceBuffer.inbandTextTrack_ = mediaSource.player_.addTextTrack('captions', 'cc1');\\n  }\\n\\n  if (segment.metadata && segment.metadata.length && !sourceBuffer.metadataTrack_) {\\n    sourceBuffer.metadataTrack_ = mediaSource.player_.addTextTrack('metadata', 'Timed Metadata');\\n    sourceBuffer.metadataTrack_.inBandMetadataTrackDispatchType = segment.metadata.dispatchType;\\n  }\\n};\\n\\nexports['default'] = createTextTracksIfNecessary;\\nmodule.exports = exports['default'];\\n},{}],71:[function(require,module,exports){\\n/**\\n * @file flash-constants.js\\n */\\n/**\\n * The maximum size in bytes for append operations to the video.js\\n * SWF. Calling through to Flash blocks and can be expensive so\\n * tuning this parameter may improve playback on slower\\n * systems. There are two factors to consider:\\n * - Each interaction with the SWF must be quick or you risk dropping\\n * video frames. To maintain 60fps for the rest of the page, each append\\n * must not  take longer than 16ms. Given the likelihood that the page\\n * will be executing more javascript than just playback, you probably\\n * want to aim for less than 8ms. We aim for just 4ms.\\n * - Bigger appends significantly increase throughput. The total number of\\n * bytes over time delivered to the SWF must exceed the video bitrate or\\n * playback will stall.\\n *\\n * We adaptively tune the size of appends to give the best throughput\\n * possible given the performance of the system. To do that we try to append\\n * as much as possible in TIME_PER_TICK and while tuning the size of appends\\n * dynamically so that we only append about 4-times in that 4ms span.\\n *\\n * The reason we try to keep the number of appends around four is due to\\n * externalities such as Flash load and garbage collection that are highly\\n * variable and having 4 iterations allows us to exit the loop early if\\n * an iteration takes longer than expected.\\n *\\n * @private\\n */\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nvar flashConstants = {\\n  TIME_BETWEEN_TICKS: Math.floor(1000 / 500),\\n  TIME_PER_TICK: Math.floor(1000 / 100),\\n  // 1kb\\n  BYTES_PER_CHUNK: 4 * 1024,\\n  MIN_CHUNK: 4096,\\n  MAX_CHUNK: 4 * 1024 * 1024\\n};\\n\\nexports[\\\"default\\\"] = flashConstants;\\nmodule.exports = exports[\\\"default\\\"];\\n},{}],72:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file flash-media-source.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _globalDocument = require('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\nvar _flashSourceBuffer = require('./flash-source-buffer');\\n\\nvar _flashSourceBuffer2 = _interopRequireDefault(_flashSourceBuffer);\\n\\nvar _flashConstants = require('./flash-constants');\\n\\nvar _flashConstants2 = _interopRequireDefault(_flashConstants);\\n\\nvar _codecUtils = require('./codec-utils');\\n\\n/**\\n * A flash implmentation of HTML MediaSources and a polyfill\\n * for browsers that don't support native or HTML MediaSources..\\n *\\n * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource\\n * @class FlashMediaSource\\n * @extends videojs.EventTarget\\n */\\n\\nvar FlashMediaSource = (function (_videojs$EventTarget) {\\n  _inherits(FlashMediaSource, _videojs$EventTarget);\\n\\n  function FlashMediaSource() {\\n    var _this = this;\\n\\n    _classCallCheck(this, FlashMediaSource);\\n\\n    _get(Object.getPrototypeOf(FlashMediaSource.prototype), 'constructor', this).call(this);\\n    this.sourceBuffers = [];\\n    this.readyState = 'closed';\\n\\n    this.on(['sourceopen', 'webkitsourceopen'], function (event) {\\n      // find the swf where we will push media data\\n      _this.swfObj = _globalDocument2['default'].getElementById(event.swfId);\\n      _this.player_ = (0, _videoJs2['default'])(_this.swfObj.parentNode);\\n      _this.tech_ = _this.swfObj.tech;\\n      _this.readyState = 'open';\\n\\n      _this.tech_.on('seeking', function () {\\n        var i = _this.sourceBuffers.length;\\n\\n        while (i--) {\\n          _this.sourceBuffers[i].abort();\\n        }\\n      });\\n\\n      // trigger load events\\n      if (_this.swfObj) {\\n        _this.swfObj.vjs_load();\\n      }\\n    });\\n  }\\n\\n  /**\\n    * Set or return the presentation duration.\\n    *\\n    * @param {Double} value the duration of the media in seconds\\n    * @param {Double} the current presentation duration\\n    * @link http://www.w3.org/TR/media-source/#widl-MediaSource-duration\\n    */\\n\\n  /**\\n   * We have this function so that the html and flash interfaces\\n   * are the same.\\n   *\\n   * @private\\n   */\\n\\n  _createClass(FlashMediaSource, [{\\n    key: 'addSeekableRange_',\\n    value: function addSeekableRange_() {}\\n    // intentional no-op\\n\\n    /**\\n     * Create a new flash source buffer and add it to our flash media source.\\n     *\\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/addSourceBuffer\\n     * @param {String} type the content-type of the source\\n     * @return {Object} the flash source buffer\\n     */\\n\\n  }, {\\n    key: 'addSourceBuffer',\\n    value: function addSourceBuffer(type) {\\n      var parsedType = (0, _codecUtils.parseContentType)(type);\\n      var sourceBuffer = undefined;\\n\\n      // if this is an FLV type, we'll push data to flash\\n      if (parsedType.type === 'video/mp2t') {\\n        // Flash source buffers\\n        sourceBuffer = new _flashSourceBuffer2['default'](this);\\n      } else {\\n        throw new Error('NotSupportedError (Video.js)');\\n      }\\n\\n      this.sourceBuffers.push(sourceBuffer);\\n      return sourceBuffer;\\n    }\\n\\n    /**\\n     * Signals the end of the stream.\\n     *\\n     * @link https://w3c.github.io/media-source/#widl-MediaSource-endOfStream-void-EndOfStreamError-error\\n     * @param {String=} error Signals that a playback error\\n     * has occurred. If specified, it must be either \\\"network\\\" or\\n     * \\\"decode\\\".\\n     */\\n  }, {\\n    key: 'endOfStream',\\n    value: function endOfStream(error) {\\n      if (error === 'network') {\\n        // MEDIA_ERR_NETWORK\\n        this.tech_.error(2);\\n      } else if (error === 'decode') {\\n        // MEDIA_ERR_DECODE\\n        this.tech_.error(3);\\n      }\\n      if (this.readyState !== 'ended') {\\n        this.readyState = 'ended';\\n        this.swfObj.vjs_endOfStream();\\n      }\\n    }\\n  }]);\\n\\n  return FlashMediaSource;\\n})(_videoJs2['default'].EventTarget);\\n\\nexports['default'] = FlashMediaSource;\\ntry {\\n  Object.defineProperty(FlashMediaSource.prototype, 'duration', {\\n    /**\\n     * Return the presentation duration.\\n     *\\n     * @return {Double} the duration of the media in seconds\\n     * @link http://www.w3.org/TR/media-source/#widl-MediaSource-duration\\n     */\\n    get: function get() {\\n      if (!this.swfObj) {\\n        return NaN;\\n      }\\n      // get the current duration from the SWF\\n      return this.swfObj.vjs_getProperty('duration');\\n    },\\n    /**\\n     * Set the presentation duration.\\n     *\\n     * @param {Double} value the duration of the media in seconds\\n     * @return {Double} the duration of the media in seconds\\n     * @link http://www.w3.org/TR/media-source/#widl-MediaSource-duration\\n     */\\n    set: function set(value) {\\n      var i = undefined;\\n      var oldDuration = this.swfObj.vjs_getProperty('duration');\\n\\n      this.swfObj.vjs_setProperty('duration', value);\\n\\n      if (value < oldDuration) {\\n        // In MSE, this triggers the range removal algorithm which causes\\n        // an update to occur\\n        for (i = 0; i < this.sourceBuffers.length; i++) {\\n          this.sourceBuffers[i].remove(value, oldDuration);\\n        }\\n      }\\n\\n      return value;\\n    }\\n  });\\n} catch (e) {\\n  // IE8 throws if defineProperty is called on a non-DOM node. We\\n  // don't support IE8 but we shouldn't throw an error if loaded\\n  // there.\\n  FlashMediaSource.prototype.duration = NaN;\\n}\\n\\nfor (var property in _flashConstants2['default']) {\\n  FlashMediaSource[property] = _flashConstants2['default'][property];\\n}\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./codec-utils\\\":69,\\\"./flash-constants\\\":71,\\\"./flash-source-buffer\\\":73,\\\"global/document\\\":25}],73:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file flash-source-buffer.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _globalWindow = require('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\nvar _muxJsLibFlv = require('mux.js/lib/flv');\\n\\nvar _muxJsLibFlv2 = _interopRequireDefault(_muxJsLibFlv);\\n\\nvar _removeCuesFromTrack = require('./remove-cues-from-track');\\n\\nvar _removeCuesFromTrack2 = _interopRequireDefault(_removeCuesFromTrack);\\n\\nvar _createTextTracksIfNecessary = require('./create-text-tracks-if-necessary');\\n\\nvar _createTextTracksIfNecessary2 = _interopRequireDefault(_createTextTracksIfNecessary);\\n\\nvar _addTextTrackData = require('./add-text-track-data');\\n\\nvar _addTextTrackData2 = _interopRequireDefault(_addTextTrackData);\\n\\nvar _flashConstants = require('./flash-constants');\\n\\nvar _flashConstants2 = _interopRequireDefault(_flashConstants);\\n\\n/**\\n * A wrapper around the setTimeout function that uses\\n * the flash constant time between ticks value.\\n *\\n * @param {Function} func the function callback to run\\n * @private\\n */\\nvar scheduleTick = function scheduleTick(func) {\\n  // Chrome doesn't invoke requestAnimationFrame callbacks\\n  // in background tabs, so use setTimeout.\\n  _globalWindow2['default'].setTimeout(func, _flashConstants2['default'].TIME_BETWEEN_TICKS);\\n};\\n\\n/**\\n * Round a number to a specified number of places much like\\n * toFixed but return a number instead of a string representation.\\n *\\n * @param {Number} num A number\\n * @param {Number} places The number of decimal places which to\\n * round\\n * @private\\n */\\nvar toDecimalPlaces = function toDecimalPlaces(num, places) {\\n  if (typeof places !== 'number' || places < 0) {\\n    places = 0;\\n  }\\n\\n  var scale = Math.pow(10, places);\\n\\n  return Math.round(num * scale) / scale;\\n};\\n\\n/**\\n * A SourceBuffer implementation for Flash rather than HTML.\\n *\\n * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource\\n * @param {Object} mediaSource the flash media source\\n * @class FlashSourceBuffer\\n * @extends videojs.EventTarget\\n */\\n\\nvar FlashSourceBuffer = (function (_videojs$EventTarget) {\\n  _inherits(FlashSourceBuffer, _videojs$EventTarget);\\n\\n  function FlashSourceBuffer(mediaSource) {\\n    var _this = this;\\n\\n    _classCallCheck(this, FlashSourceBuffer);\\n\\n    _get(Object.getPrototypeOf(FlashSourceBuffer.prototype), 'constructor', this).call(this);\\n    var encodedHeader = undefined;\\n\\n    // Start off using the globally defined value but refine\\n    // as we append data into flash\\n    this.chunkSize_ = _flashConstants2['default'].BYTES_PER_CHUNK;\\n\\n    // byte arrays queued to be appended\\n    this.buffer_ = [];\\n\\n    // the total number of queued bytes\\n    this.bufferSize_ = 0;\\n\\n    // to be able to determine the correct position to seek to, we\\n    // need to retain information about the mapping between the\\n    // media timeline and PTS values\\n    this.basePtsOffset_ = NaN;\\n\\n    this.mediaSource = mediaSource;\\n\\n    // indicates whether the asynchronous continuation of an operation\\n    // is still being processed\\n    // see https://w3c.github.io/media-source/#widl-SourceBuffer-updating\\n    this.updating = false;\\n    this.timestampOffset_ = 0;\\n\\n    // TS to FLV transmuxer\\n    this.segmentParser_ = new _muxJsLibFlv2['default'].Transmuxer();\\n    this.segmentParser_.on('data', this.receiveBuffer_.bind(this));\\n    encodedHeader = _globalWindow2['default'].btoa(String.fromCharCode.apply(null, Array.prototype.slice.call(this.segmentParser_.getFlvHeader())));\\n    this.mediaSource.swfObj.vjs_appendBuffer(encodedHeader);\\n\\n    this.one('updateend', function () {\\n      _this.mediaSource.tech_.trigger('loadedmetadata');\\n    });\\n\\n    Object.defineProperty(this, 'timestampOffset', {\\n      get: function get() {\\n        return this.timestampOffset_;\\n      },\\n      set: function set(val) {\\n        if (typeof val === 'number' && val >= 0) {\\n          this.timestampOffset_ = val;\\n          this.segmentParser_ = new _muxJsLibFlv2['default'].Transmuxer();\\n          this.segmentParser_.on('data', this.receiveBuffer_.bind(this));\\n          // We have to tell flash to expect a discontinuity\\n          this.mediaSource.swfObj.vjs_discontinuity();\\n          // the media <-> PTS mapping must be re-established after\\n          // the discontinuity\\n          this.basePtsOffset_ = NaN;\\n        }\\n      }\\n    });\\n\\n    Object.defineProperty(this, 'buffered', {\\n      get: function get() {\\n        if (!this.mediaSource || !this.mediaSource.swfObj || !('vjs_getProperty' in this.mediaSource.swfObj)) {\\n          return _videoJs2['default'].createTimeRange();\\n        }\\n\\n        var buffered = this.mediaSource.swfObj.vjs_getProperty('buffered');\\n\\n        if (buffered && buffered.length) {\\n          buffered[0][0] = toDecimalPlaces(buffered[0][0], 3);\\n          buffered[0][1] = toDecimalPlaces(buffered[0][1], 3);\\n        }\\n        return _videoJs2['default'].createTimeRanges(buffered);\\n      }\\n    });\\n\\n    // On a seek we remove all text track data since flash has no concept\\n    // of a buffered-range and everything else is reset on seek\\n    this.mediaSource.player_.on('seeked', function () {\\n      (0, _removeCuesFromTrack2['default'])(0, Infinity, _this.metadataTrack_);\\n      (0, _removeCuesFromTrack2['default'])(0, Infinity, _this.inbandTextTrack_);\\n    });\\n  }\\n\\n  /**\\n   * Append bytes to the sourcebuffers buffer, in this case we\\n   * have to append it to swf object.\\n   *\\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/appendBuffer\\n   * @param {Array} bytes\\n   */\\n\\n  _createClass(FlashSourceBuffer, [{\\n    key: 'appendBuffer',\\n    value: function appendBuffer(bytes) {\\n      var _this2 = this;\\n\\n      var error = undefined;\\n      var chunk = 512 * 1024;\\n      var i = 0;\\n\\n      if (this.updating) {\\n        error = new Error('SourceBuffer.append() cannot be called ' + 'while an update is in progress');\\n        error.name = 'InvalidStateError';\\n        error.code = 11;\\n        throw error;\\n      }\\n\\n      this.updating = true;\\n      this.mediaSource.readyState = 'open';\\n      this.trigger({ type: 'update' });\\n\\n      // this is here to use recursion\\n      var chunkInData = function chunkInData() {\\n        _this2.segmentParser_.push(bytes.subarray(i, i + chunk));\\n        i += chunk;\\n        if (i < bytes.byteLength) {\\n          scheduleTick(chunkInData);\\n        } else {\\n          scheduleTick(_this2.segmentParser_.flush.bind(_this2.segmentParser_));\\n        }\\n      };\\n\\n      chunkInData();\\n    }\\n\\n    /**\\n     * Reset the parser and remove any data queued to be sent to the SWF.\\n     *\\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/abort\\n     */\\n  }, {\\n    key: 'abort',\\n    value: function abort() {\\n      this.buffer_ = [];\\n      this.bufferSize_ = 0;\\n      this.mediaSource.swfObj.vjs_abort();\\n\\n      // report any outstanding updates have ended\\n      if (this.updating) {\\n        this.updating = false;\\n        this.trigger({ type: 'updateend' });\\n      }\\n    }\\n\\n    /**\\n     * Flash cannot remove ranges already buffered in the NetStream\\n     * but seeking clears the buffer entirely. For most purposes,\\n     * having this operation act as a no-op is acceptable.\\n     *\\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/remove\\n     * @param {Double} start start of the section to remove\\n     * @param {Double} end end of the section to remove\\n     */\\n  }, {\\n    key: 'remove',\\n    value: function remove(start, end) {\\n      (0, _removeCuesFromTrack2['default'])(start, end, this.metadataTrack_);\\n      (0, _removeCuesFromTrack2['default'])(start, end, this.inbandTextTrack_);\\n      this.trigger({ type: 'update' });\\n      this.trigger({ type: 'updateend' });\\n    }\\n\\n    /**\\n     * Receive a buffer from the flv.\\n     *\\n     * @param {Object} segment\\n     * @private\\n     */\\n  }, {\\n    key: 'receiveBuffer_',\\n    value: function receiveBuffer_(segment) {\\n      var _this3 = this;\\n\\n      // create an in-band caption track if one is present in the segment\\n      (0, _createTextTracksIfNecessary2['default'])(this, this.mediaSource, segment);\\n      (0, _addTextTrackData2['default'])(this, segment.captions, segment.metadata);\\n\\n      // Do this asynchronously since convertTagsToData_ can be time consuming\\n      scheduleTick(function () {\\n        var flvBytes = _this3.convertTagsToData_(segment);\\n\\n        if (_this3.buffer_.length === 0) {\\n          scheduleTick(_this3.processBuffer_.bind(_this3));\\n        }\\n\\n        if (flvBytes) {\\n          _this3.buffer_.push(flvBytes);\\n          _this3.bufferSize_ += flvBytes.byteLength;\\n        }\\n      });\\n    }\\n\\n    /**\\n     * Append a portion of the current buffer to the SWF.\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'processBuffer_',\\n    value: function processBuffer_() {\\n      var chunk = undefined;\\n      var i = undefined;\\n      var length = undefined;\\n      var binary = undefined;\\n      var b64str = undefined;\\n      var startByte = 0;\\n      var appendIterations = 0;\\n      var startTime = +new Date();\\n      var appendTime = undefined;\\n\\n      if (!this.buffer_.length) {\\n        if (this.updating !== false) {\\n          this.updating = false;\\n          this.trigger({ type: 'updateend' });\\n        }\\n        // do nothing if the buffer is empty\\n        return;\\n      }\\n\\n      do {\\n        appendIterations++;\\n        // concatenate appends up to the max append size\\n        chunk = this.buffer_[0].subarray(startByte, startByte + this.chunkSize_);\\n\\n        // requeue any bytes that won't make it this round\\n        if (chunk.byteLength < this.chunkSize_ || this.buffer_[0].byteLength === startByte + this.chunkSize_) {\\n          startByte = 0;\\n          this.buffer_.shift();\\n        } else {\\n          startByte += this.chunkSize_;\\n        }\\n\\n        this.bufferSize_ -= chunk.byteLength;\\n\\n        // base64 encode the bytes\\n        binary = '';\\n        length = chunk.byteLength;\\n        for (i = 0; i < length; i++) {\\n          binary += String.fromCharCode(chunk[i]);\\n        }\\n        b64str = _globalWindow2['default'].btoa(binary);\\n\\n        // bypass normal ExternalInterface calls and pass xml directly\\n        // IE can be slow by default\\n        this.mediaSource.swfObj.CallFunction('<invoke name=\\\"vjs_appendBuffer\\\"' + 'returntype=\\\"javascript\\\"><arguments><string>' + b64str + '</string></arguments></invoke>');\\n        appendTime = new Date() - startTime;\\n      } while (this.buffer_.length && appendTime < _flashConstants2['default'].TIME_PER_TICK);\\n\\n      if (this.buffer_.length && startByte) {\\n        this.buffer_[0] = this.buffer_[0].subarray(startByte);\\n      }\\n\\n      if (appendTime >= _flashConstants2['default'].TIME_PER_TICK) {\\n        // We want to target 4 iterations per time-slot so that gives us\\n        // room to adjust to changes in Flash load and other externalities\\n        // such as garbage collection while still maximizing throughput\\n        this.chunkSize_ = Math.floor(this.chunkSize_ * (appendIterations / 4));\\n      }\\n\\n      // We also make sure that the chunk-size doesn't drop below 1KB or\\n      // go above 1MB as a sanity check\\n      this.chunkSize_ = Math.max(_flashConstants2['default'].MIN_CHUNK, Math.min(this.chunkSize_, _flashConstants2['default'].MAX_CHUNK));\\n\\n      // schedule another append if necessary\\n      if (this.bufferSize_ !== 0) {\\n        scheduleTick(this.processBuffer_.bind(this));\\n      } else {\\n        this.updating = false;\\n        this.trigger({ type: 'updateend' });\\n      }\\n    }\\n\\n    /**\\n     * Turns an array of flv tags into a Uint8Array representing the\\n     * flv data. Also removes any tags that are before the current\\n     * time so that playback begins at or slightly after the right\\n     * place on a seek\\n     *\\n     * @private\\n     * @param {Object} segmentData object of segment data\\n     */\\n  }, {\\n    key: 'convertTagsToData_',\\n    value: function convertTagsToData_(segmentData) {\\n      var segmentByteLength = 0;\\n      var tech = this.mediaSource.tech_;\\n      var targetPts = 0;\\n      var i = undefined;\\n      var j = undefined;\\n      var segment = undefined;\\n      var filteredTags = [];\\n      var tags = this.getOrderedTags_(segmentData);\\n\\n      // Establish the media timeline to PTS translation if we don't\\n      // have one already\\n      if (isNaN(this.basePtsOffset_) && tags.length) {\\n        this.basePtsOffset_ = tags[0].pts;\\n      }\\n\\n      // Trim any tags that are before the end of the end of\\n      // the current buffer\\n      if (tech.buffered().length) {\\n        targetPts = tech.buffered().end(0) - this.timestampOffset;\\n      }\\n      // Trim to currentTime if it's ahead of buffered or buffered doesn't exist\\n      targetPts = Math.max(targetPts, tech.currentTime() - this.timestampOffset);\\n\\n      // PTS values are represented in milliseconds\\n      targetPts *= 1e3;\\n      targetPts += this.basePtsOffset_;\\n\\n      // skip tags with a presentation time less than the seek target\\n      for (i = 0; i < tags.length; i++) {\\n        if (tags[i].pts >= targetPts) {\\n          filteredTags.push(tags[i]);\\n        }\\n      }\\n\\n      if (filteredTags.length === 0) {\\n        return;\\n      }\\n\\n      // concatenate the bytes into a single segment\\n      for (i = 0; i < filteredTags.length; i++) {\\n        segmentByteLength += filteredTags[i].bytes.byteLength;\\n      }\\n      segment = new Uint8Array(segmentByteLength);\\n      for (i = 0, j = 0; i < filteredTags.length; i++) {\\n        segment.set(filteredTags[i].bytes, j);\\n        j += filteredTags[i].bytes.byteLength;\\n      }\\n\\n      return segment;\\n    }\\n\\n    /**\\n     * Assemble the FLV tags in decoder order.\\n     *\\n     * @private\\n     * @param {Object} segmentData object of segment data\\n     */\\n  }, {\\n    key: 'getOrderedTags_',\\n    value: function getOrderedTags_(segmentData) {\\n      var videoTags = segmentData.tags.videoTags;\\n      var audioTags = segmentData.tags.audioTags;\\n      var tag = undefined;\\n      var tags = [];\\n\\n      while (videoTags.length || audioTags.length) {\\n        if (!videoTags.length) {\\n          // only audio tags remain\\n          tag = audioTags.shift();\\n        } else if (!audioTags.length) {\\n          // only video tags remain\\n          tag = videoTags.shift();\\n        } else if (audioTags[0].dts < videoTags[0].dts) {\\n          // audio should be decoded next\\n          tag = audioTags.shift();\\n        } else {\\n          // video should be decoded next\\n          tag = videoTags.shift();\\n        }\\n\\n        tags.push(tag.finalize());\\n      }\\n\\n      return tags;\\n    }\\n  }]);\\n\\n  return FlashSourceBuffer;\\n})(_videoJs2['default'].EventTarget);\\n\\nexports['default'] = FlashSourceBuffer;\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./add-text-track-data\\\":68,\\\"./create-text-tracks-if-necessary\\\":70,\\\"./flash-constants\\\":71,\\\"./remove-cues-from-track\\\":75,\\\"global/window\\\":26,\\\"mux.js/lib/flv\\\":83}],74:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file html-media-source.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _globalWindow = require('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _globalDocument = require('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\nvar _virtualSourceBuffer = require('./virtual-source-buffer');\\n\\nvar _virtualSourceBuffer2 = _interopRequireDefault(_virtualSourceBuffer);\\n\\nvar _codecUtils = require('./codec-utils');\\n\\n/**\\n * Replace the old apple-style `avc1.<dd>.<dd>` codec string with the standard\\n * `avc1.<hhhhhh>`\\n *\\n * @param {Array} codecs an array of codec strings to fix\\n * @return {Array} the translated codec array\\n * @private\\n */\\nvar translateLegacyCodecs = function translateLegacyCodecs(codecs) {\\n  return codecs.map(function (codec) {\\n    return codec.replace(/avc1\\\\.(\\\\d+)\\\\.(\\\\d+)/i, function (orig, profile, avcLevel) {\\n      var profileHex = ('00' + Number(profile).toString(16)).slice(-2);\\n      var avcLevelHex = ('00' + Number(avcLevel).toString(16)).slice(-2);\\n\\n      return 'avc1.' + profileHex + '00' + avcLevelHex;\\n    });\\n  });\\n};\\n\\n/**\\n * Our MediaSource implementation in HTML, mimics native\\n * MediaSource where/if possible.\\n *\\n * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource\\n * @class HtmlMediaSource\\n * @extends videojs.EventTarget\\n */\\n\\nvar HtmlMediaSource = (function (_videojs$EventTarget) {\\n  _inherits(HtmlMediaSource, _videojs$EventTarget);\\n\\n  function HtmlMediaSource() {\\n    var _this = this;\\n\\n    _classCallCheck(this, HtmlMediaSource);\\n\\n    _get(Object.getPrototypeOf(HtmlMediaSource.prototype), 'constructor', this).call(this);\\n    var property = undefined;\\n\\n    this.nativeMediaSource_ = new _globalWindow2['default'].MediaSource();\\n    // delegate to the native MediaSource's methods by default\\n    for (property in this.nativeMediaSource_) {\\n      if (!(property in HtmlMediaSource.prototype) && typeof this.nativeMediaSource_[property] === 'function') {\\n        this[property] = this.nativeMediaSource_[property].bind(this.nativeMediaSource_);\\n      }\\n    }\\n\\n    // emulate `duration` and `seekable` until seeking can be\\n    // handled uniformly for live streams\\n    // see https://github.com/w3c/media-source/issues/5\\n    this.duration_ = NaN;\\n    Object.defineProperty(this, 'duration', {\\n      get: function get() {\\n        if (this.duration_ === Infinity) {\\n          return this.duration_;\\n        }\\n        return this.nativeMediaSource_.duration;\\n      },\\n      set: function set(duration) {\\n        this.duration_ = duration;\\n        if (duration !== Infinity) {\\n          this.nativeMediaSource_.duration = duration;\\n          return;\\n        }\\n      }\\n    });\\n    Object.defineProperty(this, 'seekable', {\\n      get: function get() {\\n        if (this.duration_ === Infinity) {\\n          return _videoJs2['default'].createTimeRanges([[0, this.nativeMediaSource_.duration]]);\\n        }\\n        return this.nativeMediaSource_.seekable;\\n      }\\n    });\\n\\n    Object.defineProperty(this, 'readyState', {\\n      get: function get() {\\n        return this.nativeMediaSource_.readyState;\\n      }\\n    });\\n\\n    Object.defineProperty(this, 'activeSourceBuffers', {\\n      get: function get() {\\n        return this.activeSourceBuffers_;\\n      }\\n    });\\n\\n    // the list of virtual and native SourceBuffers created by this\\n    // MediaSource\\n    this.sourceBuffers = [];\\n\\n    this.activeSourceBuffers_ = [];\\n\\n    /**\\n     * update the list of active source buffers based upon various\\n     * imformation from HLS and video.js\\n     *\\n     * @private\\n     */\\n    this.updateActiveSourceBuffers_ = function () {\\n      // Retain the reference but empty the array\\n      _this.activeSourceBuffers_.length = 0;\\n\\n      // By default, the audio in the combined virtual source buffer is enabled\\n      // and the audio-only source buffer (if it exists) is disabled.\\n      var combined = false;\\n      var audioOnly = true;\\n\\n      // TODO: maybe we can store the sourcebuffers on the track objects?\\n      // safari may do something like this\\n      for (var i = 0; i < _this.player_.audioTracks().length; i++) {\\n        var track = _this.player_.audioTracks()[i];\\n\\n        if (track.enabled && track.kind !== 'main') {\\n          // The enabled track is an alternate audio track so disable the audio in\\n          // the combined source buffer and enable the audio-only source buffer.\\n          combined = true;\\n          audioOnly = false;\\n          break;\\n        }\\n      }\\n\\n      // Since we currently support a max of two source buffers, add all of the source\\n      // buffers (in order).\\n      _this.sourceBuffers.forEach(function (sourceBuffer) {\\n        /* eslinst-disable */\\n        // TODO once codecs are required, we can switch to using the codecs to determine\\n        //      what stream is the video stream, rather than relying on videoTracks\\n        /* eslinst-enable */\\n\\n        if (sourceBuffer.videoCodec_ && sourceBuffer.audioCodec_) {\\n          // combined\\n          sourceBuffer.audioDisabled_ = combined;\\n        } else if (sourceBuffer.videoCodec_ && !sourceBuffer.audioCodec_) {\\n          // If the \\\"combined\\\" source buffer is video only, then we do not want\\n          // disable the audio-only source buffer (this is mostly for demuxed\\n          // audio and video hls)\\n          sourceBuffer.audioDisabled_ = true;\\n          audioOnly = false;\\n        } else if (!sourceBuffer.videoCodec_ && sourceBuffer.audioCodec_) {\\n          // audio only\\n          sourceBuffer.audioDisabled_ = audioOnly;\\n          if (audioOnly) {\\n            return;\\n          }\\n        }\\n\\n        _this.activeSourceBuffers_.push(sourceBuffer);\\n      });\\n    };\\n\\n    // Re-emit MediaSource events on the polyfill\\n    ['sourceopen', 'sourceclose', 'sourceended'].forEach(function (eventName) {\\n      this.nativeMediaSource_.addEventListener(eventName, this.trigger.bind(this));\\n    }, this);\\n\\n    // capture the associated player when the MediaSource is\\n    // successfully attached\\n    this.on('sourceopen', function (event) {\\n      // Get the player this MediaSource is attached to\\n      var video = _globalDocument2['default'].querySelector('[src=\\\"' + _this.url_ + '\\\"]');\\n\\n      if (!video) {\\n        return;\\n      }\\n\\n      _this.player_ = (0, _videoJs2['default'])(video.parentNode);\\n\\n      if (_this.player_.audioTracks && _this.player_.audioTracks()) {\\n        _this.player_.audioTracks().on('change', _this.updateActiveSourceBuffers_);\\n        _this.player_.audioTracks().on('addtrack', _this.updateActiveSourceBuffers_);\\n        _this.player_.audioTracks().on('removetrack', _this.updateActiveSourceBuffers_);\\n      }\\n    });\\n\\n    // explicitly terminate any WebWorkers that were created\\n    // by SourceHandlers\\n    this.on('sourceclose', function (event) {\\n      this.sourceBuffers.forEach(function (sourceBuffer) {\\n        if (sourceBuffer.transmuxer_) {\\n          sourceBuffer.transmuxer_.terminate();\\n        }\\n      });\\n      this.sourceBuffers.length = 0;\\n      if (!this.player_) {\\n        return;\\n      }\\n\\n      if (this.player_.audioTracks && this.player_.audioTracks()) {\\n        this.player_.audioTracks().off('change', this.updateActiveSourceBuffers_);\\n        this.player_.audioTracks().off('addtrack', this.updateActiveSourceBuffers_);\\n        this.player_.audioTracks().off('removetrack', this.updateActiveSourceBuffers_);\\n      }\\n    });\\n  }\\n\\n  /**\\n   * Add a range that that can now be seeked to.\\n   *\\n   * @param {Double} start where to start the addition\\n   * @param {Double} end where to end the addition\\n   * @private\\n   */\\n\\n  _createClass(HtmlMediaSource, [{\\n    key: 'addSeekableRange_',\\n    value: function addSeekableRange_(start, end) {\\n      var error = undefined;\\n\\n      if (this.duration !== Infinity) {\\n        error = new Error('MediaSource.addSeekableRange() can only be invoked ' + 'when the duration is Infinity');\\n        error.name = 'InvalidStateError';\\n        error.code = 11;\\n        throw error;\\n      }\\n\\n      if (end > this.nativeMediaSource_.duration || isNaN(this.nativeMediaSource_.duration)) {\\n        this.nativeMediaSource_.duration = end;\\n      }\\n    }\\n\\n    /**\\n     * Add a source buffer to the media source.\\n     *\\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/addSourceBuffer\\n     * @param {String} type the content-type of the content\\n     * @return {Object} the created source buffer\\n     */\\n  }, {\\n    key: 'addSourceBuffer',\\n    value: function addSourceBuffer(type) {\\n      var buffer = undefined;\\n      var parsedType = (0, _codecUtils.parseContentType)(type);\\n\\n      // Create a VirtualSourceBuffer to transmux MPEG-2 transport\\n      // stream segments into fragmented MP4s\\n      if (parsedType.type === 'video/mp2t') {\\n        var codecs = [];\\n\\n        if (parsedType.parameters && parsedType.parameters.codecs) {\\n          codecs = parsedType.parameters.codecs.split(',');\\n          codecs = translateLegacyCodecs(codecs);\\n          codecs = codecs.filter(function (codec) {\\n            return (0, _codecUtils.isAudioCodec)(codec) || (0, _codecUtils.isVideoCodec)(codec);\\n          });\\n        }\\n\\n        if (codecs.length === 0) {\\n          codecs = ['avc1.4d400d', 'mp4a.40.2'];\\n        }\\n\\n        buffer = new _virtualSourceBuffer2['default'](this, codecs);\\n\\n        if (this.sourceBuffers.length !== 0) {\\n          // If another VirtualSourceBuffer already exists, then we are creating a\\n          // SourceBuffer for an alternate audio track and therefore we know that\\n          // the source has both an audio and video track.\\n          // That means we should trigger the manual creation of the real\\n          // SourceBuffers instead of waiting for the transmuxer to return data\\n          this.sourceBuffers[0].createRealSourceBuffers_();\\n          buffer.createRealSourceBuffers_();\\n\\n          // Automatically disable the audio on the first source buffer if\\n          // a second source buffer is ever created\\n          this.sourceBuffers[0].audioDisabled_ = true;\\n        }\\n      } else {\\n        // delegate to the native implementation\\n        buffer = this.nativeMediaSource_.addSourceBuffer(type);\\n      }\\n\\n      this.sourceBuffers.push(buffer);\\n      return buffer;\\n    }\\n  }]);\\n\\n  return HtmlMediaSource;\\n})(_videoJs2['default'].EventTarget);\\n\\nexports['default'] = HtmlMediaSource;\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./codec-utils\\\":69,\\\"./virtual-source-buffer\\\":78,\\\"global/document\\\":25,\\\"global/window\\\":26}],75:[function(require,module,exports){\\n/**\\n * @file remove-cues-from-track.js\\n */\\n\\n/**\\n * Remove cues from a track on video.js.\\n *\\n * @param {Double} start start of where we should remove the cue\\n * @param {Double} end end of where the we should remove the cue\\n * @param {Object} track the text track to remove the cues from\\n * @private\\n */\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nvar removeCuesFromTrack = function removeCuesFromTrack(start, end, track) {\\n  var i = undefined;\\n  var cue = undefined;\\n\\n  if (!track) {\\n    return;\\n  }\\n\\n  i = track.cues.length;\\n\\n  while (i--) {\\n    cue = track.cues[i];\\n\\n    // Remove any overlapping cue\\n    if (cue.startTime <= end && cue.endTime >= start) {\\n      track.removeCue(cue);\\n    }\\n  }\\n};\\n\\nexports[\\\"default\\\"] = removeCuesFromTrack;\\nmodule.exports = exports[\\\"default\\\"];\\n},{}],76:[function(require,module,exports){\\n/**\\n * @file transmuxer-worker.js\\n */\\n\\n/**\\n * videojs-contrib-media-sources\\n *\\n * Copyright (c) 2015 Brightcove\\n * All rights reserved.\\n *\\n * Handles communication between the browser-world and the mux.js\\n * transmuxer running inside of a WebWorker by exposing a simple\\n * message-based interface to a Transmuxer object.\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nvar _globalWindow = require('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _muxJsLibMp4 = require('mux.js/lib/mp4');\\n\\nvar _muxJsLibMp42 = _interopRequireDefault(_muxJsLibMp4);\\n\\n/**\\n * Re-emits tranmsuxer events by converting them into messages to the\\n * world outside the worker.\\n *\\n * @param {Object} transmuxer the transmuxer to wire events on\\n * @private\\n */\\nvar wireTransmuxerEvents = function wireTransmuxerEvents(transmuxer) {\\n  transmuxer.on('data', function (segment) {\\n    // transfer ownership of the underlying ArrayBuffer\\n    // instead of doing a copy to save memory\\n    // ArrayBuffers are transferable but generic TypedArrays are not\\n    // @link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers#Passing_data_by_transferring_ownership_(transferable_objects)\\n    var typedArray = segment.data;\\n\\n    segment.data = typedArray.buffer;\\n    _globalWindow2['default'].postMessage({\\n      action: 'data',\\n      segment: segment,\\n      byteOffset: typedArray.byteOffset,\\n      byteLength: typedArray.byteLength\\n    }, [segment.data]);\\n  });\\n\\n  if (transmuxer.captionStream) {\\n    transmuxer.captionStream.on('data', function (caption) {\\n      _globalWindow2['default'].postMessage({\\n        action: 'caption',\\n        data: caption\\n      });\\n    });\\n  }\\n\\n  transmuxer.on('done', function (data) {\\n    _globalWindow2['default'].postMessage({ action: 'done' });\\n  });\\n};\\n\\n/**\\n * All incoming messages route through this hash. If no function exists\\n * to handle an incoming message, then we ignore the message.\\n *\\n * @class MessageHandlers\\n * @param {Object} options the options to initialize with\\n */\\n\\nvar MessageHandlers = (function () {\\n  function MessageHandlers(options) {\\n    _classCallCheck(this, MessageHandlers);\\n\\n    this.options = options || {};\\n    this.init();\\n  }\\n\\n  /**\\n   * Our web wroker interface so that things can talk to mux.js\\n   * that will be running in a web worker. the scope is passed to this by\\n   * webworkify.\\n   *\\n   * @param {Object} self the scope for the web worker\\n   */\\n\\n  /**\\n   * initialize our web worker and wire all the events.\\n   */\\n\\n  _createClass(MessageHandlers, [{\\n    key: 'init',\\n    value: function init() {\\n      if (this.transmuxer) {\\n        this.transmuxer.dispose();\\n      }\\n      this.transmuxer = new _muxJsLibMp42['default'].Transmuxer(this.options);\\n      wireTransmuxerEvents(this.transmuxer);\\n    }\\n\\n    /**\\n     * Adds data (a ts segment) to the start of the transmuxer pipeline for\\n     * processing.\\n     *\\n     * @param {ArrayBuffer} data data to push into the muxer\\n     */\\n  }, {\\n    key: 'push',\\n    value: function push(data) {\\n      // Cast array buffer to correct type for transmuxer\\n      var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);\\n\\n      this.transmuxer.push(segment);\\n    }\\n\\n    /**\\n     * Recreate the transmuxer so that the next segment added via `push`\\n     * start with a fresh transmuxer.\\n     */\\n  }, {\\n    key: 'reset',\\n    value: function reset() {\\n      this.init();\\n    }\\n\\n    /**\\n     * Set the value that will be used as the `baseMediaDecodeTime` time for the\\n     * next segment pushed in. Subsequent segments will have their `baseMediaDecodeTime`\\n     * set relative to the first based on the PTS values.\\n     *\\n     * @param {Object} data used to set the timestamp offset in the muxer\\n     */\\n  }, {\\n    key: 'setTimestampOffset',\\n    value: function setTimestampOffset(data) {\\n      var timestampOffset = data.timestampOffset || 0;\\n\\n      this.transmuxer.setBaseMediaDecodeTime(Math.round(timestampOffset * 90000));\\n    }\\n\\n    /**\\n     * Forces the pipeline to finish processing the last segment and emit it's\\n     * results.\\n     *\\n     * @param {Object} data event data, not really used\\n     */\\n  }, {\\n    key: 'flush',\\n    value: function flush(data) {\\n      this.transmuxer.flush();\\n    }\\n  }]);\\n\\n  return MessageHandlers;\\n})();\\n\\nvar Worker = function Worker(self) {\\n  self.onmessage = function (event) {\\n    if (event.data.action === 'init' && event.data.options) {\\n      this.messageHandlers = new MessageHandlers(event.data.options);\\n      return;\\n    }\\n\\n    if (!this.messageHandlers) {\\n      this.messageHandlers = new MessageHandlers();\\n    }\\n\\n    if (event.data && event.data.action && event.data.action !== 'init') {\\n      if (this.messageHandlers[event.data.action]) {\\n        this.messageHandlers[event.data.action](event.data);\\n      }\\n    }\\n  };\\n};\\n\\nexports['default'] = function (self) {\\n  return new Worker(self);\\n};\\n\\nmodule.exports = exports['default'];\\n},{\\\"global/window\\\":26,\\\"mux.js/lib/mp4\\\":90}],77:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file videojs-contrib-media-sources.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nvar _globalWindow = require('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\nvar _flashMediaSource = require('./flash-media-source');\\n\\nvar _flashMediaSource2 = _interopRequireDefault(_flashMediaSource);\\n\\nvar _htmlMediaSource = require('./html-media-source');\\n\\nvar _htmlMediaSource2 = _interopRequireDefault(_htmlMediaSource);\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\nvar urlCount = 0;\\n\\n// ------------\\n// Media Source\\n// ------------\\n\\nvar defaults = {\\n  // how to determine the MediaSource implementation to use. There\\n  // are three available modes:\\n  // - auto: use native MediaSources where available and Flash\\n  //   everywhere else\\n  // - html5: always use native MediaSources\\n  // - flash: always use the Flash MediaSource polyfill\\n  mode: 'auto'\\n};\\n\\n// lolomo references to the media sources so they can be connected\\n// to a video element (a swf object)\\n// TODO: can we lolomo this somewhere local to this module?\\n_videoJs2['default'].mediaSources = {};\\n\\n/**\\n * Provide a method for a swf object to notify JS that a\\n * media source is now open.\\n *\\n * @param {String} msObjectURL string referencing the MSE Object URL\\n * @param {String} swfId the swf id\\n */\\nvar open = function open(msObjectURL, swfId) {\\n  var mediaSource = _videoJs2['default'].mediaSources[msObjectURL];\\n\\n  if (mediaSource) {\\n    mediaSource.trigger({ type: 'sourceopen', swfId: swfId });\\n  } else {\\n    throw new Error('Media Source not found (Video.js)');\\n  }\\n};\\n\\n/**\\n * Check to see if the native MediaSource object exists and supports\\n * an MP4 container with both H.264 video and AAC-LC audio.\\n *\\n * @return {Boolean} if  native media sources are supported\\n */\\nvar supportsNativeMediaSources = function supportsNativeMediaSources() {\\n  return !!_globalWindow2['default'].MediaSource && !!_globalWindow2['default'].MediaSource.isTypeSupported && _globalWindow2['default'].MediaSource.isTypeSupported('video/mp4;codecs=\\\"avc1.4d400d,mp4a.40.2\\\"');\\n};\\n\\n/**\\n * An emulation of the MediaSource API so that we can support\\n * native and non-native functionality such as flash and\\n * video/mp2t videos. returns an instance of HtmlMediaSource or\\n * FlashMediaSource depending on what is supported and what options\\n * are passed in.\\n *\\n * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/MediaSource\\n * @param {Object} options options to use during setup.\\n */\\nvar MediaSource = function MediaSource(options) {\\n  var settings = _videoJs2['default'].mergeOptions(defaults, options);\\n\\n  this.MediaSource = {\\n    open: open,\\n    supportsNativeMediaSources: supportsNativeMediaSources\\n  };\\n\\n  // determine whether HTML MediaSources should be used\\n  if (settings.mode === 'html5' || settings.mode === 'auto' && supportsNativeMediaSources()) {\\n    return new _htmlMediaSource2['default']();\\n  }\\n\\n  // otherwise, emulate them through the SWF\\n  return new _flashMediaSource2['default']();\\n};\\n\\nexports.MediaSource = MediaSource;\\nMediaSource.open = open;\\nMediaSource.supportsNativeMediaSources = supportsNativeMediaSources;\\n\\n/**\\n * A wrapper around the native URL for our MSE object\\n * implementation, this object is exposed under videojs.URL\\n *\\n * @link https://developer.mozilla.org/en-US/docs/Web/API/URL/URL\\n */\\nvar URL = {\\n  /**\\n   * A wrapper around the native createObjectURL for our objects.\\n   * This function maps a native or emulated mediaSource to a blob\\n   * url so that it can be loaded into video.js\\n   *\\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\\n   * @param {MediaSource} object the object to create a blob url to\\n   */\\n  createObjectURL: function createObjectURL(object) {\\n    var objectUrlPrefix = 'blob:vjs-media-source/';\\n    var url = undefined;\\n\\n    // use the native MediaSource to generate an object URL\\n    if (object instanceof _htmlMediaSource2['default']) {\\n      url = _globalWindow2['default'].URL.createObjectURL(object.nativeMediaSource_);\\n      object.url_ = url;\\n      return url;\\n    }\\n    // if the object isn't an emulated MediaSource, delegate to the\\n    // native implementation\\n    if (!(object instanceof _flashMediaSource2['default'])) {\\n      url = _globalWindow2['default'].URL.createObjectURL(object);\\n      object.url_ = url;\\n      return url;\\n    }\\n\\n    // build a URL that can be used to map back to the emulated\\n    // MediaSource\\n    url = objectUrlPrefix + urlCount;\\n\\n    urlCount++;\\n\\n    // setup the mapping back to object\\n    _videoJs2['default'].mediaSources[url] = object;\\n\\n    return url;\\n  }\\n};\\n\\nexports.URL = URL;\\n_videoJs2['default'].MediaSource = MediaSource;\\n_videoJs2['default'].URL = URL;\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./flash-media-source\\\":72,\\\"./html-media-source\\\":74,\\\"global/window\\\":26}],78:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file virtual-source-buffer.js\\n */\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\nvar _createTextTracksIfNecessary = require('./create-text-tracks-if-necessary');\\n\\nvar _createTextTracksIfNecessary2 = _interopRequireDefault(_createTextTracksIfNecessary);\\n\\nvar _removeCuesFromTrack = require('./remove-cues-from-track');\\n\\nvar _removeCuesFromTrack2 = _interopRequireDefault(_removeCuesFromTrack);\\n\\nvar _addTextTrackData = require('./add-text-track-data');\\n\\nvar _addTextTrackData2 = _interopRequireDefault(_addTextTrackData);\\n\\nvar _webworkify = require('webworkify');\\n\\nvar _webworkify2 = _interopRequireDefault(_webworkify);\\n\\nvar _transmuxerWorker = require('./transmuxer-worker');\\n\\nvar _transmuxerWorker2 = _interopRequireDefault(_transmuxerWorker);\\n\\nvar _codecUtils = require('./codec-utils');\\n\\n/**\\n * VirtualSourceBuffers exist so that we can transmux non native formats\\n * into a native format, but keep the same api as a native source buffer.\\n * It creates a transmuxer, that works in its own thread (a web worker) and\\n * that transmuxer muxes the data into a native format. VirtualSourceBuffer will\\n * then send all of that data to the naive sourcebuffer so that it is\\n * indestinguishable from a natively supported format.\\n *\\n * @param {HtmlMediaSource} mediaSource the parent mediaSource\\n * @param {Array} codecs array of codecs that we will be dealing with\\n * @class VirtualSourceBuffer\\n * @extends video.js.EventTarget\\n */\\n\\nvar VirtualSourceBuffer = (function (_videojs$EventTarget) {\\n  _inherits(VirtualSourceBuffer, _videojs$EventTarget);\\n\\n  function VirtualSourceBuffer(mediaSource, codecs) {\\n    var _this = this;\\n\\n    _classCallCheck(this, VirtualSourceBuffer);\\n\\n    _get(Object.getPrototypeOf(VirtualSourceBuffer.prototype), 'constructor', this).call(this, _videoJs2['default'].EventTarget);\\n    this.timestampOffset_ = 0;\\n    this.pendingBuffers_ = [];\\n    this.bufferUpdating_ = false;\\n    this.mediaSource_ = mediaSource;\\n    this.codecs_ = codecs;\\n    this.audioCodec_ = null;\\n    this.videoCodec_ = null;\\n    this.audioDisabled_ = false;\\n\\n    var options = {\\n      remux: false\\n    };\\n\\n    this.codecs_.forEach(function (codec) {\\n      if ((0, _codecUtils.isAudioCodec)(codec)) {\\n        _this.audioCodec_ = codec;\\n      } else if ((0, _codecUtils.isVideoCodec)(codec)) {\\n        _this.videoCodec_ = codec;\\n      }\\n    });\\n\\n    // append muxed segments to their respective native buffers as\\n    // soon as they are available\\n    this.transmuxer_ = (0, _webworkify2['default'])(_transmuxerWorker2['default']);\\n    this.transmuxer_.postMessage({ action: 'init', options: options });\\n\\n    this.transmuxer_.onmessage = function (event) {\\n      if (event.data.action === 'data') {\\n        return _this.data_(event);\\n      }\\n\\n      if (event.data.action === 'done') {\\n        return _this.done_(event);\\n      }\\n    };\\n\\n    // this timestampOffset is a property with the side-effect of resetting\\n    // baseMediaDecodeTime in the transmuxer on the setter\\n    Object.defineProperty(this, 'timestampOffset', {\\n      get: function get() {\\n        return this.timestampOffset_;\\n      },\\n      set: function set(val) {\\n        if (typeof val === 'number' && val >= 0) {\\n          this.timestampOffset_ = val;\\n\\n          // We have to tell the transmuxer to set the baseMediaDecodeTime to\\n          // the desired timestampOffset for the next segment\\n          this.transmuxer_.postMessage({\\n            action: 'setTimestampOffset',\\n            timestampOffset: val\\n          });\\n        }\\n      }\\n    });\\n\\n    // setting the append window affects both source buffers\\n    Object.defineProperty(this, 'appendWindowStart', {\\n      get: function get() {\\n        return (this.videoBuffer_ || this.audioBuffer_).appendWindowStart;\\n      },\\n      set: function set(start) {\\n        if (this.videoBuffer_) {\\n          this.videoBuffer_.appendWindowStart = start;\\n        }\\n        if (this.audioBuffer_) {\\n          this.audioBuffer_.appendWindowStart = start;\\n        }\\n      }\\n    });\\n\\n    // this buffer is \\\"updating\\\" if either of its native buffers are\\n    Object.defineProperty(this, 'updating', {\\n      get: function get() {\\n        return !!(this.bufferUpdating_ || !this.audioDisabled_ && this.audioBuffer_ && this.audioBuffer_.updating || this.videoBuffer_ && this.videoBuffer_.updating);\\n      }\\n    });\\n\\n    // the buffered property is the intersection of the buffered\\n    // ranges of the native source buffers\\n    Object.defineProperty(this, 'buffered', {\\n      get: function get() {\\n        var start = null;\\n        var end = null;\\n        var arity = 0;\\n        var extents = [];\\n        var ranges = [];\\n\\n        if (!this.videoBuffer_ && (this.audioDisabled_ || !this.audioBuffer_)) {\\n          return _videoJs2['default'].createTimeRange();\\n        }\\n\\n        // Handle the case where we only have one buffer\\n        if (!this.videoBuffer_) {\\n          return this.audioBuffer_.buffered;\\n        } else if (this.audioDisabled_ || !this.audioBuffer_) {\\n          return this.videoBuffer_.buffered;\\n        }\\n\\n        // Handle the case where there is no buffer data\\n        if ((!this.videoBuffer_ || this.videoBuffer_.buffered.length === 0) && (!this.audioBuffer_ || this.audioBuffer_.buffered.length === 0)) {\\n          return _videoJs2['default'].createTimeRange();\\n        }\\n\\n        // Handle the case where we have both buffers and create an\\n        // intersection of the two\\n        var videoBuffered = this.videoBuffer_.buffered;\\n        var audioBuffered = this.audioBuffer_.buffered;\\n        var count = videoBuffered.length;\\n\\n        // A) Gather up all start and end times\\n        while (count--) {\\n          extents.push({ time: videoBuffered.start(count), type: 'start' });\\n          extents.push({ time: videoBuffered.end(count), type: 'end' });\\n        }\\n        count = audioBuffered.length;\\n        while (count--) {\\n          extents.push({ time: audioBuffered.start(count), type: 'start' });\\n          extents.push({ time: audioBuffered.end(count), type: 'end' });\\n        }\\n        // B) Sort them by time\\n        extents.sort(function (a, b) {\\n          return a.time - b.time;\\n        });\\n\\n        // C) Go along one by one incrementing arity for start and decrementing\\n        //    arity for ends\\n        for (count = 0; count < extents.length; count++) {\\n          if (extents[count].type === 'start') {\\n            arity++;\\n\\n            // D) If arity is ever incremented to 2 we are entering an\\n            //    overlapping range\\n            if (arity === 2) {\\n              start = extents[count].time;\\n            }\\n          } else if (extents[count].type === 'end') {\\n            arity--;\\n\\n            // E) If arity is ever decremented to 1 we leaving an\\n            //    overlapping range\\n            if (arity === 1) {\\n              end = extents[count].time;\\n            }\\n          }\\n\\n          // F) Record overlapping ranges\\n          if (start !== null && end !== null) {\\n            ranges.push([start, end]);\\n            start = null;\\n            end = null;\\n          }\\n        }\\n\\n        return _videoJs2['default'].createTimeRanges(ranges);\\n      }\\n    });\\n  }\\n\\n  /**\\n   * When we get a data event from the transmuxer\\n   * we call this function and handle the data that\\n   * was sent to us\\n   *\\n   * @private\\n   * @param {Event} event the data event from the transmuxer\\n   */\\n\\n  _createClass(VirtualSourceBuffer, [{\\n    key: 'data_',\\n    value: function data_(event) {\\n      var segment = event.data.segment;\\n\\n      // Cast ArrayBuffer to TypedArray\\n      segment.data = new Uint8Array(segment.data, event.data.byteOffset, event.data.byteLength);\\n\\n      (0, _createTextTracksIfNecessary2['default'])(this, this.mediaSource_, segment);\\n\\n      // Add the segments to the pendingBuffers array\\n      this.pendingBuffers_.push(segment);\\n      return;\\n    }\\n\\n    /**\\n     * When we get a done event from the transmuxer\\n     * we call this function and we process all\\n     * of the pending data that we have been saving in the\\n     * data_ function\\n     *\\n     * @private\\n     * @param {Event} event the done event from the transmuxer\\n     */\\n  }, {\\n    key: 'done_',\\n    value: function done_(event) {\\n      // All buffers should have been flushed from the muxer\\n      // start processing anything we have received\\n      this.processPendingSegments_();\\n      return;\\n    }\\n\\n    /**\\n     * Create our internal native audio/video source buffers and add\\n     * event handlers to them with the following conditions:\\n     * 1. they do not already exist on the mediaSource\\n     * 2. this VSB has a codec for them\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'createRealSourceBuffers_',\\n    value: function createRealSourceBuffers_() {\\n      var _this2 = this;\\n\\n      var types = ['audio', 'video'];\\n      // XA Default codecs\\n      var defaultCodecs = {\\\"audio\\\": \\\"mp4a.40.2\\\", \\\"video\\\":\\\"avc1.4d400d\\\"};\\n\\n      types.forEach(function (type) {\\n        // Don't create a SourceBuffer of this type if we don't have a\\n        // codec for it\\n        if (!_this2[type + 'Codec_']) {\\n          return;\\n        }\\n\\n        // Do nothing if a SourceBuffer of this type already exists\\n        if (_this2[type + 'Buffer_']) {\\n          return;\\n        }\\n\\n        var buffer = null;\\n\\n        // If the mediasource already has a SourceBuffer for the codec\\n        // use that\\n        if (_this2.mediaSource_[type + 'Buffer_']) {\\n          buffer = _this2.mediaSource_[type + 'Buffer_'];\\n        } else {\\n          try {\\n            buffer = _this2.mediaSource_.nativeMediaSource_.addSourceBuffer(type + '/mp4;codecs=\\\"' + _this2[type + 'Codec_'] + '\\\"');\\n          } catch (e) {\\n            // XA The codec is not supported by the browser\\n            // Replace it by a default codec\\n            var defaultCodec = defaultCodecs[type];\\n            if (defaultCodec != undefined) {\\n              buffer = _this2.mediaSource_.nativeMediaSource_.addSourceBuffer(type + '/mp4;codecs=\\\"' + defaultCodec + '\\\"');\\n              console.log(\\\"Replace unsupported CODEC \\\" +_this2[type + 'Codec_'] +\\\" of type \\\"+ type + \\\" by default CODEC \\\" + defaultCodec);\\n            }\\n          }\\n          _this2.mediaSource_[type + 'Buffer_'] = buffer;\\n        }\\n\\n        _this2[type + 'Buffer_'] = buffer;\\n\\n        // Wire up the events to the SourceBuffer\\n        ['update', 'updatestart', 'updateend'].forEach(function (event) {\\n          buffer.addEventListener(event, function () {\\n            // if audio is disabled\\n            if (type === 'audio' && _this2.audioDisabled_) {\\n              return;\\n            }\\n\\n            var shouldTrigger = types.every(function (t) {\\n              // skip checking audio's updating status if audio\\n              // is not enabled\\n              if (t === 'audio' && _this2.audioDisabled_) {\\n                return true;\\n              }\\n              // if the other type if updating we don't trigger\\n              if (type !== t && _this2[t + 'Buffer_'] && _this2[t + 'Buffer_'].updating) {\\n                return false;\\n              }\\n              return true;\\n            });\\n\\n            if (shouldTrigger) {\\n              return _this2.trigger(event);\\n            }\\n          });\\n        });\\n      });\\n    }\\n\\n    /**\\n     * Emulate the native mediasource function, but our function will\\n     * send all of the proposed segments to the transmuxer so that we\\n     * can transmux them before we append them to our internal\\n     * native source buffers in the correct format.\\n     *\\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/appendBuffer\\n     * @param {Uint8Array} segment the segment to append to the buffer\\n     */\\n  }, {\\n    key: 'appendBuffer',\\n    value: function appendBuffer(segment) {\\n      // Start the internal \\\"updating\\\" state\\n      this.bufferUpdating_ = true;\\n\\n      this.transmuxer_.postMessage({\\n        action: 'push',\\n        // Send the typed-array of data as an ArrayBuffer so that\\n        // it can be sent as a \\\"Transferable\\\" and avoid the costly\\n        // memory copy\\n        data: segment.buffer,\\n\\n        // To recreate the original typed-array, we need information\\n        // about what portion of the ArrayBuffer it was a view into\\n        byteOffset: segment.byteOffset,\\n        byteLength: segment.byteLength\\n      }, [segment.buffer]);\\n      this.transmuxer_.postMessage({ action: 'flush' });\\n    }\\n\\n    /**\\n     * Emulate the native mediasource function and remove parts\\n     * of the buffer from any of our internal buffers that exist\\n     *\\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/remove\\n     * @param {Double} start position to start the remove at\\n     * @param {Double} end position to end the remove at\\n     */\\n  }, {\\n    key: 'remove',\\n    value: function remove(start, end) {\\n      if (this.videoBuffer_) {\\n        this.videoBuffer_.remove(start, end);\\n      }\\n      if (!this.audioDisabled_ && this.audioBuffer_) {\\n        this.audioBuffer_.remove(start, end);\\n      }\\n\\n      // Remove Metadata Cues (id3)\\n      (0, _removeCuesFromTrack2['default'])(start, end, this.metadataTrack_);\\n\\n      // Remove Any Captions\\n      (0, _removeCuesFromTrack2['default'])(start, end, this.inbandTextTrack_);\\n    }\\n\\n    /**\\n     * Process any segments that the muxer has output\\n     * Concatenate segments together based on type and append them into\\n     * their respective sourceBuffers\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'processPendingSegments_',\\n    value: function processPendingSegments_() {\\n      var sortedSegments = {\\n        video: {\\n          segments: [],\\n          bytes: 0\\n        },\\n        audio: {\\n          segments: [],\\n          bytes: 0\\n        },\\n        captions: [],\\n        metadata: []\\n      };\\n\\n      // Sort segments into separate video/audio arrays and\\n      // keep track of their total byte lengths\\n      sortedSegments = this.pendingBuffers_.reduce(function (segmentObj, segment) {\\n        var type = segment.type;\\n        var data = segment.data;\\n\\n        segmentObj[type].segments.push(data);\\n        segmentObj[type].bytes += data.byteLength;\\n\\n        // Gather any captions into a single array\\n        if (segment.captions) {\\n          segmentObj.captions = segmentObj.captions.concat(segment.captions);\\n        }\\n\\n        if (segment.info) {\\n          segmentObj[type].info = segment.info;\\n        }\\n\\n        // Gather any metadata into a single array\\n        if (segment.metadata) {\\n          segmentObj.metadata = segmentObj.metadata.concat(segment.metadata);\\n        }\\n\\n        return segmentObj;\\n      }, sortedSegments);\\n\\n      // Create the real source buffers if they don't exist by now since we\\n      // finally are sure what tracks are contained in the source\\n      if (!this.videoBuffer_ && !this.audioBuffer_) {\\n        // Remove any codecs that may have been specified by default but\\n        // are no longer applicable now\\n        if (sortedSegments.video.bytes === 0) {\\n          this.videoCodec_ = null;\\n        }\\n        if (sortedSegments.audio.bytes === 0) {\\n          this.audioCodec_ = null;\\n        }\\n\\n        this.createRealSourceBuffers_();\\n      }\\n\\n      if (sortedSegments.audio.info) {\\n        this.mediaSource_.trigger({ type: 'audioinfo', info: sortedSegments.audio.info });\\n      }\\n      if (sortedSegments.video.info) {\\n        this.mediaSource_.trigger({ type: 'videoinfo', info: sortedSegments.video.info });\\n      }\\n\\n      // Merge multiple video and audio segments into one and append\\n      if (this.videoBuffer_) {\\n        this.concatAndAppendSegments_(sortedSegments.video, this.videoBuffer_);\\n        // TODO: are video tracks the only ones with text tracks?\\n        (0, _addTextTrackData2['default'])(this, sortedSegments.captions, sortedSegments.metadata);\\n      }\\n      if (!this.audioDisabled_ && this.audioBuffer_) {\\n        this.concatAndAppendSegments_(sortedSegments.audio, this.audioBuffer_);\\n      }\\n\\n      this.pendingBuffers_.length = 0;\\n\\n      // We are no longer in the internal \\\"updating\\\" state\\n      this.bufferUpdating_ = false;\\n    }\\n\\n    /**\\n     * Combine all segments into a single Uint8Array and then append them\\n     * to the destination buffer\\n     *\\n     * @param {Object} segmentObj\\n     * @param {SourceBuffer} destinationBuffer native source buffer to append data to\\n     * @private\\n     */\\n  }, {\\n    key: 'concatAndAppendSegments_',\\n    value: function concatAndAppendSegments_(segmentObj, destinationBuffer) {\\n      var offset = 0;\\n      var tempBuffer = undefined;\\n\\n      if (segmentObj.bytes) {\\n        tempBuffer = new Uint8Array(segmentObj.bytes);\\n\\n        // Combine the individual segments into one large typed-array\\n        segmentObj.segments.forEach(function (segment) {\\n          tempBuffer.set(segment, offset);\\n          offset += segment.byteLength;\\n        });\\n\\n        destinationBuffer.appendBuffer(tempBuffer);\\n      }\\n    }\\n\\n    /**\\n     * Emulate the native mediasource function. abort any soureBuffer\\n     * actions and throw out any un-appended data.\\n     *\\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/abort\\n     */\\n  }, {\\n    key: 'abort',\\n    value: function abort() {\\n      if (this.videoBuffer_) {\\n        this.videoBuffer_.abort();\\n      }\\n      if (this.audioBuffer_) {\\n        this.audioBuffer_.abort();\\n      }\\n      if (this.transmuxer_) {\\n        this.transmuxer_.postMessage({ action: 'reset' });\\n      }\\n      this.pendingBuffers_.length = 0;\\n      this.bufferUpdating_ = false;\\n    }\\n  }]);\\n\\n  return VirtualSourceBuffer;\\n})(_videoJs2['default'].EventTarget);\\n\\nexports['default'] = VirtualSourceBuffer;\\nmodule.exports = exports['default'];\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./add-text-track-data\\\":68,\\\"./codec-utils\\\":69,\\\"./create-text-tracks-if-necessary\\\":70,\\\"./remove-cues-from-track\\\":75,\\\"./transmuxer-worker\\\":76,\\\"webworkify\\\":95}],79:[function(require,module,exports){\\n/**\\n * mux.js\\n *\\n * Copyright (c) 2016 Brightcove\\n * All rights reserved.\\n *\\n * A stream-based aac to mp4 converter. This utility can be used to\\n * deliver mp4s to a SourceBuffer on platforms that support native\\n * Media Source Extensions.\\n */\\n'use strict';\\nvar Stream = require('../utils/stream.js');\\n\\n// Constants\\nvar AacStream;\\n\\n/**\\n * Splits an incoming stream of binary data into ADTS and ID3 Frames.\\n */\\n\\nAacStream = function() {\\n  var\\n    everything = new Uint8Array(),\\n    timeStamp = 0;\\n\\n  AacStream.prototype.init.call(this);\\n\\n  this.setTimestamp = function(timestamp) {\\n    timeStamp = timestamp;\\n  };\\n\\n  this.parseId3TagSize = function(header, byteIndex) {\\n    var\\n      returnSize = (header[byteIndex + 6] << 21) |\\n                   (header[byteIndex + 7] << 14) |\\n                   (header[byteIndex + 8] << 7) |\\n                   (header[byteIndex + 9]),\\n      flags = header[byteIndex + 5],\\n      footerPresent = (flags & 16) >> 4;\\n\\n    if (footerPresent) {\\n      return returnSize + 20;\\n    }\\n    return returnSize + 10;\\n  };\\n\\n  this.parseAdtsSize = function(header, byteIndex) {\\n    var\\n      lowThree = (header[byteIndex + 5] & 0xE0) >> 5,\\n      middle = header[byteIndex + 4] << 3,\\n      highTwo = header[byteIndex + 3] & 0x3 << 11;\\n\\n    return (highTwo | middle) | lowThree;\\n  };\\n\\n  this.push = function(bytes) {\\n    var\\n      frameSize = 0,\\n      byteIndex = 0,\\n      bytesLeft,\\n      chunk,\\n      packet,\\n      tempLength;\\n\\n    // If there are bytes remaining from the last segment, prepend them to the\\n    // bytes that were pushed in\\n    if (everything.length) {\\n      tempLength = everything.length;\\n      everything = new Uint8Array(bytes.byteLength + tempLength);\\n      everything.set(everything.subarray(0, tempLength));\\n      everything.set(bytes, tempLength);\\n    } else {\\n      everything = bytes;\\n    }\\n\\n    while (everything.length - byteIndex >= 3) {\\n      if ((everything[byteIndex] === 'I'.charCodeAt(0)) &&\\n          (everything[byteIndex + 1] === 'D'.charCodeAt(0)) &&\\n          (everything[byteIndex + 2] === '3'.charCodeAt(0))) {\\n\\n        // Exit early because we don't have enough to parse\\n        // the ID3 tag header\\n        if (everything.length - byteIndex < 10) {\\n          break;\\n        }\\n\\n        // check framesize\\n        frameSize = this.parseId3TagSize(everything, byteIndex);\\n\\n        // Exit early if we don't have enough in the buffer\\n        // to emit a full packet\\n        if (frameSize > everything.length) {\\n          break;\\n        }\\n        chunk = {\\n          type: 'timed-metadata',\\n          data: everything.subarray(byteIndex, byteIndex + frameSize)\\n        };\\n        this.trigger('data', chunk);\\n        byteIndex += frameSize;\\n        continue;\\n      } else if ((everything[byteIndex] & 0xff === 0xff) &&\\n                 ((everything[byteIndex + 1] & 0xf0) === 0xf0)) {\\n\\n        // Exit early because we don't have enough to parse\\n        // the ADTS frame header\\n        if (everything.length - byteIndex < 7) {\\n          break;\\n        }\\n\\n        frameSize = this.parseAdtsSize(everything, byteIndex);\\n\\n        // Exit early if we don't have enough in the buffer\\n        // to emit a full packet\\n        if (frameSize > everything.length) {\\n          break;\\n        }\\n\\n        packet = {\\n          type: 'audio',\\n          data: everything.subarray(byteIndex, byteIndex + frameSize),\\n          pts: timeStamp,\\n          dts: timeStamp\\n        };\\n        this.trigger('data', packet);\\n        byteIndex += frameSize;\\n        continue;\\n      }\\n      byteIndex++;\\n    }\\n    bytesLeft = everything.length - byteIndex;\\n\\n    if (bytesLeft > 0) {\\n      everything = everything.subarray(byteIndex);\\n    } else {\\n      everything = new Uint8Array();\\n    }\\n  };\\n};\\n\\nAacStream.prototype = new Stream();\\n\\nmodule.exports = AacStream;\\n\\n},{\\\"../utils/stream.js\\\":94}],80:[function(require,module,exports){\\n'use strict';\\n\\nvar Stream = require('../utils/stream.js');\\n\\nvar AdtsStream;\\n\\nvar\\n  ADTS_SAMPLING_FREQUENCIES = [\\n    96000,\\n    88200,\\n    64000,\\n    48000,\\n    44100,\\n    32000,\\n    24000,\\n    22050,\\n    16000,\\n    12000,\\n    11025,\\n    8000,\\n    7350\\n  ];\\n\\n/*\\n * Accepts a ElementaryStream and emits data events with parsed\\n * AAC Audio Frames of the individual packets. Input audio in ADTS\\n * format is unpacked and re-emitted as AAC frames.\\n *\\n * @see http://wiki.multimedia.cx/index.php?title=ADTS\\n * @see http://wiki.multimedia.cx/?title=Understanding_AAC\\n */\\nAdtsStream = function() {\\n  var buffer;\\n\\n  AdtsStream.prototype.init.call(this);\\n\\n  this.push = function(packet) {\\n    var\\n      i = 0,\\n      frameNum = 0,\\n      frameLength,\\n      protectionSkipBytes,\\n      frameEnd,\\n      oldBuffer,\\n      sampleCount,\\n      adtsFrameDuration;\\n\\n    if (packet.type !== 'audio') {\\n      // ignore non-audio data\\n      return;\\n    }\\n\\n    // Prepend any data in the buffer to the input data so that we can parse\\n    // aac frames the cross a PES packet boundary\\n    if (buffer) {\\n      oldBuffer = buffer;\\n      buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);\\n      buffer.set(oldBuffer);\\n      buffer.set(packet.data, oldBuffer.byteLength);\\n    } else {\\n      buffer = packet.data;\\n    }\\n\\n    // unpack any ADTS frames which have been fully received\\n    // for details on the ADTS header, see http://wiki.multimedia.cx/index.php?title=ADTS\\n    while (i + 5 < buffer.length) {\\n\\n      // Loook for the start of an ADTS header..\\n      if (buffer[i] !== 0xFF || (buffer[i + 1] & 0xF6) !== 0xF0) {\\n        // If a valid header was not found,  jump one forward and attempt to\\n        // find a valid ADTS header starting at the next byte\\n        i++;\\n        continue;\\n      }\\n\\n      // The protection skip bit tells us if we have 2 bytes of CRC data at the\\n      // end of the ADTS header\\n      protectionSkipBytes = (~buffer[i + 1] & 0x01) * 2;\\n\\n      // Frame length is a 13 bit integer starting 16 bits from the\\n      // end of the sync sequence\\n      frameLength = ((buffer[i + 3] & 0x03) << 11) |\\n        (buffer[i + 4] << 3) |\\n        ((buffer[i + 5] & 0xe0) >> 5);\\n\\n      sampleCount = ((buffer[i + 6] & 0x03) + 1) * 1024;\\n      adtsFrameDuration = (sampleCount * 90000) /\\n        ADTS_SAMPLING_FREQUENCIES[(buffer[i + 2] & 0x3c) >>> 2];\\n\\n      frameEnd = i + frameLength;\\n\\n      // If we don't have enough data to actually finish this ADTS frame, return\\n      // and wait for more data\\n      if (buffer.byteLength < frameEnd) {\\n        return;\\n      }\\n\\n      // Otherwise, deliver the complete AAC frame\\n      this.trigger('data', {\\n        pts: packet.pts + (frameNum * adtsFrameDuration),\\n        dts: packet.dts + (frameNum * adtsFrameDuration),\\n        sampleCount: sampleCount,\\n        audioobjecttype: ((buffer[i + 2] >>> 6) & 0x03) + 1,\\n        channelcount: ((buffer[i + 2] & 1) << 2) |\\n          ((buffer[i + 3] & 0xc0) >>> 6),\\n        samplerate: ADTS_SAMPLING_FREQUENCIES[(buffer[i + 2] & 0x3c) >>> 2],\\n        samplingfrequencyindex: (buffer[i + 2] & 0x3c) >>> 2,\\n        // assume ISO/IEC 14496-12 AudioSampleEntry default of 16\\n        samplesize: 16,\\n        data: buffer.subarray(i + 7 + protectionSkipBytes, frameEnd)\\n      });\\n\\n      // If the buffer is empty, clear it and return\\n      if (buffer.byteLength === frameEnd) {\\n        buffer = undefined;\\n        return;\\n      }\\n\\n      frameNum++;\\n\\n      // Remove the finished frame from the buffer and start the process again\\n      buffer = buffer.subarray(frameEnd);\\n    }\\n  };\\n  this.flush = function() {\\n    this.trigger('done');\\n  };\\n};\\n\\nAdtsStream.prototype = new Stream();\\n\\nmodule.exports = AdtsStream;\\n\\n},{\\\"../utils/stream.js\\\":94}],81:[function(require,module,exports){\\n'use strict';\\n\\nvar Stream = require('../utils/stream.js');\\nvar ExpGolomb = require('../utils/exp-golomb.js');\\n\\nvar H264Stream, NalByteStream;\\nvar PROFILES_WITH_OPTIONAL_SPS_DATA;\\n\\n/**\\n * Accepts a NAL unit byte stream and unpacks the embedded NAL units.\\n */\\nNalByteStream = function() {\\n  var\\n    syncPoint = 0,\\n    i,\\n    buffer;\\n  NalByteStream.prototype.init.call(this);\\n\\n  this.push = function(data) {\\n    var swapBuffer;\\n\\n    if (!buffer) {\\n      buffer = data.data;\\n    } else {\\n      swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);\\n      swapBuffer.set(buffer);\\n      swapBuffer.set(data.data, buffer.byteLength);\\n      buffer = swapBuffer;\\n    }\\n\\n    // Rec. ITU-T H.264, Annex B\\n    // scan for NAL unit boundaries\\n\\n    // a match looks like this:\\n    // 0 0 1 .. NAL .. 0 0 1\\n    // ^ sync point        ^ i\\n    // or this:\\n    // 0 0 1 .. NAL .. 0 0 0\\n    // ^ sync point        ^ i\\n\\n    // advance the sync point to a NAL start, if necessary\\n    for (; syncPoint < buffer.byteLength - 3; syncPoint++) {\\n      if (buffer[syncPoint + 2] === 1) {\\n        // the sync point is properly aligned\\n        i = syncPoint + 5;\\n        break;\\n      }\\n    }\\n\\n    while (i < buffer.byteLength) {\\n      // look at the current byte to determine if we've hit the end of\\n      // a NAL unit boundary\\n      switch (buffer[i]) {\\n      case 0:\\n        // skip past non-sync sequences\\n        if (buffer[i - 1] !== 0) {\\n          i += 2;\\n          break;\\n        } else if (buffer[i - 2] !== 0) {\\n          i++;\\n          break;\\n        }\\n\\n        // deliver the NAL unit if it isn't empty\\n        if (syncPoint + 3 !== i - 2) {\\n          this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\\n        }\\n\\n        // drop trailing zeroes\\n        do {\\n          i++;\\n        } while (buffer[i] !== 1 && i < buffer.length);\\n        syncPoint = i - 2;\\n        i += 3;\\n        break;\\n      case 1:\\n        // skip past non-sync sequences\\n        if (buffer[i - 1] !== 0 ||\\n            buffer[i - 2] !== 0) {\\n          i += 3;\\n          break;\\n        }\\n\\n        // deliver the NAL unit\\n        this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\\n        syncPoint = i - 2;\\n        i += 3;\\n        break;\\n      default:\\n        // the current byte isn't a one or zero, so it cannot be part\\n        // of a sync sequence\\n        i += 3;\\n        break;\\n      }\\n    }\\n    // filter out the NAL units that were delivered\\n    buffer = buffer.subarray(syncPoint);\\n    i -= syncPoint;\\n    syncPoint = 0;\\n  };\\n\\n  this.flush = function() {\\n    // deliver the last buffered NAL unit\\n    if (buffer && buffer.byteLength > 3) {\\n      this.trigger('data', buffer.subarray(syncPoint + 3));\\n    }\\n    // reset the stream state\\n    buffer = null;\\n    syncPoint = 0;\\n    this.trigger('done');\\n  };\\n};\\nNalByteStream.prototype = new Stream();\\n\\n// values of profile_idc that indicate additional fields are included in the SPS\\n// see Recommendation ITU-T H.264 (4/2013),\\n// 7.3.2.1.1 Sequence parameter set data syntax\\nPROFILES_WITH_OPTIONAL_SPS_DATA = {\\n  100: true,\\n  110: true,\\n  122: true,\\n  244: true,\\n  44: true,\\n  83: true,\\n  86: true,\\n  118: true,\\n  128: true,\\n  138: true,\\n  139: true,\\n  134: true\\n};\\n\\n/**\\n * Accepts input from a ElementaryStream and produces H.264 NAL unit data\\n * events.\\n */\\nH264Stream = function() {\\n  var\\n    nalByteStream = new NalByteStream(),\\n    self,\\n    trackId,\\n    currentPts,\\n    currentDts,\\n\\n    discardEmulationPreventionBytes,\\n    readSequenceParameterSet,\\n    skipScalingList;\\n\\n  H264Stream.prototype.init.call(this);\\n  self = this;\\n\\n  this.push = function(packet) {\\n    if (packet.type !== 'video') {\\n      return;\\n    }\\n    trackId = packet.trackId;\\n    currentPts = packet.pts;\\n    currentDts = packet.dts;\\n\\n    nalByteStream.push(packet);\\n  };\\n\\n  nalByteStream.on('data', function(data) {\\n    var\\n      event = {\\n        trackId: trackId,\\n        pts: currentPts,\\n        dts: currentDts,\\n        data: data\\n      };\\n\\n    switch (data[0] & 0x1f) {\\n    case 0x05:\\n      event.nalUnitType = 'slice_layer_without_partitioning_rbsp_idr';\\n      break;\\n    case 0x06:\\n      event.nalUnitType = 'sei_rbsp';\\n      event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\\n      break;\\n    case 0x07:\\n      event.nalUnitType = 'seq_parameter_set_rbsp';\\n      event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\\n      event.config = readSequenceParameterSet(event.escapedRBSP);\\n      break;\\n    case 0x08:\\n      event.nalUnitType = 'pic_parameter_set_rbsp';\\n      break;\\n    case 0x09:\\n      event.nalUnitType = 'access_unit_delimiter_rbsp';\\n      break;\\n\\n    default:\\n      break;\\n    }\\n    self.trigger('data', event);\\n  });\\n  nalByteStream.on('done', function() {\\n    self.trigger('done');\\n  });\\n\\n  this.flush = function() {\\n    nalByteStream.flush();\\n  };\\n\\n  /**\\n   * Advance the ExpGolomb decoder past a scaling list. The scaling\\n   * list is optionally transmitted as part of a sequence parameter\\n   * set and is not relevant to transmuxing.\\n   * @param count {number} the number of entries in this scaling list\\n   * @param expGolombDecoder {object} an ExpGolomb pointed to the\\n   * start of a scaling list\\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\\n   */\\n  skipScalingList = function(count, expGolombDecoder) {\\n    var\\n      lastScale = 8,\\n      nextScale = 8,\\n      j,\\n      deltaScale;\\n\\n    for (j = 0; j < count; j++) {\\n      if (nextScale !== 0) {\\n        deltaScale = expGolombDecoder.readExpGolomb();\\n        nextScale = (lastScale + deltaScale + 256) % 256;\\n      }\\n\\n      lastScale = (nextScale === 0) ? lastScale : nextScale;\\n    }\\n  };\\n\\n  /**\\n   * Expunge any \\\"Emulation Prevention\\\" bytes from a \\\"Raw Byte\\n   * Sequence Payload\\\"\\n   * @param data {Uint8Array} the bytes of a RBSP from a NAL\\n   * unit\\n   * @return {Uint8Array} the RBSP without any Emulation\\n   * Prevention Bytes\\n   */\\n  discardEmulationPreventionBytes = function(data) {\\n    var\\n      length = data.byteLength,\\n      emulationPreventionBytesPositions = [],\\n      i = 1,\\n      newLength, newData;\\n\\n    // Find all `Emulation Prevention Bytes`\\n    while (i < length - 2) {\\n      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\\n        emulationPreventionBytesPositions.push(i + 2);\\n        i += 2;\\n      } else {\\n        i++;\\n      }\\n    }\\n\\n    // If no Emulation Prevention Bytes were found just return the original\\n    // array\\n    if (emulationPreventionBytesPositions.length === 0) {\\n      return data;\\n    }\\n\\n    // Create a new array to hold the NAL unit data\\n    newLength = length - emulationPreventionBytesPositions.length;\\n    newData = new Uint8Array(newLength);\\n    var sourceIndex = 0;\\n\\n    for (i = 0; i < newLength; sourceIndex++, i++) {\\n      if (sourceIndex === emulationPreventionBytesPositions[0]) {\\n        // Skip this byte\\n        sourceIndex++;\\n        // Remove this position index\\n        emulationPreventionBytesPositions.shift();\\n      }\\n      newData[i] = data[sourceIndex];\\n    }\\n\\n    return newData;\\n  };\\n\\n  /**\\n   * Read a sequence parameter set and return some interesting video\\n   * properties. A sequence parameter set is the H264 metadata that\\n   * describes the properties of upcoming video frames.\\n   * @param data {Uint8Array} the bytes of a sequence parameter set\\n   * @return {object} an object with configuration parsed from the\\n   * sequence parameter set, including the dimensions of the\\n   * associated video frames.\\n   */\\n  readSequenceParameterSet = function(data) {\\n    var\\n      frameCropLeftOffset = 0,\\n      frameCropRightOffset = 0,\\n      frameCropTopOffset = 0,\\n      frameCropBottomOffset = 0,\\n      sarScale = 1,\\n      expGolombDecoder, profileIdc, levelIdc, profileCompatibility,\\n      chromaFormatIdc, picOrderCntType,\\n      numRefFramesInPicOrderCntCycle, picWidthInMbsMinus1,\\n      picHeightInMapUnitsMinus1,\\n      frameMbsOnlyFlag,\\n      scalingListCount,\\n      sarRatio,\\n      aspectRatioIdc,\\n      i;\\n\\n    expGolombDecoder = new ExpGolomb(data);\\n    profileIdc = expGolombDecoder.readUnsignedByte(); // profile_idc\\n    profileCompatibility = expGolombDecoder.readUnsignedByte(); // constraint_set[0-5]_flag\\n    levelIdc = expGolombDecoder.readUnsignedByte(); // level_idc u(8)\\n    expGolombDecoder.skipUnsignedExpGolomb(); // seq_parameter_set_id\\n\\n    // some profiles have more optional data we don't need\\n    if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {\\n      chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();\\n      if (chromaFormatIdc === 3) {\\n        expGolombDecoder.skipBits(1); // separate_colour_plane_flag\\n      }\\n      expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_luma_minus8\\n      expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_chroma_minus8\\n      expGolombDecoder.skipBits(1); // qpprime_y_zero_transform_bypass_flag\\n      if (expGolombDecoder.readBoolean()) { // seq_scaling_matrix_present_flag\\n        scalingListCount = (chromaFormatIdc !== 3) ? 8 : 12;\\n        for (i = 0; i < scalingListCount; i++) {\\n          if (expGolombDecoder.readBoolean()) { // seq_scaling_list_present_flag[ i ]\\n            if (i < 6) {\\n              skipScalingList(16, expGolombDecoder);\\n            } else {\\n              skipScalingList(64, expGolombDecoder);\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    expGolombDecoder.skipUnsignedExpGolomb(); // log2_max_frame_num_minus4\\n    picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();\\n\\n    if (picOrderCntType === 0) {\\n      expGolombDecoder.readUnsignedExpGolomb(); // log2_max_pic_order_cnt_lsb_minus4\\n    } else if (picOrderCntType === 1) {\\n      expGolombDecoder.skipBits(1); // delta_pic_order_always_zero_flag\\n      expGolombDecoder.skipExpGolomb(); // offset_for_non_ref_pic\\n      expGolombDecoder.skipExpGolomb(); // offset_for_top_to_bottom_field\\n      numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();\\n      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\\n        expGolombDecoder.skipExpGolomb(); // offset_for_ref_frame[ i ]\\n      }\\n    }\\n\\n    expGolombDecoder.skipUnsignedExpGolomb(); // max_num_ref_frames\\n    expGolombDecoder.skipBits(1); // gaps_in_frame_num_value_allowed_flag\\n\\n    picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\\n    picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\\n\\n    frameMbsOnlyFlag = expGolombDecoder.readBits(1);\\n    if (frameMbsOnlyFlag === 0) {\\n      expGolombDecoder.skipBits(1); // mb_adaptive_frame_field_flag\\n    }\\n\\n    expGolombDecoder.skipBits(1); // direct_8x8_inference_flag\\n    if (expGolombDecoder.readBoolean()) { // frame_cropping_flag\\n      frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();\\n      frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();\\n      frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();\\n      frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();\\n    }\\n    if (expGolombDecoder.readBoolean()) {\\n      // vui_parameters_present_flag\\n      if (expGolombDecoder.readBoolean()) {\\n        // aspect_ratio_info_present_flag\\n        aspectRatioIdc = expGolombDecoder.readUnsignedByte();\\n        switch (aspectRatioIdc) {\\n          case 1: sarRatio = [1, 1]; break;\\n          case 2: sarRatio = [12, 11]; break;\\n          case 3: sarRatio = [10, 11]; break;\\n          case 4: sarRatio = [16, 11]; break;\\n          case 5: sarRatio = [40, 33]; break;\\n          case 6: sarRatio = [24, 11]; break;\\n          case 7: sarRatio = [20, 11]; break;\\n          case 8: sarRatio = [32, 11]; break;\\n          case 9: sarRatio = [80, 33]; break;\\n          case 10: sarRatio = [18, 11]; break;\\n          case 11: sarRatio = [15, 11]; break;\\n          case 12: sarRatio = [64, 33]; break;\\n          case 13: sarRatio = [160, 99]; break;\\n          case 14: sarRatio = [4, 3]; break;\\n          case 15: sarRatio = [3, 2]; break;\\n          case 16: sarRatio = [2, 1]; break;\\n          case 255: {\\n            sarRatio = [expGolombDecoder.readUnsignedByte() << 8 |\\n                        expGolombDecoder.readUnsignedByte(),\\n                        expGolombDecoder.readUnsignedByte() << 8 |\\n                        expGolombDecoder.readUnsignedByte() ];\\n            break;\\n          }\\n        }\\n        if (sarRatio) {\\n          sarScale = sarRatio[0] / sarRatio[1];\\n        }\\n      }\\n    }\\n    return {\\n      profileIdc: profileIdc,\\n      levelIdc: levelIdc,\\n      profileCompatibility: profileCompatibility,\\n      width: Math.ceil((((picWidthInMbsMinus1 + 1) * 16) - frameCropLeftOffset * 2 - frameCropRightOffset * 2) * sarScale),\\n      height: ((2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16) - (frameCropTopOffset * 2) - (frameCropBottomOffset * 2)\\n    };\\n  };\\n\\n};\\nH264Stream.prototype = new Stream();\\n\\nmodule.exports = {\\n  H264Stream: H264Stream,\\n  NalByteStream: NalByteStream\\n};\\n\\n},{\\\"../utils/exp-golomb.js\\\":93,\\\"../utils/stream.js\\\":94}],82:[function(require,module,exports){\\n/**\\n * An object that stores the bytes of an FLV tag and methods for\\n * querying and manipulating that data.\\n * @see http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf\\n */\\n'use strict';\\n\\nvar FlvTag;\\n\\n// (type:uint, extraData:Boolean = false) extends ByteArray\\nFlvTag = function(type, extraData) {\\n  var\\n    // Counter if this is a metadata tag, nal start marker if this is a video\\n    // tag. unused if this is an audio tag\\n    adHoc = 0, // :uint\\n\\n    // The default size is 16kb but this is not enough to hold iframe\\n    // data and the resizing algorithm costs a bit so we create a larger\\n    // starting buffer for video tags\\n    bufferStartSize = 16384,\\n\\n    // checks whether the FLV tag has enough capacity to accept the proposed\\n    // write and re-allocates the internal buffers if necessary\\n    prepareWrite = function(flv, count) {\\n      var\\n        bytes,\\n        minLength = flv.position + count;\\n      if (minLength < flv.bytes.byteLength) {\\n        // there's enough capacity so do nothing\\n        return;\\n      }\\n\\n      // allocate a new buffer and copy over the data that will not be modified\\n      bytes = new Uint8Array(minLength * 2);\\n      bytes.set(flv.bytes.subarray(0, flv.position), 0);\\n      flv.bytes = bytes;\\n      flv.view = new DataView(flv.bytes.buffer);\\n    },\\n\\n    // commonly used metadata properties\\n    widthBytes = FlvTag.widthBytes || new Uint8Array('width'.length),\\n    heightBytes = FlvTag.heightBytes || new Uint8Array('height'.length),\\n    videocodecidBytes = FlvTag.videocodecidBytes || new Uint8Array('videocodecid'.length),\\n    i;\\n\\n  if (!FlvTag.widthBytes) {\\n    // calculating the bytes of common metadata names ahead of time makes the\\n    // corresponding writes faster because we don't have to loop over the\\n    // characters\\n    // re-test with test/perf.html if you're planning on changing this\\n    for (i = 0; i < 'width'.length; i++) {\\n      widthBytes[i] = 'width'.charCodeAt(i);\\n    }\\n    for (i = 0; i < 'height'.length; i++) {\\n      heightBytes[i] = 'height'.charCodeAt(i);\\n    }\\n    for (i = 0; i < 'videocodecid'.length; i++) {\\n      videocodecidBytes[i] = 'videocodecid'.charCodeAt(i);\\n    }\\n\\n    FlvTag.widthBytes = widthBytes;\\n    FlvTag.heightBytes = heightBytes;\\n    FlvTag.videocodecidBytes = videocodecidBytes;\\n  }\\n\\n  this.keyFrame = false; // :Boolean\\n\\n  switch (type) {\\n  case FlvTag.VIDEO_TAG:\\n    this.length = 16;\\n    // Start the buffer at 256k\\n    bufferStartSize *= 6;\\n    break;\\n  case FlvTag.AUDIO_TAG:\\n    this.length = 13;\\n    this.keyFrame = true;\\n    break;\\n  case FlvTag.METADATA_TAG:\\n    this.length = 29;\\n    this.keyFrame = true;\\n    break;\\n  default:\\n    throw new Error('Unknown FLV tag type');\\n  }\\n\\n  this.bytes = new Uint8Array(bufferStartSize);\\n  this.view = new DataView(this.bytes.buffer);\\n  this.bytes[0] = type;\\n  this.position = this.length;\\n  this.keyFrame = extraData; // Defaults to false\\n\\n  // presentation timestamp\\n  this.pts = 0;\\n  // decoder timestamp\\n  this.dts = 0;\\n\\n  // ByteArray#writeBytes(bytes:ByteArray, offset:uint = 0, length:uint = 0)\\n  this.writeBytes = function(bytes, offset, length) {\\n    var\\n      start = offset || 0,\\n      end;\\n    length = length || bytes.byteLength;\\n    end = start + length;\\n\\n    prepareWrite(this, length);\\n    this.bytes.set(bytes.subarray(start, end), this.position);\\n\\n    this.position += length;\\n    this.length = Math.max(this.length, this.position);\\n  };\\n\\n  // ByteArray#writeByte(value:int):void\\n  this.writeByte = function(byte) {\\n    prepareWrite(this, 1);\\n    this.bytes[this.position] = byte;\\n    this.position++;\\n    this.length = Math.max(this.length, this.position);\\n  };\\n\\n  // ByteArray#writeShort(value:int):void\\n  this.writeShort = function(short) {\\n    prepareWrite(this, 2);\\n    this.view.setUint16(this.position, short);\\n    this.position += 2;\\n    this.length = Math.max(this.length, this.position);\\n  };\\n\\n  // Negative index into array\\n  // (pos:uint):int\\n  this.negIndex = function(pos) {\\n    return this.bytes[this.length - pos];\\n  };\\n\\n  // The functions below ONLY work when this[0] == VIDEO_TAG.\\n  // We are not going to check for that because we dont want the overhead\\n  // (nal:ByteArray = null):int\\n  this.nalUnitSize = function() {\\n    if (adHoc === 0) {\\n      return 0;\\n    }\\n\\n    return this.length - (adHoc + 4);\\n  };\\n\\n  this.startNalUnit = function() {\\n    // remember position and add 4 bytes\\n    if (adHoc > 0) {\\n      throw new Error('Attempted to create new NAL wihout closing the old one');\\n    }\\n\\n    // reserve 4 bytes for nal unit size\\n    adHoc = this.length;\\n    this.length += 4;\\n    this.position = this.length;\\n  };\\n\\n  // (nal:ByteArray = null):void\\n  this.endNalUnit = function(nalContainer) {\\n    var\\n      nalStart, // :uint\\n      nalLength; // :uint\\n\\n    // Rewind to the marker and write the size\\n    if (this.length === adHoc + 4) {\\n      // we started a nal unit, but didnt write one, so roll back the 4 byte size value\\n      this.length -= 4;\\n    } else if (adHoc > 0) {\\n      nalStart = adHoc + 4;\\n      nalLength = this.length - nalStart;\\n\\n      this.position = adHoc;\\n      this.view.setUint32(this.position, nalLength);\\n      this.position = this.length;\\n\\n      if (nalContainer) {\\n        // Add the tag to the NAL unit\\n        nalContainer.push(this.bytes.subarray(nalStart, nalStart + nalLength));\\n      }\\n    }\\n\\n    adHoc = 0;\\n  };\\n\\n  /**\\n   * Write out a 64-bit floating point valued metadata property. This method is\\n   * called frequently during a typical parse and needs to be fast.\\n   */\\n  // (key:String, val:Number):void\\n  this.writeMetaDataDouble = function(key, val) {\\n    var i;\\n    prepareWrite(this, 2 + key.length + 9);\\n\\n    // write size of property name\\n    this.view.setUint16(this.position, key.length);\\n    this.position += 2;\\n\\n    // this next part looks terrible but it improves parser throughput by\\n    // 10kB/s in my testing\\n\\n    // write property name\\n    if (key === 'width') {\\n      this.bytes.set(widthBytes, this.position);\\n      this.position += 5;\\n    } else if (key === 'height') {\\n      this.bytes.set(heightBytes, this.position);\\n      this.position += 6;\\n    } else if (key === 'videocodecid') {\\n      this.bytes.set(videocodecidBytes, this.position);\\n      this.position += 12;\\n    } else {\\n      for (i = 0; i < key.length; i++) {\\n        this.bytes[this.position] = key.charCodeAt(i);\\n        this.position++;\\n      }\\n    }\\n\\n    // skip null byte\\n    this.position++;\\n\\n    // write property value\\n    this.view.setFloat64(this.position, val);\\n    this.position += 8;\\n\\n    // update flv tag length\\n    this.length = Math.max(this.length, this.position);\\n    ++adHoc;\\n  };\\n\\n  // (key:String, val:Boolean):void\\n  this.writeMetaDataBoolean = function(key, val) {\\n    var i;\\n    prepareWrite(this, 2);\\n    this.view.setUint16(this.position, key.length);\\n    this.position += 2;\\n    for (i = 0; i < key.length; i++) {\\n      // if key.charCodeAt(i) >= 255, handle error\\n      prepareWrite(this, 1);\\n      this.bytes[this.position] = key.charCodeAt(i);\\n      this.position++;\\n    }\\n    prepareWrite(this, 2);\\n    this.view.setUint8(this.position, 0x01);\\n    this.position++;\\n    this.view.setUint8(this.position, val ? 0x01 : 0x00);\\n    this.position++;\\n    this.length = Math.max(this.length, this.position);\\n    ++adHoc;\\n  };\\n\\n  // ():ByteArray\\n  this.finalize = function() {\\n    var\\n      dtsDelta, // :int\\n      len; // :int\\n\\n    switch (this.bytes[0]) {\\n      // Video Data\\n    case FlvTag.VIDEO_TAG:\\n       // We only support AVC, 1 = key frame (for AVC, a seekable\\n       // frame), 2 = inter frame (for AVC, a non-seekable frame)\\n      this.bytes[11] = ((this.keyFrame || extraData) ? 0x10 : 0x20) | 0x07;\\n      this.bytes[12] = extraData ?  0x00 : 0x01;\\n\\n      dtsDelta = this.pts - this.dts;\\n      this.bytes[13] = (dtsDelta & 0x00FF0000) >>> 16;\\n      this.bytes[14] = (dtsDelta & 0x0000FF00) >>>  8;\\n      this.bytes[15] = (dtsDelta & 0x000000FF) >>>  0;\\n      break;\\n\\n    case FlvTag.AUDIO_TAG:\\n      this.bytes[11] = 0xAF; // 44 kHz, 16-bit stereo\\n      this.bytes[12] = extraData ? 0x00 : 0x01;\\n      break;\\n\\n    case FlvTag.METADATA_TAG:\\n      this.position = 11;\\n      this.view.setUint8(this.position, 0x02); // String type\\n      this.position++;\\n      this.view.setUint16(this.position, 0x0A); // 10 Bytes\\n      this.position += 2;\\n      // set \\\"onMetaData\\\"\\n      this.bytes.set([0x6f, 0x6e, 0x4d, 0x65,\\n                      0x74, 0x61, 0x44, 0x61,\\n                      0x74, 0x61], this.position);\\n      this.position += 10;\\n      this.bytes[this.position] = 0x08; // Array type\\n      this.position++;\\n      this.view.setUint32(this.position, adHoc);\\n      this.position = this.length;\\n      this.bytes.set([0, 0, 9], this.position);\\n      this.position += 3; // End Data Tag\\n      this.length = this.position;\\n      break;\\n    }\\n\\n    len = this.length - 11;\\n\\n    // write the DataSize field\\n    this.bytes[ 1] = (len & 0x00FF0000) >>> 16;\\n    this.bytes[ 2] = (len & 0x0000FF00) >>>  8;\\n    this.bytes[ 3] = (len & 0x000000FF) >>>  0;\\n    // write the Timestamp\\n    this.bytes[ 4] = (this.dts & 0x00FF0000) >>> 16;\\n    this.bytes[ 5] = (this.dts & 0x0000FF00) >>>  8;\\n    this.bytes[ 6] = (this.dts & 0x000000FF) >>>  0;\\n    this.bytes[ 7] = (this.dts & 0xFF000000) >>> 24;\\n    // write the StreamID\\n    this.bytes[ 8] = 0;\\n    this.bytes[ 9] = 0;\\n    this.bytes[10] = 0;\\n\\n    // Sometimes we're at the end of the view and have one slot to write a\\n    // uint32, so, prepareWrite of count 4, since, view is uint8\\n    prepareWrite(this, 4);\\n    this.view.setUint32(this.length, this.length);\\n    this.length += 4;\\n    this.position += 4;\\n\\n    // trim down the byte buffer to what is actually being used\\n    this.bytes = this.bytes.subarray(0, this.length);\\n    this.frameTime = FlvTag.frameTime(this.bytes);\\n    // if bytes.bytelength isn't equal to this.length, handle error\\n    return this;\\n  };\\n};\\n\\nFlvTag.AUDIO_TAG = 0x08; // == 8, :uint\\nFlvTag.VIDEO_TAG = 0x09; // == 9, :uint\\nFlvTag.METADATA_TAG = 0x12; // == 18, :uint\\n\\n// (tag:ByteArray):Boolean {\\nFlvTag.isAudioFrame = function(tag) {\\n  return FlvTag.AUDIO_TAG === tag[0];\\n};\\n\\n// (tag:ByteArray):Boolean {\\nFlvTag.isVideoFrame = function(tag) {\\n  return FlvTag.VIDEO_TAG === tag[0];\\n};\\n\\n// (tag:ByteArray):Boolean {\\nFlvTag.isMetaData = function(tag) {\\n  return FlvTag.METADATA_TAG === tag[0];\\n};\\n\\n// (tag:ByteArray):Boolean {\\nFlvTag.isKeyFrame = function(tag) {\\n  if (FlvTag.isVideoFrame(tag)) {\\n    return tag[11] === 0x17;\\n  }\\n\\n  if (FlvTag.isAudioFrame(tag)) {\\n    return true;\\n  }\\n\\n  if (FlvTag.isMetaData(tag)) {\\n    return true;\\n  }\\n\\n  return false;\\n};\\n\\n// (tag:ByteArray):uint {\\nFlvTag.frameTime = function(tag) {\\n  var pts = tag[ 4] << 16; // :uint\\n  pts |= tag[ 5] <<  8;\\n  pts |= tag[ 6] <<  0;\\n  pts |= tag[ 7] << 24;\\n  return pts;\\n};\\n\\nmodule.exports = FlvTag;\\n\\n},{}],83:[function(require,module,exports){\\nmodule.exports = {\\n  tag: require('./flv-tag'),\\n  Transmuxer: require('./transmuxer')\\n};\\n\\n},{\\\"./flv-tag\\\":82,\\\"./transmuxer\\\":84}],84:[function(require,module,exports){\\n'use strict';\\n\\nvar Stream = require('../utils/stream.js');\\nvar FlvTag = require('./flv-tag.js');\\nvar m2ts = require('../m2ts/m2ts.js');\\nvar AdtsStream = require('../codecs/adts.js');\\nvar H264Stream = require('../codecs/h264').H264Stream;\\n\\nvar\\n  Transmuxer,\\n  VideoSegmentStream,\\n  AudioSegmentStream,\\n  CoalesceStream,\\n  collectTimelineInfo,\\n  metaDataTag,\\n  extraDataTag;\\n\\n/**\\n * Store information about the start and end of the tracka and the\\n * duration for each frame/sample we process in order to calculate\\n * the baseMediaDecodeTime\\n */\\ncollectTimelineInfo = function(track, data) {\\n  if (typeof data.pts === 'number') {\\n    if (track.timelineStartInfo.pts === undefined) {\\n      track.timelineStartInfo.pts = data.pts;\\n    } else {\\n      track.timelineStartInfo.pts =\\n        Math.min(track.timelineStartInfo.pts, data.pts);\\n    }\\n  }\\n\\n  if (typeof data.dts === 'number') {\\n    if (track.timelineStartInfo.dts === undefined) {\\n      track.timelineStartInfo.dts = data.dts;\\n    } else {\\n      track.timelineStartInfo.dts =\\n        Math.min(track.timelineStartInfo.dts, data.dts);\\n    }\\n  }\\n};\\n\\nmetaDataTag = function(track, pts) {\\n  var\\n    tag = new FlvTag(FlvTag.METADATA_TAG); // :FlvTag\\n\\n  tag.dts = pts;\\n  tag.pts = pts;\\n\\n  tag.writeMetaDataDouble('videocodecid', 7);\\n  tag.writeMetaDataDouble('width', track.width);\\n  tag.writeMetaDataDouble('height', track.height);\\n\\n  return tag;\\n};\\n\\nextraDataTag = function(track, pts) {\\n  var\\n    i,\\n    tag = new FlvTag(FlvTag.VIDEO_TAG, true);\\n\\n  tag.dts = pts;\\n  tag.pts = pts;\\n\\n  tag.writeByte(0x01);// version\\n  tag.writeByte(track.profileIdc);// profile\\n  tag.writeByte(track.profileCompatibility);// compatibility\\n  tag.writeByte(track.levelIdc);// level\\n  tag.writeByte(0xFC | 0x03); // reserved (6 bits), NULA length size - 1 (2 bits)\\n  tag.writeByte(0xE0 | 0x01); // reserved (3 bits), num of SPS (5 bits)\\n  tag.writeShort(track.sps[0].length); // data of SPS\\n  tag.writeBytes(track.sps[0]); // SPS\\n\\n  tag.writeByte(track.pps.length); // num of PPS (will there ever be more that 1 PPS?)\\n  for (i = 0; i < track.pps.length; ++i) {\\n    tag.writeShort(track.pps[i].length); // 2 bytes for length of PPS\\n    tag.writeBytes(track.pps[i]); // data of PPS\\n  }\\n\\n  return tag;\\n};\\n\\n/**\\n * Constructs a single-track, media segment from AAC data\\n * events. The output of this stream can be fed to flash.\\n */\\nAudioSegmentStream = function(track) {\\n  var\\n    adtsFrames = [],\\n    oldExtraData;\\n\\n  AudioSegmentStream.prototype.init.call(this);\\n\\n  this.push = function(data) {\\n    collectTimelineInfo(track, data);\\n\\n    if (track && track.channelcount === undefined) {\\n      track.audioobjecttype = data.audioobjecttype;\\n      track.channelcount = data.channelcount;\\n      track.samplerate = data.samplerate;\\n      track.samplingfrequencyindex = data.samplingfrequencyindex;\\n      track.samplesize = data.samplesize;\\n      track.extraData = (track.audioobjecttype << 11) |\\n                        (track.samplingfrequencyindex << 7) |\\n                        (track.channelcount << 3);\\n    }\\n\\n    data.pts = Math.round(data.pts / 90);\\n    data.dts = Math.round(data.dts / 90);\\n\\n    // buffer audio data until end() is called\\n    adtsFrames.push(data);\\n  };\\n\\n  this.flush = function() {\\n    var currentFrame, adtsFrame, lastMetaPts, tags = [];\\n    // return early if no audio data has been observed\\n    if (adtsFrames.length === 0) {\\n      this.trigger('done');\\n      return;\\n    }\\n\\n    lastMetaPts = -Infinity;\\n\\n    while (adtsFrames.length) {\\n      currentFrame = adtsFrames.shift();\\n\\n      // write out metadata tags every 1 second so that the decoder\\n      // is re-initialized quickly after seeking into a different\\n      // audio configuration\\n      if (track.extraData !== oldExtraData || currentFrame.pts - lastMetaPts >= 1000) {\\n       adtsFrame = new FlvTag(FlvTag.METADATA_TAG);\\n        adtsFrame.pts = currentFrame.pts;\\n        adtsFrame.dts = currentFrame.dts;\\n\\n        // AAC is always 10\\n        adtsFrame.writeMetaDataDouble('audiocodecid', 10);\\n        adtsFrame.writeMetaDataBoolean('stereo', track.channelcount === 2);\\n        adtsFrame.writeMetaDataDouble('audiosamplerate', track.samplerate);\\n        // Is AAC always 16 bit?\\n        adtsFrame.writeMetaDataDouble('audiosamplesize', 16);\\n\\n        tags.push(adtsFrame);\\n\\n        oldExtraData = track.extraData;\\n\\n        adtsFrame = new FlvTag(FlvTag.AUDIO_TAG, true);\\n        // For audio, DTS is always the same as PTS. We want to set the DTS\\n        // however so we can compare with video DTS to determine approximate\\n        // packet order\\n        adtsFrame.pts = currentFrame.pts;\\n        adtsFrame.dts = currentFrame.dts;\\n\\n        adtsFrame.view.setUint16(adtsFrame.position, track.extraData);\\n        adtsFrame.position += 2;\\n        adtsFrame.length = Math.max(adtsFrame.length, adtsFrame.position);\\n\\n        tags.push(adtsFrame);\\n\\n        lastMetaPts = currentFrame.pts;\\n      }\\n      adtsFrame = new FlvTag(FlvTag.AUDIO_TAG);\\n      adtsFrame.pts = currentFrame.pts;\\n      adtsFrame.dts = currentFrame.dts;\\n\\n      adtsFrame.writeBytes(currentFrame.data);\\n\\n      tags.push(adtsFrame);\\n    }\\n\\n    oldExtraData = null;\\n    this.trigger('data', {track: track, tags: tags});\\n\\n    this.trigger('done');\\n  };\\n};\\nAudioSegmentStream.prototype = new Stream();\\n\\n/**\\n * Store FlvTags for the h264 stream\\n * @param track {object} track metadata configuration\\n */\\nVideoSegmentStream = function(track) {\\n  var\\n    nalUnits = [],\\n    config,\\n    h264Frame;\\n  VideoSegmentStream.prototype.init.call(this);\\n\\n  this.finishFrame = function(tags, frame) {\\n    if (!frame) {\\n      return;\\n    }\\n    // Check if keyframe and the length of tags.\\n    // This makes sure we write metadata on the first frame of a segment.\\n    if (config && track && track.newMetadata &&\\n        (frame.keyFrame || tags.length === 0)) {\\n      // Push extra data on every IDR frame in case we did a stream change + seek\\n      tags.push(metaDataTag(config, frame.pts));\\n      tags.push(extraDataTag(track, frame.pts));\\n      track.newMetadata = false;\\n    }\\n\\n    frame.endNalUnit();\\n    tags.push(frame);\\n  };\\n\\n  this.push = function(data) {\\n    collectTimelineInfo(track, data);\\n\\n    data.pts = Math.round(data.pts / 90);\\n    data.dts = Math.round(data.dts / 90);\\n\\n    // buffer video until flush() is called\\n    nalUnits.push(data);\\n  };\\n\\n  this.flush = function() {\\n    var\\n      currentNal,\\n      tags = [];\\n\\n    // Throw away nalUnits at the start of the byte stream until we find\\n    // the first AUD\\n    while (nalUnits.length) {\\n      if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\\n        break;\\n      }\\n      nalUnits.shift();\\n    }\\n\\n    // return early if no video data has been observed\\n    if (nalUnits.length === 0) {\\n      this.trigger('done');\\n      return;\\n    }\\n\\n    while (nalUnits.length) {\\n      currentNal = nalUnits.shift();\\n\\n      // record the track config\\n      if (currentNal.nalUnitType === 'seq_parameter_set_rbsp') {\\n        track.newMetadata = true;\\n        config = currentNal.config;\\n        track.width = config.width;\\n        track.height = config.height;\\n        track.sps = [currentNal.data];\\n        track.profileIdc = config.profileIdc;\\n        track.levelIdc = config.levelIdc;\\n        track.profileCompatibility = config.profileCompatibility;\\n        h264Frame.endNalUnit();\\n      } else if (currentNal.nalUnitType === 'pic_parameter_set_rbsp') {\\n        track.newMetadata = true;\\n        track.pps = [currentNal.data];\\n        h264Frame.endNalUnit();\\n      } else if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\\n        if (h264Frame) {\\n          this.finishFrame(tags, h264Frame);\\n        }\\n        h264Frame = new FlvTag(FlvTag.VIDEO_TAG);\\n        h264Frame.pts = currentNal.pts;\\n        h264Frame.dts = currentNal.dts;\\n      } else {\\n        if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\\n          // the current sample is a key frame\\n          h264Frame.keyFrame = true;\\n        }\\n        h264Frame.endNalUnit();\\n      }\\n      h264Frame.startNalUnit();\\n      h264Frame.writeBytes(currentNal.data);\\n    }\\n    if (h264Frame) {\\n      this.finishFrame(tags, h264Frame);\\n    }\\n\\n    this.trigger('data', {track: track, tags: tags});\\n\\n    // Continue with the flush process now\\n    this.trigger('done');\\n  };\\n};\\n\\nVideoSegmentStream.prototype = new Stream();\\n\\n/**\\n * The final stage of the transmuxer that emits the flv tags\\n * for audio, video, and metadata. Also tranlates in time and\\n * outputs caption data and id3 cues.\\n */\\nCoalesceStream = function(options) {\\n  // Number of Tracks per output segment\\n  // If greater than 1, we combine multiple\\n  // tracks into a single segment\\n  this.numberOfTracks = 0;\\n  this.metadataStream = options.metadataStream;\\n\\n  this.videoTags = [];\\n  this.audioTags = [];\\n  this.videoTrack = null;\\n  this.audioTrack = null;\\n  this.pendingCaptions = [];\\n  this.pendingMetadata = [];\\n  this.pendingTracks = 0;\\n\\n  CoalesceStream.prototype.init.call(this);\\n\\n  // Take output from multiple\\n  this.push = function(output) {\\n    // buffer incoming captions until the associated video segment\\n    // finishes\\n    if (output.text) {\\n      return this.pendingCaptions.push(output);\\n    }\\n    // buffer incoming id3 tags until the final flush\\n    if (output.frames) {\\n      return this.pendingMetadata.push(output);\\n    }\\n\\n    if (output.track.type === 'video') {\\n      this.videoTrack = output.track;\\n      this.videoTags = output.tags;\\n      this.pendingTracks++;\\n    }\\n    if (output.track.type === 'audio') {\\n      this.audioTrack = output.track;\\n      this.audioTags = output.tags;\\n      this.pendingTracks++;\\n    }\\n  };\\n};\\n\\nCoalesceStream.prototype = new Stream();\\nCoalesceStream.prototype.flush = function() {\\n  var\\n    id3,\\n    caption,\\n    i,\\n    timelineStartPts,\\n    event = {\\n      tags: {},\\n      captions: [],\\n      metadata: []\\n    };\\n\\n  if (this.pendingTracks < this.numberOfTracks) {\\n    return;\\n  }\\n\\n  if (this.videoTrack) {\\n    timelineStartPts = this.videoTrack.timelineStartInfo.pts;\\n  } else if (this.audioTrack) {\\n    timelineStartPts = this.audioTrack.timelineStartInfo.pts;\\n  }\\n\\n  event.tags.videoTags = this.videoTags;\\n  event.tags.audioTags = this.audioTags;\\n\\n  // Translate caption PTS times into second offsets into the\\n  // video timeline for the segment\\n  for (i = 0; i < this.pendingCaptions.length; i++) {\\n    caption = this.pendingCaptions[i];\\n    caption.startTime = caption.startPts - timelineStartPts;\\n    caption.startTime /= 90e3;\\n    caption.endTime = caption.endPts - timelineStartPts;\\n    caption.endTime /= 90e3;\\n    event.captions.push(caption);\\n  }\\n\\n  // Translate ID3 frame PTS times into second offsets into the\\n  // video timeline for the segment\\n  for (i = 0; i < this.pendingMetadata.length; i++) {\\n    id3 = this.pendingMetadata[i];\\n    id3.cueTime = id3.pts - timelineStartPts;\\n    id3.cueTime /= 90e3;\\n    event.metadata.push(id3);\\n  }\\n  // We add this to every single emitted segment even though we only need\\n  // it for the first\\n  event.metadata.dispatchType = this.metadataStream.dispatchType;\\n\\n  // Reset stream state\\n  this.videoTrack = null;\\n  this.audioTrack = null;\\n  this.videoTags = [];\\n  this.audioTags = [];\\n  this.pendingCaptions.length = 0;\\n  this.pendingMetadata.length = 0;\\n  this.pendingTracks = 0;\\n\\n  // Emit the final segment\\n  this.trigger('data', event);\\n\\n  this.trigger('done');\\n};\\n\\n/**\\n * An object that incrementally transmuxes MPEG2 Trasport Stream\\n * chunks into an FLV.\\n */\\nTransmuxer = function(options) {\\n  var\\n    self = this,\\n\\n    packetStream, parseStream, elementaryStream,\\n    videoTimestampRolloverStream, audioTimestampRolloverStream,\\n    timedMetadataTimestampRolloverStream,\\n    adtsStream, h264Stream,\\n    videoSegmentStream, audioSegmentStream, captionStream,\\n    coalesceStream;\\n\\n  Transmuxer.prototype.init.call(this);\\n\\n  options = options || {};\\n\\n  // expose the metadata stream\\n  this.metadataStream = new m2ts.MetadataStream();\\n\\n  options.metadataStream = this.metadataStream;\\n\\n  // set up the parsing pipeline\\n  packetStream = new m2ts.TransportPacketStream();\\n  parseStream = new m2ts.TransportParseStream();\\n  elementaryStream = new m2ts.ElementaryStream();\\n  videoTimestampRolloverStream = new m2ts.TimestampRolloverStream('video');\\n  audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\\n  timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\\n\\n  adtsStream = new AdtsStream();\\n  h264Stream = new H264Stream();\\n  coalesceStream = new CoalesceStream(options);\\n\\n  // disassemble MPEG2-TS packets into elementary streams\\n  packetStream\\n    .pipe(parseStream)\\n    .pipe(elementaryStream);\\n\\n  // !!THIS ORDER IS IMPORTANT!!\\n  // demux the streams\\n  elementaryStream\\n    .pipe(videoTimestampRolloverStream)\\n    .pipe(h264Stream);\\n  elementaryStream\\n    .pipe(audioTimestampRolloverStream)\\n    .pipe(adtsStream);\\n\\n  elementaryStream\\n    .pipe(timedMetadataTimestampRolloverStream)\\n    .pipe(this.metadataStream)\\n    .pipe(coalesceStream);\\n  // if CEA-708 parsing is available, hook up a caption stream\\n  captionStream = new m2ts.CaptionStream();\\n  h264Stream.pipe(captionStream)\\n    .pipe(coalesceStream);\\n\\n  // hook up the segment streams once track metadata is delivered\\n  elementaryStream.on('data', function(data) {\\n    var i, videoTrack, audioTrack;\\n\\n    if (data.type === 'metadata') {\\n      i = data.tracks.length;\\n\\n      // scan the tracks listed in the metadata\\n      while (i--) {\\n        if (data.tracks[i].type === 'video') {\\n          videoTrack = data.tracks[i];\\n        } else if (data.tracks[i].type === 'audio') {\\n          audioTrack = data.tracks[i];\\n        }\\n      }\\n\\n      // hook up the video segment stream to the first track with h264 data\\n      if (videoTrack && !videoSegmentStream) {\\n        coalesceStream.numberOfTracks++;\\n        videoSegmentStream = new VideoSegmentStream(videoTrack);\\n\\n        // Set up the final part of the video pipeline\\n        h264Stream\\n          .pipe(videoSegmentStream)\\n          .pipe(coalesceStream);\\n      }\\n\\n      if (audioTrack && !audioSegmentStream) {\\n        // hook up the audio segment stream to the first track with aac data\\n        coalesceStream.numberOfTracks++;\\n        audioSegmentStream = new AudioSegmentStream(audioTrack);\\n\\n        // Set up the final part of the audio pipeline\\n        adtsStream\\n          .pipe(audioSegmentStream)\\n          .pipe(coalesceStream);\\n      }\\n    }\\n  });\\n\\n  // feed incoming data to the front of the parsing pipeline\\n  this.push = function(data) {\\n    packetStream.push(data);\\n  };\\n\\n  // flush any buffered data\\n  this.flush = function() {\\n    // Start at the top of the pipeline and flush all pending work\\n    packetStream.flush();\\n  };\\n\\n  // Re-emit any data coming from the coalesce stream to the outside world\\n  coalesceStream.on('data', function(event) {\\n    self.trigger('data', event);\\n  });\\n\\n  // Let the consumer know we have finished flushing the entire pipeline\\n  coalesceStream.on('done', function() {\\n    self.trigger('done');\\n  });\\n\\n  // For information on the FLV format, see\\n  // http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf.\\n  // Technically, this function returns the header and a metadata FLV tag\\n  // if duration is greater than zero\\n  // duration in seconds\\n  // @return {object} the bytes of the FLV header as a Uint8Array\\n  this.getFlvHeader = function(duration, audio, video) { // :ByteArray {\\n    var\\n      headBytes = new Uint8Array(3 + 1 + 1 + 4),\\n      head = new DataView(headBytes.buffer),\\n      metadata,\\n      result,\\n      metadataLength;\\n\\n    // default arguments\\n    duration = duration || 0;\\n    audio = audio === undefined ? true : audio;\\n    video = video === undefined ? true : video;\\n\\n    // signature\\n    head.setUint8(0, 0x46); // 'F'\\n    head.setUint8(1, 0x4c); // 'L'\\n    head.setUint8(2, 0x56); // 'V'\\n\\n    // version\\n    head.setUint8(3, 0x01);\\n\\n    // flags\\n    head.setUint8(4, (audio ? 0x04 : 0x00) | (video ? 0x01 : 0x00));\\n\\n    // data offset, should be 9 for FLV v1\\n    head.setUint32(5, headBytes.byteLength);\\n\\n    // init the first FLV tag\\n    if (duration <= 0) {\\n      // no duration available so just write the first field of the first\\n      // FLV tag\\n      result = new Uint8Array(headBytes.byteLength + 4);\\n      result.set(headBytes);\\n      result.set([0, 0, 0, 0], headBytes.byteLength);\\n      return result;\\n    }\\n\\n    // write out the duration metadata tag\\n    metadata = new FlvTag(FlvTag.METADATA_TAG);\\n    metadata.pts = metadata.dts = 0;\\n    metadata.writeMetaDataDouble('duration', duration);\\n    metadataLength = metadata.finalize().length;\\n    result = new Uint8Array(headBytes.byteLength + metadataLength);\\n    result.set(headBytes);\\n    result.set(head.byteLength, metadataLength);\\n\\n    return result;\\n  };\\n};\\nTransmuxer.prototype = new Stream();\\n\\n// forward compatibility\\nmodule.exports = Transmuxer;\\n\\n},{\\\"../codecs/adts.js\\\":80,\\\"../codecs/h264\\\":81,\\\"../m2ts/m2ts.js\\\":86,\\\"../utils/stream.js\\\":94,\\\"./flv-tag.js\\\":82}],85:[function(require,module,exports){\\n/**\\n * mux.js\\n *\\n * Copyright (c) 2015 Brightcove\\n * All rights reserved.\\n *\\n * Reads in-band caption information from a video elementary\\n * stream. Captions must follow the CEA-708 standard for injection\\n * into an MPEG-2 transport streams.\\n * @see https://en.wikipedia.org/wiki/CEA-708\\n */\\n\\n'use strict';\\n\\n// -----------------\\n// Link To Transport\\n// -----------------\\n\\n// Supplemental enhancement information (SEI) NAL units have a\\n// payload type field to indicate how they are to be\\n// interpreted. CEAS-708 caption content is always transmitted with\\n// payload type 0x04.\\nvar USER_DATA_REGISTERED_ITU_T_T35 = 4,\\n    RBSP_TRAILING_BITS = 128,\\n    Stream = require('../utils/stream');\\n\\n/**\\n  * Parse a supplemental enhancement information (SEI) NAL unit.\\n  * Stops parsing once a message of type ITU T T35 has been found.\\n  *\\n  * @param bytes {Uint8Array} the bytes of a SEI NAL unit\\n  * @return {object} the parsed SEI payload\\n  * @see Rec. ITU-T H.264, 7.3.2.3.1\\n  */\\nvar parseSei = function(bytes) {\\n  var\\n    i = 0,\\n    result = {\\n      payloadType: -1,\\n      payloadSize: 0\\n    },\\n    payloadType = 0,\\n    payloadSize = 0;\\n\\n  // go through the sei_rbsp parsing each each individual sei_message\\n  while (i < bytes.byteLength) {\\n    // stop once we have hit the end of the sei_rbsp\\n    if (bytes[i] === RBSP_TRAILING_BITS) {\\n      break;\\n    }\\n\\n    // Parse payload type\\n    while (bytes[i] === 0xFF) {\\n      payloadType += 255;\\n      i++;\\n    }\\n    payloadType += bytes[i++];\\n\\n    // Parse payload size\\n    while (bytes[i] === 0xFF) {\\n      payloadSize += 255;\\n      i++;\\n    }\\n    payloadSize += bytes[i++];\\n\\n    // this sei_message is a 608/708 caption so save it and break\\n    // there can only ever be one caption message in a frame's sei\\n    if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {\\n      result.payloadType = payloadType;\\n      result.payloadSize = payloadSize;\\n      result.payload = bytes.subarray(i, i + payloadSize);\\n      break;\\n    }\\n\\n    // skip the payload and parse the next message\\n    i += payloadSize;\\n    payloadType = 0;\\n    payloadSize = 0;\\n  }\\n\\n  return result;\\n};\\n\\n// see ANSI/SCTE 128-1 (2013), section 8.1\\nvar parseUserData = function(sei) {\\n  // itu_t_t35_contry_code must be 181 (United States) for\\n  // captions\\n  if (sei.payload[0] !== 181) {\\n    return null;\\n  }\\n\\n  // itu_t_t35_provider_code should be 49 (ATSC) for captions\\n  if (((sei.payload[1] << 8) | sei.payload[2]) !== 49) {\\n    return null;\\n  }\\n\\n  // the user_identifier should be \\\"GA94\\\" to indicate ATSC1 data\\n  if (String.fromCharCode(sei.payload[3],\\n                          sei.payload[4],\\n                          sei.payload[5],\\n                          sei.payload[6]) !== 'GA94') {\\n    return null;\\n  }\\n\\n  // finally, user_data_type_code should be 0x03 for caption data\\n  if (sei.payload[7] !== 0x03) {\\n    return null;\\n  }\\n\\n  // return the user_data_type_structure and strip the trailing\\n  // marker bits\\n  return sei.payload.subarray(8, sei.payload.length - 1);\\n};\\n\\n// see CEA-708-D, section 4.4\\nvar parseCaptionPackets = function(pts, userData) {\\n  var results = [], i, count, offset, data;\\n\\n  // if this is just filler, return immediately\\n  if (!(userData[0] & 0x40)) {\\n    return results;\\n  }\\n\\n  // parse out the cc_data_1 and cc_data_2 fields\\n  count = userData[0] & 0x1f;\\n  for (i = 0; i < count; i++) {\\n    offset = i * 3;\\n    data = {\\n      type: userData[offset + 2] & 0x03,\\n      pts: pts\\n    };\\n\\n    // capture cc data when cc_valid is 1\\n    if (userData[offset + 2] & 0x04) {\\n      data.ccData = (userData[offset + 3] << 8) | userData[offset + 4];\\n      results.push(data);\\n    }\\n  }\\n  return results;\\n};\\n\\nvar CaptionStream = function() {\\n  CaptionStream.prototype.init.call(this);\\n\\n  this.captionPackets_ = [];\\n\\n  this.field1_ = new Cea608Stream(); // eslint-disable-line no-use-before-define\\n\\n  // forward data and done events from field1_ to this CaptionStream\\n  this.field1_.on('data', this.trigger.bind(this, 'data'));\\n  this.field1_.on('done', this.trigger.bind(this, 'done'));\\n};\\nCaptionStream.prototype = new Stream();\\nCaptionStream.prototype.push = function(event) {\\n  var sei, userData;\\n\\n  // only examine SEI NALs\\n  if (event.nalUnitType !== 'sei_rbsp') {\\n    return;\\n  }\\n\\n  // parse the sei\\n  sei = parseSei(event.escapedRBSP);\\n\\n  // ignore everything but user_data_registered_itu_t_t35\\n  if (sei.payloadType !== USER_DATA_REGISTERED_ITU_T_T35) {\\n    return;\\n  }\\n\\n  // parse out the user data payload\\n  userData = parseUserData(sei);\\n\\n  // ignore unrecognized userData\\n  if (!userData) {\\n    return;\\n  }\\n\\n  // parse out CC data packets and save them for later\\n  this.captionPackets_ = this.captionPackets_.concat(parseCaptionPackets(event.pts, userData));\\n};\\n\\nCaptionStream.prototype.flush = function() {\\n  // make sure we actually parsed captions before proceeding\\n  if (!this.captionPackets_.length) {\\n    this.field1_.flush();\\n    return;\\n  }\\n\\n  // In Chrome, the Array#sort function is not stable so add a\\n  // presortIndex that we can use to ensure we get a stable-sort\\n  this.captionPackets_.forEach(function(elem, idx) {\\n    elem.presortIndex = idx;\\n  });\\n\\n  // sort caption byte-pairs based on their PTS values\\n  this.captionPackets_.sort(function(a, b) {\\n    if (a.pts === b.pts) {\\n      return a.presortIndex - b.presortIndex;\\n    }\\n    return a.pts - b.pts;\\n  });\\n\\n  // Push each caption into Cea608Stream\\n  this.captionPackets_.forEach(this.field1_.push, this.field1_);\\n\\n  this.captionPackets_.length = 0;\\n  this.field1_.flush();\\n  return;\\n};\\n// ----------------------\\n// Session to Application\\n// ----------------------\\n\\nvar BASIC_CHARACTER_TRANSLATION = {\\n  0x2a: 0xe1,\\n  0x5c: 0xe9,\\n  0x5e: 0xed,\\n  0x5f: 0xf3,\\n  0x60: 0xfa,\\n  0x7b: 0xe7,\\n  0x7c: 0xf7,\\n  0x7d: 0xd1,\\n  0x7e: 0xf1,\\n  0x7f: 0x2588\\n};\\n\\nvar getCharFromCode = function(code) {\\n  if (code === null) {\\n    return '';\\n  }\\n  code = BASIC_CHARACTER_TRANSLATION[code] || code;\\n  return String.fromCharCode(code);\\n};\\n\\n// Constants for the byte codes recognized by Cea608Stream. This\\n// list is not exhaustive. For a more comprehensive listing and\\n// semantics see\\n// http://www.gpo.gov/fdsys/pkg/CFR-2010-title47-vol1/pdf/CFR-2010-title47-vol1-sec15-119.pdf\\nvar PADDING                    = 0x0000,\\n\\n    // Pop-on Mode\\n    RESUME_CAPTION_LOADING     = 0x1420,\\n    END_OF_CAPTION             = 0x142f,\\n\\n    // Roll-up Mode\\n    ROLL_UP_2_ROWS             = 0x1425,\\n    ROLL_UP_3_ROWS             = 0x1426,\\n    ROLL_UP_4_ROWS             = 0x1427,\\n    CARRIAGE_RETURN            = 0x142d,\\n    // Erasure\\n    BACKSPACE                  = 0x1421,\\n    ERASE_DISPLAYED_MEMORY     = 0x142c,\\n    ERASE_NON_DISPLAYED_MEMORY = 0x142e;\\n\\n// the index of the last row in a CEA-608 display buffer\\nvar BOTTOM_ROW = 14;\\n// CEA-608 captions are rendered onto a 34x15 matrix of character\\n// cells. The \\\"bottom\\\" row is the last element in the outer array.\\nvar createDisplayBuffer = function() {\\n  var result = [], i = BOTTOM_ROW + 1;\\n  while (i--) {\\n    result.push('');\\n  }\\n  return result;\\n};\\n\\nvar Cea608Stream = function() {\\n  Cea608Stream.prototype.init.call(this);\\n\\n  this.mode_ = 'popOn';\\n  // When in roll-up mode, the index of the last row that will\\n  // actually display captions. If a caption is shifted to a row\\n  // with a lower index than this, it is cleared from the display\\n  // buffer\\n  this.topRow_ = 0;\\n  this.startPts_ = 0;\\n  this.displayed_ = createDisplayBuffer();\\n  this.nonDisplayed_ = createDisplayBuffer();\\n  this.lastControlCode_ = null;\\n\\n  this.push = function(packet) {\\n    // Ignore other channels\\n    if (packet.type !== 0) {\\n      return;\\n    }\\n    var data, swap, char0, char1;\\n    // remove the parity bits\\n    data = packet.ccData & 0x7f7f;\\n\\n    // ignore duplicate control codes\\n    if (data === this.lastControlCode_) {\\n      this.lastControlCode_ = null;\\n      return;\\n    }\\n\\n    // Store control codes\\n    if ((data & 0xf000) === 0x1000) {\\n      this.lastControlCode_ = data;\\n    } else {\\n      this.lastControlCode_ = null;\\n    }\\n\\n    switch (data) {\\n    case PADDING:\\n      break;\\n    case RESUME_CAPTION_LOADING:\\n      this.mode_ = 'popOn';\\n      break;\\n    case END_OF_CAPTION:\\n      // if a caption was being displayed, it's gone now\\n      this.flushDisplayed(packet.pts);\\n\\n      // flip memory\\n      swap = this.displayed_;\\n      this.displayed_ = this.nonDisplayed_;\\n      this.nonDisplayed_ = swap;\\n\\n      // start measuring the time to display the caption\\n      this.startPts_ = packet.pts;\\n      break;\\n\\n    case ROLL_UP_2_ROWS:\\n      this.topRow_ = BOTTOM_ROW - 1;\\n      this.mode_ = 'rollUp';\\n      break;\\n    case ROLL_UP_3_ROWS:\\n      this.topRow_ = BOTTOM_ROW - 2;\\n      this.mode_ = 'rollUp';\\n      break;\\n    case ROLL_UP_4_ROWS:\\n      this.topRow_ = BOTTOM_ROW - 3;\\n      this.mode_ = 'rollUp';\\n      break;\\n    case CARRIAGE_RETURN:\\n      this.flushDisplayed(packet.pts);\\n      this.shiftRowsUp_();\\n      this.startPts_ = packet.pts;\\n      break;\\n\\n    case BACKSPACE:\\n      if (this.mode_ === 'popOn') {\\n        this.nonDisplayed_[BOTTOM_ROW] = this.nonDisplayed_[BOTTOM_ROW].slice(0, -1);\\n      } else {\\n        this.displayed_[BOTTOM_ROW] = this.displayed_[BOTTOM_ROW].slice(0, -1);\\n      }\\n      break;\\n    case ERASE_DISPLAYED_MEMORY:\\n      this.flushDisplayed(packet.pts);\\n      this.displayed_ = createDisplayBuffer();\\n      break;\\n    case ERASE_NON_DISPLAYED_MEMORY:\\n      this.nonDisplayed_ = createDisplayBuffer();\\n      break;\\n    default:\\n      char0 = data >>> 8;\\n      char1 = data & 0xff;\\n\\n      // Look for a Channel 1 Preamble Address Code\\n      if (char0 >= 0x10 && char0 <= 0x17 &&\\n          char1 >= 0x40 && char1 <= 0x7F &&\\n          (char0 !== 0x10 || char1 < 0x60)) {\\n        // Follow Safari's lead and replace the PAC with a space\\n        char0 = 0x20;\\n        // we only want one space so make the second character null\\n        // which will get become '' in getCharFromCode\\n        char1 = null;\\n      }\\n\\n      // Look for special character sets\\n      if ((char0 === 0x11 || char0 === 0x19) &&\\n          (char1 >= 0x30 && char1 <= 0x3F)) {\\n        // Put in eigth note and space\\n        char0 = 0x266A;\\n        char1 = '';\\n      }\\n\\n      // ignore unsupported control codes\\n      if ((char0 & 0xf0) === 0x10) {\\n        return;\\n      }\\n\\n      // character handling is dependent on the current mode\\n      this[this.mode_](packet.pts, char0, char1);\\n      break;\\n    }\\n  };\\n};\\nCea608Stream.prototype = new Stream();\\n// Trigger a cue point that captures the current state of the\\n// display buffer\\nCea608Stream.prototype.flushDisplayed = function(pts) {\\n  var content = this.displayed_\\n    // remove spaces from the start and end of the string\\n    .map(function(row) {\\n      return row.trim();\\n    })\\n    // remove empty rows\\n    .filter(function(row) {\\n      return row.length;\\n    })\\n    // combine all text rows to display in one cue\\n    .join('\\\\n');\\n\\n  if (content.length) {\\n    this.trigger('data', {\\n      startPts: this.startPts_,\\n      endPts: pts,\\n      text: content\\n    });\\n  }\\n};\\n\\n// Mode Implementations\\nCea608Stream.prototype.popOn = function(pts, char0, char1) {\\n  var baseRow = this.nonDisplayed_[BOTTOM_ROW];\\n\\n  // buffer characters\\n  baseRow += getCharFromCode(char0);\\n  baseRow += getCharFromCode(char1);\\n  this.nonDisplayed_[BOTTOM_ROW] = baseRow;\\n};\\n\\nCea608Stream.prototype.rollUp = function(pts, char0, char1) {\\n  var baseRow = this.displayed_[BOTTOM_ROW];\\n  if (baseRow === '') {\\n    // we're starting to buffer new display input, so flush out the\\n    // current display\\n    this.flushDisplayed(pts);\\n\\n    this.startPts_ = pts;\\n  }\\n\\n  baseRow += getCharFromCode(char0);\\n  baseRow += getCharFromCode(char1);\\n\\n  this.displayed_[BOTTOM_ROW] = baseRow;\\n};\\nCea608Stream.prototype.shiftRowsUp_ = function() {\\n  var i;\\n  // clear out inactive rows\\n  for (i = 0; i < this.topRow_; i++) {\\n    this.displayed_[i] = '';\\n  }\\n  // shift displayed rows up\\n  for (i = this.topRow_; i < BOTTOM_ROW; i++) {\\n    this.displayed_[i] = this.displayed_[i + 1];\\n  }\\n  // clear out the bottom row\\n  this.displayed_[BOTTOM_ROW] = '';\\n};\\n\\n// exports\\nmodule.exports = {\\n  CaptionStream: CaptionStream,\\n  Cea608Stream: Cea608Stream\\n};\\n\\n},{\\\"../utils/stream\\\":94}],86:[function(require,module,exports){\\n/**\\n * mux.js\\n *\\n * Copyright (c) 2015 Brightcove\\n * All rights reserved.\\n *\\n * A stream-based mp2t to mp4 converter. This utility can be used to\\n * deliver mp4s to a SourceBuffer on platforms that support native\\n * Media Source Extensions.\\n */\\n'use strict';\\nvar Stream = require('../utils/stream.js'),\\n  CaptionStream = require('./caption-stream'),\\n  StreamTypes = require('./stream-types'),\\n  TimestampRolloverStream = require('./timestamp-rollover-stream');\\n\\nvar m2tsStreamTypes = require('./stream-types.js');\\n\\n// object types\\nvar TransportPacketStream, TransportParseStream, ElementaryStream;\\n\\n// constants\\nvar\\n  MP2T_PACKET_LENGTH = 188, // bytes\\n  SYNC_BYTE = 0x47;\\n\\n/**\\n * Splits an incoming stream of binary data into MPEG-2 Transport\\n * Stream packets.\\n */\\nTransportPacketStream = function() {\\n  var\\n    buffer = new Uint8Array(MP2T_PACKET_LENGTH),\\n    bytesInBuffer = 0;\\n\\n  TransportPacketStream.prototype.init.call(this);\\n\\n   // Deliver new bytes to the stream.\\n\\n  this.push = function(bytes) {\\n    var\\n      startIndex = 0,\\n      endIndex = MP2T_PACKET_LENGTH,\\n      everything;\\n\\n    // If there are bytes remaining from the last segment, prepend them to the\\n    // bytes that were pushed in\\n    if (bytesInBuffer) {\\n      everything = new Uint8Array(bytes.byteLength + bytesInBuffer);\\n      everything.set(buffer.subarray(0, bytesInBuffer));\\n      everything.set(bytes, bytesInBuffer);\\n      bytesInBuffer = 0;\\n    } else {\\n      everything = bytes;\\n    }\\n\\n    // While we have enough data for a packet\\n    while (endIndex < everything.byteLength) {\\n      // Look for a pair of start and end sync bytes in the data..\\n      if (everything[startIndex] === SYNC_BYTE && everything[endIndex] === SYNC_BYTE) {\\n        // We found a packet so emit it and jump one whole packet forward in\\n        // the stream\\n        this.trigger('data', everything.subarray(startIndex, endIndex));\\n        startIndex += MP2T_PACKET_LENGTH;\\n        endIndex += MP2T_PACKET_LENGTH;\\n        continue;\\n      }\\n      // If we get here, we have somehow become de-synchronized and we need to step\\n      // forward one byte at a time until we find a pair of sync bytes that denote\\n      // a packet\\n      startIndex++;\\n      endIndex++;\\n    }\\n\\n    // If there was some data left over at the end of the segment that couldn't\\n    // possibly be a whole packet, keep it because it might be the start of a packet\\n    // that continues in the next segment\\n    if (startIndex < everything.byteLength) {\\n      buffer.set(everything.subarray(startIndex), 0);\\n      bytesInBuffer = everything.byteLength - startIndex;\\n    }\\n  };\\n\\n  this.flush = function() {\\n    // If the buffer contains a whole packet when we are being flushed, emit it\\n    // and empty the buffer. Otherwise hold onto the data because it may be\\n    // important for decoding the next segment\\n    if (bytesInBuffer === MP2T_PACKET_LENGTH && buffer[0] === SYNC_BYTE) {\\n      this.trigger('data', buffer);\\n      bytesInBuffer = 0;\\n    }\\n    this.trigger('done');\\n  };\\n};\\nTransportPacketStream.prototype = new Stream();\\n\\n/**\\n * Accepts an MP2T TransportPacketStream and emits data events with parsed\\n * forms of the individual transport stream packets.\\n */\\nTransportParseStream = function() {\\n  var parsePsi, parsePat, parsePmt, self;\\n  TransportParseStream.prototype.init.call(this);\\n  self = this;\\n\\n  this.packetsWaitingForPmt = [];\\n  this.programMapTable = undefined;\\n\\n  parsePsi = function(payload, psi) {\\n    var offset = 0;\\n\\n    // PSI packets may be split into multiple sections and those\\n    // sections may be split into multiple packets. If a PSI\\n    // section starts in this packet, the payload_unit_start_indicator\\n    // will be true and the first byte of the payload will indicate\\n    // the offset from the current position to the start of the\\n    // section.\\n    if (psi.payloadUnitStartIndicator) {\\n      offset += payload[offset] + 1;\\n    }\\n\\n    if (psi.type === 'pat') {\\n      parsePat(payload.subarray(offset), psi);\\n    } else {\\n      parsePmt(payload.subarray(offset), psi);\\n    }\\n  };\\n\\n  parsePat = function(payload, pat) {\\n    pat.section_number = payload[7]; // eslint-disable-line camelcase\\n    pat.last_section_number = payload[8]; // eslint-disable-line camelcase\\n\\n    // skip the PSI header and parse the first PMT entry\\n    self.pmtPid = (payload[10] & 0x1F) << 8 | payload[11];\\n    pat.pmtPid = self.pmtPid;\\n  };\\n\\n  /**\\n   * Parse out the relevant fields of a Program Map Table (PMT).\\n   * @param payload {Uint8Array} the PMT-specific portion of an MP2T\\n   * packet. The first byte in this array should be the table_id\\n   * field.\\n   * @param pmt {object} the object that should be decorated with\\n   * fields parsed from the PMT.\\n   */\\n  parsePmt = function(payload, pmt) {\\n    var sectionLength, tableEnd, programInfoLength, offset;\\n\\n    // PMTs can be sent ahead of the time when they should actually\\n    // take effect. We don't believe this should ever be the case\\n    // for HLS but we'll ignore \\\"forward\\\" PMT declarations if we see\\n    // them. Future PMT declarations have the current_next_indicator\\n    // set to zero.\\n    if (!(payload[5] & 0x01)) {\\n      return;\\n    }\\n\\n    // overwrite any existing program map table\\n    self.programMapTable = {};\\n\\n    // the mapping table ends at the end of the current section\\n    sectionLength = (payload[1] & 0x0f) << 8 | payload[2];\\n    tableEnd = 3 + sectionLength - 4;\\n\\n    // to determine where the table is, we have to figure out how\\n    // long the program info descriptors are\\n    programInfoLength = (payload[10] & 0x0f) << 8 | payload[11];\\n\\n    // advance the offset to the first entry in the mapping table\\n    offset = 12 + programInfoLength;\\n    while (offset < tableEnd) {\\n      // add an entry that maps the elementary_pid to the stream_type\\n      self.programMapTable[(payload[offset + 1] & 0x1F) << 8 | payload[offset + 2]] = payload[offset];\\n\\n      // move to the next table entry\\n      // skip past the elementary stream descriptors, if present\\n      offset += ((payload[offset + 3] & 0x0F) << 8 | payload[offset + 4]) + 5;\\n    }\\n\\n    // record the map on the packet as well\\n    pmt.programMapTable = self.programMapTable;\\n\\n    // if there are any packets waiting for a PMT to be found, process them now\\n    while (self.packetsWaitingForPmt.length) {\\n      self.processPes_.apply(self, self.packetsWaitingForPmt.shift());\\n    }\\n  };\\n\\n  /**\\n   * Deliver a new MP2T packet to the stream.\\n   */\\n  this.push = function(packet) {\\n    var\\n      result = {},\\n      offset = 4;\\n\\n    result.payloadUnitStartIndicator = !!(packet[1] & 0x40);\\n\\n    // pid is a 13-bit field starting at the last bit of packet[1]\\n    result.pid = packet[1] & 0x1f;\\n    result.pid <<= 8;\\n    result.pid |= packet[2];\\n\\n    // if an adaption field is present, its length is specified by the\\n    // fifth byte of the TS packet header. The adaptation field is\\n    // used to add stuffing to PES packets that don't fill a complete\\n    // TS packet, and to specify some forms of timing and control data\\n    // that we do not currently use.\\n    if (((packet[3] & 0x30) >>> 4) > 0x01) {\\n      offset += packet[offset] + 1;\\n    }\\n\\n    // parse the rest of the packet based on the type\\n    if (result.pid === 0) {\\n      result.type = 'pat';\\n      parsePsi(packet.subarray(offset), result);\\n      this.trigger('data', result);\\n    } else if (result.pid === this.pmtPid) {\\n      result.type = 'pmt';\\n      parsePsi(packet.subarray(offset), result);\\n      this.trigger('data', result);\\n    } else if (this.programMapTable === undefined) {\\n      // When we have not seen a PMT yet, defer further processing of\\n      // PES packets until one has been parsed\\n      this.packetsWaitingForPmt.push([packet, offset, result]);\\n    } else {\\n      this.processPes_(packet, offset, result);\\n    }\\n  };\\n\\n  this.processPes_ = function(packet, offset, result) {\\n    result.streamType = this.programMapTable[result.pid];\\n    result.type = 'pes';\\n    result.data = packet.subarray(offset);\\n\\n    this.trigger('data', result);\\n  };\\n\\n};\\nTransportParseStream.prototype = new Stream();\\nTransportParseStream.STREAM_TYPES  = {\\n  h264: 0x1b,\\n  adts: 0x0f\\n};\\n\\n/**\\n * Reconsistutes program elementary stream (PES) packets from parsed\\n * transport stream packets. That is, if you pipe an\\n * mp2t.TransportParseStream into a mp2t.ElementaryStream, the output\\n * events will be events which capture the bytes for individual PES\\n * packets plus relevant metadata that has been extracted from the\\n * container.\\n */\\nElementaryStream = function() {\\n  var\\n    self = this,\\n    // PES packet fragments\\n    video = {\\n      data: [],\\n      size: 0\\n    },\\n    audio = {\\n      data: [],\\n      size: 0\\n    },\\n    timedMetadata = {\\n      data: [],\\n      size: 0\\n    },\\n    parsePes = function(payload, pes) {\\n      var ptsDtsFlags;\\n\\n      // find out if this packets starts a new keyframe\\n      pes.dataAlignmentIndicator = (payload[6] & 0x04) !== 0;\\n      // PES packets may be annotated with a PTS value, or a PTS value\\n      // and a DTS value. Determine what combination of values is\\n      // available to work with.\\n      ptsDtsFlags = payload[7];\\n\\n      // PTS and DTS are normally stored as a 33-bit number.  Javascript\\n      // performs all bitwise operations on 32-bit integers but javascript\\n      // supports a much greater range (52-bits) of integer using standard\\n      // mathematical operations.\\n      // We construct a 31-bit value using bitwise operators over the 31\\n      // most significant bits and then multiply by 4 (equal to a left-shift\\n      // of 2) before we add the final 2 least significant bits of the\\n      // timestamp (equal to an OR.)\\n      if (ptsDtsFlags & 0xC0) {\\n        // the PTS and DTS are not written out directly. For information\\n        // on how they are encoded, see\\n        // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\\n        pes.pts = (payload[9] & 0x0E) << 27 |\\n          (payload[10] & 0xFF) << 20 |\\n          (payload[11] & 0xFE) << 12 |\\n          (payload[12] & 0xFF) <<  5 |\\n          (payload[13] & 0xFE) >>>  3;\\n        pes.pts *= 4; // Left shift by 2\\n        pes.pts += (payload[13] & 0x06) >>> 1; // OR by the two LSBs\\n        pes.dts = pes.pts;\\n        if (ptsDtsFlags & 0x40) {\\n          pes.dts = (payload[14] & 0x0E) << 27 |\\n            (payload[15] & 0xFF) << 20 |\\n            (payload[16] & 0xFE) << 12 |\\n            (payload[17] & 0xFF) << 5 |\\n            (payload[18] & 0xFE) >>> 3;\\n          pes.dts *= 4; // Left shift by 2\\n          pes.dts += (payload[18] & 0x06) >>> 1; // OR by the two LSBs\\n        }\\n      }\\n      // the data section starts immediately after the PES header.\\n      // pes_header_data_length specifies the number of header bytes\\n      // that follow the last byte of the field.\\n      pes.data = payload.subarray(9 + payload[8]);\\n    },\\n    flushStream = function(stream, type) {\\n      var\\n        packetData = new Uint8Array(stream.size),\\n        event = {\\n          type: type\\n        },\\n        i = 0,\\n        fragment;\\n\\n      // do nothing if there is no buffered data\\n      if (!stream.data.length) {\\n        return;\\n      }\\n      event.trackId = stream.data[0].pid;\\n\\n      // reassemble the packet\\n      while (stream.data.length) {\\n        fragment = stream.data.shift();\\n\\n        packetData.set(fragment.data, i);\\n        i += fragment.data.byteLength;\\n      }\\n\\n      // parse assembled packet's PES header\\n      parsePes(packetData, event);\\n\\n      stream.size = 0;\\n\\n      self.trigger('data', event);\\n    };\\n\\n  ElementaryStream.prototype.init.call(this);\\n\\n  this.push = function(data) {\\n    ({\\n      pat: function() {\\n        // we have to wait for the PMT to arrive as well before we\\n        // have any meaningful metadata\\n      },\\n      pes: function() {\\n        var stream, streamType;\\n\\n        switch (data.streamType) {\\n        case StreamTypes.H264_STREAM_TYPE:\\n        case m2tsStreamTypes.H264_STREAM_TYPE:\\n          stream = video;\\n          streamType = 'video';\\n          break;\\n        case StreamTypes.ADTS_STREAM_TYPE:\\n          stream = audio;\\n          streamType = 'audio';\\n          break;\\n        case StreamTypes.METADATA_STREAM_TYPE:\\n          stream = timedMetadata;\\n          streamType = 'timed-metadata';\\n          break;\\n        default:\\n          // ignore unknown stream types\\n          return;\\n        }\\n\\n        // if a new packet is starting, we can flush the completed\\n        // packet\\n        if (data.payloadUnitStartIndicator) {\\n          flushStream(stream, streamType);\\n        }\\n\\n        // buffer this fragment until we are sure we've received the\\n        // complete payload\\n        stream.data.push(data);\\n        stream.size += data.data.byteLength;\\n      },\\n      pmt: function() {\\n        var\\n          event = {\\n            type: 'metadata',\\n            tracks: []\\n          },\\n          programMapTable = data.programMapTable,\\n          k,\\n          track;\\n\\n        // translate streams to tracks\\n        for (k in programMapTable) {\\n          if (programMapTable.hasOwnProperty(k)) {\\n            track = {\\n              timelineStartInfo: {\\n                baseMediaDecodeTime: 0\\n              }\\n            };\\n            track.id = +k;\\n            if (programMapTable[k] === m2tsStreamTypes.H264_STREAM_TYPE) {\\n              track.codec = 'avc';\\n              track.type = 'video';\\n            } else if (programMapTable[k] === m2tsStreamTypes.ADTS_STREAM_TYPE) {\\n              track.codec = 'adts';\\n              track.type = 'audio';\\n            }\\n            event.tracks.push(track);\\n          }\\n        }\\n        self.trigger('data', event);\\n      }\\n    })[data.type]();\\n  };\\n\\n  /**\\n   * Flush any remaining input. Video PES packets may be of variable\\n   * length. Normally, the start of a new video packet can trigger the\\n   * finalization of the previous packet. That is not possible if no\\n   * more video is forthcoming, however. In that case, some other\\n   * mechanism (like the end of the file) has to be employed. When it is\\n   * clear that no additional data is forthcoming, calling this method\\n   * will flush the buffered packets.\\n   */\\n  this.flush = function() {\\n    // !!THIS ORDER IS IMPORTANT!!\\n    // video first then audio\\n    flushStream(video, 'video');\\n    flushStream(audio, 'audio');\\n    flushStream(timedMetadata, 'timed-metadata');\\n    this.trigger('done');\\n  };\\n};\\nElementaryStream.prototype = new Stream();\\n\\nvar m2ts = {\\n  PAT_PID: 0x0000,\\n  MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH,\\n  TransportPacketStream: TransportPacketStream,\\n  TransportParseStream: TransportParseStream,\\n  ElementaryStream: ElementaryStream,\\n  TimestampRolloverStream: TimestampRolloverStream,\\n  CaptionStream: CaptionStream.CaptionStream,\\n  Cea608Stream: CaptionStream.Cea608Stream,\\n  MetadataStream: require('./metadata-stream')\\n};\\n\\nfor (var type in StreamTypes) {\\n  if (StreamTypes.hasOwnProperty(type)) {\\n    m2ts[type] = StreamTypes[type];\\n  }\\n}\\n\\nmodule.exports = m2ts;\\n\\n},{\\\"../utils/stream.js\\\":94,\\\"./caption-stream\\\":85,\\\"./metadata-stream\\\":87,\\\"./stream-types\\\":88,\\\"./stream-types.js\\\":88,\\\"./timestamp-rollover-stream\\\":89}],87:[function(require,module,exports){\\n/**\\n * Accepts program elementary stream (PES) data events and parses out\\n * ID3 metadata from them, if present.\\n * @see http://id3.org/id3v2.3.0\\n */\\n'use strict';\\nvar\\n  Stream = require('../utils/stream'),\\n  StreamTypes = require('./stream-types'),\\n  // return a percent-encoded representation of the specified byte range\\n  // @see http://en.wikipedia.org/wiki/Percent-encoding\\n  percentEncode = function(bytes, start, end) {\\n    var i, result = '';\\n    for (i = start; i < end; i++) {\\n      result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\\n    }\\n    return result;\\n  },\\n  // return the string representation of the specified byte range,\\n  // interpreted as UTf-8.\\n  parseUtf8 = function(bytes, start, end) {\\n    return decodeURIComponent(percentEncode(bytes, start, end));\\n  },\\n  // return the string representation of the specified byte range,\\n  // interpreted as ISO-8859-1.\\n  parseIso88591 = function(bytes, start, end) {\\n    return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\\n  },\\n  parseSyncSafeInteger = function(data) {\\n    return (data[0] << 21) |\\n            (data[1] << 14) |\\n            (data[2] << 7) |\\n            (data[3]);\\n  },\\n  tagParsers = {\\n    TXXX: function(tag) {\\n      var i;\\n      if (tag.data[0] !== 3) {\\n        // ignore frames with unrecognized character encodings\\n        return;\\n      }\\n\\n      for (i = 1; i < tag.data.length; i++) {\\n        if (tag.data[i] === 0) {\\n          // parse the text fields\\n          tag.description = parseUtf8(tag.data, 1, i);\\n          // do not include the null terminator in the tag value\\n          tag.value = parseUtf8(tag.data, i + 1, tag.data.length - 1);\\n          break;\\n        }\\n      }\\n      tag.data = tag.value;\\n    },\\n    WXXX: function(tag) {\\n      var i;\\n      if (tag.data[0] !== 3) {\\n        // ignore frames with unrecognized character encodings\\n        return;\\n      }\\n\\n      for (i = 1; i < tag.data.length; i++) {\\n        if (tag.data[i] === 0) {\\n          // parse the description and URL fields\\n          tag.description = parseUtf8(tag.data, 1, i);\\n          tag.url = parseUtf8(tag.data, i + 1, tag.data.length);\\n          break;\\n        }\\n      }\\n    },\\n    PRIV: function(tag) {\\n      var i;\\n\\n      for (i = 0; i < tag.data.length; i++) {\\n        if (tag.data[i] === 0) {\\n          // parse the description and URL fields\\n          tag.owner = parseIso88591(tag.data, 0, i);\\n          break;\\n        }\\n      }\\n      tag.privateData = tag.data.subarray(i + 1);\\n      tag.data = tag.privateData;\\n    }\\n  },\\n  MetadataStream;\\n\\nMetadataStream = function(options) {\\n  var\\n    settings = {\\n      debug: !!(options && options.debug),\\n\\n      // the bytes of the program-level descriptor field in MP2T\\n      // see ISO/IEC 13818-1:2013 (E), section 2.6 \\\"Program and\\n      // program element descriptors\\\"\\n      descriptor: options && options.descriptor\\n    },\\n    // the total size in bytes of the ID3 tag being parsed\\n    tagSize = 0,\\n    // tag data that is not complete enough to be parsed\\n    buffer = [],\\n    // the total number of bytes currently in the buffer\\n    bufferSize = 0,\\n    i;\\n\\n  MetadataStream.prototype.init.call(this);\\n\\n  // calculate the text track in-band metadata track dispatch type\\n  // https://html.spec.whatwg.org/multipage/embedded-content.html#steps-to-expose-a-media-resource-specific-text-track\\n  this.dispatchType = StreamTypes.METADATA_STREAM_TYPE.toString(16);\\n  if (settings.descriptor) {\\n    for (i = 0; i < settings.descriptor.length; i++) {\\n      this.dispatchType += ('00' + settings.descriptor[i].toString(16)).slice(-2);\\n    }\\n  }\\n\\n  this.push = function(chunk) {\\n    var tag, frameStart, frameSize, frame, i, frameHeader;\\n    if (chunk.type !== 'timed-metadata') {\\n      return;\\n    }\\n\\n    // if data_alignment_indicator is set in the PES header,\\n    // we must have the start of a new ID3 tag. Assume anything\\n    // remaining in the buffer was malformed and throw it out\\n    if (chunk.dataAlignmentIndicator) {\\n      bufferSize = 0;\\n      buffer.length = 0;\\n    }\\n\\n    // ignore events that don't look like ID3 data\\n    if (buffer.length === 0 &&\\n        (chunk.data.length < 10 ||\\n          chunk.data[0] !== 'I'.charCodeAt(0) ||\\n          chunk.data[1] !== 'D'.charCodeAt(0) ||\\n          chunk.data[2] !== '3'.charCodeAt(0))) {\\n      if (settings.debug) {\\n        // eslint-disable-next-line no-console\\n        console.log('Skipping unrecognized metadata packet');\\n      }\\n      return;\\n    }\\n\\n    // add this chunk to the data we've collected so far\\n\\n    buffer.push(chunk);\\n    bufferSize += chunk.data.byteLength;\\n\\n    // grab the size of the entire frame from the ID3 header\\n    if (buffer.length === 1) {\\n      // the frame size is transmitted as a 28-bit integer in the\\n      // last four bytes of the ID3 header.\\n      // The most significant bit of each byte is dropped and the\\n      // results concatenated to recover the actual value.\\n      tagSize = parseSyncSafeInteger(chunk.data.subarray(6, 10));\\n\\n      // ID3 reports the tag size excluding the header but it's more\\n      // convenient for our comparisons to include it\\n      tagSize += 10;\\n    }\\n\\n    // if the entire frame has not arrived, wait for more data\\n    if (bufferSize < tagSize) {\\n      return;\\n    }\\n\\n    // collect the entire frame so it can be parsed\\n    tag = {\\n      data: new Uint8Array(tagSize),\\n      frames: [],\\n      pts: buffer[0].pts,\\n      dts: buffer[0].dts\\n    };\\n    for (i = 0; i < tagSize;) {\\n      tag.data.set(buffer[0].data.subarray(0, tagSize - i), i);\\n      i += buffer[0].data.byteLength;\\n      bufferSize -= buffer[0].data.byteLength;\\n      buffer.shift();\\n    }\\n\\n    // find the start of the first frame and the end of the tag\\n    frameStart = 10;\\n    if (tag.data[5] & 0x40) {\\n      // advance the frame start past the extended header\\n      frameStart += 4; // header size field\\n      frameStart += parseSyncSafeInteger(tag.data.subarray(10, 14));\\n\\n      // clip any padding off the end\\n      tagSize -= parseSyncSafeInteger(tag.data.subarray(16, 20));\\n    }\\n\\n    // parse one or more ID3 frames\\n    // http://id3.org/id3v2.3.0#ID3v2_frame_overview\\n    do {\\n      // determine the number of bytes in this frame\\n      frameSize = parseSyncSafeInteger(tag.data.subarray(frameStart + 4, frameStart + 8));\\n      if (frameSize < 1) {\\n         // eslint-disable-next-line no-console\\n        return console.log('Malformed ID3 frame encountered. Skipping metadata parsing.');\\n      }\\n      frameHeader = String.fromCharCode(tag.data[frameStart],\\n                                        tag.data[frameStart + 1],\\n                                        tag.data[frameStart + 2],\\n                                        tag.data[frameStart + 3]);\\n\\n\\n      frame = {\\n        id: frameHeader,\\n        data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)\\n      };\\n      frame.key = frame.id;\\n      if (tagParsers[frame.id]) {\\n        tagParsers[frame.id](frame);\\n        if (frame.owner === 'com.apple.streaming.transportStreamTimestamp') {\\n          var\\n            d = frame.data,\\n            size = ((d[3] & 0x01)  << 30) |\\n                   (d[4]  << 22) |\\n                   (d[5] << 14) |\\n                   (d[6] << 6) |\\n                   (d[7] >>> 2);\\n\\n          size *= 4;\\n          size += d[7] & 0x03;\\n          frame.timeStamp = size;\\n          this.trigger('timestamp', frame);\\n        }\\n      }\\n      tag.frames.push(frame);\\n\\n      frameStart += 10; // advance past the frame header\\n      frameStart += frameSize; // advance past the frame body\\n    } while (frameStart < tagSize);\\n    this.trigger('data', tag);\\n  };\\n};\\nMetadataStream.prototype = new Stream();\\n\\nmodule.exports = MetadataStream;\\n\\n},{\\\"../utils/stream\\\":94,\\\"./stream-types\\\":88}],88:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = {\\n  H264_STREAM_TYPE: 0x1B,\\n  ADTS_STREAM_TYPE: 0x0F,\\n  METADATA_STREAM_TYPE: 0x15\\n};\\n\\n},{}],89:[function(require,module,exports){\\n/**\\n * mux.js\\n *\\n * Copyright (c) 2016 Brightcove\\n * All rights reserved.\\n *\\n * Accepts program elementary stream (PES) data events and corrects\\n * decode and presentation time stamps to account for a rollover\\n * of the 33 bit value.\\n */\\n\\n'use strict';\\n\\nvar Stream = require('../utils/stream');\\n\\nvar MAX_TS = 8589934592;\\n\\nvar RO_THRESH = 4294967296;\\n\\nvar TimestampRolloverStream = function(type) {\\n  var lastDTS, referenceDTS;\\n\\n  TimestampRolloverStream.prototype.init.call(this);\\n\\n  this.type_ = type;\\n\\n  var handleRollover = function(value, reference) {\\n    var direction = 1;\\n\\n    if (value > reference) {\\n      // If the current timestamp value is greater than our reference timestamp and we detect a\\n      // timestamp rollover, this means the roll over is happening in the opposite direction.\\n      // Example scenario: Enter a long stream/video just after a rollover occurred. The reference\\n      // point will be set to a small number, e.g. 1. The user then seeks backwards over the\\n      // rollover point. In loading this segment, the timestamp values will be very large,\\n      // e.g. 2^33 - 1. Since this comes before the data we loaded previously, we want to adjust\\n      // the time stamp to be `value - 2^33`.\\n      direction = -1;\\n    }\\n\\n    // Note: A seek forwards or back that is greater than the RO_THRESH (2^32, ~13 hours) will\\n    // cause an incorrect adjustment.\\n    while (Math.abs(reference - value) > RO_THRESH) {\\n      value += (direction * MAX_TS);\\n    }\\n\\n    return value;\\n  };\\n\\n  this.push = function(data) {\\n    if (data.type !== this.type_) {\\n      return;\\n    }\\n\\n    if (referenceDTS === undefined) {\\n      referenceDTS = data.dts;\\n    }\\n\\n    data.dts = handleRollover(data.dts, referenceDTS);\\n    data.pts = handleRollover(data.pts, referenceDTS);\\n\\n    lastDTS = data.dts;\\n\\n    this.trigger('data', data);\\n  };\\n\\n  this.flush = function() {\\n    referenceDTS = lastDTS;\\n    this.trigger('done');\\n  };\\n\\n};\\n\\nTimestampRolloverStream.prototype = new Stream();\\n\\nmodule.exports = TimestampRolloverStream;\\n\\n},{\\\"../utils/stream\\\":94}],90:[function(require,module,exports){\\nmodule.exports = {\\n  generator: require('./mp4-generator'),\\n  Transmuxer: require('./transmuxer').Transmuxer,\\n  AudioSegmentStream: require('./transmuxer').AudioSegmentStream,\\n  VideoSegmentStream: require('./transmuxer').VideoSegmentStream\\n};\\n\\n},{\\\"./mp4-generator\\\":91,\\\"./transmuxer\\\":92}],91:[function(require,module,exports){\\n/**\\n * mux.js\\n *\\n * Copyright (c) 2015 Brightcove\\n * All rights reserved.\\n *\\n * Functions that generate fragmented MP4s suitable for use with Media\\n * Source Extensions.\\n */\\n'use strict';\\n\\nvar box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd,\\n    trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex,\\n    trun, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR,\\n    AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS;\\n\\n// pre-calculate constants\\n(function() {\\n  var i;\\n  types = {\\n    avc1: [], // codingname\\n    avcC: [],\\n    btrt: [],\\n    dinf: [],\\n    dref: [],\\n    esds: [],\\n    ftyp: [],\\n    hdlr: [],\\n    mdat: [],\\n    mdhd: [],\\n    mdia: [],\\n    mfhd: [],\\n    minf: [],\\n    moof: [],\\n    moov: [],\\n    mp4a: [], // codingname\\n    mvex: [],\\n    mvhd: [],\\n    sdtp: [],\\n    smhd: [],\\n    stbl: [],\\n    stco: [],\\n    stsc: [],\\n    stsd: [],\\n    stsz: [],\\n    stts: [],\\n    styp: [],\\n    tfdt: [],\\n    tfhd: [],\\n    traf: [],\\n    trak: [],\\n    trun: [],\\n    trex: [],\\n    tkhd: [],\\n    vmhd: []\\n  };\\n\\n  // In environments where Uint8Array is undefined (e.g., IE8), skip set up so that we\\n  // don't throw an error\\n  if (typeof Uint8Array === 'undefined') {\\n    return;\\n  }\\n\\n  for (i in types) {\\n    if (types.hasOwnProperty(i)) {\\n      types[i] = [\\n        i.charCodeAt(0),\\n        i.charCodeAt(1),\\n        i.charCodeAt(2),\\n        i.charCodeAt(3)\\n      ];\\n    }\\n  }\\n\\n  MAJOR_BRAND = new Uint8Array([\\n    'i'.charCodeAt(0),\\n    's'.charCodeAt(0),\\n    'o'.charCodeAt(0),\\n    'm'.charCodeAt(0)\\n  ]);\\n  AVC1_BRAND = new Uint8Array([\\n    'a'.charCodeAt(0),\\n    'v'.charCodeAt(0),\\n    'c'.charCodeAt(0),\\n    '1'.charCodeAt(0)\\n  ]);\\n  MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);\\n  VIDEO_HDLR = new Uint8Array([\\n    0x00, // version 0\\n    0x00, 0x00, 0x00, // flags\\n    0x00, 0x00, 0x00, 0x00, // pre_defined\\n    0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\\n    0x00, 0x00, 0x00, 0x00, // reserved\\n    0x00, 0x00, 0x00, 0x00, // reserved\\n    0x00, 0x00, 0x00, 0x00, // reserved\\n    0x56, 0x69, 0x64, 0x65,\\n    0x6f, 0x48, 0x61, 0x6e,\\n    0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\\n  ]);\\n  AUDIO_HDLR = new Uint8Array([\\n    0x00, // version 0\\n    0x00, 0x00, 0x00, // flags\\n    0x00, 0x00, 0x00, 0x00, // pre_defined\\n    0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\\n    0x00, 0x00, 0x00, 0x00, // reserved\\n    0x00, 0x00, 0x00, 0x00, // reserved\\n    0x00, 0x00, 0x00, 0x00, // reserved\\n    0x53, 0x6f, 0x75, 0x6e,\\n    0x64, 0x48, 0x61, 0x6e,\\n    0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\\n  ]);\\n  HDLR_TYPES = {\\n    video: VIDEO_HDLR,\\n    audio: AUDIO_HDLR\\n  };\\n  DREF = new Uint8Array([\\n    0x00, // version 0\\n    0x00, 0x00, 0x00, // flags\\n    0x00, 0x00, 0x00, 0x01, // entry_count\\n    0x00, 0x00, 0x00, 0x0c, // entry_size\\n    0x75, 0x72, 0x6c, 0x20, // 'url' type\\n    0x00, // version 0\\n    0x00, 0x00, 0x01 // entry_flags\\n  ]);\\n  SMHD = new Uint8Array([\\n    0x00,             // version\\n    0x00, 0x00, 0x00, // flags\\n    0x00, 0x00,       // balance, 0 means centered\\n    0x00, 0x00        // reserved\\n  ]);\\n  STCO = new Uint8Array([\\n    0x00, // version\\n    0x00, 0x00, 0x00, // flags\\n    0x00, 0x00, 0x00, 0x00 // entry_count\\n  ]);\\n  STSC = STCO;\\n  STSZ = new Uint8Array([\\n    0x00, // version\\n    0x00, 0x00, 0x00, // flags\\n    0x00, 0x00, 0x00, 0x00, // sample_size\\n    0x00, 0x00, 0x00, 0x00 // sample_count\\n  ]);\\n  STTS = STCO;\\n  VMHD = new Uint8Array([\\n    0x00, // version\\n    0x00, 0x00, 0x01, // flags\\n    0x00, 0x00, // graphicsmode\\n    0x00, 0x00,\\n    0x00, 0x00,\\n    0x00, 0x00 // opcolor\\n  ]);\\n}());\\n\\nbox = function(type) {\\n  var\\n    payload = [],\\n    size = 0,\\n    i,\\n    result,\\n    view;\\n\\n  for (i = 1; i < arguments.length; i++) {\\n    payload.push(arguments[i]);\\n  }\\n\\n  i = payload.length;\\n\\n  // calculate the total size we need to allocate\\n  while (i--) {\\n    size += payload[i].byteLength;\\n  }\\n  result = new Uint8Array(size + 8);\\n  view = new DataView(result.buffer, result.byteOffset, result.byteLength);\\n  view.setUint32(0, result.byteLength);\\n  result.set(type, 4);\\n\\n  // copy the payload into the result\\n  for (i = 0, size = 8; i < payload.length; i++) {\\n    result.set(payload[i], size);\\n    size += payload[i].byteLength;\\n  }\\n  return result;\\n};\\n\\ndinf = function() {\\n  return box(types.dinf, box(types.dref, DREF));\\n};\\n\\nesds = function(track) {\\n  return box(types.esds, new Uint8Array([\\n    0x00, // version\\n    0x00, 0x00, 0x00, // flags\\n\\n    // ES_Descriptor\\n    0x03, // tag, ES_DescrTag\\n    0x19, // length\\n    0x00, 0x00, // ES_ID\\n    0x00, // streamDependenceFlag, URL_flag, reserved, streamPriority\\n\\n    // DecoderConfigDescriptor\\n    0x04, // tag, DecoderConfigDescrTag\\n    0x11, // length\\n    0x40, // object type\\n    0x15,  // streamType\\n    0x00, 0x06, 0x00, // bufferSizeDB\\n    0x00, 0x00, 0xda, 0xc0, // maxBitrate\\n    0x00, 0x00, 0xda, 0xc0, // avgBitrate\\n\\n    // DecoderSpecificInfo\\n    0x05, // tag, DecoderSpecificInfoTag\\n    0x02, // length\\n    // ISO/IEC 14496-3, AudioSpecificConfig\\n    // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35\\n    (track.audioobjecttype << 3) | (track.samplingfrequencyindex >>> 1),\\n    (track.samplingfrequencyindex << 7) | (track.channelcount << 3),\\n    0x06, 0x01, 0x02 // GASpecificConfig\\n  ]));\\n};\\n\\nftyp = function() {\\n  return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);\\n};\\n\\nhdlr = function(type) {\\n  return box(types.hdlr, HDLR_TYPES[type]);\\n};\\nmdat = function(data) {\\n  return box(types.mdat, data);\\n};\\nmdhd = function(track) {\\n  var result = new Uint8Array([\\n    0x00,                   // version 0\\n    0x00, 0x00, 0x00,       // flags\\n    0x00, 0x00, 0x00, 0x02, // creation_time\\n    0x00, 0x00, 0x00, 0x03, // modification_time\\n    0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \\\"ticks\\\" per second\\n\\n    (track.duration >>> 24) & 0xFF,\\n    (track.duration >>> 16) & 0xFF,\\n    (track.duration >>>  8) & 0xFF,\\n    track.duration & 0xFF,  // duration\\n    0x55, 0xc4,             // 'und' language (undetermined)\\n    0x00, 0x00\\n  ]);\\n\\n  // Use the sample rate from the track metadata, when it is\\n  // defined. The sample rate can be parsed out of an ADTS header, for\\n  // instance.\\n  if (track.samplerate) {\\n    result[12] = (track.samplerate >>> 24) & 0xFF;\\n    result[13] = (track.samplerate >>> 16) & 0xFF;\\n    result[14] = (track.samplerate >>>  8) & 0xFF;\\n    result[15] = (track.samplerate)        & 0xFF;\\n  }\\n\\n  return box(types.mdhd, result);\\n};\\nmdia = function(track) {\\n  return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));\\n};\\nmfhd = function(sequenceNumber) {\\n  return box(types.mfhd, new Uint8Array([\\n    0x00,\\n    0x00, 0x00, 0x00, // flags\\n    (sequenceNumber & 0xFF000000) >> 24,\\n    (sequenceNumber & 0xFF0000) >> 16,\\n    (sequenceNumber & 0xFF00) >> 8,\\n    sequenceNumber & 0xFF // sequence_number\\n  ]));\\n};\\nminf = function(track) {\\n  return box(types.minf,\\n             track.type === 'video' ? box(types.vmhd, VMHD) : box(types.smhd, SMHD),\\n             dinf(),\\n             stbl(track));\\n};\\nmoof = function(sequenceNumber, tracks) {\\n  var\\n    trackFragments = [],\\n    i = tracks.length;\\n  // build traf boxes for each track fragment\\n  while (i--) {\\n    trackFragments[i] = traf(tracks[i]);\\n  }\\n  return box.apply(null, [\\n    types.moof,\\n    mfhd(sequenceNumber)\\n  ].concat(trackFragments));\\n};\\n/**\\n * Returns a movie box.\\n * @param tracks {array} the tracks associated with this movie\\n * @see ISO/IEC 14496-12:2012(E), section 8.2.1\\n */\\nmoov = function(tracks) {\\n  var\\n    i = tracks.length,\\n    boxes = [];\\n\\n  while (i--) {\\n    boxes[i] = trak(tracks[i]);\\n  }\\n\\n  return box.apply(null, [types.moov, mvhd(0xffffffff)].concat(boxes).concat(mvex(tracks)));\\n};\\nmvex = function(tracks) {\\n  var\\n    i = tracks.length,\\n    boxes = [];\\n\\n  while (i--) {\\n    boxes[i] = trex(tracks[i]);\\n  }\\n  return box.apply(null, [types.mvex].concat(boxes));\\n};\\nmvhd = function(duration) {\\n  var\\n    bytes = new Uint8Array([\\n      0x00, // version 0\\n      0x00, 0x00, 0x00, // flags\\n      0x00, 0x00, 0x00, 0x01, // creation_time\\n      0x00, 0x00, 0x00, 0x02, // modification_time\\n      0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \\\"ticks\\\" per second\\n      (duration & 0xFF000000) >> 24,\\n      (duration & 0xFF0000) >> 16,\\n      (duration & 0xFF00) >> 8,\\n      duration & 0xFF, // duration\\n      0x00, 0x01, 0x00, 0x00, // 1.0 rate\\n      0x01, 0x00, // 1.0 volume\\n      0x00, 0x00, // reserved\\n      0x00, 0x00, 0x00, 0x00, // reserved\\n      0x00, 0x00, 0x00, 0x00, // reserved\\n      0x00, 0x01, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x01, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00, // pre_defined\\n      0xff, 0xff, 0xff, 0xff // next_track_ID\\n    ]);\\n  return box(types.mvhd, bytes);\\n};\\n\\nsdtp = function(track) {\\n  var\\n    samples = track.samples || [],\\n    bytes = new Uint8Array(4 + samples.length),\\n    flags,\\n    i;\\n\\n  // leave the full box header (4 bytes) all zero\\n\\n  // write the sample table\\n  for (i = 0; i < samples.length; i++) {\\n    flags = samples[i].flags;\\n\\n    bytes[i + 4] = (flags.dependsOn << 4) |\\n      (flags.isDependedOn << 2) |\\n      (flags.hasRedundancy);\\n  }\\n\\n  return box(types.sdtp,\\n             bytes);\\n};\\n\\nstbl = function(track) {\\n  return box(types.stbl,\\n             stsd(track),\\n             box(types.stts, STTS),\\n             box(types.stsc, STSC),\\n             box(types.stsz, STSZ),\\n             box(types.stco, STCO));\\n};\\n\\n(function() {\\n  var videoSample, audioSample;\\n\\n  stsd = function(track) {\\n\\n    return box(types.stsd, new Uint8Array([\\n      0x00, // version 0\\n      0x00, 0x00, 0x00, // flags\\n      0x00, 0x00, 0x00, 0x01\\n    ]), track.type === 'video' ? videoSample(track) : audioSample(track));\\n  };\\n\\n  videoSample = function(track) {\\n    var\\n      sps = track.sps || [],\\n      pps = track.pps || [],\\n      sequenceParameterSets = [],\\n      pictureParameterSets = [],\\n      i;\\n\\n    // assemble the SPSs\\n    for (i = 0; i < sps.length; i++) {\\n      sequenceParameterSets.push((sps[i].byteLength & 0xFF00) >>> 8);\\n      sequenceParameterSets.push((sps[i].byteLength & 0xFF)); // sequenceParameterSetLength\\n      sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i])); // SPS\\n    }\\n\\n    // assemble the PPSs\\n    for (i = 0; i < pps.length; i++) {\\n      pictureParameterSets.push((pps[i].byteLength & 0xFF00) >>> 8);\\n      pictureParameterSets.push((pps[i].byteLength & 0xFF));\\n      pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));\\n    }\\n\\n    return box(types.avc1, new Uint8Array([\\n      0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, // reserved\\n      0x00, 0x01, // data_reference_index\\n      0x00, 0x00, // pre_defined\\n      0x00, 0x00, // reserved\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00, // pre_defined\\n      (track.width & 0xff00) >> 8,\\n      track.width & 0xff, // width\\n      (track.height & 0xff00) >> 8,\\n      track.height & 0xff, // height\\n      0x00, 0x48, 0x00, 0x00, // horizresolution\\n      0x00, 0x48, 0x00, 0x00, // vertresolution\\n      0x00, 0x00, 0x00, 0x00, // reserved\\n      0x00, 0x01, // frame_count\\n      0x13,\\n      0x76, 0x69, 0x64, 0x65,\\n      0x6f, 0x6a, 0x73, 0x2d,\\n      0x63, 0x6f, 0x6e, 0x74,\\n      0x72, 0x69, 0x62, 0x2d,\\n      0x68, 0x6c, 0x73, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, // compressorname\\n      0x00, 0x18, // depth = 24\\n      0x11, 0x11 // pre_defined = -1\\n    ]), box(types.avcC, new Uint8Array([\\n      0x01, // configurationVersion\\n      track.profileIdc, // AVCProfileIndication\\n      track.profileCompatibility, // profile_compatibility\\n      track.levelIdc, // AVCLevelIndication\\n      0xff // lengthSizeMinusOne, hard-coded to 4 bytes\\n    ].concat([\\n      sps.length // numOfSequenceParameterSets\\n    ]).concat(sequenceParameterSets).concat([\\n      pps.length // numOfPictureParameterSets\\n    ]).concat(pictureParameterSets))), // \\\"PPS\\\"\\n            box(types.btrt, new Uint8Array([\\n              0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\\n              0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\\n              0x00, 0x2d, 0xc6, 0xc0\\n            ])) // avgBitrate\\n              );\\n  };\\n\\n  audioSample = function(track) {\\n    return box(types.mp4a, new Uint8Array([\\n\\n      // SampleEntry, ISO/IEC 14496-12\\n      0x00, 0x00, 0x00,\\n      0x00, 0x00, 0x00, // reserved\\n      0x00, 0x01, // data_reference_index\\n\\n      // AudioSampleEntry, ISO/IEC 14496-12\\n      0x00, 0x00, 0x00, 0x00, // reserved\\n      0x00, 0x00, 0x00, 0x00, // reserved\\n      (track.channelcount & 0xff00) >> 8,\\n      (track.channelcount & 0xff), // channelcount\\n\\n      (track.samplesize & 0xff00) >> 8,\\n      (track.samplesize & 0xff), // samplesize\\n      0x00, 0x00, // pre_defined\\n      0x00, 0x00, // reserved\\n\\n      (track.samplerate & 0xff00) >> 8,\\n      (track.samplerate & 0xff),\\n      0x00, 0x00 // samplerate, 16.16\\n\\n      // MP4AudioSampleEntry, ISO/IEC 14496-14\\n    ]), esds(track));\\n  };\\n}());\\n\\ntkhd = function(track) {\\n  var result = new Uint8Array([\\n    0x00, // version 0\\n    0x00, 0x00, 0x07, // flags\\n    0x00, 0x00, 0x00, 0x00, // creation_time\\n    0x00, 0x00, 0x00, 0x00, // modification_time\\n    (track.id & 0xFF000000) >> 24,\\n    (track.id & 0xFF0000) >> 16,\\n    (track.id & 0xFF00) >> 8,\\n    track.id & 0xFF, // track_ID\\n    0x00, 0x00, 0x00, 0x00, // reserved\\n    (track.duration & 0xFF000000) >> 24,\\n    (track.duration & 0xFF0000) >> 16,\\n    (track.duration & 0xFF00) >> 8,\\n    track.duration & 0xFF, // duration\\n    0x00, 0x00, 0x00, 0x00,\\n    0x00, 0x00, 0x00, 0x00, // reserved\\n    0x00, 0x00, // layer\\n    0x00, 0x00, // alternate_group\\n    0x01, 0x00, // non-audio track volume\\n    0x00, 0x00, // reserved\\n    0x00, 0x01, 0x00, 0x00,\\n    0x00, 0x00, 0x00, 0x00,\\n    0x00, 0x00, 0x00, 0x00,\\n    0x00, 0x00, 0x00, 0x00,\\n    0x00, 0x01, 0x00, 0x00,\\n    0x00, 0x00, 0x00, 0x00,\\n    0x00, 0x00, 0x00, 0x00,\\n    0x00, 0x00, 0x00, 0x00,\\n    0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\\n    (track.width & 0xFF00) >> 8,\\n    track.width & 0xFF,\\n    0x00, 0x00, // width\\n    (track.height & 0xFF00) >> 8,\\n    track.height & 0xFF,\\n    0x00, 0x00 // height\\n  ]);\\n\\n  return box(types.tkhd, result);\\n};\\n\\n/**\\n * Generate a track fragment (traf) box. A traf box collects metadata\\n * about tracks in a movie fragment (moof) box.\\n */\\ntraf = function(track) {\\n  var trackFragmentHeader, trackFragmentDecodeTime,\\n      trackFragmentRun, sampleDependencyTable, dataOffset;\\n\\n  trackFragmentHeader = box(types.tfhd, new Uint8Array([\\n    0x00, // version 0\\n    0x00, 0x00, 0x3a, // flags\\n    (track.id & 0xFF000000) >> 24,\\n    (track.id & 0xFF0000) >> 16,\\n    (track.id & 0xFF00) >> 8,\\n    (track.id & 0xFF), // track_ID\\n    0x00, 0x00, 0x00, 0x01, // sample_description_index\\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\\n    0x00, 0x00, 0x00, 0x00  // default_sample_flags\\n  ]));\\n\\n  trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([\\n    0x00, // version 0\\n    0x00, 0x00, 0x00, // flags\\n    // baseMediaDecodeTime\\n    (track.baseMediaDecodeTime >>> 24) & 0xFF,\\n    (track.baseMediaDecodeTime >>> 16) & 0xFF,\\n    (track.baseMediaDecodeTime >>> 8) & 0xFF,\\n    track.baseMediaDecodeTime & 0xFF\\n  ]));\\n\\n  // the data offset specifies the number of bytes from the start of\\n  // the containing moof to the first payload byte of the associated\\n  // mdat\\n  dataOffset = (32 + // tfhd\\n                16 + // tfdt\\n                8 +  // traf header\\n                16 + // mfhd\\n                8 +  // moof header\\n                8);  // mdat header\\n\\n  // audio tracks require less metadata\\n  if (track.type === 'audio') {\\n    trackFragmentRun = trun(track, dataOffset);\\n    return box(types.traf,\\n               trackFragmentHeader,\\n               trackFragmentDecodeTime,\\n               trackFragmentRun);\\n  }\\n\\n  // video tracks should contain an independent and disposable samples\\n  // box (sdtp)\\n  // generate one and adjust offsets to match\\n  sampleDependencyTable = sdtp(track);\\n  trackFragmentRun = trun(track,\\n                          sampleDependencyTable.length + dataOffset);\\n  return box(types.traf,\\n             trackFragmentHeader,\\n             trackFragmentDecodeTime,\\n             trackFragmentRun,\\n             sampleDependencyTable);\\n};\\n\\n/**\\n * Generate a track box.\\n * @param track {object} a track definition\\n * @return {Uint8Array} the track box\\n */\\ntrak = function(track) {\\n  track.duration = track.duration || 0xffffffff;\\n  return box(types.trak,\\n             tkhd(track),\\n             mdia(track));\\n};\\n\\ntrex = function(track) {\\n  var result = new Uint8Array([\\n    0x00, // version 0\\n    0x00, 0x00, 0x00, // flags\\n    (track.id & 0xFF000000) >> 24,\\n    (track.id & 0xFF0000) >> 16,\\n    (track.id & 0xFF00) >> 8,\\n    (track.id & 0xFF), // track_ID\\n    0x00, 0x00, 0x00, 0x01, // default_sample_description_index\\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\\n  ]);\\n  // the last two bytes of default_sample_flags is the sample\\n  // degradation priority, a hint about the importance of this sample\\n  // relative to others. Lower the degradation priority for all sample\\n  // types other than video.\\n  if (track.type !== 'video') {\\n    result[result.length - 1] = 0x00;\\n  }\\n\\n  return box(types.trex, result);\\n};\\n\\n(function() {\\n  var audioTrun, videoTrun, trunHeader;\\n\\n  // This method assumes all samples are uniform. That is, if a\\n  // duration is present for the first sample, it will be present for\\n  // all subsequent samples.\\n  // see ISO/IEC 14496-12:2012, Section 8.8.8.1\\n  trunHeader = function(samples, offset) {\\n    var durationPresent = 0, sizePresent = 0,\\n        flagsPresent = 0, compositionTimeOffset = 0;\\n\\n    // trun flag constants\\n    if (samples.length) {\\n      if (samples[0].duration !== undefined) {\\n        durationPresent = 0x1;\\n      }\\n      if (samples[0].size !== undefined) {\\n        sizePresent = 0x2;\\n      }\\n      if (samples[0].flags !== undefined) {\\n        flagsPresent = 0x4;\\n      }\\n      if (samples[0].compositionTimeOffset !== undefined) {\\n        compositionTimeOffset = 0x8;\\n      }\\n    }\\n\\n    return [\\n      0x00, // version 0\\n      0x00,\\n      durationPresent | sizePresent | flagsPresent | compositionTimeOffset,\\n      0x01, // flags\\n      (samples.length & 0xFF000000) >>> 24,\\n      (samples.length & 0xFF0000) >>> 16,\\n      (samples.length & 0xFF00) >>> 8,\\n      samples.length & 0xFF, // sample_count\\n      (offset & 0xFF000000) >>> 24,\\n      (offset & 0xFF0000) >>> 16,\\n      (offset & 0xFF00) >>> 8,\\n      offset & 0xFF // data_offset\\n    ];\\n  };\\n\\n  videoTrun = function(track, offset) {\\n    var bytes, samples, sample, i;\\n\\n    samples = track.samples || [];\\n    offset += 8 + 12 + (16 * samples.length);\\n\\n    bytes = trunHeader(samples, offset);\\n\\n    for (i = 0; i < samples.length; i++) {\\n      sample = samples[i];\\n      bytes = bytes.concat([\\n        (sample.duration & 0xFF000000) >>> 24,\\n        (sample.duration & 0xFF0000) >>> 16,\\n        (sample.duration & 0xFF00) >>> 8,\\n        sample.duration & 0xFF, // sample_duration\\n        (sample.size & 0xFF000000) >>> 24,\\n        (sample.size & 0xFF0000) >>> 16,\\n        (sample.size & 0xFF00) >>> 8,\\n        sample.size & 0xFF, // sample_size\\n        (sample.flags.isLeading << 2) | sample.flags.dependsOn,\\n        (sample.flags.isDependedOn << 6) |\\n          (sample.flags.hasRedundancy << 4) |\\n          (sample.flags.paddingValue << 1) |\\n          sample.flags.isNonSyncSample,\\n        sample.flags.degradationPriority & 0xF0 << 8,\\n        sample.flags.degradationPriority & 0x0F, // sample_flags\\n        (sample.compositionTimeOffset & 0xFF000000) >>> 24,\\n        (sample.compositionTimeOffset & 0xFF0000) >>> 16,\\n        (sample.compositionTimeOffset & 0xFF00) >>> 8,\\n        sample.compositionTimeOffset & 0xFF // sample_composition_time_offset\\n      ]);\\n    }\\n    return box(types.trun, new Uint8Array(bytes));\\n  };\\n\\n  audioTrun = function(track, offset) {\\n    var bytes, samples, sample, i;\\n\\n    samples = track.samples || [];\\n    offset += 8 + 12 + (8 * samples.length);\\n\\n    bytes = trunHeader(samples, offset);\\n\\n    for (i = 0; i < samples.length; i++) {\\n      sample = samples[i];\\n      bytes = bytes.concat([\\n        (sample.duration & 0xFF000000) >>> 24,\\n        (sample.duration & 0xFF0000) >>> 16,\\n        (sample.duration & 0xFF00) >>> 8,\\n        sample.duration & 0xFF, // sample_duration\\n        (sample.size & 0xFF000000) >>> 24,\\n        (sample.size & 0xFF0000) >>> 16,\\n        (sample.size & 0xFF00) >>> 8,\\n        sample.size & 0xFF]); // sample_size\\n    }\\n\\n    return box(types.trun, new Uint8Array(bytes));\\n  };\\n\\n  trun = function(track, offset) {\\n    if (track.type === 'audio') {\\n      return audioTrun(track, offset);\\n    }\\n\\n    return videoTrun(track, offset);\\n  };\\n}());\\n\\nmodule.exports = {\\n  ftyp: ftyp,\\n  mdat: mdat,\\n  moof: moof,\\n  moov: moov,\\n  initSegment: function(tracks) {\\n    var\\n      fileType = ftyp(),\\n      movie = moov(tracks),\\n      result;\\n\\n    result = new Uint8Array(fileType.byteLength + movie.byteLength);\\n    result.set(fileType);\\n    result.set(movie, fileType.byteLength);\\n    return result;\\n  }\\n};\\n\\n},{}],92:[function(require,module,exports){\\n/**\\n * mux.js\\n *\\n * Copyright (c) 2015 Brightcove\\n * All rights reserved.\\n *\\n * A stream-based mp2t to mp4 converter. This utility can be used to\\n * deliver mp4s to a SourceBuffer on platforms that support native\\n * Media Source Extensions.\\n */\\n'use strict';\\n\\nvar Stream = require('../utils/stream.js');\\nvar mp4 = require('./mp4-generator.js');\\nvar m2ts = require('../m2ts/m2ts.js');\\nvar AdtsStream = require('../codecs/adts.js');\\nvar H264Stream = require('../codecs/h264').H264Stream;\\nvar AacStream = require('../aac');\\n\\n// constants\\nvar AUDIO_PROPERTIES = [\\n  'audioobjecttype',\\n  'channelcount',\\n  'samplerate',\\n  'samplingfrequencyindex',\\n  'samplesize'\\n];\\n\\nvar VIDEO_PROPERTIES = [\\n  'width',\\n  'height',\\n  'profileIdc',\\n  'levelIdc',\\n  'profileCompatibility'\\n];\\n\\n// object types\\nvar VideoSegmentStream, AudioSegmentStream, Transmuxer, CoalesceStream;\\n\\n// Helper functions\\nvar\\n  createDefaultSample,\\n  isLikelyAacData,\\n  collectDtsInfo,\\n  clearDtsInfo,\\n  calculateTrackBaseMediaDecodeTime,\\n  arrayEquals,\\n  sumFrameByteLengths;\\n\\n/**\\n * Default sample object\\n * see ISO/IEC 14496-12:2012, section 8.6.4.3\\n */\\ncreateDefaultSample = function() {\\n  return {\\n    size: 0,\\n    flags: {\\n      isLeading: 0,\\n      dependsOn: 1,\\n      isDependedOn: 0,\\n      hasRedundancy: 0,\\n      degradationPriority: 0\\n    }\\n  };\\n};\\n\\nisLikelyAacData = function(data) {\\n  if ((data[0] === 'I'.charCodeAt(0)) &&\\n      (data[1] === 'D'.charCodeAt(0)) &&\\n      (data[2] === '3'.charCodeAt(0))) {\\n    return true;\\n  }\\n  return false;\\n};\\n\\n/**\\n * Compare two arrays (even typed) for same-ness\\n */\\narrayEquals = function(a, b) {\\n  var\\n    i;\\n\\n  if (a.length !== b.length) {\\n    return false;\\n  }\\n\\n  // compare the value of each element in the array\\n  for (i = 0; i < a.length; i++) {\\n    if (a[i] !== b[i]) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n};\\n\\n/**\\n * Sum the `byteLength` properties of the data in each AAC frame\\n */\\nsumFrameByteLengths = function(array) {\\n  var\\n    i,\\n    currentObj,\\n    sum = 0;\\n\\n  // sum the byteLength's all each nal unit in the frame\\n  for (i = 0; i < array.length; i++) {\\n    currentObj = array[i];\\n    sum += currentObj.data.byteLength;\\n  }\\n\\n  return sum;\\n};\\n\\n/**\\n * Constructs a single-track, ISO BMFF media segment from AAC data\\n * events. The output of this stream can be fed to a SourceBuffer\\n * configured with a suitable initialization segment.\\n */\\nAudioSegmentStream = function(track) {\\n  var\\n    adtsFrames = [],\\n    sequenceNumber = 0,\\n    earliestAllowedDts = 0;\\n\\n  AudioSegmentStream.prototype.init.call(this);\\n\\n  this.push = function(data) {\\n    collectDtsInfo(track, data);\\n\\n    if (track) {\\n      AUDIO_PROPERTIES.forEach(function(prop) {\\n        track[prop] = data[prop];\\n      });\\n    }\\n\\n    // buffer audio data until end() is called\\n    adtsFrames.push(data);\\n  };\\n\\n  this.setEarliestDts = function(earliestDts) {\\n    earliestAllowedDts = earliestDts - track.timelineStartInfo.baseMediaDecodeTime;\\n  };\\n\\n  this.flush = function() {\\n    var\\n      frames,\\n      moof,\\n      mdat,\\n      boxes;\\n\\n    // return early if no audio data has been observed\\n    if (adtsFrames.length === 0) {\\n      this.trigger('done', 'AudioSegmentStream');\\n      return;\\n    }\\n\\n    frames = this.trimAdtsFramesByEarliestDts_(adtsFrames);\\n\\n    // we have to build the index from byte locations to\\n    // samples (that is, adts frames) in the audio data\\n    track.samples = this.generateSampleTable_(frames);\\n\\n    // concatenate the audio data to constuct the mdat\\n    mdat = mp4.mdat(this.concatenateFrameData_(frames));\\n\\n    adtsFrames = [];\\n\\n    calculateTrackBaseMediaDecodeTime(track);\\n    moof = mp4.moof(sequenceNumber, [track]);\\n    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\\n\\n    // bump the sequence number for next time\\n    sequenceNumber++;\\n\\n    boxes.set(moof);\\n    boxes.set(mdat, moof.byteLength);\\n\\n    clearDtsInfo(track);\\n\\n    this.trigger('data', {track: track, boxes: boxes});\\n    this.trigger('done', 'AudioSegmentStream');\\n  };\\n\\n  // If the audio segment extends before the earliest allowed dts\\n  // value, remove AAC frames until starts at or after the earliest\\n  // allowed DTS so that we don't end up with a negative baseMedia-\\n  // DecodeTime for the audio track\\n  this.trimAdtsFramesByEarliestDts_ = function(adtsFrames) {\\n    if (track.minSegmentDts >= earliestAllowedDts) {\\n      return adtsFrames;\\n    }\\n\\n    // We will need to recalculate the earliest segment Dts\\n    track.minSegmentDts = Infinity;\\n\\n    return adtsFrames.filter(function(currentFrame) {\\n      // If this is an allowed frame, keep it and record it's Dts\\n      if (currentFrame.dts >= earliestAllowedDts) {\\n        track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);\\n        track.minSegmentPts = track.minSegmentDts;\\n        return true;\\n      }\\n      // Otherwise, discard it\\n      return false;\\n    });\\n  };\\n\\n  // generate the track's raw mdat data from an array of frames\\n  this.generateSampleTable_ = function(frames) {\\n    var\\n      i,\\n      currentFrame,\\n      samples = [];\\n\\n    for (i = 0; i < frames.length; i++) {\\n      currentFrame = frames[i];\\n      samples.push({\\n        size: currentFrame.data.byteLength,\\n        duration: 1024 // For AAC audio, all samples contain 1024 samples\\n      });\\n    }\\n    return samples;\\n  };\\n\\n  // generate the track's sample table from an array of frames\\n  this.concatenateFrameData_ = function(frames) {\\n    var\\n      i,\\n      currentFrame,\\n      dataOffset = 0,\\n      data = new Uint8Array(sumFrameByteLengths(frames));\\n\\n    for (i = 0; i < frames.length; i++) {\\n      currentFrame = frames[i];\\n\\n      data.set(currentFrame.data, dataOffset);\\n      dataOffset += currentFrame.data.byteLength;\\n    }\\n    return data;\\n  };\\n};\\n\\nAudioSegmentStream.prototype = new Stream();\\n\\n/**\\n * Constructs a single-track, ISO BMFF media segment from H264 data\\n * events. The output of this stream can be fed to a SourceBuffer\\n * configured with a suitable initialization segment.\\n * @param track {object} track metadata configuration\\n */\\nVideoSegmentStream = function(track) {\\n  var\\n    sequenceNumber = 0,\\n    nalUnits = [],\\n    config,\\n    pps;\\n\\n  VideoSegmentStream.prototype.init.call(this);\\n\\n  delete track.minPTS;\\n\\n  this.gopCache_ = [];\\n\\n  this.push = function(nalUnit) {\\n    collectDtsInfo(track, nalUnit);\\n\\n    // record the track config\\n    if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\\n      config = nalUnit.config;\\n      track.sps = [nalUnit.data];\\n\\n      VIDEO_PROPERTIES.forEach(function(prop) {\\n        track[prop] = config[prop];\\n      }, this);\\n    }\\n\\n    if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' &&\\n        !pps) {\\n      pps = nalUnit.data;\\n      track.pps = [nalUnit.data];\\n    }\\n\\n    // buffer video until flush() is called\\n    nalUnits.push(nalUnit);\\n  };\\n\\n  this.flush = function() {\\n    var\\n      frames,\\n      gopForFusion,\\n      gops,\\n      moof,\\n      mdat,\\n      boxes;\\n\\n    // Throw away nalUnits at the start of the byte stream until\\n    // we find the first AUD\\n    while (nalUnits.length) {\\n      if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\\n        break;\\n      }\\n      nalUnits.shift();\\n    }\\n\\n    // Return early if no video data has been observed\\n    if (nalUnits.length === 0) {\\n      this.resetStream_();\\n      this.trigger('done', 'VideoSegmentStream');\\n      return;\\n    }\\n\\n    // Organize the raw nal-units into arrays that represent\\n    // higher-level constructs such as frames and gops\\n    // (group-of-pictures)\\n    frames = this.groupNalsIntoFrames_(nalUnits);\\n    gops = this.groupFramesIntoGops_(frames);\\n\\n    // If the first frame of this fragment is not a keyframe we have\\n    // a problem since MSE (on Chrome) requires a leading keyframe.\\n    //\\n    // We have two approaches to repairing this situation:\\n    // 1) GOP-FUSION:\\n    //    This is where we keep track of the GOPS (group-of-pictures)\\n    //    from previous fragments and attempt to find one that we can\\n    //    prepend to the current fragment in order to create a valid\\n    //    fragment.\\n    // 2) KEYFRAME-PULLING:\\n    //    Here we search for the first keyframe in the fragment and\\n    //    throw away all the frames between the start of the fragment\\n    //    and that keyframe. We then extend the duration and pull the\\n    //    PTS of the keyframe forward so that it covers the time range\\n    //    of the frames that were disposed of.\\n    //\\n    // #1 is far prefereable over #2 which can cause \\\"stuttering\\\" but\\n    // requires more things to be just right.\\n    if (!gops[0][0].keyFrame) {\\n      // Search for a gop for fusion from our gopCache\\n      gopForFusion = this.getGopForFusion_(nalUnits[0], track);\\n\\n      if (gopForFusion) {\\n        gops.unshift(gopForFusion);\\n        // Adjust Gops' metadata to account for the inclusion of the\\n        // new gop at the beginning\\n        gops.byteLength += gopForFusion.byteLength;\\n        gops.nalCount += gopForFusion.nalCount;\\n        gops.pts = gopForFusion.pts;\\n        gops.dts = gopForFusion.dts;\\n        gops.duration += gopForFusion.duration;\\n      } else {\\n        // If we didn't find a candidate gop fall back to keyrame-pulling\\n        gops = this.extendFirstKeyFrame_(gops);\\n      }\\n    }\\n    collectDtsInfo(track, gops);\\n\\n    // First, we have to build the index from byte locations to\\n    // samples (that is, frames) in the video data\\n    track.samples = this.generateSampleTable_(gops);\\n\\n    // Concatenate the video data and construct the mdat\\n    mdat = mp4.mdat(this.concatenateNalData_(gops));\\n\\n    // save all the nals in the last GOP into the gop cache\\n    this.gopCache_.unshift({\\n      gop: gops.pop(),\\n      pps: track.pps,\\n      sps: track.sps\\n    });\\n\\n    // Keep a maximum of 6 GOPs in the cache\\n    this.gopCache_.length = Math.min(6, this.gopCache_.length);\\n\\n    // Clear nalUnits\\n    nalUnits = [];\\n\\n    calculateTrackBaseMediaDecodeTime(track);\\n\\n    this.trigger('timelineStartInfo', track.timelineStartInfo);\\n\\n    moof = mp4.moof(sequenceNumber, [track]);\\n\\n    // it would be great to allocate this array up front instead of\\n    // throwing away hundreds of media segment fragments\\n    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\\n\\n    // Bump the sequence number for next time\\n    sequenceNumber++;\\n\\n    boxes.set(moof);\\n    boxes.set(mdat, moof.byteLength);\\n\\n    this.trigger('data', {track: track, boxes: boxes});\\n\\n    this.resetStream_();\\n\\n    // Continue with the flush process now\\n    this.trigger('done', 'VideoSegmentStream');\\n  };\\n\\n  this.resetStream_ = function() {\\n    clearDtsInfo(track);\\n\\n    // reset config and pps because they may differ across segments\\n    // for instance, when we are rendition switching\\n    config = undefined;\\n    pps = undefined;\\n  };\\n\\n  // Search for a candidate Gop for gop-fusion from the gop cache and\\n  // return it or return null if no good candidate was found\\n  this.getGopForFusion_ = function(nalUnit) {\\n    var\\n      halfSecond = 45000, // Half-a-second in a 90khz clock\\n      allowableOverlap = 10000, // About 3 frames @ 30fps\\n      nearestDistance = Infinity,\\n      dtsDistance,\\n      nearestGopObj,\\n      currentGop,\\n      currentGopObj,\\n      i;\\n\\n    // Search for the GOP nearest to the beginning of this nal unit\\n    for (i = 0; i < this.gopCache_.length; i++) {\\n      currentGopObj = this.gopCache_[i];\\n      currentGop = currentGopObj.gop;\\n\\n      // Reject Gops with different SPS or PPS\\n      if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) ||\\n          !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {\\n        continue;\\n      }\\n\\n      // Reject Gops that would require a negative baseMediaDecodeTime\\n      if (currentGop.dts < track.timelineStartInfo.dts) {\\n        continue;\\n      }\\n\\n      // The distance between the end of the gop and the start of the nalUnit\\n      dtsDistance = (nalUnit.dts - currentGop.dts) - currentGop.duration;\\n\\n      // Only consider GOPS that start before the nal unit and end within\\n      // a half-second of the nal unit\\n      if (dtsDistance >= -allowableOverlap &&\\n          dtsDistance <= halfSecond) {\\n\\n        // Always use the closest GOP we found if there is more than\\n        // one candidate\\n        if (!nearestGopObj ||\\n            nearestDistance > dtsDistance) {\\n          nearestGopObj = currentGopObj;\\n          nearestDistance = dtsDistance;\\n        }\\n      }\\n    }\\n\\n    if (nearestGopObj) {\\n      return nearestGopObj.gop;\\n    }\\n    return null;\\n  };\\n\\n  this.extendFirstKeyFrame_ = function(gops) {\\n    var currentGop;\\n\\n    if (!gops[0][0].keyFrame) {\\n      // Remove the first GOP\\n      currentGop = gops.shift();\\n\\n      gops.byteLength -=  currentGop.byteLength;\\n      gops.nalCount -= currentGop.nalCount;\\n\\n      // Extend the first frame of what is now the\\n      // first gop to cover the time period of the\\n      // frames we just removed\\n      gops[0][0].dts = currentGop.dts;\\n      gops[0][0].pts = currentGop.pts;\\n      gops[0][0].duration += currentGop.duration;\\n    }\\n\\n    return gops;\\n  };\\n\\n  // Convert an array of nal units into an array of frames with each frame being\\n  // composed of the nal units that make up that frame\\n  // Also keep track of cummulative data about the frame from the nal units such\\n  // as the frame duration, starting pts, etc.\\n  this.groupNalsIntoFrames_ = function(nalUnits) {\\n    var\\n      i,\\n      currentNal,\\n      currentFrame = [],\\n      frames = [];\\n\\n    currentFrame.byteLength = 0;\\n\\n    for (i = 0; i < nalUnits.length; i++) {\\n      currentNal = nalUnits[i];\\n\\n      // Split on 'aud'-type nal units\\n      if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\\n        // Since the very first nal unit is expected to be an AUD\\n        // only push to the frames array when currentFrame is not empty\\n        if (currentFrame.length) {\\n          currentFrame.duration = currentNal.dts - currentFrame.dts;\\n          frames.push(currentFrame);\\n        }\\n        currentFrame = [currentNal];\\n        currentFrame.byteLength = currentNal.data.byteLength;\\n        currentFrame.pts = currentNal.pts;\\n        currentFrame.dts = currentNal.dts;\\n      } else {\\n        // Specifically flag key frames for ease of use later\\n        if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\\n          currentFrame.keyFrame = true;\\n        }\\n        currentFrame.duration = currentNal.dts - currentFrame.dts;\\n        currentFrame.byteLength += currentNal.data.byteLength;\\n        currentFrame.push(currentNal);\\n      }\\n    }\\n\\n    // For the last frame, use the duration of the previous frame if we\\n    // have nothing better to go on\\n    if (frames.length &&\\n        (!currentFrame.duration ||\\n         currentFrame.duration <= 0)) {\\n      currentFrame.duration = frames[frames.length - 1].duration;\\n    }\\n\\n    // Push the final frame\\n    frames.push(currentFrame);\\n    return frames;\\n  };\\n\\n  // Convert an array of frames into an array of Gop with each Gop being composed\\n  // of the frames that make up that Gop\\n  // Also keep track of cummulative data about the Gop from the frames such as the\\n  // Gop duration, starting pts, etc.\\n  this.groupFramesIntoGops_ = function(frames) {\\n    var\\n      i,\\n      currentFrame,\\n      currentGop = [],\\n      gops = [];\\n\\n    // We must pre-set some of the values on the Gop since we\\n    // keep running totals of these values\\n    currentGop.byteLength = 0;\\n    currentGop.nalCount = 0;\\n    currentGop.duration = 0;\\n    currentGop.pts = frames[0].pts;\\n    currentGop.dts = frames[0].dts;\\n\\n    // store some metadata about all the Gops\\n    gops.byteLength = 0;\\n    gops.nalCount = 0;\\n    gops.duration = 0;\\n    gops.pts = frames[0].pts;\\n    gops.dts = frames[0].dts;\\n\\n    for (i = 0; i < frames.length; i++) {\\n      currentFrame = frames[i];\\n\\n      if (currentFrame.keyFrame) {\\n        // Since the very first frame is expected to be an keyframe\\n        // only push to the gops array when currentGop is not empty\\n        if (currentGop.length) {\\n          gops.push(currentGop);\\n          gops.byteLength += currentGop.byteLength;\\n          gops.nalCount += currentGop.nalCount;\\n          gops.duration += currentGop.duration;\\n        }\\n\\n        currentGop = [currentFrame];\\n        currentGop.nalCount = currentFrame.length;\\n        currentGop.byteLength = currentFrame.byteLength;\\n        currentGop.pts = currentFrame.pts;\\n        currentGop.dts = currentFrame.dts;\\n        currentGop.duration = currentFrame.duration;\\n      } else {\\n        currentGop.duration += currentFrame.duration;\\n        currentGop.nalCount += currentFrame.length;\\n        currentGop.byteLength += currentFrame.byteLength;\\n        currentGop.push(currentFrame);\\n      }\\n    }\\n\\n    if (gops.length && currentGop.duration <= 0) {\\n      currentGop.duration = gops[gops.length - 1].duration;\\n    }\\n    gops.byteLength += currentGop.byteLength;\\n    gops.nalCount += currentGop.nalCount;\\n    gops.duration += currentGop.duration;\\n\\n    // push the final Gop\\n    gops.push(currentGop);\\n    return gops;\\n  };\\n\\n  // generate the track's sample table from an array of gops\\n  this.generateSampleTable_ = function(gops, baseDataOffset) {\\n    var\\n      h, i,\\n      sample,\\n      currentGop,\\n      currentFrame,\\n      dataOffset = baseDataOffset || 0,\\n      samples = [];\\n\\n    for (h = 0; h < gops.length; h++) {\\n      currentGop = gops[h];\\n\\n      for (i = 0; i < currentGop.length; i++) {\\n        currentFrame = currentGop[i];\\n\\n        sample = createDefaultSample();\\n\\n        sample.dataOffset = dataOffset;\\n        sample.compositionTimeOffset = currentFrame.pts - currentFrame.dts;\\n        sample.duration = currentFrame.duration;\\n        sample.size = 4 * currentFrame.length; // Space for nal unit size\\n        sample.size += currentFrame.byteLength;\\n\\n        if (currentFrame.keyFrame) {\\n          sample.flags.dependsOn = 2;\\n        }\\n\\n        dataOffset += sample.size;\\n\\n        samples.push(sample);\\n      }\\n    }\\n    return samples;\\n  };\\n\\n  // generate the track's raw mdat data from an array of gops\\n  this.concatenateNalData_ = function(gops) {\\n    var\\n      h, i, j,\\n      currentGop,\\n      currentFrame,\\n      currentNal,\\n      dataOffset = 0,\\n      nalsByteLength = gops.byteLength,\\n      numberOfNals = gops.nalCount,\\n      totalByteLength = nalsByteLength + 4 * numberOfNals,\\n      data = new Uint8Array(totalByteLength),\\n      view = new DataView(data.buffer);\\n\\n    // For each Gop..\\n    for (h = 0; h < gops.length; h++) {\\n      currentGop = gops[h];\\n\\n      // For each Frame..\\n      for (i = 0; i < currentGop.length; i++) {\\n        currentFrame = currentGop[i];\\n\\n        // For each NAL..\\n        for (j = 0; j < currentFrame.length; j++) {\\n          currentNal = currentFrame[j];\\n\\n          view.setUint32(dataOffset, currentNal.data.byteLength);\\n          dataOffset += 4;\\n          data.set(currentNal.data, dataOffset);\\n          dataOffset += currentNal.data.byteLength;\\n        }\\n      }\\n    }\\n    return data;\\n  };\\n};\\n\\nVideoSegmentStream.prototype = new Stream();\\n\\n/**\\n * Store information about the start and end of the track and the\\n * duration for each frame/sample we process in order to calculate\\n * the baseMediaDecodeTime\\n */\\ncollectDtsInfo = function(track, data) {\\n  if (typeof data.pts === 'number') {\\n    if (track.timelineStartInfo.pts === undefined) {\\n      track.timelineStartInfo.pts = data.pts;\\n    }\\n\\n    if (track.minSegmentPts === undefined) {\\n      track.minSegmentPts = data.pts;\\n    } else {\\n      track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);\\n    }\\n\\n    if (track.maxSegmentPts === undefined) {\\n      track.maxSegmentPts = data.pts;\\n    } else {\\n      track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);\\n    }\\n  }\\n\\n  if (typeof data.dts === 'number') {\\n    if (track.timelineStartInfo.dts === undefined) {\\n      track.timelineStartInfo.dts = data.dts;\\n    }\\n\\n    if (track.minSegmentDts === undefined) {\\n      track.minSegmentDts = data.dts;\\n    } else {\\n      track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);\\n    }\\n\\n    if (track.maxSegmentDts === undefined) {\\n      track.maxSegmentDts = data.dts;\\n    } else {\\n      track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);\\n    }\\n  }\\n};\\n\\n/**\\n * Clear values used to calculate the baseMediaDecodeTime between\\n * tracks\\n */\\nclearDtsInfo = function(track) {\\n  delete track.minSegmentDts;\\n  delete track.maxSegmentDts;\\n  delete track.minSegmentPts;\\n  delete track.maxSegmentPts;\\n};\\n\\n/**\\n * Calculate the track's baseMediaDecodeTime based on the earliest\\n * DTS the transmuxer has ever seen and the minimum DTS for the\\n * current track\\n */\\ncalculateTrackBaseMediaDecodeTime = function(track) {\\n  var\\n    oneSecondInPTS = 90000, // 90kHz clock\\n    scale,\\n    // Calculate the distance, in time, that this segment starts from the start\\n    // of the timeline (earliest time seen since the transmuxer initialized)\\n    timeSinceStartOfTimeline = track.minSegmentDts - track.timelineStartInfo.dts,\\n    // Calculate the first sample's effective compositionTimeOffset\\n    firstSampleCompositionOffset = track.minSegmentPts - track.minSegmentDts;\\n\\n  // track.timelineStartInfo.baseMediaDecodeTime is the location, in time, where\\n  // we want the start of the first segment to be placed\\n  track.baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime;\\n\\n  // Add to that the distance this segment is from the very first\\n  track.baseMediaDecodeTime += timeSinceStartOfTimeline;\\n\\n  // Subtract this segment's \\\"compositionTimeOffset\\\" so that the first frame of\\n  // this segment is displayed exactly at the `baseMediaDecodeTime` or at the\\n  // end of the previous segment\\n  track.baseMediaDecodeTime -= firstSampleCompositionOffset;\\n\\n  // baseMediaDecodeTime must not become negative\\n  track.baseMediaDecodeTime = Math.max(0, track.baseMediaDecodeTime);\\n\\n  if (track.type === 'audio') {\\n    // Audio has a different clock equal to the sampling_rate so we need to\\n    // scale the PTS values into the clock rate of the track\\n    scale = track.samplerate / oneSecondInPTS;\\n    track.baseMediaDecodeTime *= scale;\\n    track.baseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime);\\n  }\\n};\\n\\n/**\\n * A Stream that can combine multiple streams (ie. audio & video)\\n * into a single output segment for MSE. Also supports audio-only\\n * and video-only streams.\\n */\\nCoalesceStream = function(options, metadataStream) {\\n  // Number of Tracks per output segment\\n  // If greater than 1, we combine multiple\\n  // tracks into a single segment\\n  this.numberOfTracks = 0;\\n  this.metadataStream = metadataStream;\\n\\n  if (typeof options.remux !== 'undefined') {\\n    this.remuxTracks = !!options.remux;\\n  } else {\\n    this.remuxTracks = true;\\n  }\\n\\n  this.pendingTracks = [];\\n  this.videoTrack = null;\\n  this.pendingBoxes = [];\\n  this.pendingCaptions = [];\\n  this.pendingMetadata = [];\\n  this.pendingBytes = 0;\\n  this.emittedTracks = 0;\\n\\n  CoalesceStream.prototype.init.call(this);\\n\\n  // Take output from multiple\\n  this.push = function(output) {\\n    // buffer incoming captions until the associated video segment\\n    // finishes\\n    if (output.text) {\\n      return this.pendingCaptions.push(output);\\n    }\\n    // buffer incoming id3 tags until the final flush\\n    if (output.frames) {\\n      return this.pendingMetadata.push(output);\\n    }\\n\\n    // Add this track to the list of pending tracks and store\\n    // important information required for the construction of\\n    // the final segment\\n    this.pendingTracks.push(output.track);\\n    this.pendingBoxes.push(output.boxes);\\n    this.pendingBytes += output.boxes.byteLength;\\n\\n    if (output.track.type === 'video') {\\n      this.videoTrack = output.track;\\n    }\\n    if (output.track.type === 'audio') {\\n      this.audioTrack = output.track;\\n    }\\n  };\\n};\\n\\nCoalesceStream.prototype = new Stream();\\nCoalesceStream.prototype.flush = function(flushSource) {\\n  var\\n    offset = 0,\\n    event = {\\n      captions: [],\\n      metadata: [],\\n      info: {}\\n    },\\n    caption,\\n    id3,\\n    initSegment,\\n    timelineStartPts = 0,\\n    i;\\n\\n  if (this.pendingTracks.length < this.numberOfTracks) {\\n    if (flushSource !== 'VideoSegmentStream' &&\\n        flushSource !== 'AudioSegmentStream') {\\n      // Return because we haven't received a flush from a data-generating\\n      // portion of the segment (meaning that we have only recieved meta-data\\n      // or captions.)\\n      return;\\n    } else if (this.remuxTracks) {\\n      // Return until we have enough tracks from the pipeline to remux (if we\\n      // are remuxing audio and video into a single MP4)\\n      return;\\n    } else if (this.pendingTracks.length === 0) {\\n      // In the case where we receive a flush without any data having been\\n      // received we consider it an emitted track for the purposes of coalescing\\n      // `done` events.\\n      // We do this for the case where there is an audio and video track in the\\n      // segment but no audio data. (seen in several playlists with alternate\\n      // audio tracks and no audio present in the main TS segments.)\\n      this.emittedTracks++;\\n\\n      if (this.emittedTracks >= this.numberOfTracks) {\\n        this.trigger('done');\\n        this.emittedTracks = 0;\\n      }\\n      return;\\n    }\\n  }\\n\\n  if (this.videoTrack) {\\n    timelineStartPts = this.videoTrack.timelineStartInfo.pts;\\n    VIDEO_PROPERTIES.forEach(function(prop) {\\n      event.info[prop] = this.videoTrack[prop];\\n    }, this);\\n  } else if (this.audioTrack) {\\n    timelineStartPts = this.audioTrack.timelineStartInfo.pts;\\n    AUDIO_PROPERTIES.forEach(function(prop) {\\n      event.info[prop] = this.audioTrack[prop];\\n    }, this);\\n  }\\n\\n  if (this.pendingTracks.length === 1) {\\n    event.type = this.pendingTracks[0].type;\\n  } else {\\n    event.type = 'combined';\\n  }\\n\\n  this.emittedTracks += this.pendingTracks.length;\\n\\n  initSegment = mp4.initSegment(this.pendingTracks);\\n\\n  // Create a new typed array large enough to hold the init\\n  // segment and all tracks\\n  event.data = new Uint8Array(initSegment.byteLength +\\n                              this.pendingBytes);\\n\\n  // Create an init segment containing a moov\\n  // and track definitions\\n  event.data.set(initSegment);\\n  offset += initSegment.byteLength;\\n\\n  // Append each moof+mdat (one per track) after the init segment\\n  for (i = 0; i < this.pendingBoxes.length; i++) {\\n    event.data.set(this.pendingBoxes[i], offset);\\n    offset += this.pendingBoxes[i].byteLength;\\n  }\\n\\n  // Translate caption PTS times into second offsets into the\\n  // video timeline for the segment\\n  for (i = 0; i < this.pendingCaptions.length; i++) {\\n    caption = this.pendingCaptions[i];\\n    caption.startTime = (caption.startPts - timelineStartPts);\\n    caption.startTime /= 90e3;\\n    caption.endTime = (caption.endPts - timelineStartPts);\\n    caption.endTime /= 90e3;\\n    event.captions.push(caption);\\n  }\\n\\n  // Translate ID3 frame PTS times into second offsets into the\\n  // video timeline for the segment\\n  for (i = 0; i < this.pendingMetadata.length; i++) {\\n    id3 = this.pendingMetadata[i];\\n    id3.cueTime = (id3.pts - timelineStartPts);\\n    id3.cueTime /= 90e3;\\n    event.metadata.push(id3);\\n  }\\n  // We add this to every single emitted segment even though we only need\\n  // it for the first\\n  event.metadata.dispatchType = this.metadataStream.dispatchType;\\n\\n  // Reset stream state\\n  this.pendingTracks.length = 0;\\n  this.videoTrack = null;\\n  this.pendingBoxes.length = 0;\\n  this.pendingCaptions.length = 0;\\n  this.pendingBytes = 0;\\n  this.pendingMetadata.length = 0;\\n\\n  // Emit the built segment\\n  this.trigger('data', event);\\n\\n  // Only emit `done` if all tracks have been flushed and emitted\\n  if (this.emittedTracks >= this.numberOfTracks) {\\n    this.trigger('done');\\n    this.emittedTracks = 0;\\n  }\\n};\\n/**\\n * A Stream that expects MP2T binary data as input and produces\\n * corresponding media segments, suitable for use with Media Source\\n * Extension (MSE) implementations that support the ISO BMFF byte\\n * stream format, like Chrome.\\n */\\nTransmuxer = function(options) {\\n  var\\n    self = this,\\n    hasFlushed = true,\\n    videoTrack,\\n    audioTrack;\\n\\n  Transmuxer.prototype.init.call(this);\\n\\n  options = options || {};\\n  this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\\n  this.transmuxPipeline_ = {};\\n\\n  this.setupAacPipeline = function() {\\n    var pipeline = {};\\n    this.transmuxPipeline_ = pipeline;\\n\\n    pipeline.type = 'aac';\\n    pipeline.metadataStream = new m2ts.MetadataStream();\\n\\n    // set up the parsing pipeline\\n    pipeline.aacStream = new AacStream();\\n    pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\\n    pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\\n    pipeline.adtsStream = new AdtsStream();\\n    pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\\n    pipeline.headOfPipeline = pipeline.aacStream;\\n\\n    pipeline.aacStream\\n      .pipe(pipeline.audioTimestampRolloverStream)\\n      .pipe(pipeline.adtsStream);\\n    pipeline.aacStream\\n      .pipe(pipeline.timedMetadataTimestampRolloverStream)\\n      .pipe(pipeline.metadataStream)\\n      .pipe(pipeline.coalesceStream);\\n\\n    pipeline.metadataStream.on('timestamp', function(frame) {\\n      pipeline.aacStream.setTimestamp(frame.timeStamp);\\n    });\\n\\n    pipeline.aacStream.on('data', function(data) {\\n      if (data.type === 'timed-metadata' && !pipeline.audioSegmentStream) {\\n        audioTrack = audioTrack || {\\n          timelineStartInfo: {\\n            baseMediaDecodeTime: self.baseMediaDecodeTime\\n          },\\n          codec: 'adts',\\n          type: 'audio'\\n        };\\n        // hook up the audio segment stream to the first track with aac data\\n        pipeline.coalesceStream.numberOfTracks++;\\n        pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack);\\n        // Set up the final part of the audio pipeline\\n        pipeline.adtsStream\\n          .pipe(pipeline.audioSegmentStream)\\n          .pipe(pipeline.coalesceStream);\\n      }\\n    });\\n\\n    // Re-emit any data coming from the coalesce stream to the outside world\\n    pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\\n    // Let the consumer know we have finished flushing the entire pipeline\\n    pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\\n  };\\n\\n  this.setupTsPipeline = function() {\\n    var pipeline = {};\\n    this.transmuxPipeline_ = pipeline;\\n\\n    pipeline.type = 'ts';\\n    pipeline.metadataStream = new m2ts.MetadataStream();\\n\\n    // set up the parsing pipeline\\n    pipeline.packetStream = new m2ts.TransportPacketStream();\\n    pipeline.parseStream = new m2ts.TransportParseStream();\\n    pipeline.elementaryStream = new m2ts.ElementaryStream();\\n    pipeline.videoTimestampRolloverStream = new m2ts.TimestampRolloverStream('video');\\n    pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\\n    pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\\n    pipeline.adtsStream = new AdtsStream();\\n    pipeline.h264Stream = new H264Stream();\\n    pipeline.captionStream = new m2ts.CaptionStream();\\n    pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\\n    pipeline.headOfPipeline = pipeline.packetStream;\\n\\n    // disassemble MPEG2-TS packets into elementary streams\\n    pipeline.packetStream\\n      .pipe(pipeline.parseStream)\\n      .pipe(pipeline.elementaryStream);\\n\\n    // !!THIS ORDER IS IMPORTANT!!\\n    // demux the streams\\n    pipeline.elementaryStream\\n      .pipe(pipeline.videoTimestampRolloverStream)\\n      .pipe(pipeline.h264Stream);\\n    pipeline.elementaryStream\\n      .pipe(pipeline.audioTimestampRolloverStream)\\n      .pipe(pipeline.adtsStream);\\n\\n    pipeline.elementaryStream\\n      .pipe(pipeline.timedMetadataTimestampRolloverStream)\\n      .pipe(pipeline.metadataStream)\\n      .pipe(pipeline.coalesceStream);\\n\\n    // Hook up CEA-608/708 caption stream\\n    pipeline.h264Stream.pipe(pipeline.captionStream)\\n      .pipe(pipeline.coalesceStream);\\n\\n    pipeline.elementaryStream.on('data', function(data) {\\n      var i;\\n\\n      if (data.type === 'metadata') {\\n        i = data.tracks.length;\\n\\n        // scan the tracks listed in the metadata\\n        while (i--) {\\n          if (!videoTrack && data.tracks[i].type === 'video') {\\n            videoTrack = data.tracks[i];\\n            videoTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\\n          } else if (!audioTrack && data.tracks[i].type === 'audio') {\\n            audioTrack = data.tracks[i];\\n            audioTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\\n          }\\n        }\\n\\n        // hook up the video segment stream to the first track with h264 data\\n        if (videoTrack && !pipeline.videoSegmentStream) {\\n          pipeline.coalesceStream.numberOfTracks++;\\n          pipeline.videoSegmentStream = new VideoSegmentStream(videoTrack);\\n\\n          pipeline.videoSegmentStream.on('timelineStartInfo', function(timelineStartInfo) {\\n          // When video emits timelineStartInfo data after a flush, we forward that\\n          // info to the AudioSegmentStream, if it exists, because video timeline\\n          // data takes precedence.\\n            if (audioTrack) {\\n              audioTrack.timelineStartInfo = timelineStartInfo;\\n              // On the first segment we trim AAC frames that exist before the\\n              // very earliest DTS we have seen in video because Chrome will\\n              // interpret any video track with a baseMediaDecodeTime that is\\n              // non-zero as a gap.\\n              pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts);\\n            }\\n          });\\n\\n          // Set up the final part of the video pipeline\\n          pipeline.h264Stream\\n            .pipe(pipeline.videoSegmentStream)\\n            .pipe(pipeline.coalesceStream);\\n        }\\n\\n        if (audioTrack && !pipeline.audioSegmentStream) {\\n          // hook up the audio segment stream to the first track with aac data\\n          pipeline.coalesceStream.numberOfTracks++;\\n          pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack);\\n\\n          // Set up the final part of the audio pipeline\\n          pipeline.adtsStream\\n            .pipe(pipeline.audioSegmentStream)\\n            .pipe(pipeline.coalesceStream);\\n        }\\n      }\\n    });\\n\\n    // Re-emit any data coming from the coalesce stream to the outside world\\n    pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\\n    // Let the consumer know we have finished flushing the entire pipeline\\n    pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\\n  };\\n\\n  // hook up the segment streams once track metadata is delivered\\n  this.setBaseMediaDecodeTime = function(baseMediaDecodeTime) {\\n    var pipeline = this.transmuxPipeline_;\\n\\n    this.baseMediaDecodeTime = baseMediaDecodeTime;\\n    if (audioTrack) {\\n      audioTrack.timelineStartInfo.dts = undefined;\\n      audioTrack.timelineStartInfo.pts = undefined;\\n      clearDtsInfo(audioTrack);\\n      audioTrack.timelineStartInfo.baseMediaDecodeTime = baseMediaDecodeTime;\\n    }\\n    if (videoTrack) {\\n      if (pipeline.videoSegmentStream) {\\n        pipeline.videoSegmentStream.gopCache_ = [];\\n      }\\n      videoTrack.timelineStartInfo.dts = undefined;\\n      videoTrack.timelineStartInfo.pts = undefined;\\n      clearDtsInfo(videoTrack);\\n      videoTrack.timelineStartInfo.baseMediaDecodeTime = baseMediaDecodeTime;\\n    }\\n  };\\n\\n  // feed incoming data to the front of the parsing pipeline\\n  this.push = function(data) {\\n    if (hasFlushed) {\\n      var isAac = isLikelyAacData(data);\\n\\n      if (isAac && this.transmuxPipeline_.type !== 'aac') {\\n        this.setupAacPipeline();\\n      } else if (!isAac && this.transmuxPipeline_.type !== 'ts') {\\n        this.setupTsPipeline();\\n      }\\n      hasFlushed = false;\\n    }\\n    this.transmuxPipeline_.headOfPipeline.push(data);\\n  };\\n\\n  // flush any buffered data\\n  this.flush = function() {\\n      hasFlushed = true;\\n    // Start at the top of the pipeline and flush all pending work\\n    this.transmuxPipeline_.headOfPipeline.flush();\\n  };\\n};\\nTransmuxer.prototype = new Stream();\\n\\nmodule.exports = {\\n  Transmuxer: Transmuxer,\\n  VideoSegmentStream: VideoSegmentStream,\\n  AudioSegmentStream: AudioSegmentStream,\\n  AUDIO_PROPERTIES: AUDIO_PROPERTIES,\\n  VIDEO_PROPERTIES: VIDEO_PROPERTIES\\n};\\n\\n},{\\\"../aac\\\":79,\\\"../codecs/adts.js\\\":80,\\\"../codecs/h264\\\":81,\\\"../m2ts/m2ts.js\\\":86,\\\"../utils/stream.js\\\":94,\\\"./mp4-generator.js\\\":91}],93:[function(require,module,exports){\\n'use strict';\\n\\nvar ExpGolomb;\\n\\n/**\\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding\\n * scheme used by h264.\\n */\\nExpGolomb = function(workingData) {\\n  var\\n    // the number of bytes left to examine in workingData\\n    workingBytesAvailable = workingData.byteLength,\\n\\n    // the current word being examined\\n    workingWord = 0, // :uint\\n\\n    // the number of bits left to examine in the current word\\n    workingBitsAvailable = 0; // :uint;\\n\\n  // ():uint\\n  this.length = function() {\\n    return (8 * workingBytesAvailable);\\n  };\\n\\n  // ():uint\\n  this.bitsAvailable = function() {\\n    return (8 * workingBytesAvailable) + workingBitsAvailable;\\n  };\\n\\n  // ():void\\n  this.loadWord = function() {\\n    var\\n      position = workingData.byteLength - workingBytesAvailable,\\n      workingBytes = new Uint8Array(4),\\n      availableBytes = Math.min(4, workingBytesAvailable);\\n\\n    if (availableBytes === 0) {\\n      throw new Error('no bytes available');\\n    }\\n\\n    workingBytes.set(workingData.subarray(position,\\n                                          position + availableBytes));\\n    workingWord = new DataView(workingBytes.buffer).getUint32(0);\\n\\n    // track the amount of workingData that has been processed\\n    workingBitsAvailable = availableBytes * 8;\\n    workingBytesAvailable -= availableBytes;\\n  };\\n\\n  // (count:int):void\\n  this.skipBits = function(count) {\\n    var skipBytes; // :int\\n    if (workingBitsAvailable > count) {\\n      workingWord          <<= count;\\n      workingBitsAvailable -= count;\\n    } else {\\n      count -= workingBitsAvailable;\\n      skipBytes = Math.floor(count / 8);\\n\\n      count -= (skipBytes * 8);\\n      workingBytesAvailable -= skipBytes;\\n\\n      this.loadWord();\\n\\n      workingWord <<= count;\\n      workingBitsAvailable -= count;\\n    }\\n  };\\n\\n  // (size:int):uint\\n  this.readBits = function(size) {\\n    var\\n      bits = Math.min(workingBitsAvailable, size), // :uint\\n      valu = workingWord >>> (32 - bits); // :uint\\n    // if size > 31, handle error\\n    workingBitsAvailable -= bits;\\n    if (workingBitsAvailable > 0) {\\n      workingWord <<= bits;\\n    } else if (workingBytesAvailable > 0) {\\n      this.loadWord();\\n    }\\n\\n    bits = size - bits;\\n    if (bits > 0) {\\n      return valu << bits | this.readBits(bits);\\n    }\\n    return valu;\\n  };\\n\\n  // ():uint\\n  this.skipLeadingZeros = function() {\\n    var leadingZeroCount; // :uint\\n    for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {\\n      if ((workingWord & (0x80000000 >>> leadingZeroCount)) !== 0) {\\n        // the first bit of working word is 1\\n        workingWord <<= leadingZeroCount;\\n        workingBitsAvailable -= leadingZeroCount;\\n        return leadingZeroCount;\\n      }\\n    }\\n\\n    // we exhausted workingWord and still have not found a 1\\n    this.loadWord();\\n    return leadingZeroCount + this.skipLeadingZeros();\\n  };\\n\\n  // ():void\\n  this.skipUnsignedExpGolomb = function() {\\n    this.skipBits(1 + this.skipLeadingZeros());\\n  };\\n\\n  // ():void\\n  this.skipExpGolomb = function() {\\n    this.skipBits(1 + this.skipLeadingZeros());\\n  };\\n\\n  // ():uint\\n  this.readUnsignedExpGolomb = function() {\\n    var clz = this.skipLeadingZeros(); // :uint\\n    return this.readBits(clz + 1) - 1;\\n  };\\n\\n  // ():int\\n  this.readExpGolomb = function() {\\n    var valu = this.readUnsignedExpGolomb(); // :int\\n    if (0x01 & valu) {\\n      // the number is odd if the low order bit is set\\n      return (1 + valu) >>> 1; // add 1 to make it even, and divide by 2\\n    }\\n    return -1 * (valu >>> 1); // divide by two then make it negative\\n  };\\n\\n  // Some convenience functions\\n  // :Boolean\\n  this.readBoolean = function() {\\n    return this.readBits(1) === 1;\\n  };\\n\\n  // ():int\\n  this.readUnsignedByte = function() {\\n    return this.readBits(8);\\n  };\\n\\n  this.loadWord();\\n};\\n\\nmodule.exports = ExpGolomb;\\n\\n},{}],94:[function(require,module,exports){\\n/**\\n * mux.js\\n *\\n * Copyright (c) 2014 Brightcove\\n * All rights reserved.\\n *\\n * A lightweight readable stream implemention that handles event dispatching.\\n * Objects that inherit from streams should call init in their constructors.\\n */\\n'use strict';\\n\\nvar Stream = function() {\\n  this.init = function() {\\n    var listeners = {};\\n    /**\\n     * Add a listener for a specified event type.\\n     * @param type {string} the event name\\n     * @param listener {function} the callback to be invoked when an event of\\n     * the specified type occurs\\n     */\\n    this.on = function(type, listener) {\\n      if (!listeners[type]) {\\n        listeners[type] = [];\\n      }\\n      listeners[type].push(listener);\\n    };\\n    /**\\n     * Remove a listener for a specified event type.\\n     * @param type {string} the event name\\n     * @param listener {function} a function previously registered for this\\n     * type of event through `on`\\n     */\\n    this.off = function(type, listener) {\\n      var index;\\n      if (!listeners[type]) {\\n        return false;\\n      }\\n      index = listeners[type].indexOf(listener);\\n      listeners[type].splice(index, 1);\\n      return index > -1;\\n    };\\n    /**\\n     * Trigger an event of the specified type on this stream. Any additional\\n     * arguments to this function are passed as parameters to event listeners.\\n     * @param type {string} the event name\\n     */\\n    this.trigger = function(type) {\\n      var callbacks, i, length, args;\\n      callbacks = listeners[type];\\n      if (!callbacks) {\\n        return;\\n      }\\n      // Slicing the arguments on every invocation of this method\\n      // can add a significant amount of overhead. Avoid the\\n      // intermediate object creation for the common case of a\\n      // single callback argument\\n      if (arguments.length === 2) {\\n        length = callbacks.length;\\n        for (i = 0; i < length; ++i) {\\n          callbacks[i].call(this, arguments[1]);\\n        }\\n      } else {\\n        args = [];\\n        i = arguments.length;\\n        for (i = 1; i < arguments.length; ++i) {\\n          args.push(arguments[i]);\\n        }\\n        length = callbacks.length;\\n        for (i = 0; i < length; ++i) {\\n          callbacks[i].apply(this, args);\\n        }\\n      }\\n    };\\n    /**\\n     * Destroys the stream and cleans up.\\n     */\\n    this.dispose = function() {\\n      listeners = {};\\n    };\\n  };\\n};\\n\\n/**\\n * Forwards all `data` events on this stream to the destination stream. The\\n * destination stream should provide a method `push` to receive the data\\n * events as they arrive.\\n * @param destination {stream} the stream that will receive all `data` events\\n * @param autoFlush {boolean} if false, we will not call `flush` on the destination\\n *                            when the current stream emits a 'done' event\\n * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\\n */\\nStream.prototype.pipe = function(destination) {\\n  this.on('data', function(data) {\\n    destination.push(data);\\n  });\\n\\n  this.on('done', function(flushSource) {\\n    destination.flush(flushSource);\\n  });\\n\\n  return destination;\\n};\\n\\n// Default stream functions that are expected to be overridden to perform\\n// actual work. These are provided by the prototype as a sort of no-op\\n// implementation so that we don't have to check for their existence in the\\n// `pipe` function above.\\nStream.prototype.push = function(data) {\\n  this.trigger('data', data);\\n};\\n\\nStream.prototype.flush = function(flushSource) {\\n  this.trigger('done', flushSource);\\n};\\n\\nmodule.exports = Stream;\\n\\n},{}],95:[function(require,module,exports){\\nvar bundleFn = arguments[3];\\nvar sources = arguments[4];\\nvar cache = arguments[5];\\n\\nvar stringify = JSON.stringify;\\n\\nmodule.exports = function (fn) {\\n    var keys = [];\\n    var wkey;\\n    var cacheKeys = Object.keys(cache);\\n\\n    for (var i = 0, l = cacheKeys.length; i < l; i++) {\\n        var key = cacheKeys[i];\\n        if (cache[key].exports === fn) {\\n            wkey = key;\\n            break;\\n        }\\n    }\\n\\n    if (!wkey) {\\n        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\\n        var wcache = {};\\n        for (var i = 0, l = cacheKeys.length; i < l; i++) {\\n            var key = cacheKeys[i];\\n            wcache[key] = key;\\n        }\\n        sources[wkey] = [\\n            Function(['require','module','exports'], '(' + fn + ')(self)'),\\n            wcache\\n        ];\\n    }\\n    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\\n\\n    var scache = {}; scache[wkey] = wkey;\\n    sources[skey] = [\\n        Function(['require'],'require(' + stringify(wkey) + ')(self)'),\\n        scache\\n    ];\\n\\n    var src = '(' + bundleFn + ')({'\\n        + Object.keys(sources).map(function (key) {\\n            return stringify(key) + ':['\\n                + sources[key][0]\\n                + ',' + stringify(sources[key][1]) + ']'\\n            ;\\n        }).join(',')\\n        + '},{},[' + stringify(skey) + '])'\\n    ;\\n\\n    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\\n\\n    return new Worker(URL.createObjectURL(\\n        new Blob([src], { type: 'text/javascript' })\\n    ));\\n};\\n\\n},{}],96:[function(require,module,exports){\\n(function (global){\\n/**\\n * @file videojs-contrib-hls.js\\n *\\n * The main file for the HLS project.\\n * License: https://github.com/videojs/videojs-contrib-hls/blob/master/LICENSE\\n */\\n'use strict';\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar _globalDocument = require('global/document');\\n\\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\\n\\nvar _playlistLoader = require('./playlist-loader');\\n\\nvar _playlistLoader2 = _interopRequireDefault(_playlistLoader);\\n\\nvar _playlist = require('./playlist');\\n\\nvar _playlist2 = _interopRequireDefault(_playlist);\\n\\nvar _xhr = require('./xhr');\\n\\nvar _xhr2 = _interopRequireDefault(_xhr);\\n\\nvar _aesDecrypter = require('aes-decrypter');\\n\\nvar _binUtils = require('./bin-utils');\\n\\nvar _binUtils2 = _interopRequireDefault(_binUtils);\\n\\nvar _videojsContribMediaSources = require('videojs-contrib-media-sources');\\n\\nvar _m3u8Parser = require('m3u8-parser');\\n\\nvar _m3u8Parser2 = _interopRequireDefault(_m3u8Parser);\\n\\nvar _videoJs = (typeof window !== \\\"undefined\\\" ? window['videojs'] : typeof global !== \\\"undefined\\\" ? global['videojs'] : null);\\n\\nvar _videoJs2 = _interopRequireDefault(_videoJs);\\n\\nvar _masterPlaylistController = require('./master-playlist-controller');\\n\\nvar _masterPlaylistController2 = _interopRequireDefault(_masterPlaylistController);\\n\\nvar _config = require('./config');\\n\\nvar _config2 = _interopRequireDefault(_config);\\n\\nvar _renditionMixin = require('./rendition-mixin');\\n\\nvar _renditionMixin2 = _interopRequireDefault(_renditionMixin);\\n\\nvar _gapSkipper = require('./gap-skipper');\\n\\nvar _gapSkipper2 = _interopRequireDefault(_gapSkipper);\\n\\nvar _globalWindow = require('global/window');\\n\\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\\n\\n/**\\n * determine if an object a is differnt from\\n * and object b. both only having one dimensional\\n * properties\\n *\\n * @param {Object} a object one\\n * @param {Object} b object two\\n * @return {Boolean} if the object has changed or not\\n */\\nvar objectChanged = function objectChanged(a, b) {\\n  if (typeof a !== typeof b) {\\n    return true;\\n  }\\n  // if we have a different number of elements\\n  // something has changed\\n  if (Object.keys(a).length !== Object.keys(b).length) {\\n    return true;\\n  }\\n\\n  for (var prop in a) {\\n    if (!b[prop] || a[prop] !== b[prop]) {\\n      return true;\\n    }\\n  }\\n  return false;\\n};\\n\\nvar Hls = {\\n  PlaylistLoader: _playlistLoader2['default'],\\n  Playlist: _playlist2['default'],\\n  Decrypter: _aesDecrypter.Decrypter,\\n  AsyncStream: _aesDecrypter.AsyncStream,\\n  decrypt: _aesDecrypter.decrypt,\\n  utils: _binUtils2['default'],\\n  xhr: (0, _xhr2['default'])()\\n};\\n\\nObject.defineProperty(Hls, 'GOAL_BUFFER_LENGTH', {\\n  get: function get() {\\n    _videoJs2['default'].log.warn('using Hls.GOAL_BUFFER_LENGTH is UNSAFE be sure ' + 'you know what you are doing');\\n    return _config2['default'].GOAL_BUFFER_LENGTH;\\n  },\\n  set: function set(v) {\\n    _videoJs2['default'].log.warn('using Hls.GOAL_BUFFER_LENGTH is UNSAFE be sure ' + 'you know what you are doing');\\n    if (typeof v !== 'number' || v <= 0) {\\n      _videoJs2['default'].log.warn('value passed to Hls.GOAL_BUFFER_LENGTH ' + 'must be a number and greater than 0');\\n      return;\\n    }\\n    _config2['default'].GOAL_BUFFER_LENGTH = v;\\n  }\\n});\\n\\n// A fudge factor to apply to advertised playlist bitrates to account for\\n// temporary flucations in client bandwidth\\nvar BANDWIDTH_VARIANCE = 1.2;\\n\\n/**\\n * Returns the CSS value for the specified property on an element\\n * using `getComputedStyle`. Firefox has a long-standing issue where\\n * getComputedStyle() may return null when running in an iframe with\\n * `display: none`.\\n *\\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=548397\\n * @param {HTMLElement} el the htmlelement to work on\\n * @param {string} the proprety to get the style for\\n */\\nvar safeGetComputedStyle = function safeGetComputedStyle(el, property) {\\n  var result = undefined;\\n\\n  if (!el) {\\n    return '';\\n  }\\n\\n  result = _globalWindow2['default'].getComputedStyle(el);\\n  if (!result) {\\n    return '';\\n  }\\n\\n  return result[property];\\n};\\n\\n/**\\n * Chooses the appropriate media playlist based on the current\\n * bandwidth estimate and the player size.\\n *\\n * @return {Playlist} the highest bitrate playlist less than the currently detected\\n * bandwidth, accounting for some amount of bandwidth variance\\n */\\nHls.STANDARD_PLAYLIST_SELECTOR = function () {\\n  var effectiveBitrate = undefined;\\n  var sortedPlaylists = this.playlists.master.playlists.slice();\\n  var bandwidthPlaylists = [];\\n  var now = +new Date();\\n  var i = undefined;\\n  var variant = undefined;\\n  var bandwidthBestVariant = undefined;\\n  var resolutionPlusOne = undefined;\\n  var resolutionPlusOneAttribute = undefined;\\n  var resolutionBestVariant = undefined;\\n  var width = undefined;\\n  var height = undefined;\\n\\n  sortedPlaylists.sort(Hls.comparePlaylistBandwidth);\\n\\n  // filter out any playlists that have been excluded due to\\n  // incompatible configurations or playback errors\\n  sortedPlaylists = sortedPlaylists.filter(function (localVariant) {\\n    if (typeof localVariant.excludeUntil !== 'undefined') {\\n      return now >= localVariant.excludeUntil;\\n    }\\n    return true;\\n  });\\n\\n  // filter out any variant that has greater effective bitrate\\n  // than the current estimated bandwidth\\n  i = sortedPlaylists.length;\\n  while (i--) {\\n    variant = sortedPlaylists[i];\\n\\n    // ignore playlists without bandwidth information\\n    if (!variant.attributes || !variant.attributes.BANDWIDTH) {\\n      continue;\\n    }\\n\\n    effectiveBitrate = variant.attributes.BANDWIDTH * BANDWIDTH_VARIANCE;\\n\\n    if (effectiveBitrate < this.bandwidth) {\\n      bandwidthPlaylists.push(variant);\\n\\n      // since the playlists are sorted in ascending order by\\n      // bandwidth, the first viable variant is the best\\n      if (!bandwidthBestVariant) {\\n        bandwidthBestVariant = variant;\\n      }\\n    }\\n  }\\n\\n  i = bandwidthPlaylists.length;\\n\\n  // sort variants by resolution\\n  bandwidthPlaylists.sort(Hls.comparePlaylistResolution);\\n\\n  // forget our old variant from above,\\n  // or we might choose that in high-bandwidth scenarios\\n  // (this could be the lowest bitrate rendition as  we go through all of them above)\\n  variant = null;\\n\\n  width = parseInt(safeGetComputedStyle(this.tech_.el(), 'width'), 10);\\n  height = parseInt(safeGetComputedStyle(this.tech_.el(), 'height'), 10);\\n\\n  // iterate through the bandwidth-filtered playlists and find\\n  // best rendition by player dimension\\n  while (i--) {\\n    variant = bandwidthPlaylists[i];\\n\\n    // ignore playlists without resolution information\\n    if (!variant.attributes || !variant.attributes.RESOLUTION || !variant.attributes.RESOLUTION.width || !variant.attributes.RESOLUTION.height) {\\n      continue;\\n    }\\n\\n    // since the playlists are sorted, the first variant that has\\n    // dimensions less than or equal to the player size is the best\\n    var variantResolution = variant.attributes.RESOLUTION;\\n\\n    if (variantResolution.width === width && variantResolution.height === height) {\\n      // if we have the exact resolution as the player use it\\n      resolutionPlusOne = null;\\n      resolutionBestVariant = variant;\\n      break;\\n    } else if (variantResolution.width < width && variantResolution.height < height) {\\n      // if both dimensions are less than the player use the\\n      // previous (next-largest) variant\\n      break;\\n    } else if (!resolutionPlusOne || variantResolution.width < resolutionPlusOneAttribute.width && variantResolution.height < resolutionPlusOneAttribute.height) {\\n      // If we still haven't found a good match keep a\\n      // reference to the previous variant for the next loop\\n      // iteration\\n\\n      // By only saving variants if they are smaller than the\\n      // previously saved variant, we ensure that we also pick\\n      // the highest bandwidth variant that is just-larger-than\\n      // the video player\\n      resolutionPlusOne = variant;\\n      resolutionPlusOneAttribute = resolutionPlusOne.attributes.RESOLUTION;\\n    }\\n  }\\n\\n  // fallback chain of variants\\n  return resolutionPlusOne || resolutionBestVariant || bandwidthBestVariant || sortedPlaylists[0];\\n};\\n\\n// HLS is a source handler, not a tech. Make sure attempts to use it\\n// as one do not cause exceptions.\\nHls.canPlaySource = function () {\\n  return _videoJs2['default'].log.warn('HLS is no longer a tech. Please remove it from ' + 'your player\\\\'s techOrder.');\\n};\\n\\n/**\\n * Whether the browser has built-in HLS support.\\n */\\nHls.supportsNativeHls = (function () {\\n  var video = _globalDocument2['default'].createElement('video');\\n\\n  // native HLS is definitely not supported if HTML5 video isn't\\n  if (!_videoJs2['default'].getComponent('Html5').isSupported()) {\\n    return false;\\n  }\\n\\n  // HLS manifests can go by many mime-types\\n  var canPlay = [\\n  // Apple santioned\\n  'application/vnd.apple.mpegurl',\\n  // Apple sanctioned for backwards compatibility\\n  'audio/mpegurl',\\n  // Very common\\n  'audio/x-mpegurl',\\n  // Very common\\n  'application/x-mpegurl',\\n  // Included for completeness\\n  'video/x-mpegurl', 'video/mpegurl', 'application/mpegurl'];\\n\\n  return canPlay.some(function (canItPlay) {\\n    return (/maybe|probably/i.test(video.canPlayType(canItPlay))\\n    );\\n  });\\n})();\\n\\n/**\\n * HLS is a source handler, not a tech. Make sure attempts to use it\\n * as one do not cause exceptions.\\n */\\nHls.isSupported = function () {\\n  return _videoJs2['default'].log.warn('HLS is no longer a tech. Please remove it from ' + 'your player\\\\'s techOrder.');\\n};\\n\\nvar Component = _videoJs2['default'].getComponent('Component');\\n\\n/**\\n * The Hls Handler object, where we orchestrate all of the parts\\n * of HLS to interact with video.js\\n *\\n * @class HlsHandler\\n * @extends videojs.Component\\n * @param {Object} source the soruce object\\n * @param {Tech} tech the parent tech object\\n * @param {Object} options optional and required options\\n */\\n\\nvar HlsHandler = (function (_Component) {\\n  _inherits(HlsHandler, _Component);\\n\\n  function HlsHandler(source, tech, options) {\\n    var _this = this;\\n\\n    _classCallCheck(this, HlsHandler);\\n\\n    _get(Object.getPrototypeOf(HlsHandler.prototype), 'constructor', this).call(this, tech);\\n\\n    // tech.player() is deprecated but setup a reference to HLS for\\n    // backwards-compatibility\\n    if (tech.options_ && tech.options_.playerId) {\\n      var _player = (0, _videoJs2['default'])(tech.options_.playerId);\\n\\n      if (!_player.hasOwnProperty('hls')) {\\n        Object.defineProperty(_player, 'hls', {\\n          get: function get() {\\n            _videoJs2['default'].log.warn('player.hls is deprecated. Use player.tech.hls instead.');\\n            return _this;\\n          }\\n        });\\n      }\\n    }\\n\\n    this.tech_ = tech;\\n    this.source_ = source;\\n    this.stats = {};\\n\\n    // handle global & Source Handler level options\\n    this.options_ = _videoJs2['default'].mergeOptions(_videoJs2['default'].options.hls || {}, options.hls);\\n    this.setOptions_();\\n\\n    // listen for fullscreenchange events for this player so that we\\n    // can adjust our quality selection quickly\\n    this.on(_globalDocument2['default'], ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'], function (event) {\\n      var fullscreenElement = _globalDocument2['default'].fullscreenElement || _globalDocument2['default'].webkitFullscreenElement || _globalDocument2['default'].mozFullScreenElement || _globalDocument2['default'].msFullscreenElement;\\n\\n      if (fullscreenElement && fullscreenElement.contains(_this.tech_.el())) {\\n        _this.masterPlaylistController_.fastQualityChange_();\\n      }\\n    });\\n\\n    this.on(this.tech_, 'seeking', function () {\\n      this.setCurrentTime(this.tech_.currentTime());\\n    });\\n    this.on(this.tech_, 'error', function () {\\n      if (this.masterPlaylistController_) {\\n        this.masterPlaylistController_.pauseLoading();\\n      }\\n    });\\n\\n    this.audioTrackChange_ = function () {\\n      _this.masterPlaylistController_.useAudio();\\n    };\\n\\n    this.on(this.tech_, 'play', this.play);\\n  }\\n\\n  /**\\n   * The Source Handler object, which informs video.js what additional\\n   * MIME types are supported and sets up playback. It is registered\\n   * automatically to the appropriate tech based on the capabilities of\\n   * the browser it is running in. It is not necessary to use or modify\\n   * this object in normal usage.\\n   */\\n\\n  _createClass(HlsHandler, [{\\n    key: 'setOptions_',\\n    value: function setOptions_() {\\n      var _this2 = this;\\n\\n      // defaults\\n      this.options_.withCredentials = this.options_.withCredentials || false;\\n\\n      // start playlist selection at a reasonable bandwidth for\\n      // broadband internet\\n      // 0.5 MB/s\\n      this.options_.bandwidth = this.options_.bandwidth || 4194304;\\n\\n      // grab options passed to player.src\\n      ['withCredentials', 'bandwidth'].forEach(function (option) {\\n        if (typeof _this2.source_[option] !== 'undefined') {\\n          _this2.options_[option] = _this2.source_[option];\\n        }\\n      });\\n\\n      this.bandwidth = this.options_.bandwidth;\\n    }\\n\\n    /**\\n     * called when player.src gets called, handle a new source\\n     *\\n     * @param {Object} src the source object to handle\\n     */\\n  }, {\\n    key: 'src',\\n    value: function src(_src) {\\n      var _this3 = this;\\n\\n      // do nothing if the src is falsey\\n      if (!_src) {\\n        return;\\n      }\\n      this.setOptions_();\\n      // add master playlist controller options\\n      this.options_.url = this.source_.src;\\n      this.options_.tech = this.tech_;\\n      this.options_.externHls = Hls;\\n      this.masterPlaylistController_ = new _masterPlaylistController2['default'](this.options_);\\n      this.gapSkipper_ = new _gapSkipper2['default'](this.options_);\\n\\n      // `this` in selectPlaylist should be the HlsHandler for backwards\\n      // compatibility with < v2\\n      this.masterPlaylistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : Hls.STANDARD_PLAYLIST_SELECTOR.bind(this);\\n\\n      // re-expose some internal objects for backwards compatibility with < v2\\n      this.playlists = this.masterPlaylistController_.masterPlaylistLoader_;\\n      this.mediaSource = this.masterPlaylistController_.mediaSource;\\n\\n      // Proxy assignment of some properties to the master playlist\\n      // controller. Using a custom property for backwards compatibility\\n      // with < v2\\n      Object.defineProperties(this, {\\n        selectPlaylist: {\\n          get: function get() {\\n            return this.masterPlaylistController_.selectPlaylist;\\n          },\\n          set: function set(selectPlaylist) {\\n            this.masterPlaylistController_.selectPlaylist = selectPlaylist.bind(this);\\n          }\\n        },\\n        bandwidth: {\\n          get: function get() {\\n            return this.masterPlaylistController_.mainSegmentLoader_.bandwidth;\\n          },\\n          set: function set(bandwidth) {\\n            this.masterPlaylistController_.mainSegmentLoader_.bandwidth = bandwidth;\\n          }\\n        }\\n      });\\n\\n      Object.defineProperties(this.stats, {\\n        bandwidth: {\\n          get: function get() {\\n            return _this3.bandwidth || 0;\\n          },\\n          enumerable: true\\n        },\\n        mediaRequests: {\\n          get: function get() {\\n            return _this3.masterPlaylistController_.mediaRequests_() || 0;\\n          },\\n          enumerable: true\\n        },\\n        mediaTransferDuration: {\\n          get: function get() {\\n            return _this3.masterPlaylistController_.mediaTransferDuration_() || 0;\\n          },\\n          enumerable: true\\n        },\\n        mediaBytesTransferred: {\\n          get: function get() {\\n            return _this3.masterPlaylistController_.mediaBytesTransferred_() || 0;\\n          },\\n          enumerable: true\\n        }\\n      });\\n\\n      this.tech_.one('canplay', this.masterPlaylistController_.setupFirstPlay.bind(this.masterPlaylistController_));\\n\\n      this.masterPlaylistController_.on('sourceopen', function () {\\n        _this3.tech_.audioTracks().addEventListener('change', _this3.audioTrackChange_);\\n      });\\n\\n      this.masterPlaylistController_.on('audioinfo', function (e) {\\n        if (!_videoJs2['default'].browser.IS_FIREFOX || !_this3.audioInfo_ || !objectChanged(_this3.audioInfo_, e.info)) {\\n          _this3.audioInfo_ = e.info;\\n          return;\\n        }\\n\\n        var error = 'had different audio properties (channels, sample rate, etc.) ' + 'or changed in some other way.  This behavior is currently ' + 'unsupported in Firefox due to an issue: \\\\n\\\\n' + 'https://bugzilla.mozilla.org/show_bug.cgi?id=1247138\\\\n\\\\n';\\n\\n        var enabledTrack = undefined;\\n        var defaultTrack = undefined;\\n\\n        _this3.masterPlaylistController_.audioTracks_.forEach(function (t) {\\n          if (!defaultTrack && t['default']) {\\n            defaultTrack = t;\\n          }\\n\\n          if (!enabledTrack && t.enabled) {\\n            enabledTrack = t;\\n          }\\n        });\\n\\n        // they did not switch audiotracks\\n        // blacklist the current playlist\\n        if (!enabledTrack.getLoader(_this3.activeAudioGroup_())) {\\n          error = 'The rendition that we tried to switch to ' + error + 'Unfortunately that means we will have to blacklist ' + 'the current playlist and switch to another. Sorry!';\\n          _this3.masterPlaylistController_.blacklistCurrentPlaylist();\\n        } else {\\n          error = 'The audio track \\\\'' + enabledTrack.label + '\\\\' that we tried to ' + ('switch to ' + error + ' Unfortunately this means we will have to ') + ('return you to the main track \\\\'' + defaultTrack.label + '\\\\'. Sorry!');\\n          defaultTrack.enabled = true;\\n          _this3.tech_.audioTracks().removeTrack(enabledTrack);\\n        }\\n\\n        _videoJs2['default'].log.warn(error);\\n        _this3.masterPlaylistController_.useAudio();\\n      });\\n      this.masterPlaylistController_.on('selectedinitialmedia', function () {\\n        // clear current audioTracks\\n        _this3.tech_.clearTracks('audio');\\n        _this3.masterPlaylistController_.audioTracks_.forEach(function (track) {\\n          _this3.tech_.audioTracks().addTrack(track);\\n        });\\n\\n        // Add the manual rendition mix-in to HlsHandler\\n        (0, _renditionMixin2['default'])(_this3);\\n      });\\n\\n      // the bandwidth of the primary segment loader is our best\\n      // estimate of overall bandwidth\\n      this.on(this.masterPlaylistController_, 'progress', function () {\\n        this.bandwidth = this.masterPlaylistController_.mainSegmentLoader_.bandwidth;\\n        this.tech_.trigger('progress');\\n      });\\n\\n      // do nothing if the tech has been disposed already\\n      // this can occur if someone sets the src in player.ready(), for instance\\n      if (!this.tech_.el()) {\\n        return;\\n      }\\n\\n      this.tech_.src(_videoJs2['default'].URL.createObjectURL(this.masterPlaylistController_.mediaSource));\\n    }\\n\\n    /**\\n     * a helper for grabbing the active audio group from MasterPlaylistController\\n     *\\n     * @private\\n     */\\n  }, {\\n    key: 'activeAudioGroup_',\\n    value: function activeAudioGroup_() {\\n      return this.masterPlaylistController_.activeAudioGroup();\\n    }\\n\\n    /**\\n     * Begin playing the video.\\n     */\\n  }, {\\n    key: 'play',\\n    value: function play() {\\n      this.masterPlaylistController_.play();\\n    }\\n\\n    /**\\n     * a wrapper around the function in MasterPlaylistController\\n     */\\n  }, {\\n    key: 'setCurrentTime',\\n    value: function setCurrentTime(currentTime) {\\n      this.masterPlaylistController_.setCurrentTime(currentTime);\\n    }\\n\\n    /**\\n     * a wrapper around the function in MasterPlaylistController\\n     */\\n  }, {\\n    key: 'duration',\\n    value: function duration() {\\n      return this.masterPlaylistController_.duration();\\n    }\\n\\n    /**\\n     * a wrapper around the function in MasterPlaylistController\\n     */\\n  }, {\\n    key: 'seekable',\\n    value: function seekable() {\\n      return this.masterPlaylistController_.seekable();\\n    }\\n\\n    /**\\n    * Abort all outstanding work and cleanup.\\n    */\\n  }, {\\n    key: 'dispose',\\n    value: function dispose() {\\n      if (this.masterPlaylistController_) {\\n        this.masterPlaylistController_.dispose();\\n      }\\n      this.gapSkipper_.dispose();\\n      this.tech_.audioTracks().removeEventListener('change', this.audioTrackChange_);\\n      _get(Object.getPrototypeOf(HlsHandler.prototype), 'dispose', this).call(this);\\n    }\\n  }]);\\n\\n  return HlsHandler;\\n})(Component);\\n\\nvar HlsSourceHandler = function HlsSourceHandler(mode) {\\n  return {\\n    canHandleSource: function canHandleSource(srcObj) {\\n      // this forces video.js to skip this tech/mode if its not the one we have been\\n      // overriden to use, by returing that we cannot handle the source.\\n      if (_videoJs2['default'].options.hls && _videoJs2['default'].options.hls.mode && _videoJs2['default'].options.hls.mode !== mode) {\\n        return false;\\n      }\\n      return HlsSourceHandler.canPlayType(srcObj.type);\\n    },\\n    handleSource: function handleSource(source, tech, options) {\\n      if (mode === 'flash') {\\n        // We need to trigger this asynchronously to give others the chance\\n        // to bind to the event when a source is set at player creation\\n        tech.setTimeout(function () {\\n          tech.trigger('loadstart');\\n        }, 1);\\n      }\\n\\n      var settings = _videoJs2['default'].mergeOptions(options, { hls: { mode: mode } });\\n\\n      tech.hls = new HlsHandler(source, tech, settings);\\n\\n      tech.hls.xhr = (0, _xhr2['default'])();\\n      // Use a global `before` function if specified on videojs.Hls.xhr\\n      // but still allow for a per-player override\\n      if (_videoJs2['default'].Hls.xhr.beforeRequest) {\\n        tech.hls.xhr.beforeRequest = _videoJs2['default'].Hls.xhr.beforeRequest;\\n      }\\n\\n      tech.hls.src(source.src);\\n      return tech.hls;\\n    },\\n    canPlayType: function canPlayType(type) {\\n      if (HlsSourceHandler.canPlayType(type)) {\\n        return 'maybe';\\n      }\\n      return '';\\n    }\\n  };\\n};\\n\\n/**\\n * A comparator function to sort two playlist object by bandwidth.\\n *\\n * @param {Object} left a media playlist object\\n * @param {Object} right a media playlist object\\n * @return {Number} Greater than zero if the bandwidth attribute of\\n * left is greater than the corresponding attribute of right. Less\\n * than zero if the bandwidth of right is greater than left and\\n * exactly zero if the two are equal.\\n */\\nHls.comparePlaylistBandwidth = function (left, right) {\\n  var leftBandwidth = undefined;\\n  var rightBandwidth = undefined;\\n\\n  if (left.attributes && left.attributes.BANDWIDTH) {\\n    leftBandwidth = left.attributes.BANDWIDTH;\\n  }\\n  leftBandwidth = leftBandwidth || _globalWindow2['default'].Number.MAX_VALUE;\\n  if (right.attributes && right.attributes.BANDWIDTH) {\\n    rightBandwidth = right.attributes.BANDWIDTH;\\n  }\\n  rightBandwidth = rightBandwidth || _globalWindow2['default'].Number.MAX_VALUE;\\n\\n  return leftBandwidth - rightBandwidth;\\n};\\n\\n/**\\n * A comparator function to sort two playlist object by resolution (width).\\n * @param {Object} left a media playlist object\\n * @param {Object} right a media playlist object\\n * @return {Number} Greater than zero if the resolution.width attribute of\\n * left is greater than the corresponding attribute of right. Less\\n * than zero if the resolution.width of right is greater than left and\\n * exactly zero if the two are equal.\\n */\\nHls.comparePlaylistResolution = function (left, right) {\\n  var leftWidth = undefined;\\n  var rightWidth = undefined;\\n\\n  if (left.attributes && left.attributes.RESOLUTION && left.attributes.RESOLUTION.width) {\\n    leftWidth = left.attributes.RESOLUTION.width;\\n  }\\n\\n  leftWidth = leftWidth || _globalWindow2['default'].Number.MAX_VALUE;\\n\\n  if (right.attributes && right.attributes.RESOLUTION && right.attributes.RESOLUTION.width) {\\n    rightWidth = right.attributes.RESOLUTION.width;\\n  }\\n\\n  rightWidth = rightWidth || _globalWindow2['default'].Number.MAX_VALUE;\\n\\n  // NOTE - Fallback to bandwidth sort as appropriate in cases where multiple renditions\\n  // have the same media dimensions/ resolution\\n  if (leftWidth === rightWidth && left.attributes.BANDWIDTH && right.attributes.BANDWIDTH) {\\n    return left.attributes.BANDWIDTH - right.attributes.BANDWIDTH;\\n  }\\n  return leftWidth - rightWidth;\\n};\\n\\nHlsSourceHandler.canPlayType = function (type) {\\n  var mpegurlRE = /^(audio|video|application)\\\\/(x-|vnd\\\\.apple\\\\.)?mpegurl/i;\\n\\n  // favor native HLS support if it's available\\n  if (Hls.supportsNativeHls) {\\n    return false;\\n  }\\n  return mpegurlRE.test(type);\\n};\\n\\nif (typeof _videoJs2['default'].MediaSource === 'undefined' || typeof _videoJs2['default'].URL === 'undefined') {\\n  _videoJs2['default'].MediaSource = _videojsContribMediaSources.MediaSource;\\n  _videoJs2['default'].URL = _videojsContribMediaSources.URL;\\n}\\n\\n// register source handlers with the appropriate techs\\nif (_videojsContribMediaSources.MediaSource.supportsNativeMediaSources()) {\\n  _videoJs2['default'].getComponent('Html5').registerSourceHandler(HlsSourceHandler('html5'));\\n}\\nif (_globalWindow2['default'].Uint8Array) {\\n  _videoJs2['default'].getComponent('Flash').registerSourceHandler(HlsSourceHandler('flash'));\\n}\\n\\n_videoJs2['default'].HlsHandler = HlsHandler;\\n_videoJs2['default'].HlsSourceHandler = HlsSourceHandler;\\n_videoJs2['default'].Hls = Hls;\\n_videoJs2['default'].m3u8 = _m3u8Parser2['default'];\\n_videoJs2['default'].registerComponent('Hls', Hls);\\n_videoJs2['default'].options.hls = _videoJs2['default'].options.hls || {};\\n\\nmodule.exports = {\\n  Hls: Hls,\\n  HlsHandler: HlsHandler,\\n  HlsSourceHandler: HlsSourceHandler\\n};\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./bin-utils\\\":2,\\\"./config\\\":3,\\\"./gap-skipper\\\":4,\\\"./master-playlist-controller\\\":6,\\\"./playlist\\\":8,\\\"./playlist-loader\\\":7,\\\"./rendition-mixin\\\":10,\\\"./xhr\\\":15,\\\"aes-decrypter\\\":19,\\\"global/document\\\":25,\\\"global/window\\\":26,\\\"m3u8-parser\\\":63,\\\"videojs-contrib-media-sources\\\":77}]},{},[96])(96)\\n});\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/francoisdagostini/Projects/infiniteUx-prototype/~/raw-loader!/Users/francoisdagostini/Projects/infiniteUx-prototype/~/source-map-loader!/Users/francoisdagostini/Projects/infiniteUx-prototype/src/assets/videojs/videojs-contrib-hls.js\n// module id = 830\n// module chunks = 3","module.exports = \"/*! tether 1.4.0 */\\n\\n(function(root, factory) {\\n  if (typeof define === 'function' && define.amd) {\\n    define(factory);\\n  } else if (typeof exports === 'object') {\\n    module.exports = factory(require, exports, module);\\n  } else {\\n    root.Tether = factory();\\n  }\\n}(this, function(require, exports, module) {\\n\\n'use strict';\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nvar TetherBase = undefined;\\nif (typeof TetherBase === 'undefined') {\\n  TetherBase = { modules: [] };\\n}\\n\\nvar zeroElement = null;\\n\\n// Same as native getBoundingClientRect, except it takes into account parent <frame> offsets\\n// if the element lies within a nested document (<frame> or <iframe>-like).\\nfunction getActualBoundingClientRect(node) {\\n  var boundingRect = node.getBoundingClientRect();\\n\\n  // The original object returned by getBoundingClientRect is immutable, so we clone it\\n  // We can't use extend because the properties are not considered part of the object by hasOwnProperty in IE9\\n  var rect = {};\\n  for (var k in boundingRect) {\\n    rect[k] = boundingRect[k];\\n  }\\n\\n  if (node.ownerDocument !== document) {\\n    var _frameElement = node.ownerDocument.defaultView.frameElement;\\n    if (_frameElement) {\\n      var frameRect = getActualBoundingClientRect(_frameElement);\\n      rect.top += frameRect.top;\\n      rect.bottom += frameRect.top;\\n      rect.left += frameRect.left;\\n      rect.right += frameRect.left;\\n    }\\n  }\\n\\n  return rect;\\n}\\n\\nfunction getScrollParents(el) {\\n  // In firefox if the el is inside an iframe with display: none; window.getComputedStyle() will return null;\\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=548397\\n  var computedStyle = getComputedStyle(el) || {};\\n  var position = computedStyle.position;\\n  var parents = [];\\n\\n  if (position === 'fixed') {\\n    return [el];\\n  }\\n\\n  var parent = el;\\n  while ((parent = parent.parentNode) && parent && parent.nodeType === 1) {\\n    var style = undefined;\\n    try {\\n      style = getComputedStyle(parent);\\n    } catch (err) {}\\n\\n    if (typeof style === 'undefined' || style === null) {\\n      parents.push(parent);\\n      return parents;\\n    }\\n\\n    var _style = style;\\n    var overflow = _style.overflow;\\n    var overflowX = _style.overflowX;\\n    var overflowY = _style.overflowY;\\n\\n    if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {\\n      if (position !== 'absolute' || ['relative', 'absolute', 'fixed'].indexOf(style.position) >= 0) {\\n        parents.push(parent);\\n      }\\n    }\\n  }\\n\\n  parents.push(el.ownerDocument.body);\\n\\n  // If the node is within a frame, account for the parent window scroll\\n  if (el.ownerDocument !== document) {\\n    parents.push(el.ownerDocument.defaultView);\\n  }\\n\\n  return parents;\\n}\\n\\nvar uniqueId = (function () {\\n  var id = 0;\\n  return function () {\\n    return ++id;\\n  };\\n})();\\n\\nvar zeroPosCache = {};\\nvar getOrigin = function getOrigin() {\\n  // getBoundingClientRect is unfortunately too accurate.  It introduces a pixel or two of\\n  // jitter as the user scrolls that messes with our ability to detect if two positions\\n  // are equivilant or not.  We place an element at the top left of the page that will\\n  // get the same jitter, so we can cancel the two out.\\n  var node = zeroElement;\\n  if (!node || !document.body.contains(node)) {\\n    node = document.createElement('div');\\n    node.setAttribute('data-tether-id', uniqueId());\\n    extend(node.style, {\\n      top: 0,\\n      left: 0,\\n      position: 'absolute'\\n    });\\n\\n    document.body.appendChild(node);\\n\\n    zeroElement = node;\\n  }\\n\\n  var id = node.getAttribute('data-tether-id');\\n  if (typeof zeroPosCache[id] === 'undefined') {\\n    zeroPosCache[id] = getActualBoundingClientRect(node);\\n\\n    // Clear the cache when this position call is done\\n    defer(function () {\\n      delete zeroPosCache[id];\\n    });\\n  }\\n\\n  return zeroPosCache[id];\\n};\\n\\nfunction removeUtilElements() {\\n  if (zeroElement) {\\n    document.body.removeChild(zeroElement);\\n  }\\n  zeroElement = null;\\n};\\n\\nfunction getBounds(el) {\\n  var doc = undefined;\\n  if (el === document) {\\n    doc = document;\\n    el = document.documentElement;\\n  } else {\\n    doc = el.ownerDocument;\\n  }\\n\\n  var docEl = doc.documentElement;\\n\\n  var box = getActualBoundingClientRect(el);\\n\\n  var origin = getOrigin();\\n\\n  box.top -= origin.top;\\n  box.left -= origin.left;\\n\\n  if (typeof box.width === 'undefined') {\\n    box.width = document.body.scrollWidth - box.left - box.right;\\n  }\\n  if (typeof box.height === 'undefined') {\\n    box.height = document.body.scrollHeight - box.top - box.bottom;\\n  }\\n\\n  box.top = box.top - docEl.clientTop;\\n  box.left = box.left - docEl.clientLeft;\\n  box.right = doc.body.clientWidth - box.width - box.left;\\n  box.bottom = doc.body.clientHeight - box.height - box.top;\\n\\n  return box;\\n}\\n\\nfunction getOffsetParent(el) {\\n  return el.offsetParent || document.documentElement;\\n}\\n\\nvar _scrollBarSize = null;\\nfunction getScrollBarSize() {\\n  if (_scrollBarSize) {\\n    return _scrollBarSize;\\n  }\\n  var inner = document.createElement('div');\\n  inner.style.width = '100%';\\n  inner.style.height = '200px';\\n\\n  var outer = document.createElement('div');\\n  extend(outer.style, {\\n    position: 'absolute',\\n    top: 0,\\n    left: 0,\\n    pointerEvents: 'none',\\n    visibility: 'hidden',\\n    width: '200px',\\n    height: '150px',\\n    overflow: 'hidden'\\n  });\\n\\n  outer.appendChild(inner);\\n\\n  document.body.appendChild(outer);\\n\\n  var widthContained = inner.offsetWidth;\\n  outer.style.overflow = 'scroll';\\n  var widthScroll = inner.offsetWidth;\\n\\n  if (widthContained === widthScroll) {\\n    widthScroll = outer.clientWidth;\\n  }\\n\\n  document.body.removeChild(outer);\\n\\n  var width = widthContained - widthScroll;\\n\\n  _scrollBarSize = { width: width, height: width };\\n  return _scrollBarSize;\\n}\\n\\nfunction extend() {\\n  var out = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\\n\\n  var args = [];\\n\\n  Array.prototype.push.apply(args, arguments);\\n\\n  args.slice(1).forEach(function (obj) {\\n    if (obj) {\\n      for (var key in obj) {\\n        if (({}).hasOwnProperty.call(obj, key)) {\\n          out[key] = obj[key];\\n        }\\n      }\\n    }\\n  });\\n\\n  return out;\\n}\\n\\nfunction removeClass(el, name) {\\n  if (typeof el.classList !== 'undefined') {\\n    name.split(' ').forEach(function (cls) {\\n      if (cls.trim()) {\\n        el.classList.remove(cls);\\n      }\\n    });\\n  } else {\\n    var regex = new RegExp('(^| )' + name.split(' ').join('|') + '( |$)', 'gi');\\n    var className = getClassName(el).replace(regex, ' ');\\n    setClassName(el, className);\\n  }\\n}\\n\\nfunction addClass(el, name) {\\n  if (typeof el.classList !== 'undefined') {\\n    name.split(' ').forEach(function (cls) {\\n      if (cls.trim()) {\\n        el.classList.add(cls);\\n      }\\n    });\\n  } else {\\n    removeClass(el, name);\\n    var cls = getClassName(el) + (' ' + name);\\n    setClassName(el, cls);\\n  }\\n}\\n\\nfunction hasClass(el, name) {\\n  if (typeof el.classList !== 'undefined') {\\n    return el.classList.contains(name);\\n  }\\n  var className = getClassName(el);\\n  return new RegExp('(^| )' + name + '( |$)', 'gi').test(className);\\n}\\n\\nfunction getClassName(el) {\\n  // Can't use just SVGAnimatedString here since nodes within a Frame in IE have\\n  // completely separately SVGAnimatedString base classes\\n  if (el.className instanceof el.ownerDocument.defaultView.SVGAnimatedString) {\\n    return el.className.baseVal;\\n  }\\n  return el.className;\\n}\\n\\nfunction setClassName(el, className) {\\n  el.setAttribute('class', className);\\n}\\n\\nfunction updateClasses(el, add, all) {\\n  // Of the set of 'all' classes, we need the 'add' classes, and only the\\n  // 'add' classes to be set.\\n  all.forEach(function (cls) {\\n    if (add.indexOf(cls) === -1 && hasClass(el, cls)) {\\n      removeClass(el, cls);\\n    }\\n  });\\n\\n  add.forEach(function (cls) {\\n    if (!hasClass(el, cls)) {\\n      addClass(el, cls);\\n    }\\n  });\\n}\\n\\nvar deferred = [];\\n\\nvar defer = function defer(fn) {\\n  deferred.push(fn);\\n};\\n\\nvar flush = function flush() {\\n  var fn = undefined;\\n  while (fn = deferred.pop()) {\\n    fn();\\n  }\\n};\\n\\nvar Evented = (function () {\\n  function Evented() {\\n    _classCallCheck(this, Evented);\\n  }\\n\\n  _createClass(Evented, [{\\n    key: 'on',\\n    value: function on(event, handler, ctx) {\\n      var once = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];\\n\\n      if (typeof this.bindings === 'undefined') {\\n        this.bindings = {};\\n      }\\n      if (typeof this.bindings[event] === 'undefined') {\\n        this.bindings[event] = [];\\n      }\\n      this.bindings[event].push({ handler: handler, ctx: ctx, once: once });\\n    }\\n  }, {\\n    key: 'once',\\n    value: function once(event, handler, ctx) {\\n      this.on(event, handler, ctx, true);\\n    }\\n  }, {\\n    key: 'off',\\n    value: function off(event, handler) {\\n      if (typeof this.bindings === 'undefined' || typeof this.bindings[event] === 'undefined') {\\n        return;\\n      }\\n\\n      if (typeof handler === 'undefined') {\\n        delete this.bindings[event];\\n      } else {\\n        var i = 0;\\n        while (i < this.bindings[event].length) {\\n          if (this.bindings[event][i].handler === handler) {\\n            this.bindings[event].splice(i, 1);\\n          } else {\\n            ++i;\\n          }\\n        }\\n      }\\n    }\\n  }, {\\n    key: 'trigger',\\n    value: function trigger(event) {\\n      if (typeof this.bindings !== 'undefined' && this.bindings[event]) {\\n        var i = 0;\\n\\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n          args[_key - 1] = arguments[_key];\\n        }\\n\\n        while (i < this.bindings[event].length) {\\n          var _bindings$event$i = this.bindings[event][i];\\n          var handler = _bindings$event$i.handler;\\n          var ctx = _bindings$event$i.ctx;\\n          var once = _bindings$event$i.once;\\n\\n          var context = ctx;\\n          if (typeof context === 'undefined') {\\n            context = this;\\n          }\\n\\n          handler.apply(context, args);\\n\\n          if (once) {\\n            this.bindings[event].splice(i, 1);\\n          } else {\\n            ++i;\\n          }\\n        }\\n      }\\n    }\\n  }]);\\n\\n  return Evented;\\n})();\\n\\nTetherBase.Utils = {\\n  getActualBoundingClientRect: getActualBoundingClientRect,\\n  getScrollParents: getScrollParents,\\n  getBounds: getBounds,\\n  getOffsetParent: getOffsetParent,\\n  extend: extend,\\n  addClass: addClass,\\n  removeClass: removeClass,\\n  hasClass: hasClass,\\n  updateClasses: updateClasses,\\n  defer: defer,\\n  flush: flush,\\n  uniqueId: uniqueId,\\n  Evented: Evented,\\n  getScrollBarSize: getScrollBarSize,\\n  removeUtilElements: removeUtilElements\\n};\\n/* globals TetherBase, performance */\\n\\n'use strict';\\n\\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\nvar _get = function get(_x6, _x7, _x8) { var _again = true; _function: while (_again) { var object = _x6, property = _x7, receiver = _x8; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x6 = parent; _x7 = property; _x8 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nif (typeof TetherBase === 'undefined') {\\n  throw new Error('You must include the utils.js file before tether.js');\\n}\\n\\nvar _TetherBase$Utils = TetherBase.Utils;\\nvar getScrollParents = _TetherBase$Utils.getScrollParents;\\nvar getBounds = _TetherBase$Utils.getBounds;\\nvar getOffsetParent = _TetherBase$Utils.getOffsetParent;\\nvar extend = _TetherBase$Utils.extend;\\nvar addClass = _TetherBase$Utils.addClass;\\nvar removeClass = _TetherBase$Utils.removeClass;\\nvar updateClasses = _TetherBase$Utils.updateClasses;\\nvar defer = _TetherBase$Utils.defer;\\nvar flush = _TetherBase$Utils.flush;\\nvar getScrollBarSize = _TetherBase$Utils.getScrollBarSize;\\nvar removeUtilElements = _TetherBase$Utils.removeUtilElements;\\n\\nfunction within(a, b) {\\n  var diff = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];\\n\\n  return a + diff >= b && b >= a - diff;\\n}\\n\\nvar transformKey = (function () {\\n  if (typeof document === 'undefined') {\\n    return '';\\n  }\\n  var el = document.createElement('div');\\n\\n  var transforms = ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform'];\\n  for (var i = 0; i < transforms.length; ++i) {\\n    var key = transforms[i];\\n    if (el.style[key] !== undefined) {\\n      return key;\\n    }\\n  }\\n})();\\n\\nvar tethers = [];\\n\\nvar position = function position() {\\n  tethers.forEach(function (tether) {\\n    tether.position(false);\\n  });\\n  flush();\\n};\\n\\nfunction now() {\\n  if (typeof performance !== 'undefined' && typeof performance.now !== 'undefined') {\\n    return performance.now();\\n  }\\n  return +new Date();\\n}\\n\\n(function () {\\n  var lastCall = null;\\n  var lastDuration = null;\\n  var pendingTimeout = null;\\n\\n  var tick = function tick() {\\n    if (typeof lastDuration !== 'undefined' && lastDuration > 16) {\\n      // We voluntarily throttle ourselves if we can't manage 60fps\\n      lastDuration = Math.min(lastDuration - 16, 250);\\n\\n      // Just in case this is the last event, remember to position just once more\\n      pendingTimeout = setTimeout(tick, 250);\\n      return;\\n    }\\n\\n    if (typeof lastCall !== 'undefined' && now() - lastCall < 10) {\\n      // Some browsers call events a little too frequently, refuse to run more than is reasonable\\n      return;\\n    }\\n\\n    if (pendingTimeout != null) {\\n      clearTimeout(pendingTimeout);\\n      pendingTimeout = null;\\n    }\\n\\n    lastCall = now();\\n    position();\\n    lastDuration = now() - lastCall;\\n  };\\n\\n  if (typeof window !== 'undefined' && typeof window.addEventListener !== 'undefined') {\\n    ['resize', 'scroll', 'touchmove'].forEach(function (event) {\\n      window.addEventListener(event, tick);\\n    });\\n  }\\n})();\\n\\nvar MIRROR_LR = {\\n  center: 'center',\\n  left: 'right',\\n  right: 'left'\\n};\\n\\nvar MIRROR_TB = {\\n  middle: 'middle',\\n  top: 'bottom',\\n  bottom: 'top'\\n};\\n\\nvar OFFSET_MAP = {\\n  top: 0,\\n  left: 0,\\n  middle: '50%',\\n  center: '50%',\\n  bottom: '100%',\\n  right: '100%'\\n};\\n\\nvar autoToFixedAttachment = function autoToFixedAttachment(attachment, relativeToAttachment) {\\n  var left = attachment.left;\\n  var top = attachment.top;\\n\\n  if (left === 'auto') {\\n    left = MIRROR_LR[relativeToAttachment.left];\\n  }\\n\\n  if (top === 'auto') {\\n    top = MIRROR_TB[relativeToAttachment.top];\\n  }\\n\\n  return { left: left, top: top };\\n};\\n\\nvar attachmentToOffset = function attachmentToOffset(attachment) {\\n  var left = attachment.left;\\n  var top = attachment.top;\\n\\n  if (typeof OFFSET_MAP[attachment.left] !== 'undefined') {\\n    left = OFFSET_MAP[attachment.left];\\n  }\\n\\n  if (typeof OFFSET_MAP[attachment.top] !== 'undefined') {\\n    top = OFFSET_MAP[attachment.top];\\n  }\\n\\n  return { left: left, top: top };\\n};\\n\\nfunction addOffset() {\\n  var out = { top: 0, left: 0 };\\n\\n  for (var _len = arguments.length, offsets = Array(_len), _key = 0; _key < _len; _key++) {\\n    offsets[_key] = arguments[_key];\\n  }\\n\\n  offsets.forEach(function (_ref) {\\n    var top = _ref.top;\\n    var left = _ref.left;\\n\\n    if (typeof top === 'string') {\\n      top = parseFloat(top, 10);\\n    }\\n    if (typeof left === 'string') {\\n      left = parseFloat(left, 10);\\n    }\\n\\n    out.top += top;\\n    out.left += left;\\n  });\\n\\n  return out;\\n}\\n\\nfunction offsetToPx(offset, size) {\\n  if (typeof offset.left === 'string' && offset.left.indexOf('%') !== -1) {\\n    offset.left = parseFloat(offset.left, 10) / 100 * size.width;\\n  }\\n  if (typeof offset.top === 'string' && offset.top.indexOf('%') !== -1) {\\n    offset.top = parseFloat(offset.top, 10) / 100 * size.height;\\n  }\\n\\n  return offset;\\n}\\n\\nvar parseOffset = function parseOffset(value) {\\n  var _value$split = value.split(' ');\\n\\n  var _value$split2 = _slicedToArray(_value$split, 2);\\n\\n  var top = _value$split2[0];\\n  var left = _value$split2[1];\\n\\n  return { top: top, left: left };\\n};\\nvar parseAttachment = parseOffset;\\n\\nvar TetherClass = (function (_Evented) {\\n  _inherits(TetherClass, _Evented);\\n\\n  function TetherClass(options) {\\n    var _this = this;\\n\\n    _classCallCheck(this, TetherClass);\\n\\n    _get(Object.getPrototypeOf(TetherClass.prototype), 'constructor', this).call(this);\\n    this.position = this.position.bind(this);\\n\\n    tethers.push(this);\\n\\n    this.history = [];\\n\\n    this.setOptions(options, false);\\n\\n    TetherBase.modules.forEach(function (module) {\\n      if (typeof module.initialize !== 'undefined') {\\n        module.initialize.call(_this);\\n      }\\n    });\\n\\n    this.position();\\n  }\\n\\n  _createClass(TetherClass, [{\\n    key: 'getClass',\\n    value: function getClass() {\\n      var key = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\\n      var classes = this.options.classes;\\n\\n      if (typeof classes !== 'undefined' && classes[key]) {\\n        return this.options.classes[key];\\n      } else if (this.options.classPrefix) {\\n        return this.options.classPrefix + '-' + key;\\n      } else {\\n        return key;\\n      }\\n    }\\n  }, {\\n    key: 'setOptions',\\n    value: function setOptions(options) {\\n      var _this2 = this;\\n\\n      var pos = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\\n\\n      var defaults = {\\n        offset: '0 0',\\n        targetOffset: '0 0',\\n        targetAttachment: 'auto auto',\\n        classPrefix: 'tether'\\n      };\\n\\n      this.options = extend(defaults, options);\\n\\n      var _options = this.options;\\n      var element = _options.element;\\n      var target = _options.target;\\n      var targetModifier = _options.targetModifier;\\n\\n      this.element = element;\\n      this.target = target;\\n      this.targetModifier = targetModifier;\\n\\n      if (this.target === 'viewport') {\\n        this.target = document.body;\\n        this.targetModifier = 'visible';\\n      } else if (this.target === 'scroll-handle') {\\n        this.target = document.body;\\n        this.targetModifier = 'scroll-handle';\\n      }\\n\\n      ['element', 'target'].forEach(function (key) {\\n        if (typeof _this2[key] === 'undefined') {\\n          throw new Error('Tether Error: Both element and target must be defined');\\n        }\\n\\n        if (typeof _this2[key].jquery !== 'undefined') {\\n          _this2[key] = _this2[key][0];\\n        } else if (typeof _this2[key] === 'string') {\\n          _this2[key] = document.querySelector(_this2[key]);\\n        }\\n      });\\n\\n      addClass(this.element, this.getClass('element'));\\n      if (!(this.options.addTargetClasses === false)) {\\n        addClass(this.target, this.getClass('target'));\\n      }\\n\\n      if (!this.options.attachment) {\\n        throw new Error('Tether Error: You must provide an attachment');\\n      }\\n\\n      this.targetAttachment = parseAttachment(this.options.targetAttachment);\\n      this.attachment = parseAttachment(this.options.attachment);\\n      this.offset = parseOffset(this.options.offset);\\n      this.targetOffset = parseOffset(this.options.targetOffset);\\n\\n      if (typeof this.scrollParents !== 'undefined') {\\n        this.disable();\\n      }\\n\\n      if (this.targetModifier === 'scroll-handle') {\\n        this.scrollParents = [this.target];\\n      } else {\\n        this.scrollParents = getScrollParents(this.target);\\n      }\\n\\n      if (!(this.options.enabled === false)) {\\n        this.enable(pos);\\n      }\\n    }\\n  }, {\\n    key: 'getTargetBounds',\\n    value: function getTargetBounds() {\\n      if (typeof this.targetModifier !== 'undefined') {\\n        if (this.targetModifier === 'visible') {\\n          if (this.target === document.body) {\\n            return { top: pageYOffset, left: pageXOffset, height: innerHeight, width: innerWidth };\\n          } else {\\n            var bounds = getBounds(this.target);\\n\\n            var out = {\\n              height: bounds.height,\\n              width: bounds.width,\\n              top: bounds.top,\\n              left: bounds.left\\n            };\\n\\n            out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));\\n            out.height = Math.min(out.height, bounds.height - (bounds.top + bounds.height - (pageYOffset + innerHeight)));\\n            out.height = Math.min(innerHeight, out.height);\\n            out.height -= 2;\\n\\n            out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));\\n            out.width = Math.min(out.width, bounds.width - (bounds.left + bounds.width - (pageXOffset + innerWidth)));\\n            out.width = Math.min(innerWidth, out.width);\\n            out.width -= 2;\\n\\n            if (out.top < pageYOffset) {\\n              out.top = pageYOffset;\\n            }\\n            if (out.left < pageXOffset) {\\n              out.left = pageXOffset;\\n            }\\n\\n            return out;\\n          }\\n        } else if (this.targetModifier === 'scroll-handle') {\\n          var bounds = undefined;\\n          var target = this.target;\\n          if (target === document.body) {\\n            target = document.documentElement;\\n\\n            bounds = {\\n              left: pageXOffset,\\n              top: pageYOffset,\\n              height: innerHeight,\\n              width: innerWidth\\n            };\\n          } else {\\n            bounds = getBounds(target);\\n          }\\n\\n          var style = getComputedStyle(target);\\n\\n          var hasBottomScroll = target.scrollWidth > target.clientWidth || [style.overflow, style.overflowX].indexOf('scroll') >= 0 || this.target !== document.body;\\n\\n          var scrollBottom = 0;\\n          if (hasBottomScroll) {\\n            scrollBottom = 15;\\n          }\\n\\n          var height = bounds.height - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth) - scrollBottom;\\n\\n          var out = {\\n            width: 15,\\n            height: height * 0.975 * (height / target.scrollHeight),\\n            left: bounds.left + bounds.width - parseFloat(style.borderLeftWidth) - 15\\n          };\\n\\n          var fitAdj = 0;\\n          if (height < 408 && this.target === document.body) {\\n            fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;\\n          }\\n\\n          if (this.target !== document.body) {\\n            out.height = Math.max(out.height, 24);\\n          }\\n\\n          var scrollPercentage = this.target.scrollTop / (target.scrollHeight - height);\\n          out.top = scrollPercentage * (height - out.height - fitAdj) + bounds.top + parseFloat(style.borderTopWidth);\\n\\n          if (this.target === document.body) {\\n            out.height = Math.max(out.height, 24);\\n          }\\n\\n          return out;\\n        }\\n      } else {\\n        return getBounds(this.target);\\n      }\\n    }\\n  }, {\\n    key: 'clearCache',\\n    value: function clearCache() {\\n      this._cache = {};\\n    }\\n  }, {\\n    key: 'cache',\\n    value: function cache(k, getter) {\\n      // More than one module will often need the same DOM info, so\\n      // we keep a cache which is cleared on each position call\\n      if (typeof this._cache === 'undefined') {\\n        this._cache = {};\\n      }\\n\\n      if (typeof this._cache[k] === 'undefined') {\\n        this._cache[k] = getter.call(this);\\n      }\\n\\n      return this._cache[k];\\n    }\\n  }, {\\n    key: 'enable',\\n    value: function enable() {\\n      var _this3 = this;\\n\\n      var pos = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\\n\\n      if (!(this.options.addTargetClasses === false)) {\\n        addClass(this.target, this.getClass('enabled'));\\n      }\\n      addClass(this.element, this.getClass('enabled'));\\n      this.enabled = true;\\n\\n      this.scrollParents.forEach(function (parent) {\\n        if (parent !== _this3.target.ownerDocument) {\\n          parent.addEventListener('scroll', _this3.position);\\n        }\\n      });\\n\\n      if (pos) {\\n        this.position();\\n      }\\n    }\\n  }, {\\n    key: 'disable',\\n    value: function disable() {\\n      var _this4 = this;\\n\\n      removeClass(this.target, this.getClass('enabled'));\\n      removeClass(this.element, this.getClass('enabled'));\\n      this.enabled = false;\\n\\n      if (typeof this.scrollParents !== 'undefined') {\\n        this.scrollParents.forEach(function (parent) {\\n          parent.removeEventListener('scroll', _this4.position);\\n        });\\n      }\\n    }\\n  }, {\\n    key: 'destroy',\\n    value: function destroy() {\\n      var _this5 = this;\\n\\n      this.disable();\\n\\n      tethers.forEach(function (tether, i) {\\n        if (tether === _this5) {\\n          tethers.splice(i, 1);\\n        }\\n      });\\n\\n      // Remove any elements we were using for convenience from the DOM\\n      if (tethers.length === 0) {\\n        removeUtilElements();\\n      }\\n    }\\n  }, {\\n    key: 'updateAttachClasses',\\n    value: function updateAttachClasses(elementAttach, targetAttach) {\\n      var _this6 = this;\\n\\n      elementAttach = elementAttach || this.attachment;\\n      targetAttach = targetAttach || this.targetAttachment;\\n      var sides = ['left', 'top', 'bottom', 'right', 'middle', 'center'];\\n\\n      if (typeof this._addAttachClasses !== 'undefined' && this._addAttachClasses.length) {\\n        // updateAttachClasses can be called more than once in a position call, so\\n        // we need to clean up after ourselves such that when the last defer gets\\n        // ran it doesn't add any extra classes from previous calls.\\n        this._addAttachClasses.splice(0, this._addAttachClasses.length);\\n      }\\n\\n      if (typeof this._addAttachClasses === 'undefined') {\\n        this._addAttachClasses = [];\\n      }\\n      var add = this._addAttachClasses;\\n\\n      if (elementAttach.top) {\\n        add.push(this.getClass('element-attached') + '-' + elementAttach.top);\\n      }\\n      if (elementAttach.left) {\\n        add.push(this.getClass('element-attached') + '-' + elementAttach.left);\\n      }\\n      if (targetAttach.top) {\\n        add.push(this.getClass('target-attached') + '-' + targetAttach.top);\\n      }\\n      if (targetAttach.left) {\\n        add.push(this.getClass('target-attached') + '-' + targetAttach.left);\\n      }\\n\\n      var all = [];\\n      sides.forEach(function (side) {\\n        all.push(_this6.getClass('element-attached') + '-' + side);\\n        all.push(_this6.getClass('target-attached') + '-' + side);\\n      });\\n\\n      defer(function () {\\n        if (!(typeof _this6._addAttachClasses !== 'undefined')) {\\n          return;\\n        }\\n\\n        updateClasses(_this6.element, _this6._addAttachClasses, all);\\n        if (!(_this6.options.addTargetClasses === false)) {\\n          updateClasses(_this6.target, _this6._addAttachClasses, all);\\n        }\\n\\n        delete _this6._addAttachClasses;\\n      });\\n    }\\n  }, {\\n    key: 'position',\\n    value: function position() {\\n      var _this7 = this;\\n\\n      var flushChanges = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\\n\\n      // flushChanges commits the changes immediately, leave true unless you are positioning multiple\\n      // tethers (in which case call Tether.Utils.flush yourself when you're done)\\n\\n      if (!this.enabled) {\\n        return;\\n      }\\n\\n      this.clearCache();\\n\\n      // Turn 'auto' attachments into the appropriate corner or edge\\n      var targetAttachment = autoToFixedAttachment(this.targetAttachment, this.attachment);\\n\\n      this.updateAttachClasses(this.attachment, targetAttachment);\\n\\n      var elementPos = this.cache('element-bounds', function () {\\n        return getBounds(_this7.element);\\n      });\\n\\n      var width = elementPos.width;\\n      var height = elementPos.height;\\n\\n      if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {\\n        var _lastSize = this.lastSize;\\n\\n        // We cache the height and width to make it possible to position elements that are\\n        // getting hidden.\\n        width = _lastSize.width;\\n        height = _lastSize.height;\\n      } else {\\n        this.lastSize = { width: width, height: height };\\n      }\\n\\n      var targetPos = this.cache('target-bounds', function () {\\n        return _this7.getTargetBounds();\\n      });\\n      var targetSize = targetPos;\\n\\n      // Get an actual px offset from the attachment\\n      var offset = offsetToPx(attachmentToOffset(this.attachment), { width: width, height: height });\\n      var targetOffset = offsetToPx(attachmentToOffset(targetAttachment), targetSize);\\n\\n      var manualOffset = offsetToPx(this.offset, { width: width, height: height });\\n      var manualTargetOffset = offsetToPx(this.targetOffset, targetSize);\\n\\n      // Add the manually provided offset\\n      offset = addOffset(offset, manualOffset);\\n      targetOffset = addOffset(targetOffset, manualTargetOffset);\\n\\n      // It's now our goal to make (element position + offset) == (target position + target offset)\\n      var left = targetPos.left + targetOffset.left - offset.left;\\n      var top = targetPos.top + targetOffset.top - offset.top;\\n\\n      for (var i = 0; i < TetherBase.modules.length; ++i) {\\n        var _module2 = TetherBase.modules[i];\\n        var ret = _module2.position.call(this, {\\n          left: left,\\n          top: top,\\n          targetAttachment: targetAttachment,\\n          targetPos: targetPos,\\n          elementPos: elementPos,\\n          offset: offset,\\n          targetOffset: targetOffset,\\n          manualOffset: manualOffset,\\n          manualTargetOffset: manualTargetOffset,\\n          scrollbarSize: scrollbarSize,\\n          attachment: this.attachment\\n        });\\n\\n        if (ret === false) {\\n          return false;\\n        } else if (typeof ret === 'undefined' || typeof ret !== 'object') {\\n          continue;\\n        } else {\\n          top = ret.top;\\n          left = ret.left;\\n        }\\n      }\\n\\n      // We describe the position three different ways to give the optimizer\\n      // a chance to decide the best possible way to position the element\\n      // with the fewest repaints.\\n      var next = {\\n        // It's position relative to the page (absolute positioning when\\n        // the element is a child of the body)\\n        page: {\\n          top: top,\\n          left: left\\n        },\\n\\n        // It's position relative to the viewport (fixed positioning)\\n        viewport: {\\n          top: top - pageYOffset,\\n          bottom: pageYOffset - top - height + innerHeight,\\n          left: left - pageXOffset,\\n          right: pageXOffset - left - width + innerWidth\\n        }\\n      };\\n\\n      var doc = this.target.ownerDocument;\\n      var win = doc.defaultView;\\n\\n      var scrollbarSize = undefined;\\n      if (win.innerHeight > doc.documentElement.clientHeight) {\\n        scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);\\n        next.viewport.bottom -= scrollbarSize.height;\\n      }\\n\\n      if (win.innerWidth > doc.documentElement.clientWidth) {\\n        scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);\\n        next.viewport.right -= scrollbarSize.width;\\n      }\\n\\n      if (['', 'static'].indexOf(doc.body.style.position) === -1 || ['', 'static'].indexOf(doc.body.parentElement.style.position) === -1) {\\n        // Absolute positioning in the body will be relative to the page, not the 'initial containing block'\\n        next.page.bottom = doc.body.scrollHeight - top - height;\\n        next.page.right = doc.body.scrollWidth - left - width;\\n      }\\n\\n      if (typeof this.options.optimizations !== 'undefined' && this.options.optimizations.moveElement !== false && !(typeof this.targetModifier !== 'undefined')) {\\n        (function () {\\n          var offsetParent = _this7.cache('target-offsetparent', function () {\\n            return getOffsetParent(_this7.target);\\n          });\\n          var offsetPosition = _this7.cache('target-offsetparent-bounds', function () {\\n            return getBounds(offsetParent);\\n          });\\n          var offsetParentStyle = getComputedStyle(offsetParent);\\n          var offsetParentSize = offsetPosition;\\n\\n          var offsetBorder = {};\\n          ['Top', 'Left', 'Bottom', 'Right'].forEach(function (side) {\\n            offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle['border' + side + 'Width']);\\n          });\\n\\n          offsetPosition.right = doc.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;\\n          offsetPosition.bottom = doc.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;\\n\\n          if (next.page.top >= offsetPosition.top + offsetBorder.top && next.page.bottom >= offsetPosition.bottom) {\\n            if (next.page.left >= offsetPosition.left + offsetBorder.left && next.page.right >= offsetPosition.right) {\\n              // We're within the visible part of the target's scroll parent\\n              var scrollTop = offsetParent.scrollTop;\\n              var scrollLeft = offsetParent.scrollLeft;\\n\\n              // It's position relative to the target's offset parent (absolute positioning when\\n              // the element is moved to be a child of the target's offset parent).\\n              next.offset = {\\n                top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,\\n                left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left\\n              };\\n            }\\n          }\\n        })();\\n      }\\n\\n      // We could also travel up the DOM and try each containing context, rather than only\\n      // looking at the body, but we're gonna get diminishing returns.\\n\\n      this.move(next);\\n\\n      this.history.unshift(next);\\n\\n      if (this.history.length > 3) {\\n        this.history.pop();\\n      }\\n\\n      if (flushChanges) {\\n        flush();\\n      }\\n\\n      return true;\\n    }\\n\\n    // THE ISSUE\\n  }, {\\n    key: 'move',\\n    value: function move(pos) {\\n      var _this8 = this;\\n\\n      if (!(typeof this.element.parentNode !== 'undefined')) {\\n        return;\\n      }\\n\\n      var same = {};\\n\\n      for (var type in pos) {\\n        same[type] = {};\\n\\n        for (var key in pos[type]) {\\n          var found = false;\\n\\n          for (var i = 0; i < this.history.length; ++i) {\\n            var point = this.history[i];\\n            if (typeof point[type] !== 'undefined' && !within(point[type][key], pos[type][key])) {\\n              found = true;\\n              break;\\n            }\\n          }\\n\\n          if (!found) {\\n            same[type][key] = true;\\n          }\\n        }\\n      }\\n\\n      var css = { top: '', left: '', right: '', bottom: '' };\\n\\n      var transcribe = function transcribe(_same, _pos) {\\n        var hasOptimizations = typeof _this8.options.optimizations !== 'undefined';\\n        var gpu = hasOptimizations ? _this8.options.optimizations.gpu : null;\\n        if (gpu !== false) {\\n          var yPos = undefined,\\n              xPos = undefined;\\n          if (_same.top) {\\n            css.top = 0;\\n            yPos = _pos.top;\\n          } else {\\n            css.bottom = 0;\\n            yPos = -_pos.bottom;\\n          }\\n\\n          if (_same.left) {\\n            css.left = 0;\\n            xPos = _pos.left;\\n          } else {\\n            css.right = 0;\\n            xPos = -_pos.right;\\n          }\\n\\n          if (window.matchMedia) {\\n            // HubSpot/tether#207\\n            var retina = window.matchMedia('only screen and (min-resolution: 1.3dppx)').matches || window.matchMedia('only screen and (-webkit-min-device-pixel-ratio: 1.3)').matches;\\n            if (!retina) {\\n              xPos = Math.round(xPos);\\n              yPos = Math.round(yPos);\\n            }\\n          }\\n\\n          css[transformKey] = 'translateX(' + xPos + 'px) translateY(' + yPos + 'px)';\\n\\n          if (transformKey !== 'msTransform') {\\n            // The Z transform will keep this in the GPU (faster, and prevents artifacts),\\n            // but IE9 doesn't support 3d transforms and will choke.\\n            css[transformKey] += \\\" translateZ(0)\\\";\\n          }\\n        } else {\\n          if (_same.top) {\\n            css.top = _pos.top + 'px';\\n          } else {\\n            css.bottom = _pos.bottom + 'px';\\n          }\\n\\n          if (_same.left) {\\n            css.left = _pos.left + 'px';\\n          } else {\\n            css.right = _pos.right + 'px';\\n          }\\n        }\\n      };\\n\\n      var moved = false;\\n      if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {\\n        css.position = 'absolute';\\n        transcribe(same.page, pos.page);\\n      } else if ((same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {\\n        css.position = 'fixed';\\n        transcribe(same.viewport, pos.viewport);\\n      } else if (typeof same.offset !== 'undefined' && same.offset.top && same.offset.left) {\\n        (function () {\\n          css.position = 'absolute';\\n          var offsetParent = _this8.cache('target-offsetparent', function () {\\n            return getOffsetParent(_this8.target);\\n          });\\n\\n          if (getOffsetParent(_this8.element) !== offsetParent) {\\n            defer(function () {\\n              _this8.element.parentNode.removeChild(_this8.element);\\n              offsetParent.appendChild(_this8.element);\\n            });\\n          }\\n\\n          transcribe(same.offset, pos.offset);\\n          moved = true;\\n        })();\\n      } else {\\n        css.position = 'absolute';\\n        transcribe({ top: true, left: true }, pos.page);\\n      }\\n\\n      if (!moved) {\\n        if (this.options.bodyElement) {\\n          this.options.bodyElement.appendChild(this.element);\\n        } else {\\n          var offsetParentIsBody = true;\\n          var currentNode = this.element.parentNode;\\n          while (currentNode && currentNode.nodeType === 1 && currentNode.tagName !== 'BODY') {\\n            if (getComputedStyle(currentNode).position !== 'static') {\\n              offsetParentIsBody = false;\\n              break;\\n            }\\n\\n            currentNode = currentNode.parentNode;\\n          }\\n\\n          if (!offsetParentIsBody) {\\n            this.element.parentNode.removeChild(this.element);\\n            this.element.ownerDocument.body.appendChild(this.element);\\n          }\\n        }\\n      }\\n\\n      // Any css change will trigger a repaint, so let's avoid one if nothing changed\\n      var writeCSS = {};\\n      var write = false;\\n      for (var key in css) {\\n        var val = css[key];\\n        var elVal = this.element.style[key];\\n\\n        if (elVal !== val) {\\n          write = true;\\n          writeCSS[key] = val;\\n        }\\n      }\\n\\n      if (write) {\\n        defer(function () {\\n          extend(_this8.element.style, writeCSS);\\n          _this8.trigger('repositioned');\\n        });\\n      }\\n    }\\n  }]);\\n\\n  return TetherClass;\\n})(Evented);\\n\\nTetherClass.modules = [];\\n\\nTetherBase.position = position;\\n\\nvar Tether = extend(TetherClass, TetherBase);\\n/* globals TetherBase */\\n\\n'use strict';\\n\\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\\n\\nvar _TetherBase$Utils = TetherBase.Utils;\\nvar getBounds = _TetherBase$Utils.getBounds;\\nvar extend = _TetherBase$Utils.extend;\\nvar updateClasses = _TetherBase$Utils.updateClasses;\\nvar defer = _TetherBase$Utils.defer;\\n\\nvar BOUNDS_FORMAT = ['left', 'top', 'right', 'bottom'];\\n\\nfunction getBoundingRect(tether, to) {\\n  if (to === 'scrollParent') {\\n    to = tether.scrollParents[0];\\n  } else if (to === 'window') {\\n    to = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset];\\n  }\\n\\n  if (to === document) {\\n    to = to.documentElement;\\n  }\\n\\n  if (typeof to.nodeType !== 'undefined') {\\n    (function () {\\n      var node = to;\\n      var size = getBounds(to);\\n      var pos = size;\\n      var style = getComputedStyle(to);\\n\\n      to = [pos.left, pos.top, size.width + pos.left, size.height + pos.top];\\n\\n      // Account any parent Frames scroll offset\\n      if (node.ownerDocument !== document) {\\n        var win = node.ownerDocument.defaultView;\\n        to[0] += win.pageXOffset;\\n        to[1] += win.pageYOffset;\\n        to[2] += win.pageXOffset;\\n        to[3] += win.pageYOffset;\\n      }\\n\\n      BOUNDS_FORMAT.forEach(function (side, i) {\\n        side = side[0].toUpperCase() + side.substr(1);\\n        if (side === 'Top' || side === 'Left') {\\n          to[i] += parseFloat(style['border' + side + 'Width']);\\n        } else {\\n          to[i] -= parseFloat(style['border' + side + 'Width']);\\n        }\\n      });\\n    })();\\n  }\\n\\n  return to;\\n}\\n\\nTetherBase.modules.push({\\n  position: function position(_ref) {\\n    var _this = this;\\n\\n    var top = _ref.top;\\n    var left = _ref.left;\\n    var targetAttachment = _ref.targetAttachment;\\n\\n    if (!this.options.constraints) {\\n      return true;\\n    }\\n\\n    var _cache = this.cache('element-bounds', function () {\\n      return getBounds(_this.element);\\n    });\\n\\n    var height = _cache.height;\\n    var width = _cache.width;\\n\\n    if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {\\n      var _lastSize = this.lastSize;\\n\\n      // Handle the item getting hidden as a result of our positioning without glitching\\n      // the classes in and out\\n      width = _lastSize.width;\\n      height = _lastSize.height;\\n    }\\n\\n    var targetSize = this.cache('target-bounds', function () {\\n      return _this.getTargetBounds();\\n    });\\n\\n    var targetHeight = targetSize.height;\\n    var targetWidth = targetSize.width;\\n\\n    var allClasses = [this.getClass('pinned'), this.getClass('out-of-bounds')];\\n\\n    this.options.constraints.forEach(function (constraint) {\\n      var outOfBoundsClass = constraint.outOfBoundsClass;\\n      var pinnedClass = constraint.pinnedClass;\\n\\n      if (outOfBoundsClass) {\\n        allClasses.push(outOfBoundsClass);\\n      }\\n      if (pinnedClass) {\\n        allClasses.push(pinnedClass);\\n      }\\n    });\\n\\n    allClasses.forEach(function (cls) {\\n      ['left', 'top', 'right', 'bottom'].forEach(function (side) {\\n        allClasses.push(cls + '-' + side);\\n      });\\n    });\\n\\n    var addClasses = [];\\n\\n    var tAttachment = extend({}, targetAttachment);\\n    var eAttachment = extend({}, this.attachment);\\n\\n    this.options.constraints.forEach(function (constraint) {\\n      var to = constraint.to;\\n      var attachment = constraint.attachment;\\n      var pin = constraint.pin;\\n\\n      if (typeof attachment === 'undefined') {\\n        attachment = '';\\n      }\\n\\n      var changeAttachX = undefined,\\n          changeAttachY = undefined;\\n      if (attachment.indexOf(' ') >= 0) {\\n        var _attachment$split = attachment.split(' ');\\n\\n        var _attachment$split2 = _slicedToArray(_attachment$split, 2);\\n\\n        changeAttachY = _attachment$split2[0];\\n        changeAttachX = _attachment$split2[1];\\n      } else {\\n        changeAttachX = changeAttachY = attachment;\\n      }\\n\\n      var bounds = getBoundingRect(_this, to);\\n\\n      if (changeAttachY === 'target' || changeAttachY === 'both') {\\n        if (top < bounds[1] && tAttachment.top === 'top') {\\n          top += targetHeight;\\n          tAttachment.top = 'bottom';\\n        }\\n\\n        if (top + height > bounds[3] && tAttachment.top === 'bottom') {\\n          top -= targetHeight;\\n          tAttachment.top = 'top';\\n        }\\n      }\\n\\n      if (changeAttachY === 'together') {\\n        if (tAttachment.top === 'top') {\\n          if (eAttachment.top === 'bottom' && top < bounds[1]) {\\n            top += targetHeight;\\n            tAttachment.top = 'bottom';\\n\\n            top += height;\\n            eAttachment.top = 'top';\\n          } else if (eAttachment.top === 'top' && top + height > bounds[3] && top - (height - targetHeight) >= bounds[1]) {\\n            top -= height - targetHeight;\\n            tAttachment.top = 'bottom';\\n\\n            eAttachment.top = 'bottom';\\n          }\\n        }\\n\\n        if (tAttachment.top === 'bottom') {\\n          if (eAttachment.top === 'top' && top + height > bounds[3]) {\\n            top -= targetHeight;\\n            tAttachment.top = 'top';\\n\\n            top -= height;\\n            eAttachment.top = 'bottom';\\n          } else if (eAttachment.top === 'bottom' && top < bounds[1] && top + (height * 2 - targetHeight) <= bounds[3]) {\\n            top += height - targetHeight;\\n            tAttachment.top = 'top';\\n\\n            eAttachment.top = 'top';\\n          }\\n        }\\n\\n        if (tAttachment.top === 'middle') {\\n          if (top + height > bounds[3] && eAttachment.top === 'top') {\\n            top -= height;\\n            eAttachment.top = 'bottom';\\n          } else if (top < bounds[1] && eAttachment.top === 'bottom') {\\n            top += height;\\n            eAttachment.top = 'top';\\n          }\\n        }\\n      }\\n\\n      if (changeAttachX === 'target' || changeAttachX === 'both') {\\n        if (left < bounds[0] && tAttachment.left === 'left') {\\n          left += targetWidth;\\n          tAttachment.left = 'right';\\n        }\\n\\n        if (left + width > bounds[2] && tAttachment.left === 'right') {\\n          left -= targetWidth;\\n          tAttachment.left = 'left';\\n        }\\n      }\\n\\n      if (changeAttachX === 'together') {\\n        if (left < bounds[0] && tAttachment.left === 'left') {\\n          if (eAttachment.left === 'right') {\\n            left += targetWidth;\\n            tAttachment.left = 'right';\\n\\n            left += width;\\n            eAttachment.left = 'left';\\n          } else if (eAttachment.left === 'left') {\\n            left += targetWidth;\\n            tAttachment.left = 'right';\\n\\n            left -= width;\\n            eAttachment.left = 'right';\\n          }\\n        } else if (left + width > bounds[2] && tAttachment.left === 'right') {\\n          if (eAttachment.left === 'left') {\\n            left -= targetWidth;\\n            tAttachment.left = 'left';\\n\\n            left -= width;\\n            eAttachment.left = 'right';\\n          } else if (eAttachment.left === 'right') {\\n            left -= targetWidth;\\n            tAttachment.left = 'left';\\n\\n            left += width;\\n            eAttachment.left = 'left';\\n          }\\n        } else if (tAttachment.left === 'center') {\\n          if (left + width > bounds[2] && eAttachment.left === 'left') {\\n            left -= width;\\n            eAttachment.left = 'right';\\n          } else if (left < bounds[0] && eAttachment.left === 'right') {\\n            left += width;\\n            eAttachment.left = 'left';\\n          }\\n        }\\n      }\\n\\n      if (changeAttachY === 'element' || changeAttachY === 'both') {\\n        if (top < bounds[1] && eAttachment.top === 'bottom') {\\n          top += height;\\n          eAttachment.top = 'top';\\n        }\\n\\n        if (top + height > bounds[3] && eAttachment.top === 'top') {\\n          top -= height;\\n          eAttachment.top = 'bottom';\\n        }\\n      }\\n\\n      if (changeAttachX === 'element' || changeAttachX === 'both') {\\n        if (left < bounds[0]) {\\n          if (eAttachment.left === 'right') {\\n            left += width;\\n            eAttachment.left = 'left';\\n          } else if (eAttachment.left === 'center') {\\n            left += width / 2;\\n            eAttachment.left = 'left';\\n          }\\n        }\\n\\n        if (left + width > bounds[2]) {\\n          if (eAttachment.left === 'left') {\\n            left -= width;\\n            eAttachment.left = 'right';\\n          } else if (eAttachment.left === 'center') {\\n            left -= width / 2;\\n            eAttachment.left = 'right';\\n          }\\n        }\\n      }\\n\\n      if (typeof pin === 'string') {\\n        pin = pin.split(',').map(function (p) {\\n          return p.trim();\\n        });\\n      } else if (pin === true) {\\n        pin = ['top', 'left', 'right', 'bottom'];\\n      }\\n\\n      pin = pin || [];\\n\\n      var pinned = [];\\n      var oob = [];\\n\\n      if (top < bounds[1]) {\\n        if (pin.indexOf('top') >= 0) {\\n          top = bounds[1];\\n          pinned.push('top');\\n        } else {\\n          oob.push('top');\\n        }\\n      }\\n\\n      if (top + height > bounds[3]) {\\n        if (pin.indexOf('bottom') >= 0) {\\n          top = bounds[3] - height;\\n          pinned.push('bottom');\\n        } else {\\n          oob.push('bottom');\\n        }\\n      }\\n\\n      if (left < bounds[0]) {\\n        if (pin.indexOf('left') >= 0) {\\n          left = bounds[0];\\n          pinned.push('left');\\n        } else {\\n          oob.push('left');\\n        }\\n      }\\n\\n      if (left + width > bounds[2]) {\\n        if (pin.indexOf('right') >= 0) {\\n          left = bounds[2] - width;\\n          pinned.push('right');\\n        } else {\\n          oob.push('right');\\n        }\\n      }\\n\\n      if (pinned.length) {\\n        (function () {\\n          var pinnedClass = undefined;\\n          if (typeof _this.options.pinnedClass !== 'undefined') {\\n            pinnedClass = _this.options.pinnedClass;\\n          } else {\\n            pinnedClass = _this.getClass('pinned');\\n          }\\n\\n          addClasses.push(pinnedClass);\\n          pinned.forEach(function (side) {\\n            addClasses.push(pinnedClass + '-' + side);\\n          });\\n        })();\\n      }\\n\\n      if (oob.length) {\\n        (function () {\\n          var oobClass = undefined;\\n          if (typeof _this.options.outOfBoundsClass !== 'undefined') {\\n            oobClass = _this.options.outOfBoundsClass;\\n          } else {\\n            oobClass = _this.getClass('out-of-bounds');\\n          }\\n\\n          addClasses.push(oobClass);\\n          oob.forEach(function (side) {\\n            addClasses.push(oobClass + '-' + side);\\n          });\\n        })();\\n      }\\n\\n      if (pinned.indexOf('left') >= 0 || pinned.indexOf('right') >= 0) {\\n        eAttachment.left = tAttachment.left = false;\\n      }\\n      if (pinned.indexOf('top') >= 0 || pinned.indexOf('bottom') >= 0) {\\n        eAttachment.top = tAttachment.top = false;\\n      }\\n\\n      if (tAttachment.top !== targetAttachment.top || tAttachment.left !== targetAttachment.left || eAttachment.top !== _this.attachment.top || eAttachment.left !== _this.attachment.left) {\\n        _this.updateAttachClasses(eAttachment, tAttachment);\\n        _this.trigger('update', {\\n          attachment: eAttachment,\\n          targetAttachment: tAttachment\\n        });\\n      }\\n    });\\n\\n    defer(function () {\\n      if (!(_this.options.addTargetClasses === false)) {\\n        updateClasses(_this.target, addClasses, allClasses);\\n      }\\n      updateClasses(_this.element, addClasses, allClasses);\\n    });\\n\\n    return { top: top, left: left };\\n  }\\n});\\n/* globals TetherBase */\\n\\n'use strict';\\n\\nvar _TetherBase$Utils = TetherBase.Utils;\\nvar getBounds = _TetherBase$Utils.getBounds;\\nvar updateClasses = _TetherBase$Utils.updateClasses;\\nvar defer = _TetherBase$Utils.defer;\\n\\nTetherBase.modules.push({\\n  position: function position(_ref) {\\n    var _this = this;\\n\\n    var top = _ref.top;\\n    var left = _ref.left;\\n\\n    var _cache = this.cache('element-bounds', function () {\\n      return getBounds(_this.element);\\n    });\\n\\n    var height = _cache.height;\\n    var width = _cache.width;\\n\\n    var targetPos = this.getTargetBounds();\\n\\n    var bottom = top + height;\\n    var right = left + width;\\n\\n    var abutted = [];\\n    if (top <= targetPos.bottom && bottom >= targetPos.top) {\\n      ['left', 'right'].forEach(function (side) {\\n        var targetPosSide = targetPos[side];\\n        if (targetPosSide === left || targetPosSide === right) {\\n          abutted.push(side);\\n        }\\n      });\\n    }\\n\\n    if (left <= targetPos.right && right >= targetPos.left) {\\n      ['top', 'bottom'].forEach(function (side) {\\n        var targetPosSide = targetPos[side];\\n        if (targetPosSide === top || targetPosSide === bottom) {\\n          abutted.push(side);\\n        }\\n      });\\n    }\\n\\n    var allClasses = [];\\n    var addClasses = [];\\n\\n    var sides = ['left', 'top', 'right', 'bottom'];\\n    allClasses.push(this.getClass('abutted'));\\n    sides.forEach(function (side) {\\n      allClasses.push(_this.getClass('abutted') + '-' + side);\\n    });\\n\\n    if (abutted.length) {\\n      addClasses.push(this.getClass('abutted'));\\n    }\\n\\n    abutted.forEach(function (side) {\\n      addClasses.push(_this.getClass('abutted') + '-' + side);\\n    });\\n\\n    defer(function () {\\n      if (!(_this.options.addTargetClasses === false)) {\\n        updateClasses(_this.target, addClasses, allClasses);\\n      }\\n      updateClasses(_this.element, addClasses, allClasses);\\n    });\\n\\n    return true;\\n  }\\n});\\n/* globals TetherBase */\\n\\n'use strict';\\n\\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\\n\\nTetherBase.modules.push({\\n  position: function position(_ref) {\\n    var top = _ref.top;\\n    var left = _ref.left;\\n\\n    if (!this.options.shift) {\\n      return;\\n    }\\n\\n    var shift = this.options.shift;\\n    if (typeof this.options.shift === 'function') {\\n      shift = this.options.shift.call(this, { top: top, left: left });\\n    }\\n\\n    var shiftTop = undefined,\\n        shiftLeft = undefined;\\n    if (typeof shift === 'string') {\\n      shift = shift.split(' ');\\n      shift[1] = shift[1] || shift[0];\\n\\n      var _shift = shift;\\n\\n      var _shift2 = _slicedToArray(_shift, 2);\\n\\n      shiftTop = _shift2[0];\\n      shiftLeft = _shift2[1];\\n\\n      shiftTop = parseFloat(shiftTop, 10);\\n      shiftLeft = parseFloat(shiftLeft, 10);\\n    } else {\\n      shiftTop = shift.top;\\n      shiftLeft = shift.left;\\n    }\\n\\n    top += shiftTop;\\n    left += shiftLeft;\\n\\n    return { top: top, left: left };\\n  }\\n});\\nreturn Tether;\\n\\n}));\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/francoisdagostini/Projects/infiniteUx-prototype/~/raw-loader!/Users/francoisdagostini/Projects/infiniteUx-prototype/~/tether/dist/js/tether.js\n// module id = 831\n// module chunks = 3"],"sourceRoot":""}